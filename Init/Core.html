<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href=".././style.css"></link><link rel="stylesheet" href=".././src/pygments.css"></link><link rel="shortcut icon" href=".././favicon.ico"></link><link rel="prefetch" href=".././/declarations/declaration-data.bmp" as="image"></link><title>Init.Core</title><script defer="true" src=".././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT=".././";</script><script>const MODULE_NAME="Init.Core";</script><script type="module" src=".././search.js"></script><script type="module" src=".././how-about.js"></script><script type="module" src=".././instances.js"></script><script type="module" src=".././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label>Documentation</h1><p class="header_filename break_within"><span class="name">Init</span>.<span class="name">Core</span></p><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;
            <button id="search_button" onclick="javascript: form.action='.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><h3><a class="break_within" href="#top"><span class="name">Init</span>.<span class="name">Core</span></a></h3><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href=".././Init/Prelude.html">Init.Prelude</a></li><li><a href=".././Init/SizeOf.html">Init.SizeOf</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Init.Core" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#inline"><span class="name">inline</span></a></div><div class="nav_link"><a class="break_within" href="#flip"><span class="name">flip</span></a></div><div class="nav_link"><a class="break_within" href="#Function.const_apply"><span class="name">Function</span>.<span class="name">const_apply</span></a></div><div class="nav_link"><a class="break_within" href="#Function.comp_apply"><span class="name">Function</span>.<span class="name">comp_apply</span></a></div><div class="nav_link"><a class="break_within" href="#Thunk"><span class="name">Thunk</span></a></div><div class="nav_link"><a class="break_within" href="#Thunk.pure"><span class="name">Thunk</span>.<span class="name">pure</span></a></div><div class="nav_link"><a class="break_within" href="#Thunk.get"><span class="name">Thunk</span>.<span class="name">get</span></a></div><div class="nav_link"><a class="break_within" href="#Thunk.map"><span class="name">Thunk</span>.<span class="name">map</span></a></div><div class="nav_link"><a class="break_within" href="#Thunk.bind"><span class="name">Thunk</span>.<span class="name">bind</span></a></div><div class="nav_link"><a class="break_within" href="#Thunk.sizeOf_eq"><span class="name">Thunk</span>.<span class="name">sizeOf_eq</span></a></div><div class="nav_link"><a class="break_within" href="#thunkCoe"><span class="name">thunkCoe</span></a></div><div class="nav_link"><a class="break_within" href="#Iff"><span class="name">Iff</span></a></div><div class="nav_link"><a class="break_within" href="#«term_<->_»"><span class="name">«term_<->_»</span></a></div><div class="nav_link"><a class="break_within" href="#«term_↔_»"><span class="name">«term_↔_»</span></a></div><div class="nav_link"><a class="break_within" href="#Sum"><span class="name">Sum</span></a></div><div class="nav_link"><a class="break_within" href="#«term_⊕_»"><span class="name">«term_⊕_»</span></a></div><div class="nav_link"><a class="break_within" href="#PSum"><span class="name">PSum</span></a></div><div class="nav_link"><a class="break_within" href="#«term_⊕'_»"><span class="name">«term_⊕'_»</span></a></div><div class="nav_link"><a class="break_within" href="#Sigma"><span class="name">Sigma</span></a></div><div class="nav_link"><a class="break_within" href="#PSigma"><span class="name">PSigma</span></a></div><div class="nav_link"><a class="break_within" href="#Exists"><span class="name">Exists</span></a></div><div class="nav_link"><a class="break_within" href="#ForInStep"><span class="name">ForInStep</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedForInStep"><span class="name">instInhabitedForInStep</span></a></div><div class="nav_link"><a class="break_within" href="#ForIn"><span class="name">ForIn</span></a></div><div class="nav_link"><a class="break_within" href="#ForIn'"><span class="name">ForIn'</span></a></div><div class="nav_link"><a class="break_within" href="#DoResultPRBC"><span class="name">DoResultPRBC</span></a></div><div class="nav_link"><a class="break_within" href="#DoResultPR"><span class="name">DoResultPR</span></a></div><div class="nav_link"><a class="break_within" href="#DoResultBC"><span class="name">DoResultBC</span></a></div><div class="nav_link"><a class="break_within" href="#DoResultSBC"><span class="name">DoResultSBC</span></a></div><div class="nav_link"><a class="break_within" href="#HasEquiv"><span class="name">HasEquiv</span></a></div><div class="nav_link"><a class="break_within" href="#«term_≈_»"><span class="name">«term_≈_»</span></a></div><div class="nav_link"><a class="break_within" href="#EmptyCollection"><span class="name">EmptyCollection</span></a></div><div class="nav_link"><a class="break_within" href="#«term{}»"><span class="name">«term{}»</span></a></div><div class="nav_link"><a class="break_within" href="#«term∅»"><span class="name">«term∅»</span></a></div><div class="nav_link"><a class="break_within" href="#Task"><span class="name">Task</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedTask"><span class="name">instInhabitedTask</span></a></div><div class="nav_link"><a class="break_within" href="#instNonemptyTask"><span class="name">instNonemptyTask</span></a></div><div class="nav_link"><a class="break_within" href="#Task.Priority"><span class="name">Task</span>.<span class="name">Priority</span></a></div><div class="nav_link"><a class="break_within" href="#Task.Priority.default"><span class="name">Task</span>.<span class="name">Priority</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Task.Priority.max"><span class="name">Task</span>.<span class="name">Priority</span>.<span class="name">max</span></a></div><div class="nav_link"><a class="break_within" href="#Task.Priority.dedicated"><span class="name">Task</span>.<span class="name">Priority</span>.<span class="name">dedicated</span></a></div><div class="nav_link"><a class="break_within" href="#Task.spawn"><span class="name">Task</span>.<span class="name">spawn</span></a></div><div class="nav_link"><a class="break_within" href="#Task.map"><span class="name">Task</span>.<span class="name">map</span></a></div><div class="nav_link"><a class="break_within" href="#Task.bind"><span class="name">Task</span>.<span class="name">bind</span></a></div><div class="nav_link"><a class="break_within" href="#NonScalar"><span class="name">NonScalar</span></a></div><div class="nav_link"><a class="break_within" href="#PNonScalar"><span class="name">PNonScalar</span></a></div><div class="nav_link"><a class="break_within" href="#Nat.add_zero"><span class="name">Nat</span>.<span class="name">add_zero</span></a></div><div class="nav_link"><a class="break_within" href="#optParam_eq"><span class="name">optParam_eq</span></a></div><div class="nav_link"><a class="break_within" href="#strictOr"><span class="name">strictOr</span></a></div><div class="nav_link"><a class="break_within" href="#strictAnd"><span class="name">strictAnd</span></a></div><div class="nav_link"><a class="break_within" href="#bne"><span class="name">bne</span></a></div><div class="nav_link"><a class="break_within" href="#«term_!=_»"><span class="name">«term_!=_»</span></a></div><div class="nav_link"><a class="break_within" href="#LawfulBEq"><span class="name">LawfulBEq</span></a></div><div class="nav_link"><a class="break_within" href="#instLawfulBEqBoolInstBEqInstDecidableEqBool"><span class="name">instLawfulBEqBoolInstBEqInstDecidableEqBool</span></a></div><div class="nav_link"><a class="break_within" href="#instLawfulBEqInstBEq"><span class="name">instLawfulBEqInstBEq</span></a></div><div class="nav_link"><a class="break_within" href="#instLawfulBEqCharInstBEqInstDecidableEqChar"><span class="name">instLawfulBEqCharInstBEqInstDecidableEqChar</span></a></div><div class="nav_link"><a class="break_within" href="#instLawfulBEqStringInstBEqInstDecidableEqString"><span class="name">instLawfulBEqStringInstBEqInstDecidableEqString</span></a></div><div class="nav_link"><a class="break_within" href="#trivial"><span class="name">trivial</span></a></div><div class="nav_link"><a class="break_within" href="#mt"><span class="name">mt</span></a></div><div class="nav_link"><a class="break_within" href="#not_false"><span class="name">not_false</span></a></div><div class="nav_link"><a class="break_within" href="#not_not_intro"><span class="name">not_not_intro</span></a></div><div class="nav_link"><a class="break_within" href="#proofIrrel"><span class="name">proofIrrel</span></a></div><div class="nav_link"><a class="break_within" href="#id.def"><span class="name">id</span>.<span class="name">def</span></a></div><div class="nav_link"><a class="break_within" href="#Eq.mp"><span class="name">Eq</span>.<span class="name">mp</span></a></div><div class="nav_link"><a class="break_within" href="#Eq.mpr"><span class="name">Eq</span>.<span class="name">mpr</span></a></div><div class="nav_link"><a class="break_within" href="#Eq.substr"><span class="name">Eq</span>.<span class="name">substr</span></a></div><div class="nav_link"><a class="break_within" href="#cast_eq"><span class="name">cast_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Ne"><span class="name">Ne</span></a></div><div class="nav_link"><a class="break_within" href="#«term_≠_»"><span class="name">«term_≠_»</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.intro"><span class="name">Ne</span>.<span class="name">intro</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.elim"><span class="name">Ne</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.irrefl"><span class="name">Ne</span>.<span class="name">irrefl</span></a></div><div class="nav_link"><a class="break_within" href="#Ne.symm"><span class="name">Ne</span>.<span class="name">symm</span></a></div><div class="nav_link"><a class="break_within" href="#false_of_ne"><span class="name">false_of_ne</span></a></div><div class="nav_link"><a class="break_within" href="#ne_false_of_self"><span class="name">ne_false_of_self</span></a></div><div class="nav_link"><a class="break_within" href="#ne_true_of_not"><span class="name">ne_true_of_not</span></a></div><div class="nav_link"><a class="break_within" href="#true_ne_false"><span class="name">true_ne_false</span></a></div><div class="nav_link"><a class="break_within" href="#Bool.of_not_eq_true"><span class="name">Bool</span>.<span class="name">of_not_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#Bool.of_not_eq_false"><span class="name">Bool</span>.<span class="name">of_not_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#ne_of_beq_false"><span class="name">ne_of_beq_false</span></a></div><div class="nav_link"><a class="break_within" href="#beq_false_of_ne"><span class="name">beq_false_of_ne</span></a></div><div class="nav_link"><a class="break_within" href="#HEq.ndrec"><span class="name">HEq</span>.<span class="name">ndrec</span></a></div><div class="nav_link"><a class="break_within" href="#HEq.ndrecOn"><span class="name">HEq</span>.<span class="name">ndrecOn</span></a></div><div class="nav_link"><a class="break_within" href="#HEq.elim"><span class="name">HEq</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#HEq.subst"><span class="name">HEq</span>.<span class="name">subst</span></a></div><div class="nav_link"><a class="break_within" href="#HEq.symm"><span class="name">HEq</span>.<span class="name">symm</span></a></div><div class="nav_link"><a class="break_within" href="#heq_of_eq"><span class="name">heq_of_eq</span></a></div><div class="nav_link"><a class="break_within" href="#HEq.trans"><span class="name">HEq</span>.<span class="name">trans</span></a></div><div class="nav_link"><a class="break_within" href="#heq_of_heq_of_eq"><span class="name">heq_of_heq_of_eq</span></a></div><div class="nav_link"><a class="break_within" href="#heq_of_eq_of_heq"><span class="name">heq_of_eq_of_heq</span></a></div><div class="nav_link"><a class="break_within" href="#type_eq_of_heq"><span class="name">type_eq_of_heq</span></a></div><div class="nav_link"><a class="break_within" href="#eqRec_heq"><span class="name">eqRec_heq</span></a></div><div class="nav_link"><a class="break_within" href="#heq_of_eqRec_eq"><span class="name">heq_of_eqRec_eq</span></a></div><div class="nav_link"><a class="break_within" href="#cast_heq"><span class="name">cast_heq</span></a></div><div class="nav_link"><a class="break_within" href="#iff_iff_implies_and_implies"><span class="name">iff_iff_implies_and_implies</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.refl"><span class="name">Iff</span>.<span class="name">refl</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.rfl"><span class="name">Iff</span>.<span class="name">rfl</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.trans"><span class="name">Iff</span>.<span class="name">trans</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.symm"><span class="name">Iff</span>.<span class="name">symm</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.comm"><span class="name">Iff</span>.<span class="name">comm</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.of_eq"><span class="name">Iff</span>.<span class="name">of_eq</span></a></div><div class="nav_link"><a class="break_within" href="#And.comm"><span class="name">And</span>.<span class="name">comm</span></a></div><div class="nav_link"><a class="break_within" href="#Exists.elim"><span class="name">Exists</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#decide_true_eq_true"><span class="name">decide_true_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#decide_false_eq_false"><span class="name">decide_false_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#toBoolUsing"><span class="name">toBoolUsing</span></a></div><div class="nav_link"><a class="break_within" href="#toBoolUsing_eq_true"><span class="name">toBoolUsing_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#ofBoolUsing_eq_true"><span class="name">ofBoolUsing_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#ofBoolUsing_eq_false"><span class="name">ofBoolUsing_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableTrue"><span class="name">instDecidableTrue</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableFalse"><span class="name">instDecidableFalse</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.byCases"><span class="name">Decidable</span>.<span class="name">byCases</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.em"><span class="name">Decidable</span>.<span class="name">em</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.byContradiction"><span class="name">Decidable</span>.<span class="name">byContradiction</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.of_not_not"><span class="name">Decidable</span>.<span class="name">of_not_not</span></a></div><div class="nav_link"><a class="break_within" href="#Decidable.not_and_iff_or_not"><span class="name">Decidable</span>.<span class="name">not_and_iff_or_not</span></a></div><div class="nav_link"><a class="break_within" href="#decidable_of_decidable_of_iff"><span class="name">decidable_of_decidable_of_iff</span></a></div><div class="nav_link"><a class="break_within" href="#decidable_of_decidable_of_eq"><span class="name">decidable_of_decidable_of_eq</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableForAll"><span class="name">instDecidableForAll</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableIff"><span class="name">instDecidableIff</span></a></div><div class="nav_link"><a class="break_within" href="#if_pos"><span class="name">if_pos</span></a></div><div class="nav_link"><a class="break_within" href="#if_neg"><span class="name">if_neg</span></a></div><div class="nav_link"><a class="break_within" href="#dif_pos"><span class="name">dif_pos</span></a></div><div class="nav_link"><a class="break_within" href="#dif_neg"><span class="name">dif_neg</span></a></div><div class="nav_link"><a class="break_within" href="#dif_eq_if"><span class="name">dif_eq_if</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableIteProp"><span class="name">instDecidableIteProp</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableDitePropNot"><span class="name">instDecidableDitePropNot</span></a></div><div class="nav_link"><a class="break_within" href="#noConfusionTypeEnum"><span class="name">noConfusionTypeEnum</span></a></div><div class="nav_link"><a class="break_within" href="#noConfusionEnum"><span class="name">noConfusionEnum</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedProp"><span class="name">instInhabitedProp</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedNonScalar"><span class="name">instInhabitedNonScalar</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedPNonScalar"><span class="name">instInhabitedPNonScalar</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedForInStep_1"><span class="name">instInhabitedForInStep_1</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedTrue"><span class="name">instInhabitedTrue</span></a></div><div class="nav_link"><a class="break_within" href="#nonempty_of_exists"><span class="name">nonempty_of_exists</span></a></div><div class="nav_link"><a class="break_within" href="#Subsingleton"><span class="name">Subsingleton</span></a></div><div class="nav_link"><a class="break_within" href="#Subsingleton.elim"><span class="name">Subsingleton</span>.<span class="name">elim</span></a></div><div class="nav_link"><a class="break_within" href="#Subsingleton.helim"><span class="name">Subsingleton</span>.<span class="name">helim</span></a></div><div class="nav_link"><a class="break_within" href="#instSubsingleton"><span class="name">instSubsingleton</span></a></div><div class="nav_link"><a class="break_within" href="#instSubsingletonDecidable"><span class="name">instSubsingletonDecidable</span></a></div><div class="nav_link"><a class="break_within" href="#recSubsingleton"><span class="name">recSubsingleton</span></a></div><div class="nav_link"><a class="break_within" href="#Equivalence"><span class="name">Equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#emptyRelation"><span class="name">emptyRelation</span></a></div><div class="nav_link"><a class="break_within" href="#Subrelation"><span class="name">Subrelation</span></a></div><div class="nav_link"><a class="break_within" href="#InvImage"><span class="name">InvImage</span></a></div><div class="nav_link"><a class="break_within" href="#TC"><span class="name">TC</span></a></div><div class="nav_link"><a class="break_within" href="#Subtype.existsOfSubtype"><span class="name">Subtype</span>.<span class="name">existsOfSubtype</span></a></div><div class="nav_link"><a class="break_within" href="#Subtype.eq"><span class="name">Subtype</span>.<span class="name">eq</span></a></div><div class="nav_link"><a class="break_within" href="#Subtype.eta"><span class="name">Subtype</span>.<span class="name">eta</span></a></div><div class="nav_link"><a class="break_within" href="#Subtype.instInhabitedSubtype"><span class="name">Subtype</span>.<span class="name">instInhabitedSubtype</span></a></div><div class="nav_link"><a class="break_within" href="#Subtype.instDecidableEqSubtype"><span class="name">Subtype</span>.<span class="name">instDecidableEqSubtype</span></a></div><div class="nav_link"><a class="break_within" href="#Sum.inhabitedLeft"><span class="name">Sum</span>.<span class="name">inhabitedLeft</span></a></div><div class="nav_link"><a class="break_within" href="#Sum.inhabitedRight"><span class="name">Sum</span>.<span class="name">inhabitedRight</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqSum"><span class="name">instDecidableEqSum</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedProd"><span class="name">instInhabitedProd</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedMProd"><span class="name">instInhabitedMProd</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedPProd"><span class="name">instInhabitedPProd</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqProd"><span class="name">instDecidableEqProd</span></a></div><div class="nav_link"><a class="break_within" href="#instBEqProd"><span class="name">instBEqProd</span></a></div><div class="nav_link"><a class="break_within" href="#Prod.lexLt"><span class="name">Prod</span>.<span class="name">lexLt</span></a></div><div class="nav_link"><a class="break_within" href="#Prod.lexLtDec"><span class="name">Prod</span>.<span class="name">lexLtDec</span></a></div><div class="nav_link"><a class="break_within" href="#Prod.lexLt_def"><span class="name">Prod</span>.<span class="name">lexLt_def</span></a></div><div class="nav_link"><a class="break_within" href="#Prod.eta"><span class="name">Prod</span>.<span class="name">eta</span></a></div><div class="nav_link"><a class="break_within" href="#Prod.map"><span class="name">Prod</span>.<span class="name">map</span></a></div><div class="nav_link"><a class="break_within" href="#ex_of_PSigma"><span class="name">ex_of_PSigma</span></a></div><div class="nav_link"><a class="break_within" href="#PSigma.eta"><span class="name">PSigma</span>.<span class="name">eta</span></a></div><div class="nav_link"><a class="break_within" href="#PUnit.subsingleton"><span class="name">PUnit</span>.<span class="name">subsingleton</span></a></div><div class="nav_link"><a class="break_within" href="#PUnit.eq_punit"><span class="name">PUnit</span>.<span class="name">eq_punit</span></a></div><div class="nav_link"><a class="break_within" href="#instSubsingletonPUnit"><span class="name">instSubsingletonPUnit</span></a></div><div class="nav_link"><a class="break_within" href="#instInhabitedPUnit"><span class="name">instInhabitedPUnit</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqPUnit"><span class="name">instDecidableEqPUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Setoid"><span class="name">Setoid</span></a></div><div class="nav_link"><a class="break_within" href="#instHasEquiv"><span class="name">instHasEquiv</span></a></div><div class="nav_link"><a class="break_within" href="#Setoid.refl"><span class="name">Setoid</span>.<span class="name">refl</span></a></div><div class="nav_link"><a class="break_within" href="#Setoid.symm"><span class="name">Setoid</span>.<span class="name">symm</span></a></div><div class="nav_link"><a class="break_within" href="#Setoid.trans"><span class="name">Setoid</span>.<span class="name">trans</span></a></div><div class="nav_link"><a class="break_within" href="#propext"><span class="name">propext</span></a></div><div class="nav_link"><a class="break_within" href="#Eq.propIntro"><span class="name">Eq</span>.<span class="name">propIntro</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqProp"><span class="name">instDecidableEqProp</span></a></div><div class="nav_link"><a class="break_within" href="#beq_iff_eq"><span class="name">beq_iff_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Iff.subst"><span class="name">Iff</span>.<span class="name">subst</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.sound"><span class="name">Quot</span>.<span class="name">sound</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.liftBeta"><span class="name">Quot</span>.<span class="name">liftBeta</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.indBeta"><span class="name">Quot</span>.<span class="name">indBeta</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.liftOn"><span class="name">Quot</span>.<span class="name">liftOn</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.inductionOn"><span class="name">Quot</span>.<span class="name">inductionOn</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.exists_rep"><span class="name">Quot</span>.<span class="name">exists_rep</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.indep"><span class="name">Quot</span>.<span class="name">indep</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.indepCoherent"><span class="name">Quot</span>.<span class="name">indepCoherent</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.liftIndepPr1"><span class="name">Quot</span>.<span class="name">liftIndepPr1</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.rec"><span class="name">Quot</span>.<span class="name">rec</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.recOn"><span class="name">Quot</span>.<span class="name">recOn</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.recOnSubsingleton"><span class="name">Quot</span>.<span class="name">recOnSubsingleton</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.hrecOn"><span class="name">Quot</span>.<span class="name">hrecOn</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient"><span class="name">Quotient</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.mk"><span class="name">Quotient</span>.<span class="name">mk</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.mk'"><span class="name">Quotient</span>.<span class="name">mk'</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.sound"><span class="name">Quotient</span>.<span class="name">sound</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.lift"><span class="name">Quotient</span>.<span class="name">lift</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.ind"><span class="name">Quotient</span>.<span class="name">ind</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.liftOn"><span class="name">Quotient</span>.<span class="name">liftOn</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.inductionOn"><span class="name">Quotient</span>.<span class="name">inductionOn</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.exists_rep"><span class="name">Quotient</span>.<span class="name">exists_rep</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.rec"><span class="name">Quotient</span>.<span class="name">rec</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.recOn"><span class="name">Quotient</span>.<span class="name">recOn</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.recOnSubsingleton"><span class="name">Quotient</span>.<span class="name">recOnSubsingleton</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.hrecOn"><span class="name">Quotient</span>.<span class="name">hrecOn</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.lift₂"><span class="name">Quotient</span>.<span class="name">lift₂</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.liftOn₂"><span class="name">Quotient</span>.<span class="name">liftOn₂</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.ind₂"><span class="name">Quotient</span>.<span class="name">ind₂</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.inductionOn₂"><span class="name">Quotient</span>.<span class="name">inductionOn₂</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.inductionOn₃"><span class="name">Quotient</span>.<span class="name">inductionOn₃</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.exact"><span class="name">Quotient</span>.<span class="name">exact</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.recOnSubsingleton₂"><span class="name">Quotient</span>.<span class="name">recOnSubsingleton₂</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqQuotient"><span class="name">instDecidableEqQuotient</span></a></div><div class="nav_link"><a class="break_within" href="#funext"><span class="name">funext</span></a></div><div class="nav_link"><a class="break_within" href="#instSubsingletonForAll"><span class="name">instSubsingletonForAll</span></a></div><div class="nav_link"><a class="break_within" href="#Squash"><span class="name">Squash</span></a></div><div class="nav_link"><a class="break_within" href="#Squash.mk"><span class="name">Squash</span>.<span class="name">mk</span></a></div><div class="nav_link"><a class="break_within" href="#Squash.ind"><span class="name">Squash</span>.<span class="name">ind</span></a></div><div class="nav_link"><a class="break_within" href="#Squash.lift"><span class="name">Squash</span>.<span class="name">lift</span></a></div><div class="nav_link"><a class="break_within" href="#instSubsingletonSquash"><span class="name">instSubsingletonSquash</span></a></div><div class="nav_link"><a class="break_within" href="#Antisymm"><span class="name">Antisymm</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.reduceBool"><span class="name">Lean</span>.<span class="name">reduceBool</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.reduceNat"><span class="name">Lean</span>.<span class="name">reduceNat</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.ofReduceBool"><span class="name">Lean</span>.<span class="name">ofReduceBool</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.ofReduceNat"><span class="name">Lean</span>.<span class="name">ofReduceNat</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.IsAssociative"><span class="name">Lean</span>.<span class="name">IsAssociative</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.IsCommutative"><span class="name">Lean</span>.<span class="name">IsCommutative</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.IsIdempotent"><span class="name">Lean</span>.<span class="name">IsIdempotent</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.IsNeutral"><span class="name">Lean</span>.<span class="name">IsNeutral</span></a></div></nav><main>
<div class="decl" id="inline"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L20-L20">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#inline"><span class="name">inline</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p><code><a href=".././Init/Core.html#inline">inline</a> (f x)</code> is an indication to the compiler to inline the definition of <code>f</code>
at the application site itself (by comparison to the <code>@[inline]</code> attribute,
which applies to all applications of the function).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#inline">inline</a> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></li></ul></details></div></div><div class="decl" id="flip"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L28-L29">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#flip"><span class="name">flip</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{φ : <a href=".././foundational_types.html">Sort</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">φ</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">α</span> → <span class="fn">φ</span></span></span></div></div><p><code><a href=".././Init/Core.html#flip">flip</a> f a b</code> is <code>f b a</code>. It is useful for "point-free" programming,
since it can sometimes be used to avoid introducing variables.
For example, <code>(·<·)</code> is the less-than relation,
and <code><a href=".././Init/Core.html#flip">flip</a> (·<·)</code> is the greater-than relation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#flip">flip</a> <span class="fn">f</span> <span class="fn">b</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">b</span></span></span></li></ul></details></div></div><div class="decl" id="Function.const_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L31-L31">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Function.const_apply"><span class="name">Function</span>.<span class="name">const_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Function.const">Function.const</a> <span class="fn">α</span> <span class="fn">y</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="Function.comp_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L33-L33">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Function.comp_apply"><span class="name">Function</span>.<span class="name">comp_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{δ : <a href=".././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">β</span> → <span class="fn">δ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href=".././Init/Prelude.html#Function.comp"><span class="fn">f</span> <a href=".././Init/Prelude.html#Function.comp">∘</a> <span class="fn">g</span></a>) <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> (<span class="fn"><span class="fn">g</span> <span class="fn">x</span></span>)</span></span></div></div></div></div><div class="decl" id="Thunk"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L41-L46">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Thunk"><span class="name">Thunk</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><ul class="structure_fields" id="Thunk.mk"><li id="Thunk.fn" class="structure_field"><div class="structure_field_info">fn : <span class="fn"><a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn">α</span></span></div></li></ul><p>Thunks are "lazy" values that are evaluated when first accessed using <code>Thunk.get/map/bind</code>.
The value is then stored and not recomputed for all further accesses.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Thunk" class="instances-for-list"></ul></details></div></div><div class="decl" id="Thunk.pure"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L51-L52">source</a></div><div class="attributes">@[extern  lean_thunk_pure]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Thunk.pure"><span class="name">Thunk</span>.<span class="name">pure</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Thunk">Thunk</a> <span class="fn">α</span></span></div></div><p>Store a value in a thunk. Note that the value has already been computed, so there is no laziness.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Thunk.pure">Thunk.pure</a> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">fn</span> := <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn">a</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Thunk.get"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L60-L61">source</a></div><div class="attributes">@[extern  lean_thunk_get_own]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Thunk.get"><span class="name">Thunk</span>.<span class="name">get</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href=".././Init/Core.html#Thunk">Thunk</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Forces a thunk to extract the value. This will cache the result,
so a second call to the same function will return the value in O(1)
instead of calling the stored getter function.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Thunk.get">Thunk.get</a> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#_private.Init.Core.0.Thunk.fn">Thunk.fn</a> <span class="fn">x</span> <a href=".././Init/Prelude.html#Unit.unit">()</a></span></span></li></ul></details></div></div><div class="decl" id="Thunk.map"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L64-L65">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Thunk.map"><span class="name">Thunk</span>.<span class="name">map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn"><a href=".././Init/Core.html#Thunk">Thunk</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Thunk">Thunk</a> <span class="fn">β</span></span></div></div><p>Map a function over a thunk.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Thunk.map">Thunk.map</a> <span class="fn">f</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">fn</span> := <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn">f</span> (<span class="fn"><a href=".././Init/Core.html#Thunk.get">Thunk.get</a> <span class="fn">x</span></span>)</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Thunk.bind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L67-L68">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Thunk.bind"><span class="name">Thunk</span>.<span class="name">bind</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href=".././Init/Core.html#Thunk">Thunk</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn"><a href=".././Init/Core.html#Thunk">Thunk</a> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Thunk">Thunk</a> <span class="fn">β</span></span></div></div><p>Constructs a thunk that applies <code>f</code> to the result of <code>x</code> when forced.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Thunk.bind">Thunk.bind</a> <span class="fn">x</span> <span class="fn">f</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">fn</span> := <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><a href=".././Init/Core.html#Thunk.get">Thunk.get</a> (<span class="fn"><span class="fn">f</span> (<span class="fn"><a href=".././Init/Core.html#Thunk.get">Thunk.get</a> <span class="fn">x</span></span>)</span>)</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Thunk.sizeOf_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L70-L71">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Thunk.sizeOf_eq"><span class="name">Thunk</span>.<span class="name">sizeOf_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/SizeOf.html#SizeOf">SizeOf</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn"><a href=".././Init/Core.html#Thunk">Thunk</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/SizeOf.html#SizeOf.sizeOf">sizeOf</a> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">1</span> <a href=".././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><a href=".././Init/SizeOf.html#SizeOf.sizeOf">sizeOf</a> (<span class="fn"><a href=".././Init/Core.html#Thunk.get">Thunk.get</a> <span class="fn">a</span></span>)</span></span></span></div></div></div></div><div class="decl" id="thunkCoe"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L73-L75">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#thunkCoe"><span class="name">thunkCoe</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn"><a href=".././Init/Prelude.html#semiOutParam">semiOutParam</a> (<a href=".././foundational_types.html">Type</a> u_1)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Coe.html#CoeTail">CoeTail</a> <span class="fn">α</span> (<span class="fn"><a href=".././Init/Core.html#Thunk">Thunk</a> <span class="fn">α</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">thunkCoe</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">coe</span> := <span class="fn">fun <span class="fn">a</span> =&gt <span class="fn">{ <span class="fn">fn</span> := <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn">a</span></span> }</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Iff"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L86-L92">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Iff"><span class="name">Iff</span></a></span><span class="decl_args">
<span class="fn">(a : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(b : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><ul class="structure_ext"><li id="Iff.intro" class="structure_ext_ctor">intro :: (</li><ul class="structure_ext_fields"><li id="Iff.mp" class="structure_field"><div class="structure_field_doc"><p>Modus ponens for if and only if. If <code>a ↔ b</code> and <code>a</code>, then <code>b</code>.</p></div><div class="structure_field_info">mp : <span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span></div></li><li id="Iff.mpr" class="structure_field"><div class="structure_field_doc"><p>Modus ponens for if and only if, reversed. If <code>a ↔ b</code> and <code>b</code>, then <code>a</code>.</p></div><div class="structure_field_info">mpr : <span class="fn"><span class="fn">b</span> → <span class="fn">a</span></span></div></li></ul><li class="structure_ext_ctor">)</li></ul><p>If and only if, or logical bi-implication. <code>a ↔ b</code> means that <code>a</code> implies <code>b</code> and vice versa.
By <code><a href=".././Init/Core.html#propext">propext</a></code>, this implies that <code>a</code> and <code>b</code> are equal and hence any expression involving <code>a</code>
is equivalent to the corresponding expression with <code>b</code> instead.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Iff" class="instances-for-list"></ul></details></div></div><div class="decl" id="«term_<->_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L94-L94">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_<->_»"><span class="name">«term_<->_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>If and only if, or logical bi-implication. <code>a ↔ b</code> means that <code>a</code> implies <code>b</code> and vice versa.
By <code><a href=".././Init/Core.html#propext">propext</a></code>, this implies that <code>a</code> and <code>b</code> are equal and hence any expression involving <code>a</code>
is equivalent to the corresponding expression with <code>b</code> instead.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#«term_<->_»">«term_&lt-&gt_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`term_&lt-&gt_</span> <span class="fn">20</span> <span class="fn">21</span>
    (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot &lt-&gt &quot</span></span>) (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">21</span></span>)</span>)</span></span></li></ul></details></div></div><div class="decl" id="«term_↔_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L95-L95">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_↔_»"><span class="name">«term_↔_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p>If and only if, or logical bi-implication. <code>a ↔ b</code> means that <code>a</code> implies <code>b</code> and vice versa.
By <code><a href=".././Init/Core.html#propext">propext</a></code>, this implies that <code>a</code> and <code>b</code> are equal and hence any expression involving <code>a</code>
is equivalent to the corresponding expression with <code>b</code> instead.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#«term_↔_»">«term_↔_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`term_↔_</span> <span class="fn">20</span> <span class="fn">21</span>
    (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot ↔ &quot</span></span>) (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">21</span></span>)</span>)</span></span></li></ul></details></div></div><div class="decl" id="Sum"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L102-L106">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Sum"><span class="name">Sum</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href=".././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (maxuv)</div></div><ul class="constructors"><li class="constructor" id="Sum.inl"><div class="inductive_ctor_doc"><p>Left injection into the sum type <code>α ⊕ β</code>. If <code>a : α</code> then <code>.<a href=".././Init/Core.html#Sum.inl">inl</a> a : α ⊕ β</code>.</p></div>inl: <span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u} → <span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> v} → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">α</span> <a href=".././Init/Core.html#Sum">⊕</a> <span class="fn">β</span></span></span></span></span></li><li class="constructor" id="Sum.inr"><div class="inductive_ctor_doc"><p>Right injection into the sum type <code>α ⊕ β</code>. If <code>b : β</code> then <code>.<a href=".././Init/Core.html#Sum.inr">inr</a> b : α ⊕ β</code>.</p></div>inr: <span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u} → <span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> v} → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">α</span> <a href=".././Init/Core.html#Sum">⊕</a> <span class="fn">β</span></span></span></span></span></li></ul><p><code><a href=".././Init/Core.html#Sum">Sum</a> α β</code>, or <code>α ⊕ β</code>, is the disjoint union of types <code>α</code> and <code>β</code>.
An element of <code>α ⊕ β</code> is either of the form <code>.<a href=".././Init/Core.html#Sum.inl">inl</a> a</code> where <code>a : α</code>,
or <code>.<a href=".././Init/Core.html#Sum.inr">inr</a> b</code> where <code>b : β</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Sum" class="instances-for-list"></ul></details></div></div><div class="decl" id="«term_⊕_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L108-L108">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_⊕_»"><span class="name">«term_⊕_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code><a href=".././Init/Core.html#Sum">Sum</a> α β</code>, or <code>α ⊕ β</code>, is the disjoint union of types <code>α</code> and <code>β</code>.
An element of <code>α ⊕ β</code> is either of the form <code>.<a href=".././Init/Core.html#Sum.inl">inl</a> a</code> where <code>a : α</code>,
or <code>.<a href=".././Init/Core.html#Sum.inr">inr</a> b</code> where <code>b : β</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#«term_⊕_»">«term_⊕_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`term_⊕_</span> <span class="fn">30</span> <span class="fn">31</span>
    (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot ⊕ &quot</span></span>) (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">30</span></span>)</span>)</span></span></li></ul></details></div></div><div class="decl" id="PSum"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L121-L125">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#PSum"><span class="name">PSum</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Sort</a> u)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href=".././foundational_types.html">Sort</a> v)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> (max(max1u)v)</div></div><ul class="constructors"><li class="constructor" id="PSum.inl"><div class="inductive_ctor_doc"><p>Left injection into the sum type <code>α ⊕' β</code>. If <code>a : α</code> then <code>.<a href=".././Init/Core.html#Sum.inl">inl</a> a : α ⊕' β</code>.</p></div>inl: <span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u} → <span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> v} → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">α</span> <a href=".././Init/Core.html#PSum">⊕'</a> <span class="fn">β</span></span></span></span></span></li><li class="constructor" id="PSum.inr"><div class="inductive_ctor_doc"><p>Right injection into the sum type <code>α ⊕' β</code>. If <code>b : β</code> then <code>.<a href=".././Init/Core.html#Sum.inr">inr</a> b : α ⊕' β</code>.</p></div>inr: <span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u} → <span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> v} → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">α</span> <a href=".././Init/Core.html#PSum">⊕'</a> <span class="fn">β</span></span></span></span></span></li></ul><p><code><a href=".././Init/Core.html#PSum">PSum</a> α β</code>, or <code>α ⊕' β</code>, is the disjoint union of types <code>α</code> and <code>β</code>.
It differs from <code>α ⊕ β</code> in that it allows <code>α</code> and <code>β</code> to have arbitrary sorts
<code>Sort u</code> and <code>Sort v</code>, instead of restricting to <code>Type u</code> and <code>Type v</code>. This means
that it can be used in situations where one side is a proposition, like <code><a href=".././Init/Prelude.html#True">True</a> ⊕' <a href=".././Init/Prelude.html#Nat">Nat</a></code>.</p><p>The reason this is not the default is that this type lives in the universe <code>Sort (max 1 u v)</code>,
which can cause problems for universe level unification,
because the equation <code><a href=".././Init/Core.html#Task.Priority.max">max</a> 1 u v = ?u + 1</code> has no solution in level arithmetic.
<code><a href=".././Init/Core.html#PSum">PSum</a></code> is usually only used in automation that constructs sums of arbitrary types.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-PSum" class="instances-for-list"></ul></details></div></div><div class="decl" id="«term_⊕'_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L127-L127">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_⊕'_»"><span class="name">«term_⊕'_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code><a href=".././Init/Core.html#PSum">PSum</a> α β</code>, or <code>α ⊕' β</code>, is the disjoint union of types <code>α</code> and <code>β</code>.
It differs from <code>α ⊕ β</code> in that it allows <code>α</code> and <code>β</code> to have arbitrary sorts
<code>Sort u</code> and <code>Sort v</code>, instead of restricting to <code>Type u</code> and <code>Type v</code>. This means
that it can be used in situations where one side is a proposition, like <code><a href=".././Init/Prelude.html#True">True</a> ⊕' <a href=".././Init/Prelude.html#Nat">Nat</a></code>.</p><p>The reason this is not the default is that this type lives in the universe <code>Sort (max 1 u v)</code>,
which can cause problems for universe level unification,
because the equation <code><a href=".././Init/Core.html#Task.Priority.max">max</a> 1 u v = ?u + 1</code> has no solution in level arithmetic.
<code><a href=".././Init/Core.html#PSum">PSum</a></code> is usually only used in automation that constructs sums of arbitrary types.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#«term_⊕'_»">«term_⊕'_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`term_⊕'_</span> <span class="fn">30</span> <span class="fn">31</span>
    (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot ⊕' &quot</span></span>) (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">30</span></span>)</span>)</span></span></li></ul></details></div></div><div class="decl" id="Sigma"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L136-L144">source</a></div><div class="attributes">@[unbox]</div>
<div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Sigma"><span class="name">Sigma</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(β : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Type</a> v</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (maxuv)</div></div><ul class="structure_fields" id="Sigma.mk"><li id="Sigma.fst" class="structure_field"><div class="structure_field_doc"><p>The first component of a dependent pair. If <code>p : @Sigma α β</code> then <code>p.1 : α</code>.</p></div><div class="structure_field_info">fst : <span class="fn">α</span></div></li><li id="Sigma.snd" class="structure_field"><div class="structure_field_doc"><p>The second component of a dependent pair. If <code>p : <a href=".././Init/Core.html#Sigma">Sigma</a> β</code> then <code>p.2 : β p.1</code>.</p></div><div class="structure_field_info">snd : <span class="fn"><span class="fn">β</span> <span class="fn">fst</span></span></div></li></ul><p><code><a href=".././Init/Core.html#Sigma">Sigma</a> β</code>, also denoted <code>Σ a : α, β a</code> or <code>(a : α) × β a</code>, is the type of dependent pairs
whose first component is <code>a : α</code> and whose second component is <code>b : β a</code>
(so the type of the second component can depend on the value of the first component).
It is sometimes known as the dependent sum type, since it is the type level version
of an indexed summation.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Sigma" class="instances-for-list"></ul></details></div></div><div class="decl" id="PSigma"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L161-L169">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#PSigma"><span class="name">PSigma</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(β : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Sort</a> v</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> (max(max1u)v)</div></div><ul class="structure_fields" id="PSigma.mk"><li id="PSigma.fst" class="structure_field"><div class="structure_field_doc"><p>The first component of a dependent pair. If <code>p : @Sigma α β</code> then <code>p.1 : α</code>.</p></div><div class="structure_field_info">fst : <span class="fn">α</span></div></li><li id="PSigma.snd" class="structure_field"><div class="structure_field_doc"><p>The second component of a dependent pair. If <code>p : <a href=".././Init/Core.html#Sigma">Sigma</a> β</code> then <code>p.2 : β p.1</code>.</p></div><div class="structure_field_info">snd : <span class="fn"><span class="fn">β</span> <span class="fn">fst</span></span></div></li></ul><p><code><a href=".././Init/Core.html#PSigma">PSigma</a> β</code>, also denoted <code>Σ' a : α, β a</code> or <code>(a : α) ×' β a</code>, is the type of dependent pairs
whose first component is <code>a : α</code> and whose second component is <code>b : β a</code>
(so the type of the second component can depend on the value of the first component).
It differs from <code>Σ a : α, β a</code> in that it allows <code>α</code> and <code>β</code> to have arbitrary sorts
<code>Sort u</code> and <code>Sort v</code>, instead of restricting to <code>Type u</code> and <code>Type v</code>. This means
that it can be used in situations where one side is a proposition, like <code>(p : Nat) ×' p = p</code>.</p><p>The reason this is not the default is that this type lives in the universe <code>Sort (max 1 u v)</code>,
which can cause problems for universe level unification,
because the equation <code><a href=".././Init/Core.html#Task.Priority.max">max</a> 1 u v = ?u + 1</code> has no solution in level arithmetic.
<code><a href=".././Init/Core.html#PSigma">PSigma</a></code> is usually only used in automation that constructs pairs of arbitrary types.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-PSigma" class="instances-for-list"></ul></details></div></div><div class="decl" id="Exists"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L196-L199">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Exists"><span class="name">Exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><ul class="constructors"><li class="constructor" id="Exists.intro"><div class="inductive_ctor_doc"><p>Existential introduction. If <code>a : α</code> and <code>h : p a</code>,
then <code>⟨a, h⟩</code> is a proof that <code>∃ x : α, p x</code>.</p></div>intro: <span class="fn">∀ {<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u} {<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>} (<span class="fn">w</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">w</span></span> → <span class="fn"><a href=".././Init/Core.html#Exists">Exists</a> <span class="fn">p</span></span></span></span></li></ul><p>Existential quantification. If <code>p : α → Prop</code> is a predicate, then <code>∃ x : α, p x</code>
asserts that there is some <code>x</code> of type <code>α</code> such that <code>p x</code> holds.
To create an existential proof, use the <code>exists</code> tactic,
or the anonymous constructor notation <code>⟨x, h⟩</code>.
To unpack an existential, use <code>cases h</code> where <code>h</code> is a proof of <code>∃ x : α, p x</code>,
or <code>let ⟨x, hx⟩ := h</code> where `.</p><p>Because Lean has proof irrelevance, any two proofs of an existential are
definitionally equal. One consequence of this is that it is impossible to recover the
witness of an existential from the mere fact of its existence.
For example, the following does not compile:</p><pre><code>example (h : ∃ x : Nat, x = x) : <a href=".././Init/Prelude.html#Nat">Nat</a> :=
  let ⟨x, _⟩ := h  -- fail, because the goal is `Nat : Type`
  x
</code></pre><p>The error message <code>recursor 'Exists.casesOn' can only eliminate into Prop</code> means
that this only works when the current goal is another proposition:</p><pre><code>example (h : ∃ x : Nat, x = x) : <a href=".././Init/Prelude.html#True">True</a> :=
  let ⟨x, _⟩ := h  -- ok, because the goal is `True : Prop`
  <a href=".././Init/Core.html#trivial">trivial</a>
</code></pre><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Exists" class="instances-for-list"></ul></details></div></div><div class="decl" id="ForInStep"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L212-L219">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#ForInStep"><span class="name">ForInStep</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><ul class="constructors"><li class="constructor" id="ForInStep.done"><div class="inductive_ctor_doc"><p><code>.<a href=".././Init/Core.html#ForInStep.done">done</a> a</code> means that we should early-exit the loop.
<code>.<a href=".././Init/Core.html#ForInStep.done">done</a></code> is produced by calls to <code><a href=".././Init/Core.html#DoResultPRBC.break">break</a></code> or <code><a href=".././Init/Core.html#DoResultPRBC.return">return</a></code> in the loop.</p></div>done: <span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn">α</span> → <span class="fn"><a href=".././Init/Core.html#ForInStep">ForInStep</a> <span class="fn">α</span></span></span></span></li><li class="constructor" id="ForInStep.yield"><div class="inductive_ctor_doc"><p><code>.<a href=".././Init/Core.html#ForInStep.yield">yield</a> a</code> means that we should continue the loop.
<code>.<a href=".././Init/Core.html#ForInStep.yield">yield</a></code> is produced by <code><a href=".././Init/Core.html#DoResultPRBC.continue">continue</a></code> and reaching the bottom of the loop body.</p></div>yield: <span class="fn">{<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn">α</span> → <span class="fn"><a href=".././Init/Core.html#ForInStep">ForInStep</a> <span class="fn">α</span></span></span></span></li></ul><p>Auxiliary type used to compile <code>for x in xs</code> notation.</p><p>This is the return value of the body of a <code><a href=".././Init/Core.html#ForIn">ForIn</a></code> call,
representing the body of a for loop. It can be:</p><ul>
<li><code>.<a href=".././Init/Core.html#ForInStep.yield">yield</a> (a : α)</code>, meaning that we should continue the loop and <code>a</code> is the new state.
<code>.<a href=".././Init/Core.html#ForInStep.yield">yield</a></code> is produced by <code><a href=".././Init/Core.html#DoResultPRBC.continue">continue</a></code> and reaching the bottom of the loop body.</li>
<li><code>.<a href=".././Init/Core.html#ForInStep.done">done</a> (a : α)</code>, meaning that we should early-exit the loop with state <code>a</code>.
<code>.<a href=".././Init/Core.html#ForInStep.done">done</a></code> is produced by calls to <code><a href=".././Init/Core.html#DoResultPRBC.break">break</a></code> or <code><a href=".././Init/Core.html#DoResultPRBC.return">return</a></code> in the loop,</li>
</ul><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-ForInStep" class="instances-for-list"></ul></details></div></div><div class="decl" id="instInhabitedForInStep"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L219-L219">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedForInStep"><span class="name">instInhabitedForInStep</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">{<span class="fn">a</span> : <a href=".././foundational_types.html">Type</a> u_1} → <span class="fn">[<span class="fn">inst</span> : <span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">a</span></span>] → <span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> (<span class="fn"><a href=".././Init/Core.html#ForInStep">ForInStep</a> <span class="fn">a</span></span>)</span></span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instInhabitedForInStep</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn"><a href=".././Init/Core.html#ForInStep.done">ForInStep.done</a> <span class="fn">default</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="ForIn"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L227-L248">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#ForIn"><span class="name">ForIn</span></a></span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href=".././foundational_types.html">Type</a> u₁ → <a href=".././foundational_types.html">Type</a> u₂</span>)</span></span>
<span class="decl_args">
<span class="fn">(ρ : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(α : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> (<a href=".././foundational_types.html">Type</a> v)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max(max(maxu(u₁+1))u₂)v)</div></div><ul class="structure_fields" id="ForIn.mk"><li id="ForIn.forIn" class="structure_field"><div class="structure_field_doc"><p><code><a href=".././Init/Core.html#ForIn.forIn">forIn</a> x b f : m β</code> runs a for-loop in the monad <code>m</code> with additional state <code>β</code>.
This traverses over the "contents" of <code>x</code>, and passes the elements <code>a : α</code> to
<code>f : α → β → m (ForInStep β)</code>. <code>b : β</code> is the initial state, and the return value
of <code>f</code> is the new state as well as a directive <code>.<a href=".././Init/Core.html#ForInStep.done">done</a></code> or <code>.<a href=".././Init/Core.html#ForInStep.yield">yield</a></code>
which indicates whether to abort early or continue iteration.</p><p>The expression</p><pre><code>let mut b := ...
for x in xs do
  b ← foo x b
</code></pre><p>in a <code>do</code> block is syntactic sugar for:</p><pre><code>let b := ...
let b ← <a href=".././Init/Core.html#ForIn.forIn">forIn</a> xs b (fun x b => do
  let b ← foo x b
  <a href=".././Init/Core.html#DoResultPRBC.return">return</a> .<a href=".././Init/Core.html#ForInStep.yield">yield</a> b)
</code></pre><p>(Here <code>b</code> corresponds to the variables mutated in the loop.)</p></div><div class="structure_field_info">forIn : <span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u₁} → <span class="fn">[<span class="fn">inst</span> : <span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>] → <span class="fn"><span class="fn">ρ</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">(<span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">m</span> (<span class="fn"><a href=".././Init/Core.html#ForInStep">ForInStep</a> <span class="fn">β</span></span>)</span></span></span>) → <span class="fn"><span class="fn">m</span> <span class="fn">β</span></span></span></span></span></span></span></div></li></ul><p><code><a href=".././Init/Core.html#ForIn">ForIn</a> m ρ α</code> is the typeclass which supports <code>for x in xs</code> notation.
Here <code>xs : ρ</code> is the type of the collection to iterate over, <code>x : α</code>
is the element type which is made available inside the loop, and <code>m</code> is the monad
for the encompassing <code>do</code> block.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-ForIn" class="instances-list"></ul></details></div></div><div class="decl" id="ForIn'"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L257-L264">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#ForIn'"><span class="name">ForIn'</span></a></span><span class="decl_args">
<span class="fn">(m : <span class="fn"><a href=".././foundational_types.html">Type</a> u₁ → <a href=".././foundational_types.html">Type</a> u₂</span>)</span></span>
<span class="decl_args">
<span class="fn">(ρ : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(α : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> (<a href=".././foundational_types.html">Type</a> v)</span>)</span></span>
<span class="decl_args">
<span class="fn">(d : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> (<span class="fn"><a href=".././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">ρ</span></span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> (max(max(maxu(u₁+1))u₂)v)</div></div><ul class="structure_fields" id="ForIn'.mk"><li id="ForIn'.forIn'" class="structure_field"><div class="structure_field_doc"><p><code><a href=".././Init/Core.html#ForIn'.forIn'">forIn'</a> x b f : m β</code> runs a for-loop in the monad <code>m</code> with additional state <code>β</code>.
This traverses over the "contents" of <code>x</code>, and passes the elements <code>a : α</code> along
with a proof that <code>a ∈ x</code> to <code>f : (a : α) → a ∈ x → β → m (ForInStep β)</code>.
<code>b : β</code> is the initial state, and the return value
of <code>f</code> is the new state as well as a directive <code>.<a href=".././Init/Core.html#ForInStep.done">done</a></code> or <code>.<a href=".././Init/Core.html#ForInStep.yield">yield</a></code>
which indicates whether to abort early or continue iteration.</p></div><div class="structure_field_info">forIn' : <span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Type</a> u₁} → <span class="fn">[<span class="fn">inst</span> : <span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>] → <span class="fn">(<span class="fn">x</span> : <span class="fn">ρ</span>) → <span class="fn"><span class="fn">β</span> → <span class="fn">(<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">x</span></span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">m</span> (<span class="fn"><a href=".././Init/Core.html#ForInStep">ForInStep</a> <span class="fn">β</span></span>)</span></span></span></span>) → <span class="fn"><span class="fn">m</span> <span class="fn">β</span></span></span></span></span></span></span></div></li></ul><p><code><a href=".././Init/Core.html#ForIn'">ForIn'</a> m ρ α d</code> is a variation on the <code><a href=".././Init/Core.html#ForIn">ForIn</a> m ρ α</code> typeclass which supports the
<code>for h : x in xs</code> notation. It is the same as <code>for x in xs</code> except that <code>h : x ∈ xs</code>
is provided as an additional argument to the body of the for-loop.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-ForIn'" class="instances-list"></ul></details></div></div><div class="decl" id="DoResultPRBC"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L282-L292">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#DoResultPRBC"><span class="name">DoResultPRBC</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(σ : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><ul class="constructors"><li class="constructor" id="DoResultPRBC.pure"><div class="inductive_ctor_doc"><p><code><a href=".././Init/Core.html#Thunk.pure">pure</a> (a : α) s</code> means that the block exited normally with return value <code>a</code></p></div>pure: <span class="fn">{<span class="fn">α </span>β σ : <a href=".././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Core.html#DoResultPRBC">DoResultPRBC</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">σ</span></span></span></span></span></li><li class="constructor" id="DoResultPRBC.return"><div class="inductive_ctor_doc"><p><code><a href=".././Init/Core.html#DoResultPRBC.return">return</a> (b : β) s</code> means that the block exited via a <code><a href=".././Init/Core.html#DoResultPRBC.return">return</a> b</code> early-exit command</p></div>return: <span class="fn">{<span class="fn">α </span>β σ : <a href=".././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Core.html#DoResultPRBC">DoResultPRBC</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">σ</span></span></span></span></span></li><li class="constructor" id="DoResultPRBC.break"><div class="inductive_ctor_doc"><p><code><a href=".././Init/Core.html#DoResultPRBC.break">break</a> s</code> means that <code><a href=".././Init/Core.html#DoResultPRBC.break">break</a></code> was called, meaning that we should exit
from the containing loop</p></div>break: <span class="fn">{<span class="fn">α </span>β σ : <a href=".././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Core.html#DoResultPRBC">DoResultPRBC</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">σ</span></span></span></span></li><li class="constructor" id="DoResultPRBC.continue"><div class="inductive_ctor_doc"><p><code><a href=".././Init/Core.html#DoResultPRBC.continue">continue</a> s</code> means that <code><a href=".././Init/Core.html#DoResultPRBC.continue">continue</a></code> was called, meaning that we should continue
to the next iteration of the containing loop</p></div>continue: <span class="fn">{<span class="fn">α </span>β σ : <a href=".././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Core.html#DoResultPRBC">DoResultPRBC</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">σ</span></span></span></span></li></ul><p>Auxiliary type used to compile <code>do</code> notation. It is used when compiling a do block
nested inside a combinator like <code>tryCatch</code>. It encodes the possible ways the
block can exit:</p><ul>
<li><code><a href=".././Init/Core.html#Thunk.pure">pure</a> (a : α) s</code> means that the block exited normally with return value <code>a</code>.</li>
<li><code><a href=".././Init/Core.html#DoResultPRBC.return">return</a> (b : β) s</code> means that the block exited via a <code><a href=".././Init/Core.html#DoResultPRBC.return">return</a> b</code> early-exit command.</li>
<li><code><a href=".././Init/Core.html#DoResultPRBC.break">break</a> s</code> means that <code><a href=".././Init/Core.html#DoResultPRBC.break">break</a></code> was called, meaning that we should exit
from the containing loop.</li>
<li><code><a href=".././Init/Core.html#DoResultPRBC.continue">continue</a> s</code> means that <code><a href=".././Init/Core.html#DoResultPRBC.continue">continue</a></code> was called, meaning that we should continue
to the next iteration of the containing loop.</li>
</ul><p>All cases return a value <code>s : σ</code> which bundles all the mutable variables of the do-block.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-DoResultPRBC" class="instances-for-list"></ul></details></div></div><div class="decl" id="DoResultPR"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L299-L303">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#DoResultPR"><span class="name">DoResultPR</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(σ : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><ul class="constructors"><li class="constructor" id="DoResultPR.pure"><div class="inductive_ctor_doc"><p><code><a href=".././Init/Core.html#Thunk.pure">pure</a> (a : α) s</code> means that the block exited normally with return value <code>a</code></p></div>pure: <span class="fn">{<span class="fn">α </span>β σ : <a href=".././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Core.html#DoResultPR">DoResultPR</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">σ</span></span></span></span></span></li><li class="constructor" id="DoResultPR.return"><div class="inductive_ctor_doc"><p><code><a href=".././Init/Core.html#DoResultPRBC.return">return</a> (b : β) s</code> means that the block exited via a <code><a href=".././Init/Core.html#DoResultPRBC.return">return</a> b</code> early-exit command</p></div>return: <span class="fn">{<span class="fn">α </span>β σ : <a href=".././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Core.html#DoResultPR">DoResultPR</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">σ</span></span></span></span></span></li></ul><p>Auxiliary type used to compile <code>do</code> notation. It is the same as
<code><a href=".././Init/Core.html#DoResultPRBC">DoResultPRBC</a> α β σ</code> except that <code><a href=".././Init/Core.html#DoResultPRBC.break">break</a></code> and <code><a href=".././Init/Core.html#DoResultPRBC.continue">continue</a></code> are not available
because we are not in a loop context.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-DoResultPR" class="instances-for-list"></ul></details></div></div><div class="decl" id="DoResultBC"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L310-L316">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#DoResultBC"><span class="name">DoResultBC</span></a></span><span class="decl_args">
<span class="fn">(σ : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><ul class="constructors"><li class="constructor" id="DoResultBC.break"><div class="inductive_ctor_doc"><p><code><a href=".././Init/Core.html#DoResultPRBC.break">break</a> s</code> means that <code><a href=".././Init/Core.html#DoResultPRBC.break">break</a></code> was called, meaning that we should exit
from the containing loop</p></div>break: <span class="fn">{<span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Core.html#DoResultBC">DoResultBC</a> <span class="fn">σ</span></span></span></span></li><li class="constructor" id="DoResultBC.continue"><div class="inductive_ctor_doc"><p><code><a href=".././Init/Core.html#DoResultPRBC.continue">continue</a> s</code> means that <code><a href=".././Init/Core.html#DoResultPRBC.continue">continue</a></code> was called, meaning that we should continue
to the next iteration of the containing loop</p></div>continue: <span class="fn">{<span class="fn">σ</span> : <a href=".././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Core.html#DoResultBC">DoResultBC</a> <span class="fn">σ</span></span></span></span></li></ul><p>Auxiliary type used to compile <code>do</code> notation. It is an optimization of
<code><a href=".././Init/Core.html#DoResultPRBC">DoResultPRBC</a> <a href=".././Init/Prelude.html#PEmpty">PEmpty</a> <a href=".././Init/Prelude.html#PEmpty">PEmpty</a> σ</code> to remove the impossible cases,
used when neither <code><a href=".././Init/Core.html#Thunk.pure">pure</a></code> nor <code><a href=".././Init/Core.html#DoResultPRBC.return">return</a></code> are possible exit paths.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-DoResultBC" class="instances-for-list"></ul></details></div></div><div class="decl" id="DoResultSBC"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L323-L335">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#DoResultSBC"><span class="name">DoResultSBC</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(σ : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><ul class="constructors"><li class="constructor" id="DoResultSBC.pureReturn"><div class="inductive_ctor_doc"><p>This encodes either <code><a href=".././Init/Core.html#Thunk.pure">pure</a> (a : α)</code> or <code><a href=".././Init/Core.html#DoResultPRBC.return">return</a> (a : α)</code>:</p><ul>
<li><code><a href=".././Init/Core.html#Thunk.pure">pure</a> (a : α) s</code> means that the block exited normally with return value <code>a</code></li>
<li><code><a href=".././Init/Core.html#DoResultPRBC.return">return</a> (b : β) s</code> means that the block exited via a <code><a href=".././Init/Core.html#DoResultPRBC.return">return</a> b</code> early-exit command</li>
</ul><p>The one that is actually encoded depends on the context of use.</p></div>pureReturn: <span class="fn">{<span class="fn">α </span>σ : <a href=".././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Core.html#DoResultSBC">DoResultSBC</a> <span class="fn">α</span> <span class="fn">σ</span></span></span></span></span></li><li class="constructor" id="DoResultSBC.break"><div class="inductive_ctor_doc"><p><code><a href=".././Init/Core.html#DoResultPRBC.break">break</a> s</code> means that <code><a href=".././Init/Core.html#DoResultPRBC.break">break</a></code> was called, meaning that we should exit
from the containing loop</p></div>break: <span class="fn">{<span class="fn">α </span>σ : <a href=".././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Core.html#DoResultSBC">DoResultSBC</a> <span class="fn">α</span> <span class="fn">σ</span></span></span></span></li><li class="constructor" id="DoResultSBC.continue"><div class="inductive_ctor_doc"><p><code><a href=".././Init/Core.html#DoResultPRBC.continue">continue</a> s</code> means that <code><a href=".././Init/Core.html#DoResultPRBC.continue">continue</a></code> was called, meaning that we should continue
to the next iteration of the containing loop</p></div>continue: <span class="fn">{<span class="fn">α </span>σ : <a href=".././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Core.html#DoResultSBC">DoResultSBC</a> <span class="fn">α</span> <span class="fn">σ</span></span></span></span></li></ul><p>Auxiliary type used to compile <code>do</code> notation. It is an optimization of
either <code><a href=".././Init/Core.html#DoResultPRBC">DoResultPRBC</a> α <a href=".././Init/Prelude.html#PEmpty">PEmpty</a> σ</code> or <code><a href=".././Init/Core.html#DoResultPRBC">DoResultPRBC</a> <a href=".././Init/Prelude.html#PEmpty">PEmpty</a> α σ</code> to remove the
impossible case, used when either <code><a href=".././Init/Core.html#Thunk.pure">pure</a></code> or <code><a href=".././Init/Core.html#DoResultPRBC.return">return</a></code> is never used.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-DoResultSBC" class="instances-for-list"></ul></details></div></div><div class="decl" id="HasEquiv"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L338-L341">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#HasEquiv"><span class="name">HasEquiv</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Sort</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> (maxu(v+1))</div></div><ul class="structure_fields" id="HasEquiv.mk"><li id="HasEquiv.Equiv" class="structure_field"><div class="structure_field_doc"><p><code>x ≈ y</code> says that <code>x</code> and <code>y</code> are equivalent. Because this is a typeclass,
the notion of equivalence is type-dependent.</p></div><div class="structure_field_info">Equiv : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Sort</a> v</span></div></li></ul><p><code><a href=".././Init/Core.html#HasEquiv">HasEquiv</a> α</code> is the typeclass which supports the notation <code>x ≈ y</code> where <code>x y : α</code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-HasEquiv" class="instances-list"></ul></details></div></div><div class="decl" id="«term_≈_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L343-L343">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_≈_»"><span class="name">«term_≈_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>x ≈ y</code> says that <code>x</code> and <code>y</code> are equivalent. Because this is a typeclass,
the notion of equivalence is type-dependent.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#«term_≈_»">«term_≈_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`term_≈_</span> <span class="fn">50</span> <span class="fn">51</span>
    (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot ≈ &quot</span></span>) (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">51</span></span>)</span>)</span></span></li></ul></details></div></div><div class="decl" id="EmptyCollection"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L346-L349">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#EmptyCollection"><span class="name">EmptyCollection</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><ul class="structure_fields" id="EmptyCollection.mk"><li id="EmptyCollection.emptyCollection" class="structure_field"><div class="structure_field_doc"><p><code>∅</code> or <code>{}</code> is the empty set or empty collection.
It is supported by the <code><a href=".././Init/Core.html#EmptyCollection">EmptyCollection</a></code> typeclass.</p></div><div class="structure_field_info">emptyCollection : <span class="fn">α</span></div></li></ul><p><code><a href=".././Init/Core.html#EmptyCollection">EmptyCollection</a> α</code> is the typeclass which supports the notation <code>∅</code>, also written as <code>{}</code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-EmptyCollection" class="instances-list"></ul></details></div></div><div class="decl" id="«term{}»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L351-L351">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term{}»"><span class="name">«term{}»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>∅</code> or <code>{}</code> is the empty set or empty collection.
It is supported by the <code><a href=".././Init/Core.html#EmptyCollection">EmptyCollection</a></code> typeclass.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#«term{}»">«term{}»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`term{}</span> <span class="fn">1024</span>
    (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot{&quot</span></span>) (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot}&quot</span></span>)</span>)</span></span></li></ul></details></div></div><div class="decl" id="«term∅»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L352-L352">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term∅»"><span class="name">«term∅»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>∅</code> or <code>{}</code> is the empty set or empty collection.
It is supported by the <code><a href=".././Init/Core.html#EmptyCollection">EmptyCollection</a></code> typeclass.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#«term∅»">«term∅»</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`term∅</span> <span class="fn">1024</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot∅&quot</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="Task"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L362-L368">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Task"><span class="name">Task</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><ul class="structure_ext"><li id="Task.pure" class="structure_ext_ctor">pure :: (</li><ul class="structure_ext_fields"><li id="Task.get" class="structure_field"><div class="structure_field_doc"><p>If <code>task : <a href=".././Init/Core.html#Task">Task</a> α</code> then <code>task.<a href=".././Init/Core.html#Thunk.get">get</a> : α</code> blocks the current thread until the
value is available, and then returns the result of the task.</p></div><div class="structure_field_info">get : <span class="fn">α</span></div></li></ul><li class="structure_ext_ctor">)</li></ul><p><code><a href=".././Init/Core.html#Task">Task</a> α</code> is a primitive for asynchronous computation.
It represents a computation that will resolve to a value of type <code>α</code>,
possibly being computed on another thread. This is similar to <code>Future</code> in Scala,
<code>Promise</code> in Javascript, and <code>JoinHandle</code> in Rust.</p><p>The tasks have an overridden representation in the runtime.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Task" class="instances-for-list"></ul></details></div></div><div class="decl" id="instInhabitedTask"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L368-L368">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedTask"><span class="name">instInhabitedTask</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">{<span class="fn">a</span> : <a href=".././foundational_types.html">Type</a> u_1} → <span class="fn">[<span class="fn">inst</span> : <span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">a</span></span>] → <span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> (<span class="fn"><a href=".././Init/Core.html#Task">Task</a> <span class="fn">a</span></span>)</span></span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instInhabitedTask</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">{ <span class="fn">get</span> := <span class="fn">default</span> }</span> }</span></span></li></ul></details></div></div><div class="decl" id="instNonemptyTask"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L368-L368">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instNonemptyTask"><span class="name">instNonemptyTask</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">α</span> : <a href=".././foundational_types.html">Type</a> u_1} [<span class="fn">inst</span> : <span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>], <span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> (<span class="fn"><a href=".././Init/Core.html#Task">Task</a> <span class="fn">α</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instNonemptyTask">@<a href=".././Init/Core.html#instNonemptyTask">instNonemptyTask</a></a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Core.html#instNonemptyTask.proof_1">@<a href=".././Init/Core.html#instNonemptyTask.proof_1">instNonemptyTask.proof_1</a></a></span></li></ul></details></div></div><div class="decl" id="Task.Priority"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L375-L375">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Task.Priority"><span class="name">Task</span>.<span class="name">Priority</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>Task priority. Tasks with higher priority will always be scheduled before ones with lower priority.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Task.Priority">Task.Priority</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Nat">Nat</a></span></li></ul></details></div></div><div class="decl" id="Task.Priority.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L378-L378">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Task.Priority.default"><span class="name">Task</span>.<span class="name">Priority</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Core.html#Task.Priority">Task.Priority</a></div></div><p>The default priority for spawned tasks, also the lowest priority: <code>0</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Task.Priority.default">Task.Priority.default</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></span></li></ul></details></div></div><div class="decl" id="Task.Priority.max"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L387-L387">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Task.Priority.max"><span class="name">Task</span>.<span class="name">Priority</span>.<span class="name">max</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Core.html#Task.Priority">Task.Priority</a></div></div><p>The highest regular priority for spawned tasks: <code>8</code>.</p><p>Spawning a task with a priority higher than <code><a href=".././Init/Core.html#Task.Priority.max">Task.Priority.max</a></code> is not an error but
will spawn a dedicated worker for the task, see <code><a href=".././Init/Core.html#Task.Priority.dedicated">Task.Priority.dedicated</a></code>.
Regular priority tasks are placed in a thread pool and worked on according to the priority order.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Task.Priority.max">Task.Priority.max</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">8</span></span></li></ul></details></div></div><div class="decl" id="Task.Priority.dedicated"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L394-L394">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Task.Priority.dedicated"><span class="name">Task</span>.<span class="name">Priority</span>.<span class="name">dedicated</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Core.html#Task.Priority">Task.Priority</a></div></div><p>Any priority higher than <code><a href=".././Init/Core.html#Task.Priority.max">Task.Priority.max</a></code> will result in the task being scheduled
immediately on a dedicated thread. This is particularly useful for long-running and/or
I/O-bound tasks since Lean will by default allocate no more non-dedicated workers
than the number of cores to reduce context switches.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Task.Priority.dedicated">Task.Priority.dedicated</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">9</span></span></li></ul></details></div></div><div class="decl" id="Task.spawn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L404-L405">source</a></div><div class="attributes">@[noinline, extern  lean_task_spawn]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Task.spawn"><span class="name">Task</span>.<span class="name">spawn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(fn : <span class="fn"><a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(prio : <span class="fn"><a href=".././Init/Prelude.html#optParam">optParam</a> <a href=".././Init/Core.html#Task.Priority">Task.Priority</a> <a href=".././Init/Core.html#Task.Priority.default">Task.Priority.default</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Task">Task</a> <span class="fn">α</span></span></div></div><p><code><a href=".././Init/Core.html#Task.spawn">spawn</a> fn : <a href=".././Init/Core.html#Task">Task</a> α</code> constructs and immediately launches a new task for
evaluating the function <code>fn () : α</code> asynchronously.</p><p><code>prio</code>, if provided, is the priority of the task.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Task.spawn">Task.spawn</a> <span class="fn">fn</span> <span class="fn">prio</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">get</span> := <span class="fn"><span class="fn">fn</span> <a href=".././Init/Prelude.html#Unit.unit">()</a></span> }</span></span></li></ul></details></div></div><div class="decl" id="Task.map"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L416-L417">source</a></div><div class="attributes">@[noinline, extern  lean_task_map]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Task.map"><span class="name">Task</span>.<span class="name">map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn"><a href=".././Init/Core.html#Task">Task</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(prio : <span class="fn"><a href=".././Init/Prelude.html#optParam">optParam</a> <a href=".././Init/Core.html#Task.Priority">Task.Priority</a> <a href=".././Init/Core.html#Task.Priority.default">Task.Priority.default</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Task">Task</a> <span class="fn">β</span></span></div></div><p><code><a href=".././Init/Core.html#Thunk.map">map</a> f x</code> maps function <code>f</code> over the task <code>x</code>: that is, it constructs
(and immediately launches) a new task which will wait for the value of <code>x</code> to
be available and then calls <code>f</code> on the result.</p><p><code>prio</code>, if provided, is the priority of the task.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Task.map">Task.map</a> <span class="fn">f</span> <span class="fn">x</span> <span class="fn">prio</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">get</span> := <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">x</span>.get</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Task.bind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L429-L430">source</a></div><div class="attributes">@[noinline, extern  lean_task_bind]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Task.bind"><span class="name">Task</span>.<span class="name">bind</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href=".././Init/Core.html#Task">Task</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn"><a href=".././Init/Core.html#Task">Task</a> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(prio : <span class="fn"><a href=".././Init/Prelude.html#optParam">optParam</a> <a href=".././Init/Core.html#Task.Priority">Task.Priority</a> <a href=".././Init/Core.html#Task.Priority.default">Task.Priority.default</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Task">Task</a> <span class="fn">β</span></span></div></div><p><code><a href=".././Init/Core.html#Thunk.bind">bind</a> x f</code> does a monad "bind" operation on the task <code>x</code> with function <code>f</code>:
that is, it constructs (and immediately launches) a new task which will wait
for the value of <code>x</code> to be available and then calls <code>f</code> on the result,
resulting in a new task which is then run for a result.</p><p><code>prio</code>, if provided, is the priority of the task.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Task.bind">Task.bind</a> <span class="fn">x</span> <span class="fn">f</span> <span class="fn">prio</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">get</span> := <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">x</span>.get</span></span>).get</span> }</span></span></li></ul></details></div></div><div class="decl" id="NonScalar"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L440-L442">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#NonScalar"><span class="name">NonScalar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="NonScalar.mk"><li id="NonScalar.val" class="structure_field"><div class="structure_field_doc"><p>You should not use this function</p></div><div class="structure_field_info">val : <a href=".././Init/Prelude.html#Nat">Nat</a></div></li></ul><p><code><a href=".././Init/Core.html#NonScalar">NonScalar</a></code> is a type that is not a scalar value in our runtime.
It is used as a stand-in for an arbitrary boxed value to avoid excessive
monomorphization, and it is only created using <code><a href=".././Init/Prelude.html#unsafeCast">unsafeCast</a></code>. It is somewhat
analogous to C <code>void*</code> in usage, but the type itself is not special.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-NonScalar" class="instances-for-list"></ul></details></div></div><div class="decl" id="PNonScalar"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L453-L455">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#PNonScalar"><span class="name">PNonScalar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><ul class="constructors"><li class="constructor" id="PNonScalar.mk"><div class="inductive_ctor_doc"><p>You should not use this function</p></div>mk: <span class="fn"><a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Core.html#PNonScalar">PNonScalar</a></span></li></ul><p><code><a href=".././Init/Core.html#PNonScalar">PNonScalar</a></code> is a type that is not a scalar value in our runtime.
It is used as a stand-in for an arbitrary boxed value to avoid excessive
monomorphization, and it is only created using <code><a href=".././Init/Prelude.html#unsafeCast">unsafeCast</a></code>. It is somewhat
analogous to C <code>void*</code> in usage, but the type itself is not special.</p><p>This is the universe-polymorphic version of <code><a href=".././Init/Core.html#PNonScalar">PNonScalar</a></code>; it is preferred to use
<code><a href=".././Init/Core.html#NonScalar">NonScalar</a></code> instead where applicable.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-PNonScalar" class="instances-for-list"></ul></details></div></div><div class="decl" id="Nat.add_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L457-L457">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Nat.add_zero"><span class="name">Nat</span>.<span class="name">add_zero</span></a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">n</span></span></div></div></div></div><div class="decl" id="optParam_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L459-L459">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#optParam_eq"><span class="name">optParam_eq</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Sort</a> u)</span></span>
<span class="decl_args">
<span class="fn">(default : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#optParam">optParam</a> <span class="fn">α</span> <span class="fn">default</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">α</span></span></div></div></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Boolean-operators">Boolean operators <a class="hover-link" href="#Boolean-operators">#</a></h1></div><div class="decl" id="strictOr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L467-L467">source</a></div><div class="attributes">@[extern  c inline "#1 || #2"]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#strictOr"><span class="name">strictOr</span></a></span><span class="decl_args">
<span class="fn">(b₁ : <a href=".././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(b₂ : <a href=".././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Bool">Bool</a></div></div><p><code><a href=".././Init/Core.html#strictOr">strictOr</a></code> is the same as <code><a href=".././Init/Prelude.html#or">or</a></code>, but it does not use short-circuit evaluation semantics:
both sides are evaluated, even if the first value is <code>true</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#strictOr">strictOr</a> <span class="fn">b₁</span> <span class="fn">b₂</span></span> <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">b₁</span> <a href=".././Init/Prelude.html#or">||</a> <span class="fn">b₂</span></span>)</span></li></ul></details></div></div><div class="decl" id="strictAnd"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L473-L473">source</a></div><div class="attributes">@[extern  c inline "#1 && #2"]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#strictAnd"><span class="name">strictAnd</span></a></span><span class="decl_args">
<span class="fn">(b₁ : <a href=".././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(b₂ : <a href=".././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Bool">Bool</a></div></div><p><code><a href=".././Init/Core.html#strictAnd">strictAnd</a></code> is the same as <code><a href=".././Init/Prelude.html#and">and</a></code>, but it does not use short-circuit evaluation semantics:
both sides are evaluated, even if the first value is <code>false</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#strictAnd">strictAnd</a> <span class="fn">b₁</span> <span class="fn">b₂</span></span> <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">b₁</span> <a href=".././Init/Prelude.html#and">&amp&amp</a> <span class="fn">b₂</span></span>)</span></li></ul></details></div></div><div class="decl" id="bne"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L482-L483">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#bne"><span class="name">bne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Bool">Bool</a></div></div><p><code>x != y</code> is boolean not-equal. It is the negation of <code>x == y</code> which is supplied by
the <code><a href=".././Init/Prelude.html#BEq">BEq</a></code> typeclass.</p><p>Unlike <code>x ≠ y</code> (which is notation for <code><a href=".././Init/Core.html#Ne">Ne</a> x y</code>), this is <code><a href=".././Init/Prelude.html#Bool">Bool</a></code> valued instead of
<code>Prop</code> valued. It is mainly intended for programming applications.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn">(<span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#bne">!=</a> <span class="fn">b</span></span>) <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#not">!</a><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span></span></span></span></li></ul></details></div></div><div class="decl" id="«term_!=_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L485-L485">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_!=_»"><span class="name">«term_!=_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>x != y</code> is boolean not-equal. It is the negation of <code>x == y</code> which is supplied by
the <code><a href=".././Init/Prelude.html#BEq">BEq</a></code> typeclass.</p><p>Unlike <code>x ≠ y</code> (which is notation for <code><a href=".././Init/Core.html#Ne">Ne</a> x y</code>), this is <code><a href=".././Init/Prelude.html#Bool">Bool</a></code> valued instead of
<code>Prop</code> valued. It is mainly intended for programming applications.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#«term_!=_»">«term_!=_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`term_!=_</span> <span class="fn">50</span> <span class="fn">51</span>
    (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot != &quot</span></span>) (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">51</span></span>)</span>)</span></span></li></ul></details></div></div><div class="decl" id="LawfulBEq"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L492-L496">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#LawfulBEq"><span class="name">LawfulBEq</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><ul class="structure_fields" id="LawfulBEq.mk"><li id="LawfulBEq.eq_of_beq" class="structure_field"><div class="structure_field_doc"><p>If <code>a == b</code> evaluates to <code>true</code>, then <code>a</code> and <code>b</code> are equal in the logic.</p></div><div class="structure_field_info">eq_of_beq : <span class="fn">∀ {<span class="fn">a </span>b : <span class="fn">α</span>}, <span class="fn"><span class="fn">(<span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span></span>) <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span> → <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></span></div></li><li id="LawfulBEq.rfl" class="structure_field"><div class="structure_field_doc"><p><code>==</code> is reflexive, that is, <code>(a == a) = true</code>.</p></div><div class="structure_field_info">rfl : <span class="fn">∀ {<span class="fn">a</span> : <span class="fn">α</span>}, <span class="fn">(<span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span></span>) <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span></span></div></li></ul><p><code><a href=".././Init/Core.html#LawfulBEq">LawfulBEq</a> α</code> is a typeclass which asserts that the <code><a href=".././Init/Prelude.html#BEq">BEq</a> α</code> implementation
(which supplies the <code>a == b</code> notation) coincides with logical equality <code>a = b</code>.
In other words, <code>a == b</code> implies <code>a = b</code>, and <code>a == a</code> is true.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-LawfulBEq" class="instances-list"></ul></details></div></div><div class="decl" id="instLawfulBEqBoolInstBEqInstDecidableEqBool"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L500-L502">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instLawfulBEqBoolInstBEqInstDecidableEqBool"><span class="name">instLawfulBEqBoolInstBEqInstDecidableEqBool</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#LawfulBEq">LawfulBEq</a> <a href=".././Init/Prelude.html#Bool">Bool</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instLawfulBEqBoolInstBEqInstDecidableEqBool">instLawfulBEqBoolInstBEqInstDecidableEqBool</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Core.html#instLawfulBEqBoolInstBEqInstDecidableEqBool.proof_1">instLawfulBEqBoolInstBEqInstDecidableEqBool.proof_1</a></span></li></ul></details></div></div><div class="decl" id="instLawfulBEqInstBEq"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L504-L506">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instLawfulBEqInstBEq"><span class="name">instLawfulBEqInstBEq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instLawfulBEqInstBEq">@<a href=".././Init/Core.html#instLawfulBEqInstBEq">instLawfulBEqInstBEq</a></a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Core.html#instLawfulBEqInstBEq.proof_1">@<a href=".././Init/Core.html#instLawfulBEqInstBEq.proof_1">instLawfulBEqInstBEq.proof_1</a></a></span></li></ul></details></div></div><div class="decl" id="instLawfulBEqCharInstBEqInstDecidableEqChar"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L508-L508">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instLawfulBEqCharInstBEqInstDecidableEqChar"><span class="name">instLawfulBEqCharInstBEqInstDecidableEqChar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#LawfulBEq">LawfulBEq</a> <a href=".././Init/Prelude.html#Char">Char</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instLawfulBEqCharInstBEqInstDecidableEqChar">instLawfulBEqCharInstBEqInstDecidableEqChar</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Core.html#instLawfulBEqCharInstBEqInstDecidableEqChar.proof_1">instLawfulBEqCharInstBEqInstDecidableEqChar.proof_1</a></span></li></ul></details></div></div><div class="decl" id="instLawfulBEqStringInstBEqInstDecidableEqString"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L510-L510">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instLawfulBEqStringInstBEqInstDecidableEqString"><span class="name">instLawfulBEqStringInstBEqInstDecidableEqString</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#LawfulBEq">LawfulBEq</a> <a href=".././Init/Prelude.html#String">String</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instLawfulBEqStringInstBEqInstDecidableEqString">instLawfulBEqStringInstBEqInstDecidableEqString</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Core.html#instLawfulBEqStringInstBEqInstDecidableEqString.proof_1">instLawfulBEqStringInstBEqInstDecidableEqString.proof_1</a></span></li></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Logical-connectives-and-equality">Logical connectives and equality <a class="hover-link" href="#Logical-connectives-and-equality">#</a></h1></div><div class="decl" id="trivial"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L514-L514">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#trivial"><span class="name">trivial</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#True">True</a></div></div><p><code><a href=".././Init/Prelude.html#True">True</a></code> is true, and <code><a href=".././Init/Prelude.html#True.intro">True.intro</a></code> (or more commonly, <code><a href=".././Init/Core.html#trivial">trivial</a></code>)
is the proof.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#trivial">trivial</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#True.intro">True.intro</a></span></li></ul></details></div></div><div class="decl" id="mt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L516-L517">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#mt"><span class="name">mt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span></div></div></div></div><div class="decl" id="not_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L519-L519">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#not_false"><span class="name">not_false</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><a href=".././Init/Prelude.html#False">False</a></span></div></div></div></div><div class="decl" id="not_not_intro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L521-L522">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#not_not_intro"><span class="name">not_not_intro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">p</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span></span></div></div></div></div><div class="decl" id="proofIrrel"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L525-L525">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#proofIrrel"><span class="name">proofIrrel</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn">a</span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">h₁</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">h₂</span></span></div></div></div></div><div class="decl" id="id.def"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L527-L527">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#id.def"><span class="name">id</span>.<span class="name">def</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#id">id</a> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Eq.mp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L536-L537">source</a></div><div class="attributes">@[macro_inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Eq.mp"><span class="name">Eq</span>.<span class="name">mp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p>If <code>h : α = β</code> is a proof of type equality, then <code>h.<a href=".././Init/Core.html#Iff.mp">mp</a> : α → β</code> is the induced
"cast" operation, mapping elements of <code>α</code> to elements of <code>β</code>.</p><p>You can prove theorems about the resulting element by induction on <code>h</code>, since
<code>rfl.<a href=".././Init/Core.html#Iff.mp">mp</a></code> is definitionally the identity function.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Eq.mp">Eq.mp</a> <span class="fn">h</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">h</span> ▸ <span class="fn">a</span></span></span></li></ul></details></div></div><div class="decl" id="Eq.mpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L546-L547">source</a></div><div class="attributes">@[macro_inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Eq.mpr"><span class="name">Eq</span>.<span class="name">mpr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>If <code>h : α = β</code> is a proof of type equality, then <code>h.<a href=".././Init/Core.html#Iff.mpr">mpr</a> : β → α</code> is the induced
"cast" operation in the reverse direction, mapping elements of <code>β</code> to elements of <code>α</code>.</p><p>You can prove theorems about the resulting element by induction on <code>h</code>, since
<code>rfl.<a href=".././Init/Core.html#Iff.mpr">mpr</a></code> is definitionally the identity function.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Eq.mpr">Eq.mpr</a> <span class="fn">h</span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(_ : <span class="fn"><span class="fn">β</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">α</span></span>)</span> ▸ <span class="fn">b</span></span></span></li></ul></details></div></div><div class="decl" id="Eq.substr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L550-L551">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Eq.substr"><span class="name">Eq</span>.<span class="name">substr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="cast_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L553-L554">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#cast_eq"><span class="name">cast_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#cast">cast</a> <span class="fn">h</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Ne"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L560-L561">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Ne"><span class="name">Ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code>a ≠ b</code>, or <code><a href=".././Init/Core.html#Ne">Ne</a> a b</code> is defined as <code>¬ (a = b)</code> or <code>a = b → <a href=".././Init/Prelude.html#False">False</a></code>,
and asserts that <code>a</code> and <code>b</code> are not equal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn">(<span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span>) <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></span></li></ul></details></div></div><div class="decl" id="«term_≠_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L563-L563">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#«term_≠_»"><span class="name">«term_≠_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><p><code>a ≠ b</code>, or <code><a href=".././Init/Core.html#Ne">Ne</a> a b</code> is defined as <code>¬ (a = b)</code> or <code>a = b → <a href=".././Init/Prelude.html#False">False</a></code>,
and asserts that <code>a</code> and <code>b</code> are not equal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#«term_≠_»">«term_≠_»</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`term_≠_</span> <span class="fn">50</span> <span class="fn">51</span>
    (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot ≠ &quot</span></span>) (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">51</span></span>)</span>)</span></span></li></ul></details></div></div><div class="decl" id="Ne.intro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L569-L569">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Ne.intro"><span class="name">Ne</span>.<span class="name">intro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> → <a href=".././Init/Prelude.html#False">False</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Ne.elim"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L571-L571">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Ne.elim"><span class="name">Ne</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span> → <a href=".././Init/Prelude.html#False">False</a></span></div></div></div></div><div class="decl" id="Ne.irrefl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L573-L573">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Ne.irrefl"><span class="name">Ne</span>.<span class="name">irrefl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#False">False</a></div></div></div></div><div class="decl" id="Ne.symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L575-L576">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Ne.symm"><span class="name">Ne</span>.<span class="name">symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">b</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="false_of_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L578-L578">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#false_of_ne"><span class="name">false_of_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">a</span></span> → <a href=".././Init/Prelude.html#False">False</a></span></div></div></div></div><div class="decl" id="ne_false_of_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L580-L581">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#ne_false_of_self"><span class="name">ne_false_of_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> → <span class="fn"><span class="fn">p</span> <a href=".././Init/Core.html#Ne">≠</a> <a href=".././Init/Prelude.html#False">False</a></span></span></div></div></div></div><div class="decl" id="ne_true_of_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L583-L586">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#ne_true_of_not"><span class="name">ne_true_of_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> → <span class="fn"><span class="fn">p</span> <a href=".././Init/Core.html#Ne">≠</a> <a href=".././Init/Prelude.html#True">True</a></span></span></div></div></div></div><div class="decl" id="true_ne_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L588-L589">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#true_ne_false"><span class="name">true_ne_false</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><a href=".././Init/Prelude.html#True">True</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#False">False</a></span></span></div></div></div></div><div class="decl" id="Bool.of_not_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L593-L595">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Bool.of_not_eq_true"><span class="name">Bool</span>.<span class="name">of_not_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././Init/Prelude.html#Bool">Bool</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span></span> → <span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span></span></div></div></div></div><div class="decl" id="Bool.of_not_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L597-L599">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Bool.of_not_eq_false"><span class="name">Bool</span>.<span class="name">of_not_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././Init/Prelude.html#Bool">Bool</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span></span> → <span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="ne_of_beq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L601-L602">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#ne_of_beq_false"><span class="name">ne_of_beq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">(<span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span></span>) <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="beq_false_of_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L604-L607">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#beq_false_of_ne"><span class="name">beq_false_of_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Ne">≠</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span></span>) <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="HEq.ndrec"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L612-L613">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#HEq.ndrec"><span class="name">HEq</span>.<span class="name">ndrec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u2} → <span class="fn"><span class="fn">β</span> → <a href=".././foundational_types.html">Sort</a> u1</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">motive</span> <span class="fn">α</span> <span class="fn">a</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">β</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="HEq.ndrecOn"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L615-L616">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#HEq.ndrecOn"><span class="name">HEq</span>.<span class="name">ndrecOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn">{<span class="fn">β</span> : <a href=".././foundational_types.html">Sort</a> u2} → <span class="fn"><span class="fn">β</span> → <a href=".././foundational_types.html">Sort</a> u1</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">motive</span> <span class="fn">α</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">β</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="HEq.elim"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L618-L619">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#HEq.elim"><span class="name">HEq</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="HEq.subst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L621-L622">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#HEq.subst"><span class="name">HEq</span>.<span class="name">subst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn">(<span class="fn">T</span> : <a href=".././foundational_types.html">Sort</a> u) → <span class="fn"><span class="fn">T</span> → <a href=".././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">p</span> <span class="fn">α</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <span class="fn">β</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="HEq.symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L624-L625">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#HEq.symm"><span class="name">HEq</span>.<span class="name">symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">b</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="heq_of_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L627-L628">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#heq_of_eq"><span class="name">heq_of_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a' : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">a'</span></span></div></div></div></div><div class="decl" id="HEq.trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L630-L631">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#HEq.trans"><span class="name">HEq</span>.<span class="name">trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{φ : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">φ</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="heq_of_heq_of_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L633-L634">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#heq_of_heq_of_eq"><span class="name">heq_of_heq_of_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b' : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b'</span></span></div></div></div></div><div class="decl" id="heq_of_eq_of_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L636-L637">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#heq_of_eq_of_heq"><span class="name">heq_of_eq_of_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a' : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a'</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="type_eq_of_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L639-L640">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#type_eq_of_heq"><span class="name">type_eq_of_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">β</span></span></div></div></div></div><div class="decl" id="eqRec_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L644-L645">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#eqRec_heq"><span class="name">eqRec_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{φ : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a' : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">φ</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> (<span class="fn"><a href=".././Init/Prelude.html#Eq.recOn">Eq.recOn</a> <span class="fn">h</span> <span class="fn">p</span></span>) <span class="fn">p</span></span></div></div></div></div><div class="decl" id="heq_of_eqRec_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L647-L650">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#heq_of_eqRec_eq"><span class="name">heq_of_eqRec_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn"><span class="fn">h₁</span> ▸ <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="cast_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L652-L653">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#cast_heq"><span class="name">cast_heq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> (<span class="fn"><a href=".././Init/Prelude.html#cast">cast</a> <span class="fn">h</span> <span class="fn">a</span></span>) <span class="fn">a</span></span></div></div></div></div><div class="decl" id="iff_iff_implies_and_implies"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L657-L658">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#iff_iff_implies_and_implies"><span class="name">iff_iff_implies_and_implies</span></a></span><span class="decl_args">
<span class="fn">(a : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(b : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span>) <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">(<span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span>) <a href=".././Init/Prelude.html#And">∧</a> (<span class="fn"><span class="fn">b</span> → <span class="fn">a</span></span>)</span></span></div></div></div></div><div class="decl" id="Iff.refl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L660-L661">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Iff.refl"><span class="name">Iff</span>.<span class="name">refl</span></a></span><span class="decl_args">
<span class="fn">(a : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Iff.rfl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L663-L664">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Iff.rfl"><span class="name">Iff</span>.<span class="name">rfl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Iff.trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L666-L669">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Iff.trans"><span class="name">Iff</span>.<span class="name">trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">b</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Iff.symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L671-L672">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Iff.symm"><span class="name">Iff</span>.<span class="name">symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">b</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Iff.comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L674-L675">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Iff.comm"><span class="name">Iff</span>.<span class="name">comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span>) <a href=".././Init/Core.html#Iff">↔</a> (<span class="fn"><span class="fn">b</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">a</span></span>)</span></div></div></div></div><div class="decl" id="Iff.of_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L677-L678">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Iff.of_eq"><span class="name">Iff</span>.<span class="name">of_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="And.comm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L680-L681">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#And.comm"><span class="name">And</span>.<span class="name">comm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn">b</span></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn">a</span></span></span></div></div></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Exists">Exists <a class="hover-link" href="#Exists">#</a></h1></div><div class="decl" id="Exists.elim"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L685-L688">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Exists.elim"><span class="name">Exists</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn">∃ <span class="fn">x</span>, <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">a</span></span> → <span class="fn">b</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">b</span></div></div></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Decidable">Decidable <a class="hover-link" href="#Decidable">#</a></h1></div><div class="decl" id="decide_true_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L692-L695">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#decide_true_eq_true"><span class="name">decide_true_eq_true</span></a></span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <a href=".././Init/Prelude.html#True">True</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Decidable.decide">decide</a> <a href=".././Init/Prelude.html#True">True</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="decide_false_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L697-L700">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#decide_false_eq_false"><span class="name">decide_false_eq_false</span></a></span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <a href=".././Init/Prelude.html#False">False</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Decidable.decide">decide</a> <a href=".././Init/Prelude.html#False">False</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="toBoolUsing"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L703-L704">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#toBoolUsing"><span class="name">toBoolUsing</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(d : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Bool">Bool</a></div></div><p>Similar to <code>decide</code>, but uses an explicit instance</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#toBoolUsing">toBoolUsing</a> <span class="fn">d</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.decide">decide</a> <span class="fn">p</span></span></span></li></ul></details></div></div><div class="decl" id="toBoolUsing_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L706-L707">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#toBoolUsing_eq_true"><span class="name">toBoolUsing_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(d : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">p</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Core.html#toBoolUsing">toBoolUsing</a> <span class="fn">d</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="ofBoolUsing_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L709-L710">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#ofBoolUsing_eq_true"><span class="name">ofBoolUsing_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href=".././Init/Core.html#toBoolUsing">toBoolUsing</a> <span class="fn">d</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span></div></div></div></div><div class="decl" id="ofBoolUsing_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L712-L713">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#ofBoolUsing_eq_false"><span class="name">ofBoolUsing_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href=".././Init/Core.html#toBoolUsing">toBoolUsing</a> <span class="fn">d</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span></div></div></div></div><div class="decl" id="instDecidableTrue"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L715-L716">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableTrue"><span class="name">instDecidableTrue</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <a href=".././Init/Prelude.html#True">True</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instDecidableTrue">instDecidableTrue</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <a href=".././Init/Core.html#trivial">trivial</a></span></span></li></ul></details></div></div><div class="decl" id="instDecidableFalse"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L718-L719">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableFalse"><span class="name">instDecidableFalse</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <a href=".././Init/Prelude.html#False">False</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instDecidableFalse">instDecidableFalse</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <a href=".././Init/Core.html#not_false">not_false</a></span></span></li></ul></details></div></div><div class="decl" id="Decidable.byCases"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L729-L732">source</a></div><div class="attributes">@[macro_inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Decidable.byCases"><span class="name">Decidable</span>.<span class="name">byCases</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[dec : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h1 : <span class="fn"><span class="fn">p</span> → <span class="fn">q</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h2 : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> → <span class="fn">q</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">q</span></div></div><p>Synonym for <code><a href=".././Init/Prelude.html#dite">dite</a></code> (dependent if-then-else). We can construct an element <code>q</code>
(of any sort, not just a proposition) by cases on whether <code>p</code> is true or false,
provided <code>p</code> is decidable.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Decidable.byCases">Decidable.byCases</a> <span class="fn">h1</span> <span class="fn">h2</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">dec</span> with
  | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isTrue</a> <span class="fn">h</span></span> =&gt <span class="fn"><span class="fn">h1</span> <span class="fn">h</span></span>
  | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">h</span></span> =&gt <span class="fn"><span class="fn">h2</span> <span class="fn">h</span></span></span></span></li></ul></details></div></div><div class="decl" id="Decidable.em"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L734-L735">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Decidable.em"><span class="name">Decidable</span>.<span class="name">em</span></a></span><span class="decl_args">
<span class="fn">(p : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span></span></div></div></div></div><div class="decl" id="Decidable.byContradiction"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L738-L739">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Decidable.byContradiction"><span class="name">Decidable</span>.<span class="name">byContradiction</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[dec : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> → <a href=".././Init/Prelude.html#False">False</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span></div></div></div></div><div class="decl" id="Decidable.of_not_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L741-L742">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Decidable.of_not_not"><span class="name">Decidable</span>.<span class="name">of_not_not</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span></span> → <span class="fn">p</span></span></div></div></div></div><div class="decl" id="Decidable.not_and_iff_or_not"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L744-L752">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Decidable.not_and_iff_or_not"><span class="name">Decidable</span>.<span class="name">not_and_iff_or_not</span></a></span><span class="decl_args">
<span class="fn">(p : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args">
<span class="fn">(q : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[d₁ : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[d₂ : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">q</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a>(<span class="fn"><span class="fn">p</span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn">q</span></span>)</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">q</span></span></span></span></div></div></div></div><div class="decl" id="decidable_of_decidable_of_iff"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L759-L763">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#decidable_of_decidable_of_iff"><span class="name">decidable_of_decidable_of_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">p</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">q</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">q</span></span></div></div><p>Transfer a decidability proof across an equivalence of propositions.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#decidable_of_decidable_of_iff">decidable_of_decidable_of_iff</a> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">if hp : <span class="fn">p</span> then <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> (<span class="fn"><a href=".././Init/Core.html#Iff.mp">Iff.mp</a> <span class="fn">h</span> <span class="fn">hp</span></span>)</span> else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">(_ : <span class="fn"><span class="fn">q</span> → <a href=".././Init/Prelude.html#False">False</a></span>)</span></span></span></span></li></ul></details></div></div><div class="decl" id="decidable_of_decidable_of_eq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L766-L767">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#decidable_of_decidable_of_eq"><span class="name">decidable_of_decidable_of_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">p</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">q</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">q</span></span></div></div><p>Transfer a decidability proof across an equality of propositions.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#decidable_of_decidable_of_eq">decidable_of_decidable_of_eq</a> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#decidable_of_decidable_of_iff">decidable_of_decidable_of_iff</a> <span class="fn">(_ : <span class="fn"><span class="fn">p</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">q</span></span>)</span></span></span></li></ul></details></div></div><div class="decl" id="instDecidableForAll"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L770-L774">source</a></div><div class="attributes">@[macro_inline]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableForAll"><span class="name">instDecidableForAll</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">q</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">p</span> → <span class="fn">q</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instDecidableForAll</span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">if hp : <span class="fn">p</span> then <span class="fn">if hq : <span class="fn">q</span> then <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> (<span class="fn"><a href=".././Init/Core.html#instDecidableForAll.proof_1">instDecidableForAll.proof_1</a> <span class="fn">hq</span></span>)</span> else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">(_ : <span class="fn">(<span class="fn"><span class="fn">p</span> → <span class="fn">q</span></span>) → <a href=".././Init/Prelude.html#False">False</a></span>)</span></span></span>
  else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> (<span class="fn"><a href=".././Init/Core.html#instDecidableForAll.proof_3">instDecidableForAll.proof_3</a> <span class="fn">hp</span></span>)</span></span></span></li></ul></details></div></div><div class="decl" id="instDecidableIff"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L776-L786">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableIff"><span class="name">instDecidableIff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">q</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">p</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">q</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instDecidableIff</span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">if hp : <span class="fn">p</span> then <span class="fn">if hq : <span class="fn">q</span> then <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">(_ : <span class="fn"><span class="fn">p</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">q</span></span>)</span></span> else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">(_ : <span class="fn">(<span class="fn"><span class="fn">p</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">q</span></span>) → <a href=".././Init/Prelude.html#False">False</a></span>)</span></span></span>
  else <span class="fn">if hq : <span class="fn">q</span> then <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">(_ : <span class="fn">(<span class="fn"><span class="fn">p</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">q</span></span>) → <a href=".././Init/Prelude.html#False">False</a></span>)</span></span> else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">(_ : <span class="fn"><span class="fn">p</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">q</span></span>)</span></span></span></span></span></li></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="if-then-else-expression-theorems">if-then-else expression theorems <a class="hover-link" href="#if-then-else-expression-theorems">#</a></h1></div><div class="decl" id="if_pos"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L790-L793">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#if_pos"><span class="name">if_pos</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{h : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">c</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hc : <span class="fn">c</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">if <span class="fn">c</span> then <span class="fn">t</span> else <span class="fn">e</span></span>) <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">t</span></span></div></div></div></div><div class="decl" id="if_neg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L795-L798">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#if_neg"><span class="name">if_neg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{h : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">c</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hnc : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">c</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">if <span class="fn">c</span> then <span class="fn">t</span> else <span class="fn">e</span></span>) <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">e</span></span></div></div></div></div><div class="decl" id="dif_pos"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L800-L803">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#dif_pos"><span class="name">dif_pos</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{h : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">c</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hc : <span class="fn">c</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn"><span class="fn">c</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">c</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#dite">dite</a> <span class="fn">c</span> <span class="fn">t</span> <span class="fn">e</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">t</span> <span class="fn">hc</span></span></span></div></div></div></div><div class="decl" id="dif_neg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L805-L808">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#dif_neg"><span class="name">dif_neg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{h : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">c</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hnc : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">c</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn"><span class="fn">c</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">c</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#dite">dite</a> <span class="fn">c</span> <span class="fn">t</span> <span class="fn">e</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">e</span> <span class="fn">hnc</span></span></span></div></div></div></div><div class="decl" id="dif_eq_if"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L811-L814">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#dif_eq_if"><span class="name">dif_eq_if</span></a></span><span class="decl_args">
<span class="fn">(c : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{h : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">c</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(t : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(e : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">if x : <span class="fn">c</span> then <span class="fn">t</span> else <span class="fn">e</span></span>) <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">if <span class="fn">c</span> then <span class="fn">t</span> else <span class="fn">e</span></span></span></div></div></div></div><div class="decl" id="instDecidableIteProp"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L816-L819">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableIteProp"><span class="name">instDecidableIteProp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[dC : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">c</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[dT : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">t</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[dE : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">e</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">if <span class="fn">c</span> then <span class="fn">t</span> else <span class="fn">e</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instDecidableIteProp</span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">dC</span> with
  | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isTrue</a> <span class="fn">h</span></span> =&gt <span class="fn">dT</span>
  | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">h</span></span> =&gt <span class="fn">dE</span></span></span></li></ul></details></div></div><div class="decl" id="instDecidableDitePropNot"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L821-L824">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableDitePropNot"><span class="name">instDecidableDitePropNot</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn"><span class="fn">c</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{e : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">c</span></span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[dC : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">c</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[dT : <span class="fn">(<span class="fn">h</span> : <span class="fn">c</span>) → <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">t</span> <span class="fn">h</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[dE : <span class="fn">(<span class="fn">h</span> : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">c</span></span>) → <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">e</span> <span class="fn">h</span></span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn">if h : <span class="fn">c</span> then <span class="fn"><span class="fn">t</span> <span class="fn">h</span></span> else <span class="fn"><span class="fn">e</span> <span class="fn">h</span></span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instDecidableDitePropNot</span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">dC</span> with
  | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isTrue</a> <span class="fn">hc</span></span> =&gt <span class="fn"><span class="fn">dT</span> <span class="fn">hc</span></span>
  | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">hc</span></span> =&gt <span class="fn"><span class="fn">dE</span> <span class="fn">hc</span></span></span></span></li></ul></details></div></div><div class="decl" id="noConfusionTypeEnum"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L827-L830">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#noConfusionTypeEnum"><span class="name">noConfusionTypeEnum</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(P : <a href=".././foundational_types.html">Sort</a> w)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(y : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> w</div></div><p>Auxiliary definition for generating compact <code>noConfusion</code> for enumeration types</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#noConfusionTypeEnum">noConfusionTypeEnum</a> <span class="fn">f</span> <span class="fn">P</span> <span class="fn">x</span> <span class="fn">y</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.casesOn">Decidable.casesOn</a> (<span class="fn"><span class="fn">inst</span> (<span class="fn"><span class="fn">f</span> <span class="fn">x</span></span>) (<span class="fn"><span class="fn">f</span> <span class="fn">y</span></span>)</span>) (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn">P</span></span>) <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn">P</span> → <span class="fn">P</span></span></span></span></span></li></ul></details></div></div><div class="decl" id="noConfusionEnum"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L833-L838">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#noConfusionEnum"><span class="name">noConfusionEnum</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <a href=".././foundational_types.html">Sort</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">x</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#noConfusionTypeEnum">noConfusionTypeEnum</a> <span class="fn">f</span> <span class="fn">P</span> <span class="fn">x</span> <span class="fn">y</span></span></div></div><p>Auxiliary definition for generating compact <code>noConfusion</code> for enumeration types</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#noConfusionEnum">noConfusionEnum</a> <span class="fn">f</span> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.casesOn">Decidable.casesOn</a> (<span class="fn"><span class="fn">inst</span> (<span class="fn"><span class="fn">f</span> <span class="fn">x</span></span>) (<span class="fn"><span class="fn">f</span> <span class="fn">y</span></span>)</span>) (<span class="fn">fun <span class="fn">h'</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#False.elim">False.elim</a> <span class="fn">(_ : <a href=".././Init/Prelude.html#False">False</a>)</span></span></span>) <span class="fn">fun <span class="fn">x</span> <span class="fn">x</span> =&gt <span class="fn">x</span></span></span></span></li></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Inhabited">Inhabited <a class="hover-link" href="#Inhabited">#</a></h1></div><div class="decl" id="instInhabitedProp"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L842-L843">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedProp"><span class="name">instInhabitedProp</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././foundational_types.html">Prop</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instInhabitedProp">instInhabitedProp</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <a href=".././Init/Prelude.html#True">True</a> }</span></span></li></ul></details></div></div><div class="decl" id="instInhabitedNonScalar"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L845-L845">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedNonScalar"><span class="name">instInhabitedNonScalar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Core.html#NonScalar">NonScalar</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instInhabitedNonScalar">instInhabitedNonScalar</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">{ <span class="fn">val</span> := <span class="fn">default</span> }</span> }</span></span></li></ul></details></div></div><div class="decl" id="instInhabitedPNonScalar"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L845-L845">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedPNonScalar"><span class="name">instInhabitedPNonScalar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Core.html#PNonScalar">PNonScalar</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instInhabitedPNonScalar">instInhabitedPNonScalar</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn"><a href=".././Init/Core.html#PNonScalar.mk">PNonScalar.mk</a> <span class="fn">default</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instInhabitedForInStep_1"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L845-L845">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedForInStep_1"><span class="name">instInhabitedForInStep_1</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">{<span class="fn">a</span> : <a href=".././foundational_types.html">Type</a> u_1} → <span class="fn">[<span class="fn">inst</span> : <span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">a</span></span>] → <span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> (<span class="fn"><a href=".././Init/Core.html#ForInStep">ForInStep</a> <span class="fn">a</span></span>)</span></span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instInhabitedForInStep_1</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn"><a href=".././Init/Core.html#ForInStep.done">ForInStep.done</a> <span class="fn">default</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instInhabitedTrue"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L845-L845">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedTrue"><span class="name">instInhabitedTrue</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#True">True</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instInhabitedTrue">instInhabitedTrue</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <a href=".././Init/Prelude.html#True.intro">True.intro</a> }</span></span></li></ul></details></div></div><div class="decl" id="nonempty_of_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L847-L848">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#nonempty_of_exists"><span class="name">nonempty_of_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">∃ <span class="fn">x</span>, <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span>) → <span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span></span></div></div></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Subsingleton">Subsingleton <a class="hover-link" href="#Subsingleton">#</a></h1></div><div class="decl" id="Subsingleton"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L860-L864">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Subsingleton"><span class="name">Subsingleton</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Sort</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><ul class="structure_ext"><li id="Subsingleton.intro" class="structure_ext_ctor">intro :: (</li><ul class="structure_ext_fields"><li id="Subsingleton.allEq" class="structure_field"><div class="structure_field_doc"><p>Any two elements of a subsingleton are equal.</p></div><div class="structure_field_info">allEq : <span class="fn">∀ (<span class="fn">a </span>b : <span class="fn">α</span>), <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></div></li></ul><li class="structure_ext_ctor">)</li></ul><p>A "subsingleton" is a type with at most one element.
In other words, it is either empty, or has a unique element.
All propositions are subsingletons because of proof irrelevance, but some other types
are subsingletons as well and they inherit many of the same properties as propositions.
<code><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> α</code> is a typeclass, so it is usually used as an implicit argument and
inferred by typeclass inference.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-Subsingleton" class="instances-list"></ul></details></div></div><div class="decl" id="Subsingleton.elim"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L866-L867">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Subsingleton.elim"><span class="name">Subsingleton</span>.<span class="name">elim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[h : <span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Subsingleton.helim"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L869-L872">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Subsingleton.helim"><span class="name">Subsingleton</span>.<span class="name">helim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[h₁ : <span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="instSubsingleton"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L874-L875">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instSubsingleton"><span class="name">instSubsingleton</span></a></span><span class="decl_args">
<span class="fn">(p : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">p</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instSubsingleton">instSubsingleton</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Core.html#instSubsingleton.proof_1">instSubsingleton.proof_1</a></span></li></ul></details></div></div><div class="decl" id="instSubsingletonDecidable"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L877-L884">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instSubsingletonDecidable"><span class="name">instSubsingletonDecidable</span></a></span><span class="decl_args">
<span class="fn">(p : <a href=".././foundational_types.html">Prop</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> (<span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instSubsingletonDecidable">instSubsingletonDecidable</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Core.html#instSubsingletonDecidable.proof_1">instSubsingletonDecidable.proof_1</a></span></li></ul></details></div></div><div class="decl" id="recSubsingleton"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L886-L895">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#recSubsingleton"><span class="name">recSubsingleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[h : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{h₁ : <span class="fn"><span class="fn">p</span> → <a href=".././foundational_types.html">Sort</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{h₂ : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> → <a href=".././foundational_types.html">Sort</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[h₃ : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn">p</span>), <span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> (<span class="fn"><span class="fn">h₁</span> <span class="fn">h</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[h₄ : <span class="fn">∀ (<span class="fn">h</span> : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span>), <span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> (<span class="fn"><span class="fn">h₂</span> <span class="fn">h</span></span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> (<span class="fn"><a href=".././Init/Prelude.html#Decidable.casesOn">Decidable.casesOn</a> <span class="fn">h</span> <span class="fn">h₂</span> <span class="fn">h₁</span></span>)</span></div></div></div></div><div class="decl" id="Equivalence"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L908-L914">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Equivalence"><span class="name">Equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><ul class="structure_fields" id="Equivalence.mk"><li id="Equivalence.refl" class="structure_field"><div class="structure_field_doc"><p>An equivalence relation is reflexive: <code>x ~ x</code></p></div><div class="structure_field_info">refl : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">x</span></span></span></div></li><li id="Equivalence.symm" class="structure_field"><div class="structure_field_doc"><p>An equivalence relation is symmetric: <code>x ~ y</code> implies <code>y ~ x</code></p></div><div class="structure_field_info">symm : <span class="fn">{<span class="fn">x </span>y : <span class="fn">α</span>} → <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">y</span> <span class="fn">x</span></span></span></span></div></li><li id="Equivalence.trans" class="structure_field"><div class="structure_field_doc"><p>An equivalence relation is transitive: <code>x ~ y</code> and <code>y ~ z</code> implies <code>x ~ z</code></p></div><div class="structure_field_info">trans : <span class="fn">{<span class="fn">x </span>y z : <span class="fn">α</span>} → <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">y</span> <span class="fn">z</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">z</span></span></span></span></span></div></li></ul><p>An equivalence relation <code>~ : α → α → Prop</code> is a relation that is:</p><ul>
<li>reflexive: <code>x ~ x</code></li>
<li>symmetric: <code>x ~ y</code> implies <code>y ~ x</code></li>
<li>transitive: <code>x ~ y</code> and <code>y ~ z</code> implies <code>x ~ z</code></li>
</ul><p>Equality is an equivalence relation, and equivalence relations share many of
the properties of equality. In particular, <code><a href=".././Init/Prelude.html#Quot">Quot</a> α <a href=".././Init/Core.html#Setoid.r">r</a></code> is most well behaved
when <code><a href=".././Init/Core.html#Setoid.r">r</a></code> is an equivalence relation, and in this case we use <code><a href=".././Init/Core.html#Quotient">Quotient</a></code> instead.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Equivalence" class="instances-for-list"></ul></details></div></div><div class="decl" id="emptyRelation"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L917-L918">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#emptyRelation"><span class="name">emptyRelation</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span></div></div><p>The empty relation is the relation on <code>α</code> which is always <code><a href=".././Init/Prelude.html#False">False</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#emptyRelation">emptyRelation</a> <span class="fn">x</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#False">False</a></span></li></ul></details></div></div><div class="decl" id="Subrelation"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L924-L925">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Subrelation"><span class="name">Subrelation</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(q : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p><code><a href=".././Init/Core.html#Subrelation">Subrelation</a> q <a href=".././Init/Core.html#Setoid.r">r</a></code> means that <code>q ⊆ <a href=".././Init/Core.html#Setoid.r">r</a></code> or <code>∀ x y, q x y → <a href=".././Init/Core.html#Setoid.r">r</a> x y</code>.
It is the analogue of the subset relation on relations.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Subrelation">Subrelation</a> <span class="fn">q</span> <span class="fn">r</span></span> <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn">{<span class="fn">x </span>y : <span class="fn">α</span>} → <span class="fn"><span class="fn"><span class="fn">q</span> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span></span></span>)</span></li></ul></details></div></div><div class="decl" id="InvImage"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L931-L932">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#InvImage"><span class="name">InvImage</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href=".././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span></div></div><p>The inverse image of <code><a href=".././Init/Core.html#Setoid.r">r</a> : β → β → Prop</code> by a function <code>α → β</code> is the relation
<code>s : α → α → Prop</code> defined by <code>s a b = <a href=".././Init/Core.html#Setoid.r">r</a> (f a) (f b)</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#InvImage">InvImage</a> <span class="fn">r</span> <span class="fn">f</span> <span class="fn">a₁</span> <span class="fn">a₂</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">r</span> (<span class="fn"><span class="fn">f</span> <span class="fn">a₁</span></span>) (<span class="fn"><span class="fn">f</span> <span class="fn">a₂</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="TC"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L939-L943">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#TC"><span class="name">TC</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span></div></div><ul class="constructors"><li class="constructor" id="TC.base"><div class="inductive_ctor_doc"><p>If <code><a href=".././Init/Core.html#Setoid.r">r</a> a b</code> then <code>r⁺ a b</code>. This is the base case of the transitive closure.</p></div>base: <span class="fn">∀ {<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u} {<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>} (<span class="fn">a </span>b : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href=".././Init/Core.html#TC">TC</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></li><li class="constructor" id="TC.trans"><div class="inductive_ctor_doc"><p>The transitive closure is transitive.</p></div>trans: <span class="fn">∀ {<span class="fn">α</span> : <a href=".././foundational_types.html">Sort</a> u} {<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>} (<span class="fn">a </span>b c : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href=".././Init/Core.html#TC">TC</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><a href=".././Init/Core.html#TC">TC</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span> → <span class="fn"><a href=".././Init/Core.html#TC">TC</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span></span></span></span></li></ul><p>The transitive closure <code>r⁺</code> of a relation <code><a href=".././Init/Core.html#Setoid.r">r</a></code> is the smallest relation which is
transitive and contains <code><a href=".././Init/Core.html#Setoid.r">r</a></code>. <code>r⁺ a z</code> if and only if there exists a sequence
<code>a <a href=".././Init/Core.html#Setoid.r">r</a> b <a href=".././Init/Core.html#Setoid.r">r</a> ... <a href=".././Init/Core.html#Setoid.r">r</a> z</code> of length at least 1 connecting <code>a</code> to <code>z</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-TC" class="instances-for-list"></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Subtype">Subtype <a class="hover-link" href="#Subtype">#</a></h1></div><div class="decl" id="Subtype.existsOfSubtype"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L948-L949">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Subtype.existsOfSubtype"><span class="name">Subtype</span>.<span class="name">existsOfSubtype</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">{ <span class="fn">x</span> // <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> }</span> → <span class="fn">∃ <span class="fn">x</span>, <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></span></div></div></div></div><div class="decl" id="Subtype.eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L953-L954">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Subtype.eq"><span class="name">Subtype</span>.<span class="name">eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a1 : <span class="fn">{ <span class="fn">x</span> // <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> }</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a2 : <span class="fn">{ <span class="fn">x</span> // <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> }</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">a1</span>.val</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">a2</span>.val</span></span> → <span class="fn"><span class="fn">a1</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a2</span></span></span></div></div></div></div><div class="decl" id="Subtype.eta"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L956-L958">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Subtype.eta"><span class="name">Subtype</span>.<span class="name">eta</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">{ <span class="fn">x</span> // <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> }</span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">p</span> <span class="fn"><span class="fn">a</span>.val</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">{ <span class="fn">val</span> := <span class="fn"><span class="fn">a</span>.val</span>, <span class="fn">property</span> := <span class="fn">h</span> }</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Subtype.instInhabitedSubtype"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L960-L961">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Subtype.instInhabitedSubtype"><span class="name">Subtype</span>.<span class="name">instInhabitedSubtype</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">{ <span class="fn">x</span> // <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> }</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Subtype.instInhabitedSubtype">Subtype.instInhabitedSubtype</a> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">{ <span class="fn">val</span> := <span class="fn">a</span>, <span class="fn">property</span> := <span class="fn">h</span> }</span> }</span></span></li></ul></details></div></div><div class="decl" id="Subtype.instDecidableEqSubtype"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L963-L966">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Subtype.instDecidableEqSubtype"><span class="name">Subtype</span>.<span class="name">instDecidableEqSubtype</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">{ <span class="fn">x</span> // <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> }</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Sum">Sum <a class="hover-link" href="#Sum">#</a></h1></div><div class="decl" id="Sum.inhabitedLeft"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L975-L976">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Sum.inhabitedLeft"><span class="name">Sum</span>.<span class="name">inhabitedLeft</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> (<span class="fn"><span class="fn">α</span> <a href=".././Init/Core.html#Sum">⊕</a> <span class="fn">β</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Sum.inhabitedLeft</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn"><a href=".././Init/Core.html#Sum.inl">Sum.inl</a> <span class="fn">default</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Sum.inhabitedRight"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L978-L979">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Sum.inhabitedRight"><span class="name">Sum</span>.<span class="name">inhabitedRight</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> (<span class="fn"><span class="fn">α</span> <a href=".././Init/Core.html#Sum">⊕</a> <span class="fn">β</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Sum.inhabitedRight</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn"><a href=".././Init/Core.html#Sum.inr">Sum.inr</a> <span class="fn">default</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instDecidableEqSum"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L981-L990">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableEqSum"><span class="name">instDecidableEqSum</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> (<span class="fn"><span class="fn">α</span> <a href=".././Init/Core.html#Sum">⊕</a> <span class="fn">β</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Product">Product <a class="hover-link" href="#Product">#</a></h1></div><div class="decl" id="instInhabitedProd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L996-L997">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedProd"><span class="name">instInhabitedProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> (<span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instInhabitedProd</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">(<span class="fn">default</span>, <span class="fn">default</span>)</span> }</span></span></li></ul></details></div></div><div class="decl" id="instInhabitedMProd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L999-L1000">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedMProd"><span class="name">instInhabitedMProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> (<span class="fn"><a href=".././Init/Prelude.html#MProd">MProd</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instInhabitedMProd</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">{ <span class="fn">fst</span> := <span class="fn">default</span>, <span class="fn">snd</span> := <span class="fn">default</span> }</span> }</span></span></li></ul></details></div></div><div class="decl" id="instInhabitedPProd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1002-L1003">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedPProd"><span class="name">instInhabitedPProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> (<span class="fn"><a href=".././Init/Prelude.html#PProd">PProd</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instInhabitedPProd</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">{ <span class="fn">fst</span> := <span class="fn">default</span>, <span class="fn">snd</span> := <span class="fn">default</span> }</span> }</span></span></li></ul></details></div></div><div class="decl" id="instDecidableEqProd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1005-L1012">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableEqProd"><span class="name">instDecidableEqProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> (<span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="instBEqProd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1014-L1015">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instBEqProd"><span class="name">instBEqProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> (<span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instBEqProd</span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">{
    <span class="fn">beq</span> := <span class="fn">fun <span class="fn">x</span> <span class="fn">x_1</span> =&gt
      <span class="fn">match <span class="fn">x</span> with
      | <span class="fn">(<span class="fn">a₁</span>, <span class="fn">b₁</span>)</span> =&gt
        <span class="fn">match <span class="fn">x_1</span> with
        | <span class="fn">(<span class="fn">a₂</span>, <span class="fn">b₂</span>)</span> =&gt <span class="fn"><span class="fn"><span class="fn">a₁</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a₂</span></span> <a href=".././Init/Prelude.html#and">&amp&amp</a> <span class="fn"><span class="fn">b₁</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b₂</span></span></span></span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Prod.lexLt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1018-L1019">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Prod.lexLt"><span class="name">Prod</span>.<span class="name">lexLt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(t : <span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Prop</a></div></div><p>Lexicographical order for products</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Prod.lexLt">Prod.lexLt</a> <span class="fn">s</span> <span class="fn">t</span></span> <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn"><span class="fn"><span class="fn">s</span>.fst</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><span class="fn">t</span>.fst</span></span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">s</span>.fst</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">t</span>.fst</span></span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn">s</span>.snd</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><span class="fn">t</span>.snd</span></span></span></span>)</span></li></ul></details></div></div><div class="decl" id="Prod.lexLtDec"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1021-L1025">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Prod.lexLtDec"><span class="name">Prod</span>.<span class="name">lexLtDec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">a </span>b : <span class="fn">α</span>) → <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">b</span></span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">a </span>b : <span class="fn">β</span>) → <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">b</span></span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(t : <span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><a href=".././Init/Core.html#Prod.lexLt">Prod.lexLt</a> <span class="fn">s</span> <span class="fn">t</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Prod.lexLtDec">Prod.lexLtDec</a> <span class="fn">x</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#inferInstanceAs">inferInstanceAs</a> (<span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.fst</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><span class="fn">x</span>.fst</span></span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">x</span>.fst</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">x</span>.fst</span></span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn">x</span>.snd</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><span class="fn">x</span>.snd</span></span></span></span>)</span>)</span></span></li></ul></details></div></div><div class="decl" id="Prod.lexLt_def"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1027-L1028">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Prod.lexLt_def"><span class="name">Prod</span>.<span class="name">lexLt_def</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(t : <span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Prod.lexLt">Prod.lexLt</a> <span class="fn">s</span> <span class="fn">t</span></span> <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn"><span class="fn"><span class="fn">s</span>.fst</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><span class="fn">t</span>.fst</span></span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">s</span>.fst</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">t</span>.fst</span></span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn">s</span>.snd</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><span class="fn">t</span>.snd</span></span></span></span>)</span></div></div></div></div><div class="decl" id="Prod.eta"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1030-L1030">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Prod.eta"><span class="name">Prod</span>.<span class="name">eta</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">p</span>.fst</span>, <span class="fn"><span class="fn">p</span>.snd</span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">p</span></span></div></div></div></div><div class="decl" id="Prod.map"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1036-L1038">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Prod.map"><span class="name">Prod</span>.<span class="name">map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α₁ : <a href=".././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α₂ : <a href=".././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β₁ : <a href=".././foundational_types.html">Type</a> v₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β₂ : <a href=".././foundational_types.html">Type</a> v₂}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α₁</span> → <span class="fn">α₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">β₁</span> → <span class="fn">β₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">α₁</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β₁</span></span> → <span class="fn"><span class="fn">α₂</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">β₂</span></span></span></div></div><p><code><a href=".././Init/Core.html#Prod.map">Prod.map</a> f g : α₁ × β₁ → α₂ × β₂</code> maps across a pair
by applying <code>f</code> to the first component and <code>g</code> to the second.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Prod.map">Prod.map</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">x</span> with
  | <span class="fn">(<span class="fn">a</span>, <span class="fn">b</span>)</span> =&gt <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">a</span></span>, <span class="fn"><span class="fn">g</span> <span class="fn">b</span></span>)</span></span></span></li></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Dependent-products">Dependent products <a class="hover-link" href="#Dependent-products">#</a></h1></div><div class="decl" id="ex_of_PSigma"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1042-L1043">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#ex_of_PSigma"><span class="name">ex_of_PSigma</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(x : <span class="fn">α</span>) ×' <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span> → <span class="fn">∃ <span class="fn">x</span>, <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span></span></span></div></div></div></div><div class="decl" id="PSigma.eta"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1045-L1049">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#PSigma.eta"><span class="name">PSigma</span>.<span class="name">eta</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₁ : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₂ : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₁ : <span class="fn"><span class="fn">β</span> <span class="fn">a₁</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b₂ : <span class="fn"><span class="fn">β</span> <span class="fn">a₂</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a₁</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn"><span class="fn">h₁</span> ▸ <span class="fn">b₁</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">{ <span class="fn">fst</span> := <span class="fn">a₁</span>, <span class="fn">snd</span> := <span class="fn">b₁</span> }</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">fst</span> := <span class="fn">a₂</span>, <span class="fn">snd</span> := <span class="fn">b₂</span> }</span></span></div></div></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Universe-polymorphic-unit">Universe polymorphic unit <a class="hover-link" href="#Universe-polymorphic-unit">#</a></h1></div><div class="decl" id="PUnit.subsingleton"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1053-L1054">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#PUnit.subsingleton"><span class="name">PUnit</span>.<span class="name">subsingleton</span></a></span><span class="decl_args">
<span class="fn">(a : <a href=".././Init/Prelude.html#PUnit">PUnit</a>)</span></span>
<span class="decl_args">
<span class="fn">(b : <a href=".././Init/Prelude.html#PUnit">PUnit</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="PUnit.eq_punit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1056-L1057">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#PUnit.eq_punit"><span class="name">PUnit</span>.<span class="name">eq_punit</span></a></span><span class="decl_args">
<span class="fn">(a : <a href=".././Init/Prelude.html#PUnit">PUnit</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#PUnit.unit">PUnit.unit</a></span></div></div></div></div><div class="decl" id="instSubsingletonPUnit"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1059-L1060">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instSubsingletonPUnit"><span class="name">instSubsingletonPUnit</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <a href=".././Init/Prelude.html#PUnit">PUnit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instSubsingletonPUnit">instSubsingletonPUnit</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">(_ : <span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <a href=".././Init/Prelude.html#PUnit">PUnit</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="instInhabitedPUnit"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1062-L1063">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instInhabitedPUnit"><span class="name">instInhabitedPUnit</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#PUnit">PUnit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instInhabitedPUnit">instInhabitedPUnit</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <a href=".././Init/Prelude.html#PUnit.unit">PUnit.unit</a> }</span></span></li></ul></details></div></div><div class="decl" id="instDecidableEqPUnit"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1065-L1066">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableEqPUnit"><span class="name">instDecidableEqPUnit</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#PUnit">PUnit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#instDecidableEqPUnit">instDecidableEqPUnit</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">(_ : <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span></span></li></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Setoid">Setoid <a class="hover-link" href="#Setoid">#</a></h1></div><div class="decl" id="Setoid"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1074-L1078">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Setoid"><span class="name">Setoid</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Sort</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> (max1u)</div></div><ul class="structure_fields" id="Setoid.mk"><li id="Setoid.r" class="structure_field"><div class="structure_field_doc"><p><code>x ≈ y</code> is the distinguished equivalence relation of a setoid.</p></div><div class="structure_field_info">r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span></div></li><li id="Setoid.iseqv" class="structure_field"><div class="structure_field_doc"><p>The relation <code>x ≈ y</code> is an equivalence relation.</p></div><div class="structure_field_info">iseqv : <span class="fn"><a href=".././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">r</span></span></div></li></ul><p>A setoid is a type with a distinguished equivalence relation, denoted <code>≈</code>.
This is mainly used as input to the <code><a href=".././Init/Core.html#Quotient">Quotient</a></code> type constructor.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-Setoid" class="instances-list"></ul></details></div></div><div class="decl" id="instHasEquiv"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1080-L1081">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instHasEquiv"><span class="name">instHasEquiv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#HasEquiv">HasEquiv</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instHasEquiv</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">Equiv</span> := <span class="fn">Setoid.r</span> }</span></span></li></ul></details></div></div><div class="decl" id="Setoid.refl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1087-L1088">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Setoid.refl"><span class="name">Setoid</span>.<span class="name">refl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Setoid.symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1090-L1091">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Setoid.symm"><span class="name">Setoid</span>.<span class="name">symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hab : <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">b</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Setoid.trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1093-L1094">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Setoid.trans"><span class="name">Setoid</span>.<span class="name">trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hab : <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hbc : <span class="fn"><span class="fn">b</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">c</span></span></div></div></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Propositional-extensionality">Propositional extensionality <a class="hover-link" href="#Propositional-extensionality">#</a></h1></div><div class="decl" id="propext"><div class="axiom"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1135-L1135">source</a></div><div class="decl_header"><span class="decl_kind">axiom</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#propext"><span class="name">propext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span>) → <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></div></div><p>The axiom of <strong>propositional extensionality</strong>. It asserts that if propositions
<code>a</code> and <code>b</code> are logically equivalent (i.e. we can prove <code>a</code> from <code>b</code> and vice versa),
then <code>a</code> and <code>b</code> are <em>equal</em>, meaning that we can replace <code>a</code> with <code>b</code> in all
contexts.</p><p>For simple expressions like <code>a ∧ c ∨ d → e</code> we can prove that because all the logical
connectives respect logical equivalence, we can replace <code>a</code> with <code>b</code> in this expression
without using <code><a href=".././Init/Core.html#propext">propext</a></code>. However, for higher order expressions like <code>P a</code> where
<code>P : Prop → Prop</code> is unknown, or indeed for <code>a = b</code> itself, we cannot replace <code>a</code> with <code>b</code>
without an axiom which says exactly this.</p><p>This is a relatively uncontroversial axiom, which is intuitionistically valid.
It does however block computation when using <code>#reduce</code> to reduce proofs directly
(which is not recommended), meaning that canonicity,
the property that all closed terms of type <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> normalize to numerals,
fails to hold when this (or any) axiom is used:</p><pre><code>set_option pp.proofs true

<a href=".././Init/Core.html#id.def">def</a> foo : <a href=".././Init/Prelude.html#Nat">Nat</a> := by
  have : (True → True) ↔ <a href=".././Init/Prelude.html#True">True</a> := ⟨λ _ => trivial, λ _ _ => trivial⟩
  have := <a href=".././Init/Core.html#propext">propext</a> this ▸ (2 : Nat)
  <a href=".././Init/Core.html#Quotient.exact">exact</a> this

#reduce foo
-- <a href=".././Init/Core.html#propext">propext</a> { <a href=".././Init/Core.html#Iff.mp">mp</a> := fun x x => True.intro, <a href=".././Init/Core.html#Iff.mpr">mpr</a> := fun x => <a href=".././Init/Prelude.html#True.intro">True.intro</a> } ▸ 2

#eval foo -- 2
</code></pre><p><code>#eval</code> can evaluate it to a numeral because the compiler erases casts and
does not evaluate proofs, so <code><a href=".././Init/Core.html#propext">propext</a></code>, whose return type is a proposition,
can never block it.</p></div></div><div class="decl" id="Eq.propIntro"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1137-L1138">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Eq.propIntro"><span class="name">Eq</span>.<span class="name">propIntro</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> → <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">b</span> → <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="instDecidableEqProp"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1141-L1144">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableEqProp"><span class="name">instDecidableEqProp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[d : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">p</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">q</span></span>)</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">p</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">q</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instDecidableEqProp</span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">d</span> with
  | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isTrue</a> <span class="fn">h</span></span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">(_ : <span class="fn"><span class="fn">p</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">q</span></span>)</span></span>
  | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">h</span></span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">(_ : <span class="fn"><span class="fn"><span class="fn">p</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">q</span></span> → <a href=".././Init/Prelude.html#False">False</a></span>)</span></span></span></span></li></ul></details></div></div><div class="decl" id="beq_iff_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1162-L1163">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#beq_iff_eq"><span class="name">beq_iff_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span></span>) <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></div></div></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Quotients">Quotients <a class="hover-link" href="#Quotients">#</a></h1></div><div class="decl" id="Iff.subst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1168-L1169">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Iff.subst"><span class="name">Iff</span>.<span class="name">subst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././foundational_types.html">Prop</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><a href=".././foundational_types.html">Prop</a> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#Iff">↔</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <span class="fn">b</span></span></div></div><p>Iff can now be used to do substitutions in a calculation</p></div></div><div class="decl" id="Quot.sound"><div class="axiom"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1202-L1202">source</a></div><div class="decl_header"><span class="decl_kind">axiom</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.sound"><span class="name">Quot</span>.<span class="name">sound</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">b</span></span></span></span></div></div><p>The <strong>quotient axiom</strong>, or at least the nontrivial part of the quotient
axiomatization. Quotient types are introduced by the <code>init_quot</code> command
in <code><a href=".././Init/Prelude.html">Init.Prelude</a></code> which introduces the axioms:</p><pre><code>opaque <a href=".././Init/Prelude.html#Quot">Quot</a> {α : Sort u} (r : α → α → Prop) : Sort u

opaque <a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> {α : Sort u} (r : α → α → Prop) (a : α) : <a href=".././Init/Prelude.html#Quot">Quot</a> <a href=".././Init/Core.html#Setoid.r">r</a>

opaque <a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a> {α : Sort u} {r : α → α → Prop} {β : Sort v} (f : α → β) :
  (∀ a b : α, <a href=".././Init/Core.html#Setoid.r">r</a> a b → f a = f b) → <a href=".././Init/Prelude.html#Quot">Quot</a> <a href=".././Init/Core.html#Setoid.r">r</a> → β

opaque <a href=".././Init/Prelude.html#Quot.ind">Quot.ind</a> {α : Sort u} {r : α → α → Prop} {β : <a href=".././Init/Prelude.html#Quot">Quot</a> <a href=".././Init/Core.html#Setoid.r">r</a> → Prop} :
  (∀ a : α, β (Quot.<a href=".././Init/Core.html#Thunk.mk">mk</a> <a href=".././Init/Core.html#Setoid.r">r</a> a)) → ∀ q : <a href=".././Init/Prelude.html#Quot">Quot</a> r, β q
</code></pre><p>All of these axioms are true if we assume <code><a href=".././Init/Prelude.html#Quot">Quot</a> α <a href=".././Init/Core.html#Setoid.r">r</a> = α</code> and <code><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a></code> and
<code><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a></code> are identity functions, so they do not add much. However this axiom
cannot be explained in that way (it is false for that interpretation), so the
real power of quotient types come from this axiom.</p><p>It says that the quotient by <code><a href=".././Init/Core.html#Setoid.r">r</a></code> maps elements which are related by <code><a href=".././Init/Core.html#Setoid.r">r</a></code> to equal
values in the quotient. Together with <code><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a></code> which says that functions
which respect <code><a href=".././Init/Core.html#Setoid.r">r</a></code> can be lifted to functions on the quotient, we can deduce that
<code><a href=".././Init/Prelude.html#Quot">Quot</a> α <a href=".././Init/Core.html#Setoid.r">r</a></code> exactly consists of the equivalence classes with respect to <code><a href=".././Init/Core.html#Setoid.r">r</a></code>.</p><p>It is important to note that <code><a href=".././Init/Core.html#Setoid.r">r</a></code> need not be an equivalence relation in this axiom.
When <code><a href=".././Init/Core.html#Setoid.r">r</a></code> is not an equivalence relation, we are actually taking a quotient with
respect to the equivalence relation generated by <code><a href=".././Init/Core.html#Setoid.r">r</a></code>.</p></div></div><div class="decl" id="Quot.liftBeta"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1204-L1209">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.liftBeta"><span class="name">Quot</span>.<span class="name">liftBeta</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn">∀ (<span class="fn">a </span>b : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a> <span class="fn">f</span> <span class="fn">c</span> (<span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span></span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="Quot.indBeta"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1211-L1215">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.indBeta"><span class="name">Quot</span>.<span class="name">indBeta</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> (<span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot.ind">Quot.ind</a> <span class="fn">p</span> (<span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span></span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">p</span> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="Quot.liftOn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1221-L1223">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.liftOn"><span class="name">Quot</span>.<span class="name">liftOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(q : <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn">∀ (<span class="fn">a </span>b : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p><code><a href=".././Init/Core.html#Quot.liftOn">Quot.liftOn</a> q f h</code> is the same as <code><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a> f h q</code>. It just reorders
the argument <code>q : <a href=".././Init/Prelude.html#Quot">Quot</a> <a href=".././Init/Core.html#Setoid.r">r</a></code> to be first.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Quot.liftOn">Quot.liftOn</a> <span class="fn">q</span> <span class="fn">f</span> <span class="fn">c</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a> <span class="fn">f</span> <span class="fn">c</span> <span class="fn">q</span></span></span></li></ul></details></div></div><div class="decl" id="Quot.inductionOn"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1226-L1230">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.inductionOn"><span class="name">Quot</span>.<span class="name">inductionOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(q : <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> (<span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></div></div></div></div><div class="decl" id="Quot.exists_rep"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1232-L1233">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.exists_rep"><span class="name">Quot</span>.<span class="name">exists_rep</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(q : <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">a</span>, <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">q</span></span></span></div></div></div></div><div class="decl" id="Quot.indep"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1242-L1243">source</a></div><div class="attributes">@[macro_inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.indep"><span class="name">Quot</span>.<span class="name">indep</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> (<span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#PSigma">PSigma</a> <span class="fn">motive</span></span></div></div><p>Auxiliary definition for <code><a href=".././Init/Core.html#Quot.rec">Quot.rec</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Quot.indep">Quot.indep</a> <span class="fn">f</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">fst</span> := <span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span></span>, <span class="fn">snd</span> := <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Quot.indepCoherent"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1245-L1249">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.indepCoherent"><span class="name">Quot</span>.<span class="name">indepCoherent</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> (<span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a </span>b : <span class="fn">α</span>) (<span class="fn">p</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn"><span class="fn">(_ : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">b</span></span></span>)</span> ▸ <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quot.indep">Quot.indep</a> <span class="fn">f</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quot.indep">Quot.indep</a> <span class="fn">f</span> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="Quot.liftIndepPr1"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1251-L1257">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.liftIndepPr1"><span class="name">Quot</span>.<span class="name">liftIndepPr1</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> (<span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a </span>b : <span class="fn">α</span>) (<span class="fn">p</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn"><span class="fn">(_ : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">b</span></span></span>)</span> ▸ <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(q : <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a> (<span class="fn"><a href=".././Init/Core.html#Quot.indep">Quot.indep</a> <span class="fn">f</span></span>) <span class="fn">(_ : <span class="fn">∀ (<span class="fn">a </span>b : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quot.indep">Quot.indep</a> <span class="fn">f</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quot.indep">Quot.indep</a> <span class="fn">f</span> <span class="fn">b</span></span></span></span></span>)</span> <span class="fn">q</span></span>).fst</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">q</span></span></div></div></div></div><div class="decl" id="Quot.rec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1267-L1271">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.rec"><span class="name">Quot</span>.<span class="name">rec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> (<span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a </span>b : <span class="fn">α</span>) (<span class="fn">p</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn"><span class="fn">(_ : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">b</span></span></span>)</span> ▸ <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(q : <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></div></div><p>Dependent recursion principle for <code><a href=".././Init/Prelude.html#Quot">Quot</a></code>. This constructor can be tricky to use,
so you should consider the simpler versions if they apply:</p><ul>
<li><code><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a></code>, for nondependent functions</li>
<li><code><a href=".././Init/Prelude.html#Quot.ind">Quot.ind</a></code>, for theorems / proofs of propositions about quotients</li>
<li><code><a href=".././Init/Core.html#Quot.recOnSubsingleton">Quot.recOnSubsingleton</a></code>, when the target type is a <code><a href=".././Init/Core.html#Subsingleton">Subsingleton</a></code></li>
<li><code><a href=".././Init/Core.html#Quot.hrecOn">Quot.hrecOn</a></code>, which uses <code><a href=".././Init/Prelude.html#HEq">HEq</a> (f a) (f b)</code> instead of a <code><a href=".././Init/Core.html#Quot.sound">sound</a> p ▸ f a = f b</code> assummption</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Quot.recOn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1273-L1278">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.recOn"><span class="name">Quot</span>.<span class="name">recOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(q : <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> (<span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a </span>b : <span class="fn">α</span>) (<span class="fn">p</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn"><span class="fn">(_ : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">b</span></span></span>)</span> ▸ <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></div></div><p>Dependent recursion principle for <code><a href=".././Init/Prelude.html#Quot">Quot</a></code>. This constructor can be tricky to use,
so you should consider the simpler versions if they apply:</p><ul>
<li><code><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a></code>, for nondependent functions</li>
<li><code><a href=".././Init/Prelude.html#Quot.ind">Quot.ind</a></code>, for theorems / proofs of propositions about quotients</li>
<li><code><a href=".././Init/Core.html#Quot.recOnSubsingleton">Quot.recOnSubsingleton</a></code>, when the target type is a <code><a href=".././Init/Core.html#Subsingleton">Subsingleton</a></code></li>
<li><code><a href=".././Init/Core.html#Quot.hrecOn">Quot.hrecOn</a></code>, which uses <code><a href=".././Init/Prelude.html#HEq">HEq</a> (f a) (f b)</code> instead of a <code><a href=".././Init/Core.html#Quot.sound">sound</a> p ▸ f a = f b</code> assummption</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Quot.recOn">Quot.recOn</a> <span class="fn">q</span> <span class="fn">f</span> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quot.rec">Quot.rec</a> <span class="fn">f</span> <span class="fn">h</span> <span class="fn">q</span></span></span></li></ul></details></div></div><div class="decl" id="Quot.recOnSubsingleton"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1284-L1291">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.recOnSubsingleton"><span class="name">Quot</span>.<span class="name">recOnSubsingleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[h : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> (<span class="fn"><span class="fn">motive</span> (<span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span></span>)</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(q : <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> (<span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></div></div><p>Dependent induction principle for a quotient, when the target type is a <code><a href=".././Init/Core.html#Subsingleton">Subsingleton</a></code>.
In this case the quotient's side condition is trivial so any function can be lifted.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Quot.recOnSubsingleton">Quot.recOnSubsingleton</a> <span class="fn">q</span> <span class="fn">f</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Core.html#Quot.rec">Quot.rec</a> (<span class="fn">fun <span class="fn">a</span> =&gt <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span></span>) <span class="fn">(_ : <span class="fn">∀ (<span class="fn">a </span>b : <span class="fn">α</span>) (<span class="fn">p</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn"><span class="fn">(_ : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">b</span></span></span>)</span> ▸ <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span></span>)</span> <span class="fn">q</span></span></span></li></ul></details></div></div><div class="decl" id="Quot.hrecOn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1298-L1305">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quot.hrecOn"><span class="name">Quot</span>.<span class="name">hrecOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(q : <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> (<span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn">∀ (<span class="fn">a </span>b : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> (<span class="fn"><span class="fn">f</span> <span class="fn">a</span></span>) (<span class="fn"><span class="fn">f</span> <span class="fn">b</span></span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></div></div><p>Heterogeneous dependent recursion principle for a quotient.
This may be easier to work with since it uses <code><a href=".././Init/Prelude.html#HEq">HEq</a></code> instead of
an <code><a href=".././Init/Prelude.html#Eq.ndrec">Eq.ndrec</a></code> in the hypothesis.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Quot.hrecOn">Quot.hrecOn</a> <span class="fn">q</span> <span class="fn">f</span> <span class="fn">c</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quot.recOn">Quot.recOn</a> <span class="fn">q</span> <span class="fn">f</span> <span class="fn">(_ : <span class="fn">∀ (<span class="fn">a </span>b : <span class="fn">α</span>) (<span class="fn">p</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn"><span class="fn">(_ : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">r</span> <span class="fn">b</span></span></span>)</span> ▸ <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span></span>)</span></span></span></li></ul></details></div></div><div class="decl" id="Quotient"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1316-L1317">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient"><span class="name">Quotient</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Sort</a> u</div></div><p><code><a href=".././Init/Core.html#Quotient">Quotient</a> α s</code> is the same as <code><a href=".././Init/Prelude.html#Quot">Quot</a> α <a href=".././Init/Core.html#Setoid.r">r</a></code>, but it is specialized to a setoid <code>s</code>
(that is, an equivalence relation) instead of an arbitrary relation.
Prefer <code><a href=".././Init/Core.html#Quotient">Quotient</a></code> over <code><a href=".././Init/Prelude.html#Quot">Quot</a></code> if your relation is actually an equivalence relation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">Setoid.r</span></span></span></li></ul></details></div></div><div class="decl" id="Quotient.mk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1323-L1324">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.mk"><span class="name">Quotient</span>.<span class="name">mk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span></div></div><p>The canonical quotient map into a <code><a href=".././Init/Core.html#Quotient">Quotient</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> <span class="fn">Setoid.r</span> <span class="fn">a</span></span></span></li></ul></details></div></div><div class="decl" id="Quotient.mk'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1330-L1331">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.mk'"><span class="name">Quotient</span>.<span class="name">mk'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[s : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span></div></div><p>The canonical quotient map into a <code><a href=".././Init/Core.html#Quotient">Quotient</a></code>.
(This synthesizes the setoid by typeclass inference.)</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient.mk'">Quotient.mk'</a> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span></span></span></li></ul></details></div></div><div class="decl" id="Quotient.sound"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1337-L1338">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.sound"><span class="name">Quotient</span>.<span class="name">sound</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">b</span></span></span></span></div></div><p>The analogue of <code><a href=".././Init/Core.html#Quot.sound">Quot.sound</a></code>: If <code>a</code> and <code>b</code> are related by the equivalence relation,
then they have equal equivalence classes.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#Quotient.sound">@<a href=".././Init/Core.html#Quotient.sound">Quotient.sound</a></a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Core.html#Quotient.sound.proof_1">@<a href=".././Init/Core.html#Quotient.sound.proof_1">Quotient.sound.proof_1</a></a></span></li></ul></details></div></div><div class="decl" id="Quotient.lift"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1344-L1345">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.lift"><span class="name">Quotient</span>.<span class="name">lift</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">∀ (<span class="fn">a </span>b : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span></span></span>) → <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span> → <span class="fn">β</span></span></span></div></div><p>The analogue of <code><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a></code>: if <code>f : α → β</code> respects the equivalence relation <code>≈</code>,
then it lifts to a function on <code><a href=".././Init/Core.html#Quotient">Quotient</a> s</code> such that <code><a href=".././Init/Core.html#Quotient.lift">lift</a> f h (mk a) = f a</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient.lift">Quotient.lift</a> <span class="fn">f</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a> <span class="fn">f</span></span></span></li></ul></details></div></div><div class="decl" id="Quotient.ind"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1348-L1349">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.ind"><span class="name">Quotient</span>.<span class="name">ind</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> (<span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span></span>)</span></span>) → <span class="fn">(<span class="fn">q</span> : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span>) → <span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></span></span></div></div><p>The analogue of <code><a href=".././Init/Prelude.html#Quot.ind">Quot.ind</a></code>: every element of <code><a href=".././Init/Core.html#Quotient">Quotient</a> s</code> is of the form <code><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> s a</code>.</p></div></div><div class="decl" id="Quotient.liftOn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1355-L1356">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.liftOn"><span class="name">Quotient</span>.<span class="name">liftOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(q : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn">∀ (<span class="fn">a </span>b : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p>The analogue of <code><a href=".././Init/Core.html#Quot.liftOn">Quot.liftOn</a></code>: if <code>f : α → β</code> respects the equivalence relation <code>≈</code>,
then it lifts to a function on <code><a href=".././Init/Core.html#Quotient">Quotient</a> s</code> such that <code><a href=".././Init/Core.html#Quotient.lift">lift</a> (mk a) f h = f a</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient.liftOn">Quotient.liftOn</a> <span class="fn">q</span> <span class="fn">f</span> <span class="fn">c</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quot.liftOn">Quot.liftOn</a> <span class="fn">q</span> <span class="fn">f</span> <span class="fn">c</span></span></span></li></ul></details></div></div><div class="decl" id="Quotient.inductionOn"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1360-L1364">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.inductionOn"><span class="name">Quotient</span>.<span class="name">inductionOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(q : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> (<span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></div></div><p>The analogue of <code><a href=".././Init/Core.html#Quot.inductionOn">Quot.inductionOn</a></code>: every element of <code><a href=".././Init/Core.html#Quotient">Quotient</a> s</code> is of the form <code><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> s a</code>.</p></div></div><div class="decl" id="Quotient.exists_rep"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1366-L1367">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.exists_rep"><span class="name">Quotient</span>.<span class="name">exists_rep</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(q : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ <span class="fn">a</span>, <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">q</span></span></span></div></div></div></div><div class="decl" id="Quotient.rec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1376-L1381">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.rec"><span class="name">Quotient</span>.<span class="name">rec</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> (<span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a </span>b : <span class="fn">α</span>) (<span class="fn">p</span> : <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b</span></span>), <span class="fn"><span class="fn"><span class="fn">(_ : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">b</span></span></span>)</span> ▸ <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(q : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></div></div><p>The analogue of <code><a href=".././Init/Core.html#Quot.rec">Quot.rec</a></code> for <code><a href=".././Init/Core.html#Quotient">Quotient</a></code>. See <code><a href=".././Init/Core.html#Quot.rec">Quot.rec</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient.rec">Quotient.rec</a> <span class="fn">f</span> <span class="fn">h</span> <span class="fn">q</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quot.rec">Quot.rec</a> <span class="fn">f</span> <span class="fn">h</span> <span class="fn">q</span></span></span></li></ul></details></div></div><div class="decl" id="Quotient.recOn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1385-L1390">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.recOn"><span class="name">Quotient</span>.<span class="name">recOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(q : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> (<span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">a </span>b : <span class="fn">α</span>) (<span class="fn">p</span> : <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b</span></span>), <span class="fn"><span class="fn"><span class="fn">(_ : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">b</span></span></span>)</span> ▸ <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></div></div><p>The analogue of <code><a href=".././Init/Core.html#Quot.recOn">Quot.recOn</a></code> for <code><a href=".././Init/Core.html#Quotient">Quotient</a></code>. See <code><a href=".././Init/Core.html#Quot.recOn">Quot.recOn</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient.recOn">Quotient.recOn</a> <span class="fn">q</span> <span class="fn">f</span> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quot.recOn">Quot.recOn</a> <span class="fn">q</span> <span class="fn">f</span> <span class="fn">h</span></span></span></li></ul></details></div></div><div class="decl" id="Quotient.recOnSubsingleton"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1394-L1399">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.recOnSubsingleton"><span class="name">Quotient</span>.<span class="name">recOnSubsingleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[h : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> (<span class="fn"><span class="fn">motive</span> (<span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span></span>)</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(q : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> (<span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></div></div><p>The analogue of <code><a href=".././Init/Core.html#Quot.recOnSubsingleton">Quot.recOnSubsingleton</a></code> for <code><a href=".././Init/Core.html#Quotient">Quotient</a></code>. See <code><a href=".././Init/Core.html#Quot.recOnSubsingleton">Quot.recOnSubsingleton</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient.recOnSubsingleton">Quotient.recOnSubsingleton</a> <span class="fn">q</span> <span class="fn">f</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quot.recOnSubsingleton">Quot.recOnSubsingleton</a> <span class="fn">q</span> <span class="fn">f</span></span></span></li></ul></details></div></div><div class="decl" id="Quotient.hrecOn"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1403-L1408">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.hrecOn"><span class="name">Quotient</span>.<span class="name">hrecOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(q : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> (<span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn">∀ (<span class="fn">a </span>b : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b</span></span> → <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> (<span class="fn"><span class="fn">f</span> <span class="fn">a</span></span>) (<span class="fn"><span class="fn">f</span> <span class="fn">b</span></span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></div></div><p>The analogue of <code><a href=".././Init/Core.html#Quot.hrecOn">Quot.hrecOn</a></code> for <code><a href=".././Init/Core.html#Quotient">Quotient</a></code>. See <code><a href=".././Init/Core.html#Quot.hrecOn">Quot.hrecOn</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient.hrecOn">Quotient.hrecOn</a> <span class="fn">q</span> <span class="fn">f</span> <span class="fn">c</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quot.hrecOn">Quot.hrecOn</a> <span class="fn">q</span> <span class="fn">f</span> <span class="fn">c</span></span></span></li></ul></details></div></div><div class="decl" id="Quotient.lift₂"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1417-L1425">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.lift₂"><span class="name">Quotient</span>.<span class="name">lift₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> uA}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> uB}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{φ : <a href=".././foundational_types.html">Sort</a> uC}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₁ : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₂ : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">φ</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn">∀ (<span class="fn">a₁</span> : <span class="fn">α</span>) (<span class="fn">b₁</span> : <span class="fn">β</span>) (<span class="fn">a₂</span> : <span class="fn">α</span>) (<span class="fn">b₂</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">a₁</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">a₂</span></span> → <span class="fn"><span class="fn"><span class="fn">b₁</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b₂</span></span> → <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a₁</span> <span class="fn">b₁</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">a₂</span> <span class="fn">b₂</span></span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(q₁ : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(q₂ : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">φ</span></div></div><p>Lift a binary function to a quotient on both arguments.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Quotient.liftOn₂"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1428-L1434">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.liftOn₂"><span class="name">Quotient</span>.<span class="name">liftOn₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> uA}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> uB}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{φ : <a href=".././foundational_types.html">Sort</a> uC}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₁ : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₂ : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(q₁ : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(q₂ : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">φ</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn">∀ (<span class="fn">a₁</span> : <span class="fn">α</span>) (<span class="fn">b₁</span> : <span class="fn">β</span>) (<span class="fn">a₂</span> : <span class="fn">α</span>) (<span class="fn">b₂</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">a₁</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">a₂</span></span> → <span class="fn"><span class="fn"><span class="fn">b₁</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b₂</span></span> → <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a₁</span> <span class="fn">b₁</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">a₂</span> <span class="fn">b₂</span></span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">φ</span></div></div><p>Lift a binary function to a quotient on both arguments.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient.liftOn₂">Quotient.liftOn₂</a> <span class="fn">q₁</span> <span class="fn">q₂</span> <span class="fn">f</span> <span class="fn">c</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quotient.lift₂">Quotient.lift₂</a> <span class="fn">f</span> <span class="fn">c</span> <span class="fn">q₁</span> <span class="fn">q₂</span></span></span></li></ul></details></div></div><div class="decl" id="Quotient.ind₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1437-L1445">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.ind₂"><span class="name">Quotient</span>.<span class="name">ind₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> uA}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> uB}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₁ : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₂ : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₁</span></span> → <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₂</span></span> → <a href=".././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn">(<span class="fn">b</span> : <span class="fn">β</span>) → <span class="fn"><span class="fn">motive</span> (<span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s₁</span> <span class="fn">a</span></span>) (<span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s₂</span> <span class="fn">b</span></span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(q₁ : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(q₂ : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q₁</span> <span class="fn">q₂</span></span></div></div></div></div><div class="decl" id="Quotient.inductionOn₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1448-L1456">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.inductionOn₂"><span class="name">Quotient</span>.<span class="name">inductionOn₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> uA}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> uB}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₁ : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₂ : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₁</span></span> → <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₂</span></span> → <a href=".././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(q₁ : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(q₂ : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn">(<span class="fn">b</span> : <span class="fn">β</span>) → <span class="fn"><span class="fn">motive</span> (<span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s₁</span> <span class="fn">a</span></span>) (<span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s₂</span> <span class="fn">b</span></span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q₁</span> <span class="fn">q₂</span></span></div></div></div></div><div class="decl" id="Quotient.inductionOn₃"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1459-L1470">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.inductionOn₃"><span class="name">Quotient</span>.<span class="name">inductionOn₃</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> uA}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> uB}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{φ : <a href=".././foundational_types.html">Sort</a> uC}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₁ : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₂ : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₃ : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">φ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₁</span></span> → <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₂</span></span> → <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₃</span></span> → <a href=".././foundational_types.html">Prop</a></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(q₁ : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(q₂ : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(q₃ : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₃</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn">(<span class="fn">b</span> : <span class="fn">β</span>) → <span class="fn">(<span class="fn">c</span> : <span class="fn">φ</span>) → <span class="fn"><span class="fn">motive</span> (<span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s₁</span> <span class="fn">a</span></span>) (<span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s₂</span> <span class="fn">b</span></span>) (<span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s₃</span> <span class="fn">c</span></span>)</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q₁</span> <span class="fn">q₂</span> <span class="fn">q₃</span></span></div></div></div></div><div class="decl" id="Quotient.exact"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1492-L1493">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.exact"><span class="name">Quotient</span>.<span class="name">exact</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s</span> <span class="fn">b</span></span></span> → <span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Quotient.recOnSubsingleton₂"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1504-L1517">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Quotient.recOnSubsingleton₂"><span class="name">Quotient</span>.<span class="name">recOnSubsingleton₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> uA}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> uB}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₁ : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₂ : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₁</span></span> → <span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₂</span></span> → <a href=".././foundational_types.html">Sort</a> uC</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[s : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn">β</span>), <span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> (<span class="fn"><span class="fn">motive</span> (<span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s₁</span> <span class="fn">a</span></span>) (<span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s₂</span> <span class="fn">b</span></span>)</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(q₁ : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(q₂ : <span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn">(<span class="fn">b</span> : <span class="fn">β</span>) → <span class="fn"><span class="fn">motive</span> (<span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s₁</span> <span class="fn">a</span></span>) (<span class="fn"><a href=".././Init/Core.html#Quotient.mk">Quotient.mk</a> <span class="fn">s₂</span> <span class="fn">b</span></span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q₁</span> <span class="fn">q₂</span></span></div></div><p>Lift a binary function to a quotient on both arguments.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Quotient.recOnSubsingleton₂">Quotient.recOnSubsingleton₂</a> <span class="fn">q₁</span> <span class="fn">q₂</span> <span class="fn">g</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Core.html#Quot.recOnSubsingleton">Quot.recOnSubsingleton</a> <span class="fn">q₁</span> <span class="fn">fun <span class="fn">a</span> =&gt <span class="fn"><a href=".././Init/Core.html#Quot.recOnSubsingleton">Quot.recOnSubsingleton</a> <span class="fn">q₂</span> <span class="fn">fun <span class="fn">a_1</span> =&gt <span class="fn"><span class="fn">g</span> <span class="fn">a</span> <span class="fn">a_1</span></span></span></span></span></span></span></li></ul></details></div></div><div class="decl" id="instDecidableEqQuotient"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1526-L1532">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instDecidableEqQuotient"><span class="name">instDecidableEqQuotient</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href=".././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[d : <span class="fn">(<span class="fn">a </span>b : <span class="fn">α</span>) → <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">a</span> <a href=".././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">b</span></span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> (<span class="fn"><a href=".././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Function-extensionality">Function extensionality <a class="hover-link" href="#Function-extensionality">#</a></h1></div><div class="decl" id="funext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1548-L1556">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#funext"><span class="name">funext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">β</span> <span class="fn">x</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">β</span> <span class="fn">x</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span> <span class="fn">x</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></span></div></div><p><strong>Function extensionality</strong> is the statement that if two functions take equal values
every point, then the functions themselves are equal: <code>(∀ x, f x = g x) → f = g</code>.
It is called "extensionality" because it talks about how to prove two objects are equal
based on the properties of the object (compare with set extensionality,
which is <code>(∀ x, x ∈ s ↔ x ∈ t) → s = t</code>).</p><p>This is often an axiom in dependent type theory systems, because it cannot be proved
from the core logic alone. However in lean's type theory this follows from the existence
of quotient types (note the <code><a href=".././Init/Core.html#Quot.sound">Quot.sound</a></code> in the proof, as well as the <code>show</code> line
which makes use of the definitional equality <code><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a> f h (Quot.<a href=".././Init/Core.html#Thunk.mk">mk</a> x) = f x</code>).</p></div></div><div class="decl" id="instSubsingletonForAll"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1558-L1559">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instSubsingletonForAll"><span class="name">instSubsingletonForAll</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href=".././foundational_types.html">Sort</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> (<span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> (<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instSubsingletonForAll">@<a href=".././Init/Core.html#instSubsingletonForAll">instSubsingletonForAll</a></a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Core.html#instSubsingletonForAll.proof_1">@<a href=".././Init/Core.html#instSubsingletonForAll.proof_1">instSubsingletonForAll.proof_1</a></a></span></li></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Squash">Squash <a class="hover-link" href="#Squash">#</a></h1></div><div class="decl" id="Squash"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1577-L1577">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Squash"><span class="name">Squash</span></a></span><span class="decl_args">
<span class="fn">(α : <a href=".././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a> u</div></div><p><code><a href=".././Init/Core.html#Squash">Squash</a> α</code> is the quotient of <code>α</code> by the always true relation.
It is empty if <code>α</code> is empty, otherwise it is a singleton.
(Thus it is unconditionally a <code><a href=".././Init/Core.html#Subsingleton">Subsingleton</a></code>.)
It is the "universal <code><a href=".././Init/Core.html#Subsingleton">Subsingleton</a></code>" mapped from <code>α</code>.</p><p>It is similar to <code><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> α</code>, which has the same properties, but unlike
<code><a href=".././Init/Prelude.html#Nonempty">Nonempty</a></code> this is a <code>Type u</code>, that is, it is "data", and the compiler
represents an element of <code><a href=".././Init/Core.html#Squash">Squash</a> α</code> the same as <code>α</code> itself
(as compared to <code><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> α</code>, whose elements are represented by a dummy value).</p><p><code><a href=".././Init/Core.html#Squash.lift">Squash.lift</a></code> will extract a value in any subsingleton <code>β</code> from a function on <code>α</code>,
while <code><a href=".././Init/Prelude.html#Nonempty.rec">Nonempty.rec</a></code> can only do the same when <code>β</code> is a proposition.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Squash">Squash</a> <span class="fn">α</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">fun <span class="fn">x</span> <span class="fn">x</span> =&gt <a href=".././Init/Prelude.html#True">True</a></span></span></span></li></ul></details></div></div><div class="decl" id="Squash.mk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1580-L1580">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Squash.mk"><span class="name">Squash</span>.<span class="name">mk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Squash">Squash</a> <span class="fn">α</span></span></div></div><p>The canonical quotient map into <code><a href=".././Init/Core.html#Squash">Squash</a> α</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Squash.mk">Squash.mk</a> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> (<span class="fn">fun <span class="fn">x</span> <span class="fn">x</span> =&gt <a href=".././Init/Prelude.html#True">True</a></span>) <span class="fn">x</span></span></span></li></ul></details></div></div><div class="decl" id="Squash.ind"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1582-L1583">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Squash.ind"><span class="name">Squash</span>.<span class="name">ind</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Squash">Squash</a> <span class="fn">α</span></span> → <a href=".././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">motive</span> (<span class="fn"><a href=".././Init/Core.html#Squash.mk">Squash.mk</a> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(q : <span class="fn"><a href=".././Init/Core.html#Squash">Squash</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">q</span></span></div></div></div></div><div class="decl" id="Squash.lift"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1586-L1587">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Squash.lift"><span class="name">Squash</span>.<span class="name">lift</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href=".././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href=".././Init/Core.html#Squash">Squash</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p>If <code>β</code> is a subsingleton, then a function <code>α → β</code> lifts to <code><a href=".././Init/Core.html#Squash">Squash</a> α → β</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Core.html#Squash.lift">Squash.lift</a> <span class="fn">s</span> <span class="fn">f</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a> <span class="fn">f</span> <span class="fn">(_ : <span class="fn">∀ (<span class="fn">x </span>x_1 : <span class="fn">α</span>), <span class="fn"><a href=".././Init/Prelude.html#True">True</a> → <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">x_1</span></span></span></span></span>)</span> <span class="fn">s</span></span></span></li></ul></details></div></div><div class="decl" id="instSubsingletonSquash"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1589-L1594">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#instSubsingletonSquash"><span class="name">instSubsingletonSquash</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Core.html#Subsingleton">Subsingleton</a> (<span class="fn"><a href=".././Init/Core.html#Squash">Squash</a> <span class="fn">α</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Core.html#instSubsingletonSquash">@<a href=".././Init/Core.html#instSubsingletonSquash">instSubsingletonSquash</a></a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Core.html#instSubsingletonSquash.proof_1">@<a href=".././Init/Core.html#instSubsingletonSquash.proof_1">instSubsingletonSquash.proof_1</a></a></span></li></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Relations">Relations <a class="hover-link" href="#Relations">#</a></h1></div><div class="decl" id="Antisymm"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1601-L1603">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Antisymm"><span class="name">Antisymm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="Antisymm.mk"><li id="Antisymm.antisymm" class="structure_field"><div class="structure_field_doc"><p>An antisymmetric relation <code>(·≤·)</code> satisfies <code>a ≤ b → b ≤ a → a = b</code>.</p></div><div class="structure_field_info">antisymm : <span class="fn">∀ {<span class="fn">a </span>b : <span class="fn">α</span>}, <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">b</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></span></span></div></li></ul><p><code><a href=".././Init/Core.html#Antisymm">Antisymm</a> (·≤·)</code> says that <code>(·≤·)</code> is antisymmetric, that is, <code>a ≤ b → b ≤ a → a = b</code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-Antisymm" class="instances-list"></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Kernel-reduction-hints">Kernel reduction hints <a class="hover-link" href="#Kernel-reduction-hints">#</a></h1></div><div class="decl" id="Lean.reduceBool"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1627-L1627">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Lean.reduceBool"><span class="name">Lean</span>.<span class="name">reduceBool</span></a></span><span class="decl_args">
<span class="fn">(b : <a href=".././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Bool">Bool</a></div></div><p>When the kernel tries to reduce a term <code><a href=".././Init/Core.html#Lean.reduceBool">Lean.reduceBool</a> c</code>, it will invoke the Lean interpreter to evaluate <code>c</code>.
The kernel will not use the interpreter if <code>c</code> is not a constant.
This feature is useful for performing proofs by reflection.</p><p>Remark: the Lean frontend allows terms of the from <code><a href=".././Init/Core.html#Lean.reduceBool">Lean.reduceBool</a> t</code> where <code>t</code> is a term not containing
free variables. The frontend automatically declares a fresh auxiliary constant <code>c</code> and replaces the term with
<code><a href=".././Init/Core.html#Lean.reduceBool">Lean.reduceBool</a> c</code>. The main motivation is that the code for <code>t</code> will be pre-compiled.</p><p>Warning: by using this feature, the Lean compiler and interpreter become part of your trusted code base.
This is extra 30k lines of code. More importantly, you will probably not be able to check your development using
external type checkers (e.g., Trepplein) that do not implement this feature.
Keep in mind that if you are using Lean as programming language, you are already trusting the Lean compiler and interpreter.
So, you are mainly losing the capability of type checking your development using external checkers.</p><p>Recall that the compiler trusts the correctness of all <code>[implemented_by ...]</code> and <code>[extern ...]</code> annotations.
If an extern function is executed, then the trusted code base will also include the implementation of the associated
foreign function.</p></div></div><div class="decl" id="Lean.reduceNat"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1636-L1636">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Lean.reduceNat"><span class="name">Lean</span>.<span class="name">reduceNat</span></a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>Similar to <code><a href=".././Init/Core.html#Lean.reduceBool">Lean.reduceBool</a></code> for closed <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> terms.</p><p>Remark: we do not have plans for supporting a generic <code>reduceValue {α} (a : α) : α := a</code>.
The main issue is that it is non-trivial to convert an arbitrary runtime object back into a Lean expression.
We believe <code><a href=".././Init/Core.html#Lean.reduceBool">Lean.reduceBool</a></code> enables most interesting applications (e.g., proof by reflection).</p></div></div><div class="decl" id="Lean.ofReduceBool"><div class="axiom"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1651-L1651">source</a></div><div class="decl_header"><span class="decl_kind">axiom</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Lean.ofReduceBool"><span class="name">Lean</span>.<span class="name">ofReduceBool</span></a></span><span class="decl_args">
<span class="fn">(a : <a href=".././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(b : <a href=".././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Lean.reduceBool">Lean.reduceBool</a> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></div></div><p>The axiom <code><a href=".././Init/Core.html#Lean.ofReduceBool">ofReduceBool</a></code> is used to perform proofs by reflection. See <code><a href=".././Init/Core.html#Lean.reduceBool">reduceBool</a></code>.</p><p>This axiom is usually not used directly, because it has some syntactic restrictions.
Instead, the <code>native_decide</code> tactic can be used to prove any proposition whose
decidability instance can be evaluated to <code>true</code> using the lean compiler / interpreter.</p><p>Warning: by using this feature, the Lean compiler and interpreter become part of your trusted code base.
This is extra 30k lines of code. More importantly, you will probably not be able to check your development using
external type checkers (e.g., Trepplein) that do not implement this feature.
Keep in mind that if you are using Lean as programming language, you are already trusting the Lean compiler and interpreter.
So, you are mainly losing the capability of type checking your development using external checkers.</p></div></div><div class="decl" id="Lean.ofReduceNat"><div class="axiom"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1662-L1662">source</a></div><div class="decl_header"><span class="decl_kind">axiom</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Lean.ofReduceNat"><span class="name">Lean</span>.<span class="name">ofReduceNat</span></a></span><span class="decl_args">
<span class="fn">(a : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(b : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href=".././Init/Core.html#Lean.reduceNat">Lean.reduceNat</a> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></div></div><p>The axiom <code><a href=".././Init/Core.html#Lean.ofReduceNat">ofReduceNat</a></code> is used to perform proofs by reflection. See <code><a href=".././Init/Core.html#Lean.reduceBool">reduceBool</a></code>.</p><p>Warning: by using this feature, the Lean compiler and interpreter become part of your trusted code base.
This is extra 30k lines of code. More importantly, you will probably not be able to check your development using
external type checkers (e.g., Trepplein) that do not implement this feature.
Keep in mind that if you are using Lean as programming language, you are already trusting the Lean compiler and interpreter.
So, you are mainly losing the capability of type checking your development using external checkers.</p></div></div><div class="decl" id="Lean.IsAssociative"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1668-L1670">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Lean.IsAssociative"><span class="name">Lean</span>.<span class="name">IsAssociative</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(op : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="Lean.IsAssociative.mk"><li id="Lean.IsAssociative.assoc" class="structure_field"><div class="structure_field_doc"><p>An associative operation satisfies <code>(a ∘ b) ∘ c = a ∘ (b ∘ c)</code>.</p></div><div class="structure_field_info">assoc : <span class="fn">∀ (<span class="fn">a </span>b c : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">op</span> (<span class="fn"><span class="fn">op</span> <span class="fn">a</span> <span class="fn">b</span></span>) <span class="fn">c</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">op</span> <span class="fn">a</span> (<span class="fn"><span class="fn">op</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span></span></div></li></ul><p><code><a href=".././Init/Core.html#Lean.IsAssociative">IsAssociative</a> op</code> says that <code>op</code> is an associative operation,
i.e. <code>(a ∘ b) ∘ c = a ∘ (b ∘ c)</code>. It is used by the <code>ac_rfl</code> tactic.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-Lean.IsAssociative" class="instances-list"></ul></details></div></div><div class="decl" id="Lean.IsCommutative"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1676-L1678">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Lean.IsCommutative"><span class="name">Lean</span>.<span class="name">IsCommutative</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(op : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="Lean.IsCommutative.mk"><li id="Lean.IsCommutative.comm" class="structure_field"><div class="structure_field_doc"><p>A commutative operation satisfies <code>a ∘ b = b ∘ a</code>.</p></div><div class="structure_field_info">comm : <span class="fn">∀ (<span class="fn">a </span>b : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">op</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">op</span> <span class="fn">b</span> <span class="fn">a</span></span></span></span></div></li></ul><p><code><a href=".././Init/Core.html#Lean.IsCommutative">IsCommutative</a> op</code> says that <code>op</code> is a commutative operation,
i.e. <code>a ∘ b = b ∘ a</code>. It is used by the <code>ac_rfl</code> tactic.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-Lean.IsCommutative" class="instances-list"></ul></details></div></div><div class="decl" id="Lean.IsIdempotent"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1685-L1687">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Lean.IsIdempotent"><span class="name">Lean</span>.<span class="name">IsIdempotent</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(op : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="Lean.IsIdempotent.mk"><li id="Lean.IsIdempotent.idempotent" class="structure_field"><div class="structure_field_doc"><p>An idempotent operation satisfies <code>a ∘ a = a</code>.</p></div><div class="structure_field_info">idempotent : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">op</span> <span class="fn">x</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></span></span></div></li></ul><p><code><a href=".././Init/Core.html#Lean.IsIdempotent">IsIdempotent</a> op</code> says that <code>op</code> is an idempotent operation,
i.e. <code>a ∘ a = a</code>. It is used by the <code>ac_rfl</code> tactic
(which also simplifies up to idempotence when available).</p><details class="instances"><summary>Instances</summary><ul id="instances-list-Lean.IsIdempotent" class="instances-list"></ul></details></div></div><div class="decl" id="Lean.IsNeutral"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/Core.lean#L1694-L1698">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Core.html#Lean.IsNeutral"><span class="name">Lean</span>.<span class="name">IsNeutral</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href=".././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(op : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(neutral : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="Lean.IsNeutral.mk"><li id="Lean.IsNeutral.left_neutral" class="structure_field"><div class="structure_field_doc"><p>A neutral element can be cancelled on the left: <code>e ∘ a = a</code>.</p></div><div class="structure_field_info">left_neutral : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">op</span> <span class="fn">neutral</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></span></div></li><li id="Lean.IsNeutral.right_neutral" class="structure_field"><div class="structure_field_doc"><p>A neutral element can be cancelled on the right: <code>a ∘ e = a</code>.</p></div><div class="structure_field_info">right_neutral : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">op</span> <span class="fn">a</span> <span class="fn">neutral</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></span></div></li></ul><p><code><a href=".././Init/Core.html#Lean.IsNeutral">IsNeutral</a> op e</code> says that <code>e</code> is a neutral operation for <code>op</code>,
i.e. <code>a ∘ e = a = e ∘ a</code>. It is used by the <code>ac_rfl</code> tactic
(which also simplifies neutral elements when available).</p><details class="instances"><summary>Instances</summary><ul id="instances-list-Lean.IsNeutral" class="instances-list"></ul></details></div></div></main>
<nav class="nav"><iframe src=".././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>