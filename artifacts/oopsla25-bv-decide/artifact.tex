%
% Prepared by Grigori Fursin with contributions from Bruce Childers,
%   Michael Heroux, Michela Taufer and other colleagues.
%
% See examples of this Artifact Appendix in
%  * SC'17 paper: https://dl.acm.org/citation.cfm?id=3126948
%  * CGO'17 paper: https://www.cl.cam.ac.uk/~sa614/papers/Software-Prefetching-CGO2017.pdf
%  * ACM ReQuEST-ASPLOS'18 paper: https://dl.acm.org/citation.cfm?doid=3229762.3229763
%
% (C)opyright 2014-2022
%
% CC BY 4.0 license
%

\documentclass[acmlarge, nonacm]{acmart}

% \documentclass[onecolumn]{sigplanconf}

\usepackage{hyperref}
\usepackage{minted}

\newminted[script]{bash}{style=bw, bgcolor=blue!5!white, breaklines, fontsize=\footnotesize}

\usepackage[verbose]{newunicodechar}
\newunicodechar{Γ}{\ensuremath{\Gamma}}
\newunicodechar{⊢}{\ensuremath{\vdash}}
\newunicodechar{▸}{\ensuremath{\blacktriangleright}}
\newunicodechar{∅}{\ensuremath{\emptyset}}
\newunicodechar{α}{\ensuremath{\alpha}}
\newunicodechar{β}{\ensuremath{\beta}}
\newunicodechar{δ}{\ensuremath{\delta}}
\newunicodechar{Δ}{\ensuremath{\Delta}}
\newunicodechar{ϵ}{\ensuremath{\epsilon}}
\newunicodechar{τ}{\ensuremath{\tau}}
\newunicodechar{ε}{\ensuremath{\epsilon}}
\newunicodechar{σ}{\ensuremath{\sigma}}
\newunicodechar{Σ}{\ensuremath{\Sigma}}
% \newunicodechar{α}{\ensuremath{\alpha}}
\newunicodechar{∈}{\ensuremath{\in}}
\newunicodechar{∧}{\ensuremath{\land}}

\newunicodechar{₀}{\textsubscript{0}}
\newunicodechar{₁}{\textsubscript{1}}
\newunicodechar{₂}{\textsubscript{2}}
\newunicodechar{₃}{\textsubscript{3}}
\newunicodechar{ₙ}{\textsubscript{n}}
\newunicodechar{ₘ}{\textsubscript{m}}
\newunicodechar{ₕ}{\textsubscript{h}}
\newunicodechar{⊕}{\ensuremath{\oplus}}
\newunicodechar{∀}{\ensuremath{\forall}}
\newunicodechar{∃}{\ensuremath{\exists}}
\newunicodechar{∘}{\ensuremath{\circ}}
\newunicodechar{⟦}{\ensuremath{\llbracket}}
\newunicodechar{⟧}{\ensuremath{\rrbracket}}
\newunicodechar{ℕ}{\ensuremath{\mathbb{N}}}
\newunicodechar{ℤ}{\ensuremath{\mathbb{Z}}}

% https://tex.stackexchange.com/questions/100966/defining-scalable-white-curly-brackets-and-and
% TODO FIXME: we gotta fix these parens!
\newunicodechar{⦃}{\ensuremath{\{\{}}
\newunicodechar{⦄}{\ensuremath{\}\}}}
\newunicodechar{⧸}{\ensuremath{/}}
\newunicodechar{⊑}{\ensuremath{\sqsubseteq}}

\begin{document}


\special{papersize=8.5in,11in}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% When adding this appendix to your paper, 
% please remove above part
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\appendix
\title[Artifact]{Artifact for Interactive Bit Vector Reasoning using Verified Bitblasting}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsection{Abstract}

% {\em Obligatory}

\subsection{Artifact check-list (meta-information)}

% {\em Obligatory. Use just a few informal keywords in all fields applicable to your artifacts
% and remove the rest. This information is needed to find appropriate reviewers and gradually 
% unify artifact meta information in Digital Libraries.}

\section{Introduction}

This artifact contains the infrastructure and tooling necessary to display the performance of the 
verified bitblaster introduced by the paper for all the benchmarks presented.

{\small
\begin{itemize}
  \item {\bf Program: } The code repository for our framework along with the test suite. Note that this is already setup in the docker image.
  \item {\bf Compilation: } The Lean4 toolchain, downloaded via \texttt{elan}. Note that this is already setup in the docker image.
  \item {\bf Run-time environment: } Any operating system that supports Docker.
  \item {\bf Hardware: } Any x86-64 machine.
  \item {\bf Output: } Key theorems of the paper will be built and shown to have no unsound axioms.
  \item {\bf How much disk space required (approximately)?: } 30GB
  \item {\bf How much time is needed to prepare workflow (approximately)?: } 1hr
  \item {\bf How much time is needed to complete experiments (approximately)?: } 5hr
  \item {\bf Publicly available?: } Yes
  \item {\bf Code licenses (if publicly available)?: } MIT
  \item {\bf Archived (provide DOI)?: } 10.5281/zenodo.15755236
\end{itemize}
}


\subsection{Performance}

We test the performance of the verified bitblaster \texttt{bv\_decide} against three benchmarks: 
\begin{itemize}
\item \texttt{InstCombine} benchmark, extracted from LLVM's peephole verifier
\item \texttt{HackersDelight} benchmark, containing bit-vector theorems extracted from the first two chapters of Hackers' Delight
\item \texttt{SMT-LIB} benchmark, containing the problems from SMT-LIB's 2024 Competition
\end{itemize}
The artifact contains the benchmarks, the scripts to evaulate \texttt{bv\_decide}'s performance, and the scripts to reproduce the plots in the paper.

\section{Hardware Dependencies}

Podman or Docker are necessary to run our artifact (we tested it with the former).
The container image has all dependencies needed to compile our framework with Lean4.
\textcolor{red}{TODO: add info}

\section{Getting Started}

Access the docker image from \url{10.5281/zenodo.15755236}: 
\begin{script}
$ docker load -i oopsla25-bv-decide.tar
$ docker run -it oopsla25-bv-decide
# | This clears the build cache,
# | fetches the maths library from the build cache,
# | and builds our framework.
$ cd /code/lean-mlir && lake clean && lake exe cache get && lake build
# | Run experiments with all the benchmarks
# | Collect the output and write all the plots and numbers
$ /code/lean-mlir/artifacts/oopsla25-bv-decide/run.sh
\end{script}

Alternatively, one can access the image from DockerHub (https://hub.docker.com/r/abdoo8080/oopsla25-bv-decide-base/) with the command \texttt{docker pull abdoo8080/oopsla25-bv-decide-base:v1}. A long-term archive of the Dockher hub image will be uploaded to Zenodo, but we support dockerhub as the primary form of access"

\section{Experiments Reproduction}

Three main scripts are involved in the reproduction of our results and plots: 
\begin{itemize}
  \item \texttt{compare.py benchmark} runs our bitblaster as well as the solver we compare against for \texttt{benchmark}. The results obtained from this run are saved in \texttt{bv-evaluation/results}. Note that the number of problems solved by \textttt{bv\_decide} might slightly change depending on the performance of the machine in relation to the timeout set for the SAT/SMT solvers.
  \item \texttt{collect.py benchmark} collects and analyzes the results obtain for \texttt{benchmark} and stores everything in \texttt{bv-evaluation/raw-data}. 
  \item \texttt{plot.py benchmark} plots the results obtained from \texttt{benchmark}'s run, including the plots presented in the paper. 
  \item \texttt{collect-stats-bv-decide.py} collects all the statistics regarding our evaluation, and in particular the numbers we describe in the paper.
\end{itemize}

\subsection{Verifying the results of \texttt{InstCombine}}

As an example, to reproduce the results of \texttt{InstCombine} using 8 threads for the experimental run and 1 repetition, the sequence of commands to run are: 
\begin{script}
$ docker load -i oopsla25-bv-decide.tar
$ docker run -it oopsla25-bv-decide
$ cd /code/lean-mlir && lake clean && lake exe cache get && lake build
# Run experiments for InstCombine
$ /code/lean-mlir/bv-evaluation/compare.py instcombine -j8 -r1
# Collect InstCombine data
$ /code/lean-mlir/bv-evaluation/collect.py instcombine
# Plot InstCombine data 
$ /code/lean-mlir/bv-evaluation/plot.py instcombine
# Extract performance numbers 
$ python3 collect-stats-bv-decide.py 
\end{script}
Figure 9 is in \texttt{plots/bv\_decide\_stacked\_perc\_instCombine.pdf} and 
Figure 7 is in \texttt{plots/cumul\_problems\_llvm\_instcombine\_solved\_data.pdf}.

\end{document}

