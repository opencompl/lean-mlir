import SSA.Projects.InstCombine.LLVM.EDSL
import SSA.Projects.InstCombine.AliveStatements
import Mathlib.Tactic
open MLIR AST

open Std (BitVec)

namespace AliveAutoGenerated

abbrev ICom.Refinement (src tgt : Com (φ:=0) Γ t) (h : Goedel.toType t = Option α := by rfl) : Prop :=
  ∀ Γv, (h ▸ src.denote Γv) ⊑ (h ▸ tgt.denote Γv)

infixr:90 (priority:=high) " ⊑ "  => ICom.Refinement

/--
- We first simplify `ICom.refinement` to see the context `Γv`.
- We `simp_peephole Γv` to simplify context accesses by variables.
- We simplify the translation overhead.
- Then we introduce variables, `cases` on the variables to eliminate the `none` cases.
- We cannot leave it at this state, since then the variables will be inaccessible.
- So, we revert the variables for the user to re-introduce them as they see fit.
-/
macro "simp_alive_peephole" : tactic =>
  `(tactic|
      (
      dsimp only [ICom.Refinement]
      intros Γv
      simp_peephole at Γv
      /- note that we need the `HVector.toPair`, `HVector.toSingle` lemmas since it's used in `InstCombine.Op.denote`
        We need `HVector.toTuple` since it's used in `MLIR.AST.mkOpExpr`. -/
      try simp only [OpDenote.denote, InstCombine.Op.denote, HVector.toPair, pairMapM, BitVec.Refinement,
        bind, Option.bind, pure,
        DerivedContext.ofContext, DerivedContext.snoc, Ctxt.snoc,
        MOp.instantiateCom, InstCombine.MTy.instantiate, ConcreteOrMVar.instantiate,
        Vector.get, HVector.toSingle, HVector.toTuple, List.nthLe]  (config := {decide := false})
      try intros v0
      try intros v1
      try intros v2
      try intros v3
      try intros v4
      try intros v5
      try cases' v0 with x0 <;> simp
        <;> try cases' v1 with x1 <;> simp
        <;> try cases' v2 with x2 <;> simp
        <;> try cases' v3 with x3 <;> simp
        <;> try cases' v4 with x4 <;> simp
        <;> try cases' v5 with x5 <;> simp
      try revert v5
      try revert v4
      try revert v3
      try revert v2
      try revert v1
      try revert v0
      )
   )

namespace OnlyReturn
def lhs (w : Nat) :=
[mlir_icom (w)| {
^bb0(%C1 : _):
  "llvm.return" (%C1) : (_) -> ()
}]

def rhs (w : Nat):=
[mlir_icom (w)| {
^bb0(%C1 : _):
  "llvm.return" (%C1) : (_) -> ()
}]

open Ctxt (Var) in
theorem refinement (w : Nat) : lhs w ⊑ rhs w := by
  rw [lhs, rhs]
  simp_alive_peephole

end OnlyReturn

-- Name:AddSub:1043
-- precondition: true
/-
  %Y = and %Z, C1
  %X = xor %Y, C1
  %LHS = add %X, 1
  %r = add %LHS, %RHS

=>
  %or = or %Z, ~C1
  %Y = and %Z, C1
  %X = xor %Y, C1
  %LHS = add %X, 1
  %r = sub %RHS, %or

-/
def AddSub_1043_src (w : Nat) :=
[mlir_icom (w)| {
^bb0(%C1 : _, %Z : _, %RHS : _):
  %v1 = "llvm.and" (%Z,%C1) : (_, _) -> (_)
  %v2 = "llvm.xor" (%v1,%C1) : (_, _) -> (_)
  %v3 = "llvm.mlir.constant" () { value = 1 : _ } :() -> (_)
  %v4 = "llvm.add" (%v2,%v3) : (_, _) -> (_)
  %v5 = "llvm.add" (%v4,%RHS) : (_, _) -> (_)
  "llvm.return" (%v5) : (_) -> ()
}]

def AddSub_1043_tgt (w : Nat):=
[mlir_icom (w)| {
^bb0(%C1 : _, %Z : _, %RHS : _):
  %v1 = "llvm.not" (%C1) : (_) -> (_)
  %v2 = "llvm.or" (%Z,%v1) : (_, _) -> (_)
  %v3 = "llvm.and" (%Z,%C1) : (_, _) -> (_)
  %v4 = "llvm.xor" (%v3,%C1) : (_, _) -> (_)
  %v5 = "llvm.mlir.constant" () { value = 1 : _ } :() -> (_)
  %v6 = "llvm.add" (%v4,%v5) : (_, _) -> (_)
  %v7 = "llvm.sub" (%RHS,%v2) : (_, _) -> (_)
  "llvm.return" (%v7) : (_) -> ()
}]


set_option pp.proofs false in
set_option pp.proofs.withType false in
open Ctxt (Var) in
theorem AddSub_1043_refinement (w : Nat) : AddSub_1043_src w ⊑ AddSub_1043_tgt w := by
  unfold AddSub_1043_src AddSub_1043_tgt
  simp_alive_peephole
  apply bitvec_AddSub_1043

end AliveAutoGenerated
