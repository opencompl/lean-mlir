
import SSA.Projects.InstCombine.LLVM.EDSL
import SSA.Projects.InstCombine.AliveStatements
import SSA.Projects.InstCombine.Refinement
import SSA.Projects.InstCombine.Tactic

open MLIR AST
open Std (BitVec)
open Ctxt (Var)

namespace AliveAutoGenerated
set_option pp.proofs false
set_option pp.proofs.withType false
set_option linter.deprecated false



-- Name:AddSub:1043
-- precondition: true
/-
  %Y = and %Z, C1
  %X = xor %Y, C1
  %LHS = add %X, 1
  %r = add %LHS, %RHS

=>
  %or = or %Z, ~C1
  %Y = and %Z, C1
  %X = xor %Y, C1
  %LHS = add %X, 1
  %r = sub %RHS, %or

-/
def alive_AddSub_1043_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%C1 : _, %Z : _, %RHS : _):
  %v1 = "llvm.and" (%Z,%C1) : (_, _) -> (_)
  %v2 = "llvm.xor" (%v1,%C1) : (_, _) -> (_)
  %v3 = "llvm.mlir.constant" () { value = 1 : _ } :() -> (_)
  %v4 = "llvm.add" (%v2,%v3) : (_, _) -> (_)
  %v5 = "llvm.add" (%v4,%RHS) : (_, _) -> (_)
  "llvm.return" (%v5) : (_) -> ()
}]

def alive_AddSub_1043_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%C1 : _, %Z : _, %RHS : _):
  %v1 = "llvm.not" (%C1) : (_) -> (_)
  %v2 = "llvm.or" (%Z,%v1) : (_, _) -> (_)
  %v3 = "llvm.and" (%Z,%C1) : (_, _) -> (_)
  %v4 = "llvm.xor" (%v3,%C1) : (_, _) -> (_)
  %v5 = "llvm.mlir.constant" () { value = 1 : _ } :() -> (_)
  %v6 = "llvm.add" (%v4,%v5) : (_, _) -> (_)
  %v7 = "llvm.sub" (%RHS,%v2) : (_, _) -> (_)
  "llvm.return" (%v7) : (_) -> ()
}]
theorem alive_AddSub_1043  (w : Nat)   : alive_AddSub_1043_src w  ⊑ alive_AddSub_1043_tgt w  := by
  unfold alive_AddSub_1043_src alive_AddSub_1043_tgt
  simp_alive_peephole
  apply bitvec_AddSub_1043


-- Name:AddSub:1152
-- precondition: true
/-
  %r = add i1 %x, %y

=>
  %r = xor %x, %y

-/
def alive_AddSub_1152_src   :=
[alive_icom ()| {
^bb0(%y : i1, %x : i1):
  %v1 = "llvm.add" (%x,%y) : (i1, i1) -> (i1)
  "llvm.return" (%v1) : (i1) -> ()
}]

def alive_AddSub_1152_tgt  :=
[alive_icom ()| {
^bb0(%y : i1, %x : i1):
  %v1 = "llvm.xor" (%x,%y) : (i1, i1) -> (i1)
  "llvm.return" (%v1) : (i1) -> ()
}]
theorem alive_AddSub_1152   : alive_AddSub_1152_src ⊑ alive_AddSub_1152_tgt := by
  unfold alive_AddSub_1152_src alive_AddSub_1152_tgt
  simp_alive_peephole
  apply bitvec_AddSub_1152


-- Name:AddSub:1156
-- precondition: true
/-
  %a = add %b, %b

=>
  %a = shl %b, 1

-/
def alive_AddSub_1156_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%b : _):
  %v1 = "llvm.add" (%b,%b) : (_, _) -> (_)
  "llvm.return" (%v1) : (_) -> ()
}]

def alive_AddSub_1156_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%b : _):
  %v1 = "llvm.mlir.constant" () { value = 1 : _ } :() -> (_)
  %v2 = "llvm.shl" (%b,%v1) : (_, _) -> (_)
  "llvm.return" (%v2) : (_) -> ()
}]
theorem alive_AddSub_1156  (w : Nat)   : alive_AddSub_1156_src w  ⊑ alive_AddSub_1156_tgt w  := by
  unfold alive_AddSub_1156_src alive_AddSub_1156_tgt
  simp_alive_peephole
  sorry --apply bitvec_AddSub_1156


-- Name:AddSub:1164
-- precondition: true
/-
  %na = sub 0, %a
  %c = add %na, %b

=>
  %na = sub 0, %a
  %c = sub %b, %a

-/
def alive_AddSub_1164_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v2 = "llvm.sub" (%v1,%a) : (_, _) -> (_)
  %v3 = "llvm.add" (%v2,%b) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]

def alive_AddSub_1164_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v2 = "llvm.sub" (%v1,%a) : (_, _) -> (_)
  %v3 = "llvm.sub" (%b,%a) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]
theorem alive_AddSub_1164  (w : Nat)   : alive_AddSub_1164_src w  ⊑ alive_AddSub_1164_tgt w  := by
  unfold alive_AddSub_1164_src alive_AddSub_1164_tgt
  simp_alive_peephole
  apply bitvec_AddSub_1164


-- Name:AddSub:1165
-- precondition: true
/-
  %na = sub 0, %a
  %nb = sub 0, %b
  %c = add %na, %nb

=>
  %ab = add %a, %b
  %na = sub 0, %a
  %nb = sub 0, %b
  %c = sub 0, %ab

-/
def alive_AddSub_1165_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v2 = "llvm.sub" (%v1,%a) : (_, _) -> (_)
  %v3 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v4 = "llvm.sub" (%v3,%b) : (_, _) -> (_)
  %v5 = "llvm.add" (%v2,%v4) : (_, _) -> (_)
  "llvm.return" (%v5) : (_) -> ()
}]

def alive_AddSub_1165_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.add" (%a,%b) : (_, _) -> (_)
  %v2 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v3 = "llvm.sub" (%v2,%a) : (_, _) -> (_)
  %v4 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v5 = "llvm.sub" (%v4,%b) : (_, _) -> (_)
  %v6 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v7 = "llvm.sub" (%v6,%v1) : (_, _) -> (_)
  "llvm.return" (%v7) : (_) -> ()
}]
theorem alive_AddSub_1165  (w : Nat)   : alive_AddSub_1165_src w  ⊑ alive_AddSub_1165_tgt w  := by
  unfold alive_AddSub_1165_src alive_AddSub_1165_tgt
  simp_alive_peephole
  apply bitvec_AddSub_1165


-- Name:AddSub:1176
-- precondition: true
/-
  %nb = sub 0, %b
  %c = add %a, %nb

=>
  %nb = sub 0, %b
  %c = sub %a, %b

-/
def alive_AddSub_1176_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v2 = "llvm.sub" (%v1,%b) : (_, _) -> (_)
  %v3 = "llvm.add" (%a,%v2) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]

def alive_AddSub_1176_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v2 = "llvm.sub" (%v1,%b) : (_, _) -> (_)
  %v3 = "llvm.sub" (%a,%b) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]
theorem alive_AddSub_1176  (w : Nat)   : alive_AddSub_1176_src w  ⊑ alive_AddSub_1176_tgt w  := by
  unfold alive_AddSub_1176_src alive_AddSub_1176_tgt
  simp_alive_peephole
  apply bitvec_AddSub_1176


-- Name:AddSub:1202
-- precondition: true
/-
  %nx = xor %x, -1
  %r = add %nx, C

=>
  %nx = xor %x, -1
  %r = sub (C - 1), %x

-/
def alive_AddSub_1202_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%x : _, %C : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%x,%v1) : (_, _) -> (_)
  %v3 = "llvm.add" (%v2,%C) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]

def alive_AddSub_1202_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%x : _, %C : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%x,%v1) : (_, _) -> (_)
  %v3 = "llvm.mlir.constant" () { value = 1 : _ } :() -> (_)
  %v4 = "llvm.sub" (%C,%v3) : (_, _) -> (_)
  %v5 = "llvm.sub" (%v4,%x) : (_, _) -> (_)
  "llvm.return" (%v5) : (_) -> ()
}]
theorem alive_AddSub_1202  (w : Nat)   : alive_AddSub_1202_src w  ⊑ alive_AddSub_1202_tgt w  := by
  unfold alive_AddSub_1202_src alive_AddSub_1202_tgt
  simp_alive_peephole
  apply bitvec_AddSub_1202


-- Name:AddSub:1295
-- precondition: true
/-
  %aab = and %a, %b
  %aob = xor %a, %b
  %c = add %aab, %aob

=>
  %aab = and %a, %b
  %aob = xor %a, %b
  %c = or %a, %b

-/
def alive_AddSub_1295_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.and" (%a,%b) : (_, _) -> (_)
  %v2 = "llvm.xor" (%a,%b) : (_, _) -> (_)
  %v3 = "llvm.add" (%v1,%v2) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]

def alive_AddSub_1295_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.and" (%a,%b) : (_, _) -> (_)
  %v2 = "llvm.xor" (%a,%b) : (_, _) -> (_)
  %v3 = "llvm.or" (%a,%b) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]
theorem alive_AddSub_1295  (w : Nat)   : alive_AddSub_1295_src w  ⊑ alive_AddSub_1295_tgt w  := by
  unfold alive_AddSub_1295_src alive_AddSub_1295_tgt
  simp_alive_peephole
  apply bitvec_AddSub_1295


-- Name:AddSub:1309
-- precondition: true
/-
  %lhs = and %a, %b
  %rhs = or %a, %b
  %c = add %lhs, %rhs

=>
  %lhs = and %a, %b
  %rhs = or %a, %b
  %c = add %a, %b

-/
def alive_AddSub_1309_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.and" (%a,%b) : (_, _) -> (_)
  %v2 = "llvm.or" (%a,%b) : (_, _) -> (_)
  %v3 = "llvm.add" (%v1,%v2) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]

def alive_AddSub_1309_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.and" (%a,%b) : (_, _) -> (_)
  %v2 = "llvm.or" (%a,%b) : (_, _) -> (_)
  %v3 = "llvm.add" (%a,%b) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]
theorem alive_AddSub_1309  (w : Nat)   : alive_AddSub_1309_src w  ⊑ alive_AddSub_1309_tgt w  := by
  unfold alive_AddSub_1309_src alive_AddSub_1309_tgt
  simp_alive_peephole
  apply bitvec_AddSub_1309


-- Name:AddSub:1539
-- precondition: true
/-
  %na = sub 0, %a
  %r = sub %x, %na

=>
  %na = sub 0, %a
  %r = add %x, %a

-/
def alive_AddSub_1539_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%a : _, %x : _):
  %v1 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v2 = "llvm.sub" (%v1,%a) : (_, _) -> (_)
  %v3 = "llvm.sub" (%x,%v2) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]

def alive_AddSub_1539_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%a : _, %x : _):
  %v1 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v2 = "llvm.sub" (%v1,%a) : (_, _) -> (_)
  %v3 = "llvm.add" (%x,%a) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]
theorem alive_AddSub_1539  (w : Nat)   : alive_AddSub_1539_src w  ⊑ alive_AddSub_1539_tgt w  := by
  unfold alive_AddSub_1539_src alive_AddSub_1539_tgt
  simp_alive_peephole
  apply bitvec_AddSub_1539


-- Name:AddSub:1539-2
-- precondition: true
/-
  %r = sub %x, C

=>
  %r = add %x, -C

-/
def alive_AddSub_1539_2_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%x : _, %C : _):
  %v1 = "llvm.sub" (%x,%C) : (_, _) -> (_)
  "llvm.return" (%v1) : (_) -> ()
}]

def alive_AddSub_1539_2_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%x : _, %C : _):
  %v1 = "llvm.neg" (%C) : (_) -> (_)
  %v2 = "llvm.add" (%x,%v1) : (_, _) -> (_)
  "llvm.return" (%v2) : (_) -> ()
}]
theorem alive_AddSub_1539_2  (w : Nat)   : alive_AddSub_1539_2_src w  ⊑ alive_AddSub_1539_2_tgt w  := by
  unfold alive_AddSub_1539_2_src alive_AddSub_1539_2_tgt
  simp_alive_peephole
  apply bitvec_AddSub_1539_2


-- Name:AddSub:1556
-- precondition: true
/-
  %r = sub i1 %x, %y

=>
  %r = xor %x, %y

-/
def alive_AddSub_1556_src   :=
[alive_icom ()| {
^bb0(%y : i1, %x : i1):
  %v1 = "llvm.sub" (%x,%y) : (i1, i1) -> (i1)
  "llvm.return" (%v1) : (i1) -> ()
}]

def alive_AddSub_1556_tgt  :=
[alive_icom ()| {
^bb0(%y : i1, %x : i1):
  %v1 = "llvm.xor" (%x,%y) : (i1, i1) -> (i1)
  "llvm.return" (%v1) : (i1) -> ()
}]
theorem alive_AddSub_1556   : alive_AddSub_1556_src ⊑ alive_AddSub_1556_tgt := by
  unfold alive_AddSub_1556_src alive_AddSub_1556_tgt
  simp_alive_peephole
  apply bitvec_AddSub_1556


-- Name:AddSub:1560
-- precondition: true
/-
  %r = sub -1, %a

=>
  %r = xor %a, -1

-/
def alive_AddSub_1560_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%a : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.sub" (%v1,%a) : (_, _) -> (_)
  "llvm.return" (%v2) : (_) -> ()
}]

def alive_AddSub_1560_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%a : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%a,%v1) : (_, _) -> (_)
  "llvm.return" (%v2) : (_) -> ()
}]
theorem alive_AddSub_1560  (w : Nat)   : alive_AddSub_1560_src w  ⊑ alive_AddSub_1560_tgt w  := by
  unfold alive_AddSub_1560_src alive_AddSub_1560_tgt
  simp_alive_peephole
  apply bitvec_AddSub_1560


-- Name:AddSub:1564
-- precondition: true
/-
  %nx = xor %x, -1
  %r = sub C, %nx

=>
  %nx = xor %x, -1
  %r = add %x, (C + 1)

-/
def alive_AddSub_1564_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%x : _, %C : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%x,%v1) : (_, _) -> (_)
  %v3 = "llvm.sub" (%C,%v2) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]

def alive_AddSub_1564_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%x : _, %C : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%x,%v1) : (_, _) -> (_)
  %v3 = "llvm.mlir.constant" () { value = 1 : _ } :() -> (_)
  %v4 = "llvm.add" (%C,%v3) : (_, _) -> (_)
  %v5 = "llvm.add" (%x,%v4) : (_, _) -> (_)
  "llvm.return" (%v5) : (_) -> ()
}]
theorem alive_AddSub_1564  (w : Nat)   : alive_AddSub_1564_src w  ⊑ alive_AddSub_1564_tgt w  := by
  unfold alive_AddSub_1564_src alive_AddSub_1564_tgt
  simp_alive_peephole
  apply bitvec_AddSub_1564


-- Name:AddSub:1574
-- precondition: true
/-
  %rhs = add %X, C2
  %r = sub C, %rhs

=>
  %rhs = add %X, C2
  %r = sub (C - C2), %X

-/
def alive_AddSub_1574_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%X : _, %C : _, %C2 : _):
  %v1 = "llvm.add" (%X,%C2) : (_, _) -> (_)
  %v2 = "llvm.sub" (%C,%v1) : (_, _) -> (_)
  "llvm.return" (%v2) : (_) -> ()
}]

def alive_AddSub_1574_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%X : _, %C : _, %C2 : _):
  %v1 = "llvm.add" (%X,%C2) : (_, _) -> (_)
  %v2 = "llvm.sub" (%C,%C2) : (_, _) -> (_)
  %v3 = "llvm.sub" (%v2,%X) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]
theorem alive_AddSub_1574  (w : Nat)   : alive_AddSub_1574_src w  ⊑ alive_AddSub_1574_tgt w  := by
  unfold alive_AddSub_1574_src alive_AddSub_1574_tgt
  simp_alive_peephole
  apply bitvec_AddSub_1574


-- Name:AddSub:1614
-- precondition: true
/-
  %Op1 = add %X, %Y
  %r = sub %X, %Op1

=>
  %Op1 = add %X, %Y
  %r = sub 0, %Y

-/
def alive_AddSub_1614_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%Y : _, %X : _):
  %v1 = "llvm.add" (%X,%Y) : (_, _) -> (_)
  %v2 = "llvm.sub" (%X,%v1) : (_, _) -> (_)
  "llvm.return" (%v2) : (_) -> ()
}]

def alive_AddSub_1614_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%Y : _, %X : _):
  %v1 = "llvm.add" (%X,%Y) : (_, _) -> (_)
  %v2 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v3 = "llvm.sub" (%v2,%Y) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]
theorem alive_AddSub_1614  (w : Nat)   : alive_AddSub_1614_src w  ⊑ alive_AddSub_1614_tgt w  := by
  unfold alive_AddSub_1614_src alive_AddSub_1614_tgt
  simp_alive_peephole
  sorry --apply bitvec_AddSub_1614


-- Name:AddSub:1619
-- precondition: true
/-
  %Op0 = sub %X, %Y
  %r = sub %Op0, %X

=>
  %Op0 = sub %X, %Y
  %r = sub 0, %Y

-/
def alive_AddSub_1619_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%Y : _, %X : _):
  %v1 = "llvm.sub" (%X,%Y) : (_, _) -> (_)
  %v2 = "llvm.sub" (%v1,%X) : (_, _) -> (_)
  "llvm.return" (%v2) : (_) -> ()
}]

def alive_AddSub_1619_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%Y : _, %X : _):
  %v1 = "llvm.sub" (%X,%Y) : (_, _) -> (_)
  %v2 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v3 = "llvm.sub" (%v2,%Y) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]
theorem alive_AddSub_1619  (w : Nat)   : alive_AddSub_1619_src w  ⊑ alive_AddSub_1619_tgt w  := by
  unfold alive_AddSub_1619_src alive_AddSub_1619_tgt
  simp_alive_peephole
  sorry --apply bitvec_AddSub_1619


-- Name:AddSub:1624
-- precondition: true
/-
  %Op0 = or %A, %B
  %Op1 = xor %A, %B
  %r = sub %Op0, %Op1

=>
  %Op0 = or %A, %B
  %Op1 = xor %A, %B
  %r = and %A, %B

-/
def alive_AddSub_1624_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.or" (%A,%B) : (_, _) -> (_)
  %v2 = "llvm.xor" (%A,%B) : (_, _) -> (_)
  %v3 = "llvm.sub" (%v1,%v2) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]

def alive_AddSub_1624_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.or" (%A,%B) : (_, _) -> (_)
  %v2 = "llvm.xor" (%A,%B) : (_, _) -> (_)
  %v3 = "llvm.and" (%A,%B) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]
theorem alive_AddSub_1624  (w : Nat)   : alive_AddSub_1624_src w  ⊑ alive_AddSub_1624_tgt w  := by
  unfold alive_AddSub_1624_src alive_AddSub_1624_tgt
  simp_alive_peephole
  apply bitvec_AddSub_1624


-- Name:AndOrXor:135
-- precondition: true
/-
  %op = xor %X, C1
  %r = and %op, C2

=>
  %a = and %X, C2
  %op = xor %X, C1
  %r = xor %a, (C1 & C2)

-/
def alive_AndOrXor_135_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%X : _, %C1 : _, %C2 : _):
  %v1 = "llvm.xor" (%X,%C1) : (_, _) -> (_)
  %v2 = "llvm.and" (%v1,%C2) : (_, _) -> (_)
  "llvm.return" (%v2) : (_) -> ()
}]

def alive_AndOrXor_135_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%X : _, %C1 : _, %C2 : _):
  %v1 = "llvm.and" (%X,%C2) : (_, _) -> (_)
  %v2 = "llvm.xor" (%X,%C1) : (_, _) -> (_)
  %v3 = "llvm.and" (%C1,%C2) : (_, _) -> (_)
  %v4 = "llvm.xor" (%v1,%v3) : (_, _) -> (_)
  "llvm.return" (%v4) : (_) -> ()
}]
theorem alive_AndOrXor_135  (w : Nat)   : alive_AndOrXor_135_src w  ⊑ alive_AndOrXor_135_tgt w  := by
  unfold alive_AndOrXor_135_src alive_AndOrXor_135_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_135


-- Name:AndOrXor:144
-- precondition: true
/-
  %op = or %X, C1
  %r = and %op, C2

=>
  %o = or %X, (C1 & C2)
  %op = or %X, C1
  %r = and %o, C2

-/
def alive_AndOrXor_144_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%X : _, %C1 : _, %C2 : _):
  %v1 = "llvm.or" (%X,%C1) : (_, _) -> (_)
  %v2 = "llvm.and" (%v1,%C2) : (_, _) -> (_)
  "llvm.return" (%v2) : (_) -> ()
}]

def alive_AndOrXor_144_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%X : _, %C1 : _, %C2 : _):
  %v1 = "llvm.and" (%C1,%C2) : (_, _) -> (_)
  %v2 = "llvm.or" (%X,%v1) : (_, _) -> (_)
  %v3 = "llvm.or" (%X,%C1) : (_, _) -> (_)
  %v4 = "llvm.and" (%v2,%C2) : (_, _) -> (_)
  "llvm.return" (%v4) : (_) -> ()
}]
theorem alive_AndOrXor_144  (w : Nat)   : alive_AndOrXor_144_src w  ⊑ alive_AndOrXor_144_tgt w  := by
  unfold alive_AndOrXor_144_src alive_AndOrXor_144_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_144


-- Name:AndOrXor:698
-- precondition: true
/-
  %a1 = and %a, %b
  %a2 = and %a, %d
  %op0 = icmp eq %a1, 0
  %op1 = icmp eq %a2, 0
  %r = and %op0, %op1

=>
  %or = or %b, %d
  %a3 = and %a, %or
  %a1 = and %a, %b
  %a2 = and %a, %d
  %op0 = icmp eq %a1, 0
  %op1 = icmp eq %a2, 0
  %r = icmp eq %a3, 0

-/
-- MANUAL FIX: the translation script inferred some of the resulting types to be `i1`
-- where they should be the meta-variable `_` (https://github.com/opencompl/ssa/issues/169)
def alive_AndOrXor_698_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _, %d : _):
  %v1 = "llvm.and" (%a,%b) : (_, _) -> (_)
  %v2 = "llvm.and" (%a,%d) : (_, _) -> (_)
  %v3 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v4 = "llvm.icmp.eq" (%v1,%v3) : (_, _) -> (i1)
  %v5 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v6 = "llvm.icmp.eq" (%v2,%v5) : (_, _) -> (i1)
  %v7 = "llvm.and" (%v4,%v6) : (i1, i1) -> (i1)
  "llvm.return" (%v7) : (i1) -> ()
}]

def alive_AndOrXor_698_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _, %d : _):
  %v1 = "llvm.or" (%b,%d) : (_, _) -> (_)
  %v2 = "llvm.and" (%a,%v1) : (_, _) -> (_)
  %v3 = "llvm.and" (%a,%b) : (_, _) -> (_)
  %v4 = "llvm.and" (%a,%d) : (_, _) -> (_)
  %v5 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v6 = "llvm.icmp.eq" (%v3,%v5) : (_, _) -> (i1)
  %v7 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v8 = "llvm.icmp.eq" (%v4,%v7) : (_, _) -> (_)
  %v9 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v10 = "llvm.icmp.eq" (%v2,%v9) : (_, _) -> (i1)
  "llvm.return" (%v10) : (i1) -> ()
}]
theorem alive_AndOrXor_698  (w : Nat)   : alive_AndOrXor_698_src w  ⊑ alive_AndOrXor_698_tgt w  := by
  unfold alive_AndOrXor_698_src alive_AndOrXor_698_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_698


-- Name:AndOrXor:709
-- precondition: true
/-
  %a1 = and %a, %b
  %a2 = and %a, %d
  %op0 = icmp eq %a1, %b
  %op1 = icmp eq %a2, %d
  %r = and %op0, %op1

=>
  %or = or %b, %d
  %a3 = and %a, %or
  %a1 = and %a, %b
  %a2 = and %a, %d
  %op0 = icmp eq %a1, %b
  %op1 = icmp eq %a2, %d
  %r = icmp eq %a3, %or

-/
def alive_AndOrXor_709_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _, %d : _):
  %v1 = "llvm.and" (%a,%b) : (_, _) -> (i1)
  %v2 = "llvm.and" (%a,%d) : (_, _) -> (i1)
  %v3 = "llvm.icmp.eq" (%v1,%b) : (_, _) -> (i1)
  %v4 = "llvm.icmp.eq" (%v2,%d) : (_, _) -> (i1)
  %v5 = "llvm.and" (%v3,%v4) : (i1, i1) -> (i1)
  "llvm.return" (%v5) : (i1) -> ()
}]

def alive_AndOrXor_709_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _, %d : _):
  %v1 = "llvm.or" (%b,%d) : (_, _) -> (i1)
  %v2 = "llvm.and" (%a,%v1) : (_, _) -> (i1)
  %v3 = "llvm.and" (%a,%b) : (_, _) -> (_)
  %v4 = "llvm.and" (%a,%d) : (_, _) -> (_)
  %v5 = "llvm.icmp.eq" (%v3,%b) : (_, _) -> (i1)
  %v6 = "llvm.icmp.eq" (%v4,%d) : (_, _) -> (i1)
  %v7 = "llvm.icmp.eq" (%v2,%v1) : (_, _) -> (i1)
  "llvm.return" (%v7) : (i1) -> ()
}]
theorem alive_AndOrXor_709  (w : Nat)   : alive_AndOrXor_709_src w  ⊑ alive_AndOrXor_709_tgt w  := by
  unfold alive_AndOrXor_709_src alive_AndOrXor_709_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_709


-- Name:AndOrXor:716
-- precondition: true
/-
  %a1 = and %a, %b
  %a2 = and %a, %d
  %op0 = icmp eq %a1, %a
  %op1 = icmp eq %a2, %a
  %r = and %op0, %op1

=>
  %a4 = and %b, %d
  %a3 = and %a, %a4
  %a1 = and %a, %b
  %a2 = and %a, %d
  %op0 = icmp eq %a1, %a
  %op1 = icmp eq %a2, %a
  %r = icmp eq %a3, %a

-/
def alive_AndOrXor_716_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _, %d : _):
  %v1 = "llvm.and" (%a,%b) : (_, _) -> (i1)
  %v2 = "llvm.and" (%a,%d) : (_, _) -> (i1)
  %v3 = "llvm.icmp.eq" (%v1,%a) : (_, _) -> (i1)
  %v4 = "llvm.icmp.eq" (%v2,%a) : (_, _) -> (i1)
  %v5 = "llvm.and" (%v3,%v4) : (i1, i1) -> (i1)
  "llvm.return" (%v5) : (i1) -> ()
}]

def alive_AndOrXor_716_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _, %d : _):
  %v1 = "llvm.and" (%b,%d) : (_, _) -> (i1)
  %v2 = "llvm.and" (%a,%v1) : (_, _) -> (i1)
  %v3 = "llvm.and" (%a,%b) : (_, _) -> (_)
  %v4 = "llvm.and" (%a,%d) : (_, _) -> (_)
  %v5 = "llvm.icmp.eq" (%v3,%a) : (_, _) -> (i1)
  %v6 = "llvm.icmp.eq" (%v4,%a) : (_, _) -> (i1)
  %v7 = "llvm.icmp.eq" (%v2,%a) : (_, _) -> (i1)
  "llvm.return" (%v7) : (i1) -> ()
}]
theorem alive_AndOrXor_716  (w : Nat)   : alive_AndOrXor_716_src w  ⊑ alive_AndOrXor_716_tgt w  := by
  unfold alive_AndOrXor_716_src alive_AndOrXor_716_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_716


-- Name:AndOrXor:794
-- precondition: true
/-
  %op0 = icmp sgt %a, %b
  %op1 = icmp ne %a, %b
  %r = and %op0, %op1

=>
  %op0 = icmp sgt %a, %b
  %op1 = icmp ne %a, %b
  %r = icmp sgt %a, %b

-/
def alive_AndOrXor_794_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.icmp.sgt" (%a,%b) : (_, _) -> (i1)
  %v2 = "llvm.icmp.ne" (%a,%b) : (_, _) -> (i1)
  %v3 = "llvm.and" (%v1,%v2) : (i1, i1) -> (i1)
  "llvm.return" (%v3) : (i1) -> ()
}]

def alive_AndOrXor_794_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.icmp.sgt" (%a,%b) : (_, _) -> (i1)
  %v2 = "llvm.icmp.ne" (%a,%b) : (_, _) -> (i1)
  %v3 = "llvm.icmp.sgt" (%a,%b) : (_, _) -> (i1)
  "llvm.return" (%v3) : (i1) -> ()
}]
theorem alive_AndOrXor_794  (w : Nat)   : alive_AndOrXor_794_src w  ⊑ alive_AndOrXor_794_tgt w  := by
  unfold alive_AndOrXor_794_src alive_AndOrXor_794_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_794


-- Name:AndOrXor:827
-- precondition: true
/-
  %op0 = icmp eq %a, 0
  %op1 = icmp eq %b, 0
  %r = and %op0, %op1

=>
  %o = or %a, %b
  %op0 = icmp eq %a, 0
  %op1 = icmp eq %b, 0
  %r = icmp eq %o, 0

-/
-- MANUAL FIX (https://github.com/opencompl/ssa/issues/169)
def alive_AndOrXor_827_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v2 = "llvm.icmp.eq" (%a,%v1) : (_, _) -> (i1)
  %v3 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v4 = "llvm.icmp.eq" (%b,%v3) : (_, _) -> (i1)
  %v5 = "llvm.and" (%v2,%v4) : (i1, i1) -> (i1)
  "llvm.return" (%v5) : (i1) -> ()
}]

def alive_AndOrXor_827_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.or" (%a,%b) : (_, _) -> (_)
  %v2 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v3 = "llvm.icmp.eq" (%a,%v2) : (_, _) -> (i1)
  %v4 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v5 = "llvm.icmp.eq" (%b,%v4) : (_, _) -> (i1)
  %v6 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v7 = "llvm.icmp.eq" (%v1,%v6) : (_, _) -> (i1)
  "llvm.return" (%v7) : (i1) -> ()
}]
theorem alive_AndOrXor_827  (w : Nat)   : alive_AndOrXor_827_src w  ⊑ alive_AndOrXor_827_tgt w  := by
  unfold alive_AndOrXor_827_src alive_AndOrXor_827_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_827


-- Name:AndOrXor:887-2
-- precondition: true
/-
  %op0 = icmp eq %a, C1
  %op1 = icmp ne %a, C1
  %r = and %op0, %op1

=>
  %op0 = icmp eq %a, C1
  %op1 = icmp ne %a, C1
  %r = false

-/
def alive_AndOrXor_887_2_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%a : _, %C1 : _):
  %v1 = "llvm.icmp.eq" (%a,%C1) : (_, _) -> (i1)
  %v2 = "llvm.icmp.ne" (%a,%C1) : (_, _) -> (i1)
  %v3 = "llvm.and" (%v1,%v2) : (i1, i1) -> (i1)
  "llvm.return" (%v3) : (i1) -> ()
}]

def alive_AndOrXor_887_2_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%a : _, %C1 : _):
  %v1 = "llvm.icmp.eq" (%a,%C1) : (_, _) -> (i1)
  %v2 = "llvm.icmp.ne" (%a,%C1) : (_, _) -> (i1)
  %v3 = "llvm.mlir.constant" () { value = 0 : i1 } :() -> (i1)
  %v4 = "llvm.copy" (%v3) : (i1) -> (i1)
  "llvm.return" (%v4) : (i1) -> ()
}]
theorem alive_AndOrXor_887_2  (w : Nat)   : alive_AndOrXor_887_2_src w  ⊑ alive_AndOrXor_887_2_tgt w  := by
  unfold alive_AndOrXor_887_2_src alive_AndOrXor_887_2_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_887_2


-- Name:AndOrXor:1230  ~A & ~B -> ~(A | B)
-- precondition: true
/-
  %op0 = xor %notOp0, -1
  %op1 = xor %notOp1, -1
  %r = and %op0, %op1

=>
  %or = or %notOp0, %notOp1
  %op0 = xor %notOp0, -1
  %op1 = xor %notOp1, -1
  %r = xor %or, -1

-/
def alive_AndOrXor_1230__A__B___A__B_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%notOp0 : _, %notOp1 : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%notOp0,%v1) : (_, _) -> (_)
  %v3 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v4 = "llvm.xor" (%notOp1,%v3) : (_, _) -> (_)
  %v5 = "llvm.and" (%v2,%v4) : (_, _) -> (_)
  "llvm.return" (%v5) : (_) -> ()
}]

def alive_AndOrXor_1230__A__B___A__B_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%notOp0 : _, %notOp1 : _):
  %v1 = "llvm.or" (%notOp0,%notOp1) : (_, _) -> (_)
  %v2 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v3 = "llvm.xor" (%notOp0,%v2) : (_, _) -> (_)
  %v4 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v5 = "llvm.xor" (%notOp1,%v4) : (_, _) -> (_)
  %v6 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v7 = "llvm.xor" (%v1,%v6) : (_, _) -> (_)
  "llvm.return" (%v7) : (_) -> ()
}]
theorem alive_AndOrXor_1230__A__B___A__B  (w : Nat)   : alive_AndOrXor_1230__A__B___A__B_src w  ⊑ alive_AndOrXor_1230__A__B___A__B_tgt w  := by
  unfold alive_AndOrXor_1230__A__B___A__B_src alive_AndOrXor_1230__A__B___A__B_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_1230__A__B___A__B


-- Name:AndOrXor:1241 (A|B) & ~(A&B) => A^B
-- precondition: true
/-
  %op0 = or %A, %B
  %notOp1 = and %A, %B
  %op1 = xor %notOp1, -1
  %r = and %op0, %op1

=>
  %op0 = or %A, %B
  %notOp1 = and %A, %B
  %op1 = xor %notOp1, -1
  %r = xor %A, %B

-/
def alive_AndOrXor_1241_AB__AB__AB_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.or" (%A,%B) : (_, _) -> (_)
  %v2 = "llvm.and" (%A,%B) : (_, _) -> (_)
  %v3 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v4 = "llvm.xor" (%v2,%v3) : (_, _) -> (_)
  %v5 = "llvm.and" (%v1,%v4) : (_, _) -> (_)
  "llvm.return" (%v5) : (_) -> ()
}]

def alive_AndOrXor_1241_AB__AB__AB_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.or" (%A,%B) : (_, _) -> (_)
  %v2 = "llvm.and" (%A,%B) : (_, _) -> (_)
  %v3 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v4 = "llvm.xor" (%v2,%v3) : (_, _) -> (_)
  %v5 = "llvm.xor" (%A,%B) : (_, _) -> (_)
  "llvm.return" (%v5) : (_) -> ()
}]
theorem alive_AndOrXor_1241_AB__AB__AB  (w : Nat)   : alive_AndOrXor_1241_AB__AB__AB_src w  ⊑ alive_AndOrXor_1241_AB__AB__AB_tgt w  := by
  unfold alive_AndOrXor_1241_AB__AB__AB_src alive_AndOrXor_1241_AB__AB__AB_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_1241_AB__AB__AB


-- Name:AndOrXor:1247 ~(A&B) & (A|B) => A^B
-- precondition: true
/-
  %notOp0 = and %A, %B
  %op0 = xor %notOp0, -1
  %op1 = or %A, %B
  %r = and %op0, %op1

=>
  %notOp0 = and %A, %B
  %op0 = xor %notOp0, -1
  %op1 = or %A, %B
  %r = xor %A, %B

-/
def alive_AndOrXor_1247_AB__AB__AB_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.and" (%A,%B) : (_, _) -> (_)
  %v2 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v3 = "llvm.xor" (%v1,%v2) : (_, _) -> (_)
  %v4 = "llvm.or" (%A,%B) : (_, _) -> (_)
  %v5 = "llvm.and" (%v3,%v4) : (_, _) -> (_)
  "llvm.return" (%v5) : (_) -> ()
}]

def alive_AndOrXor_1247_AB__AB__AB_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.and" (%A,%B) : (_, _) -> (_)
  %v2 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v3 = "llvm.xor" (%v1,%v2) : (_, _) -> (_)
  %v4 = "llvm.or" (%A,%B) : (_, _) -> (_)
  %v5 = "llvm.xor" (%A,%B) : (_, _) -> (_)
  "llvm.return" (%v5) : (_) -> ()
}]
theorem alive_AndOrXor_1247_AB__AB__AB  (w : Nat)   : alive_AndOrXor_1247_AB__AB__AB_src w  ⊑ alive_AndOrXor_1247_AB__AB__AB_tgt w  := by
  unfold alive_AndOrXor_1247_AB__AB__AB_src alive_AndOrXor_1247_AB__AB__AB_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_1247_AB__AB__AB


-- Name:AndOrXor:1253 A & (A^B) -> A & ~B
-- precondition: true
/-
  %op0 = xor %A, %B
  %r = and %op0, %A

=>
  %notB = xor %B, -1
  %op0 = xor %A, %B
  %r = and %A, %notB

-/
def alive_AndOrXor_1253_A__AB___A__B_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.xor" (%A,%B) : (_, _) -> (_)
  %v2 = "llvm.and" (%v1,%A) : (_, _) -> (_)
  "llvm.return" (%v2) : (_) -> ()
}]

def alive_AndOrXor_1253_A__AB___A__B_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%B,%v1) : (_, _) -> (_)
  %v3 = "llvm.xor" (%A,%B) : (_, _) -> (_)
  %v4 = "llvm.and" (%A,%v2) : (_, _) -> (_)
  "llvm.return" (%v4) : (_) -> ()
}]
theorem alive_AndOrXor_1253_A__AB___A__B  (w : Nat)   : alive_AndOrXor_1253_A__AB___A__B_src w  ⊑ alive_AndOrXor_1253_A__AB___A__B_tgt w  := by
  unfold alive_AndOrXor_1253_A__AB___A__B_src alive_AndOrXor_1253_A__AB___A__B_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_1253_A__AB___A__B


-- Name:AndOrXor:1280 (~A|B)&A -> A&B
-- precondition: true
/-
  %nA = xor %A, -1
  %op0 = or %nA, %B
  %r = and %op0, %A

=>
  %nA = xor %A, -1
  %op0 = or %nA, %B
  %r = and %A, %B

-/
def alive_AndOrXor_1280_ABA___AB_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%A,%v1) : (_, _) -> (_)
  %v3 = "llvm.or" (%v2,%B) : (_, _) -> (_)
  %v4 = "llvm.and" (%v3,%A) : (_, _) -> (_)
  "llvm.return" (%v4) : (_) -> ()
}]

def alive_AndOrXor_1280_ABA___AB_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%A,%v1) : (_, _) -> (_)
  %v3 = "llvm.or" (%v2,%B) : (_, _) -> (_)
  %v4 = "llvm.and" (%A,%B) : (_, _) -> (_)
  "llvm.return" (%v4) : (_) -> ()
}]
theorem alive_AndOrXor_1280_ABA___AB  (w : Nat)   : alive_AndOrXor_1280_ABA___AB_src w  ⊑ alive_AndOrXor_1280_ABA___AB_tgt w  := by
  unfold alive_AndOrXor_1280_ABA___AB_src alive_AndOrXor_1280_ABA___AB_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_1280_ABA___AB


-- Name:AndOrXor:1288 (A ^ B) & ((B ^ C) ^ A) -> (A ^ B) & ~C
-- precondition: true
/-
  %op0 = xor %A, %B
  %x = xor %B, %C
  %op1 = xor %x, %A
  %r = and %op0, %op1

=>
  %op0 = xor %A, %B
  %negC = xor %C, -1
  %x = xor %B, %C
  %op1 = xor %x, %A
  %r = and %op0, %negC

-/
def alive_AndOrXor_1288_A__B__B__C__A___A__B__C_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%A : _, %C : _, %B : _):
  %v1 = "llvm.xor" (%A,%B) : (_, _) -> (_)
  %v2 = "llvm.xor" (%B,%C) : (_, _) -> (_)
  %v3 = "llvm.xor" (%v2,%A) : (_, _) -> (_)
  %v4 = "llvm.and" (%v1,%v3) : (_, _) -> (_)
  "llvm.return" (%v4) : (_) -> ()
}]

def alive_AndOrXor_1288_A__B__B__C__A___A__B__C_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%A : _, %C : _, %B : _):
  %v1 = "llvm.xor" (%A,%B) : (_, _) -> (_)
  %v2 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v3 = "llvm.xor" (%C,%v2) : (_, _) -> (_)
  %v4 = "llvm.xor" (%B,%C) : (_, _) -> (_)
  %v5 = "llvm.xor" (%v4,%A) : (_, _) -> (_)
  %v6 = "llvm.and" (%v1,%v3) : (_, _) -> (_)
  "llvm.return" (%v6) : (_) -> ()
}]
theorem alive_AndOrXor_1288_A__B__B__C__A___A__B__C  (w : Nat)   : alive_AndOrXor_1288_A__B__B__C__A___A__B__C_src w  ⊑ alive_AndOrXor_1288_A__B__B__C__A___A__B__C_tgt w  := by
  unfold alive_AndOrXor_1288_A__B__B__C__A___A__B__C_src alive_AndOrXor_1288_A__B__B__C__A___A__B__C_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_1288_A__B__B__C__A___A__B__C


-- Name:AndOrXor:1294 (A | B) & ((~A) ^ B) -> (A & B)
-- precondition: true
/-
  %op0 = or %A, %B
  %x = xor %A, -1
  %op1 = xor %x, %B
  %r = and %op0, %op1

=>
  %op0 = or %A, %B
  %x = xor %A, -1
  %op1 = xor %x, %B
  %r = and %A, %B

-/
def alive_AndOrXor_1294_A__B__A__B___A__B_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.or" (%A,%B) : (_, _) -> (_)
  %v2 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v3 = "llvm.xor" (%A,%v2) : (_, _) -> (_)
  %v4 = "llvm.xor" (%v3,%B) : (_, _) -> (_)
  %v5 = "llvm.and" (%v1,%v4) : (_, _) -> (_)
  "llvm.return" (%v5) : (_) -> ()
}]

def alive_AndOrXor_1294_A__B__A__B___A__B_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.or" (%A,%B) : (_, _) -> (_)
  %v2 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v3 = "llvm.xor" (%A,%v2) : (_, _) -> (_)
  %v4 = "llvm.xor" (%v3,%B) : (_, _) -> (_)
  %v5 = "llvm.and" (%A,%B) : (_, _) -> (_)
  "llvm.return" (%v5) : (_) -> ()
}]
theorem alive_AndOrXor_1294_A__B__A__B___A__B  (w : Nat)   : alive_AndOrXor_1294_A__B__A__B___A__B_src w  ⊑ alive_AndOrXor_1294_A__B__A__B___A__B_tgt w  := by
  unfold alive_AndOrXor_1294_A__B__A__B___A__B_src alive_AndOrXor_1294_A__B__A__B___A__B_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_1294_A__B__A__B___A__B


-- Name:AndOrXor:1683-1
-- precondition: true
/-
  %op0 = icmp ugt %a, %b
  %op1 = icmp eq %a, %b
  %r = or %op0, %op1

=>
  %op0 = icmp ugt %a, %b
  %op1 = icmp eq %a, %b
  %r = icmp uge %a, %b

-/
def alive_AndOrXor_1683_1_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.icmp.ugt" (%a,%b) : (_, _) -> (i1)
  %v2 = "llvm.icmp.eq" (%a,%b) : (_, _) -> (i1)
  %v3 = "llvm.or" (%v1,%v2) : (i1, i1) -> (i1)
  "llvm.return" (%v3) : (i1) -> ()
}]

def alive_AndOrXor_1683_1_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.icmp.ugt" (%a,%b) : (_, _) -> (i1)
  %v2 = "llvm.icmp.eq" (%a,%b) : (_, _) -> (i1)
  %v3 = "llvm.icmp.uge" (%a,%b) : (_, _) -> (i1)
  "llvm.return" (%v3) : (i1) -> ()
}]
theorem alive_AndOrXor_1683_1  (w : Nat)   : alive_AndOrXor_1683_1_src w  ⊑ alive_AndOrXor_1683_1_tgt w  := by
  unfold alive_AndOrXor_1683_1_src alive_AndOrXor_1683_1_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_1683_1


-- Name:AndOrXor:1683-2
-- precondition: true
/-
  %op0 = icmp uge %a, %b
  %op1 = icmp ne %a, %b
  %r = or %op0, %op1

=>
  %op0 = icmp uge %a, %b
  %op1 = icmp ne %a, %b
  %r = true

-/
def alive_AndOrXor_1683_2_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.icmp.uge" (%a,%b) : (_, _) -> (i1)
  %v2 = "llvm.icmp.ne" (%a,%b) : (_, _) -> (i1)
  %v3 = "llvm.or" (%v1,%v2) : (i1, i1) -> (i1)
  "llvm.return" (%v3) : (i1) -> ()
}]

def alive_AndOrXor_1683_2_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.icmp.uge" (%a,%b) : (_, _) -> (i1)
  %v2 = "llvm.icmp.ne" (%a,%b) : (_, _) -> (i1)
  %v3 = "llvm.mlir.constant" () { value = 1 : i1 } :() -> (i1)
  %v4 = "llvm.copy" (%v3) : (i1) -> (i1)
  "llvm.return" (%v4) : (i1) -> ()
}]
theorem alive_AndOrXor_1683_2  (w : Nat)   : alive_AndOrXor_1683_2_src w  ⊑ alive_AndOrXor_1683_2_tgt w  := by
  unfold alive_AndOrXor_1683_2_src alive_AndOrXor_1683_2_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_1683_2


-- Name:AndOrXor:1704
-- precondition: true
/-
  %cmp1 = icmp eq %B, 0
  %cmp2 = icmp ult %A, %B
  %r = or %cmp1, %cmp2

=>
  %b1 = add %B, -1
  %cmp1 = icmp eq %B, 0
  %cmp2 = icmp ult %A, %B
  %r = icmp uge %b1, %A

-/
-- MANUAL FIX (https://github.com/opencompl/ssa/issues/169)
def alive_AndOrXor_1704_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v2 = "llvm.icmp.eq" (%B,%v1) : (_, _) -> (i1)
  %v3 = "llvm.icmp.ult" (%A,%B) : (_, _) -> (i1)
  %v4 = "llvm.or" (%v2,%v3) : (i1, i1) -> (i1)
  "llvm.return" (%v4) : (i1) -> ()
}]

def alive_AndOrXor_1704_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.add" (%B,%v1) : (_, _) -> (i1)
  %v3 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v4 = "llvm.icmp.eq" (%B,%v3) : (_, _) -> (i1)
  %v5 = "llvm.icmp.ult" (%A,%B) : (_, _) -> (i1)
  %v6 = "llvm.icmp.uge" (%v2,%A) : (_, _) -> (i1)
  "llvm.return" (%v6) : (i1) -> ()
}]
theorem alive_AndOrXor_1704  (w : Nat)   : alive_AndOrXor_1704_src w  ⊑ alive_AndOrXor_1704_tgt w  := by
  unfold alive_AndOrXor_1704_src alive_AndOrXor_1704_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_1704


-- Name:AndOrXor:1705
-- precondition: true
/-
  %cmp1 = icmp eq %B, 0
  %cmp2 = icmp ugt %B, %A
  %r = or %cmp1, %cmp2

=>
  %b1 = add %B, -1
  %cmp1 = icmp eq %B, 0
  %cmp2 = icmp ugt %B, %A
  %r = icmp uge %b1, %A

-/
-- MANUAL FIX (https://github.com/opencompl/ssa/issues/169)
def alive_AndOrXor_1705_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (i1)
  %v2 = "llvm.icmp.eq" (%B,%v1) : (_, _) -> (i1)
  %v3 = "llvm.icmp.ugt" (%B,%A) : (_, _) -> (i1)
  %v4 = "llvm.or" (%v2,%v3) : (i1, i1) -> (i1)
  "llvm.return" (%v4) : (i1) -> ()
}]

def alive_AndOrXor_1705_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (i1)
  %v2 = "llvm.add" (%B,%v1) : (_, _) -> (i1)
  %v3 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v4 = "llvm.icmp.eq" (%B,%v3) : (_, _) -> (i1)
  %v5 = "llvm.icmp.ugt" (%B,%A) : (_, _) -> (i1)
  %v6 = "llvm.icmp.uge" (%v2,%A) : (_, _) -> (i1)
  "llvm.return" (%v6) : (i1) -> ()
}]
theorem alive_AndOrXor_1705  (w : Nat)   : alive_AndOrXor_1705_src w  ⊑ alive_AndOrXor_1705_tgt w  := by
  unfold alive_AndOrXor_1705_src alive_AndOrXor_1705_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_1705


-- Name:AndOrXor:1733
-- precondition: true
/-
  %cmp1 = icmp ne %A, 0
  %cmp2 = icmp ne %B, 0
  %r = or %cmp1, %cmp2

=>
  %or = or %A, %B
  %cmp1 = icmp ne %A, 0
  %cmp2 = icmp ne %B, 0
  %r = icmp ne %or, 0

-/
-- MANUAL FIX (https://github.com/opencompl/ssa/issues/169)
def alive_AndOrXor_1733_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (i1)
  %v2 = "llvm.icmp.ne" (%A,%v1) : (_, _) -> (i1)
  %v3 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (i1)
  %v4 = "llvm.icmp.ne" (%B,%v3) : (_, _) -> (i1)
  %v5 = "llvm.or" (%v2,%v4) : (i1, i1) -> (i1)
  "llvm.return" (%v5) : (i1) -> ()
}]

def alive_AndOrXor_1733_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.or" (%A,%B) : (_, _) -> (i1)
  %v2 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v3 = "llvm.icmp.ne" (%A,%v2) : (_, _) -> (i1)
  %v4 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v5 = "llvm.icmp.ne" (%B,%v4) : (_, _) -> (i1)
  %v6 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (i1)
  %v7 = "llvm.icmp.ne" (%v1,%v6) : (_, _) -> (i1)
  "llvm.return" (%v7) : (i1) -> ()
}]
theorem alive_AndOrXor_1733  (w : Nat)   : alive_AndOrXor_1733_src w  ⊑ alive_AndOrXor_1733_tgt w  := by
  unfold alive_AndOrXor_1733_src alive_AndOrXor_1733_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_1733


-- Name:AndOrXor:2063  (X ^ C1) | C2 --> (X | C2) ^ (C1 & ~C2)
-- precondition: true
/-
  %op0 = xor %x, C1
  %r = or %op0, C

=>
  %or = or %x, C
  %op0 = xor %x, C1
  %r = xor %or, (C1 & ~C)

-/
def alive_AndOrXor_2063__X__C1__C2____X__C2__C1__C2_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%x : _, %C1 : _, %C : _):
  %v1 = "llvm.xor" (%x,%C1) : (_, _) -> (_)
  %v2 = "llvm.or" (%v1,%C) : (_, _) -> (_)
  "llvm.return" (%v2) : (_) -> ()
}]

def alive_AndOrXor_2063__X__C1__C2____X__C2__C1__C2_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%x : _, %C1 : _, %C : _):
  %v1 = "llvm.or" (%x,%C) : (_, _) -> (_)
  %v2 = "llvm.xor" (%x,%C1) : (_, _) -> (_)
  %v3 = "llvm.not" (%C) : (_) -> (_)
  %v4 = "llvm.and" (%C1,%v3) : (_, _) -> (_)
  %v5 = "llvm.xor" (%v1,%v4) : (_, _) -> (_)
  "llvm.return" (%v5) : (_) -> ()
}]
theorem alive_AndOrXor_2063__X__C1__C2____X__C2__C1__C2  (w : Nat)   : alive_AndOrXor_2063__X__C1__C2____X__C2__C1__C2_src w  ⊑ alive_AndOrXor_2063__X__C1__C2____X__C2__C1__C2_tgt w  := by
  unfold alive_AndOrXor_2063__X__C1__C2____X__C2__C1__C2_src alive_AndOrXor_2063__X__C1__C2____X__C2__C1__C2_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_2063__X__C1__C2____X__C2__C1__C2


-- Name:AndOrXor:2113   ((~A & B) | A) -> (A | B)
-- precondition: true
/-
  %negA = xor %A, -1
  %op0 = and %negA, %B
  %r = or %op0, %A

=>
  %negA = xor %A, -1
  %op0 = and %negA, %B
  %r = or %A, %B

-/
def alive_AndOrXor_2113___A__B__A___A__B_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%A,%v1) : (_, _) -> (_)
  %v3 = "llvm.and" (%v2,%B) : (_, _) -> (_)
  %v4 = "llvm.or" (%v3,%A) : (_, _) -> (_)
  "llvm.return" (%v4) : (_) -> ()
}]

def alive_AndOrXor_2113___A__B__A___A__B_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%A,%v1) : (_, _) -> (_)
  %v3 = "llvm.and" (%v2,%B) : (_, _) -> (_)
  %v4 = "llvm.or" (%A,%B) : (_, _) -> (_)
  "llvm.return" (%v4) : (_) -> ()
}]
theorem alive_AndOrXor_2113___A__B__A___A__B  (w : Nat)   : alive_AndOrXor_2113___A__B__A___A__B_src w  ⊑ alive_AndOrXor_2113___A__B__A___A__B_tgt w  := by
  unfold alive_AndOrXor_2113___A__B__A___A__B_src alive_AndOrXor_2113___A__B__A___A__B_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_2113___A__B__A___A__B


-- Name:AndOrXor:2118   ((A & B) | ~A) -> (~A | B)
-- precondition: true
/-
  %negA = xor %A, -1
  %op0 = and %A, %B
  %r = or %op0, %negA

=>
  %negA = xor %A, -1
  %op0 = and %A, %B
  %r = or %negA, %B

-/
def alive_AndOrXor_2118___A__B__A___A__B_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%A,%v1) : (_, _) -> (_)
  %v3 = "llvm.and" (%A,%B) : (_, _) -> (_)
  %v4 = "llvm.or" (%v3,%v2) : (_, _) -> (_)
  "llvm.return" (%v4) : (_) -> ()
}]

def alive_AndOrXor_2118___A__B__A___A__B_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%A,%v1) : (_, _) -> (_)
  %v3 = "llvm.and" (%A,%B) : (_, _) -> (_)
  %v4 = "llvm.or" (%v2,%B) : (_, _) -> (_)
  "llvm.return" (%v4) : (_) -> ()
}]
theorem alive_AndOrXor_2118___A__B__A___A__B  (w : Nat)   : alive_AndOrXor_2118___A__B__A___A__B_src w  ⊑ alive_AndOrXor_2118___A__B__A___A__B_tgt w  := by
  unfold alive_AndOrXor_2118___A__B__A___A__B_src alive_AndOrXor_2118___A__B__A___A__B_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_2118___A__B__A___A__B


-- Name:AndOrXor:2123   (A & (~B)) | (A ^ B) -> (A ^ B)
-- precondition: true
/-
  %negB = xor %B, -1
  %op0 = and %A, %negB
  %op1 = xor %A, %B
  %r = or %op0, %op1

=>
  %negB = xor %B, -1
  %op0 = and %A, %negB
  %op1 = xor %A, %B
  %r = xor %A, %B

-/
def alive_AndOrXor_2123___A__B__A__B___A__B_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%B,%v1) : (_, _) -> (_)
  %v3 = "llvm.and" (%A,%v2) : (_, _) -> (_)
  %v4 = "llvm.xor" (%A,%B) : (_, _) -> (_)
  %v5 = "llvm.or" (%v3,%v4) : (_, _) -> (_)
  "llvm.return" (%v5) : (_) -> ()
}]

def alive_AndOrXor_2123___A__B__A__B___A__B_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%B,%v1) : (_, _) -> (_)
  %v3 = "llvm.and" (%A,%v2) : (_, _) -> (_)
  %v4 = "llvm.xor" (%A,%B) : (_, _) -> (_)
  %v5 = "llvm.xor" (%A,%B) : (_, _) -> (_)
  "llvm.return" (%v5) : (_) -> ()
}]
theorem alive_AndOrXor_2123___A__B__A__B___A__B  (w : Nat)   : alive_AndOrXor_2123___A__B__A__B___A__B_src w  ⊑ alive_AndOrXor_2123___A__B__A__B___A__B_tgt w  := by
  unfold alive_AndOrXor_2123___A__B__A__B___A__B_src alive_AndOrXor_2123___A__B__A__B___A__B_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_2123___A__B__A__B___A__B


-- Name:AndOrXor:2188
-- precondition: true
/-
  %C = xor %D, -1
  %B = xor %A, -1
  %op0 = and %A, %C
  %op1 = and %B, %D
  %r = or %op0, %op1

=>
  %C = xor %D, -1
  %B = xor %A, -1
  %op0 = and %A, %C
  %op1 = and %B, %D
  %r = xor %A, %D

-/
def alive_AndOrXor_2188_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%A : _, %D : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%D,%v1) : (_, _) -> (_)
  %v3 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v4 = "llvm.xor" (%A,%v3) : (_, _) -> (_)
  %v5 = "llvm.and" (%A,%v2) : (_, _) -> (_)
  %v6 = "llvm.and" (%v4,%D) : (_, _) -> (_)
  %v7 = "llvm.or" (%v5,%v6) : (_, _) -> (_)
  "llvm.return" (%v7) : (_) -> ()
}]

def alive_AndOrXor_2188_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%A : _, %D : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%D,%v1) : (_, _) -> (_)
  %v3 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v4 = "llvm.xor" (%A,%v3) : (_, _) -> (_)
  %v5 = "llvm.and" (%A,%v2) : (_, _) -> (_)
  %v6 = "llvm.and" (%v4,%D) : (_, _) -> (_)
  %v7 = "llvm.xor" (%A,%D) : (_, _) -> (_)
  "llvm.return" (%v7) : (_) -> ()
}]
theorem alive_AndOrXor_2188  (w : Nat)   : alive_AndOrXor_2188_src w  ⊑ alive_AndOrXor_2188_tgt w  := by
  unfold alive_AndOrXor_2188_src alive_AndOrXor_2188_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_2188


-- Name:AndOrXor:2231  (A ^ B) | ((B ^ C) ^ A) -> (A ^ B) | C
-- precondition: true
/-
  %op0 = xor %A, %B
  %x = xor %B, %C
  %op1 = xor %x, %A
  %r = or %op0, %op1

=>
  %op0 = xor %A, %B
  %x = xor %B, %C
  %op1 = xor %x, %A
  %r = or %op0, %C

-/
def alive_AndOrXor_2231__A__B__B__C__A___A__B__C_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%A : _, %C : _, %B : _):
  %v1 = "llvm.xor" (%A,%B) : (_, _) -> (_)
  %v2 = "llvm.xor" (%B,%C) : (_, _) -> (_)
  %v3 = "llvm.xor" (%v2,%A) : (_, _) -> (_)
  %v4 = "llvm.or" (%v1,%v3) : (_, _) -> (_)
  "llvm.return" (%v4) : (_) -> ()
}]

def alive_AndOrXor_2231__A__B__B__C__A___A__B__C_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%A : _, %C : _, %B : _):
  %v1 = "llvm.xor" (%A,%B) : (_, _) -> (_)
  %v2 = "llvm.xor" (%B,%C) : (_, _) -> (_)
  %v3 = "llvm.xor" (%v2,%A) : (_, _) -> (_)
  %v4 = "llvm.or" (%v1,%C) : (_, _) -> (_)
  "llvm.return" (%v4) : (_) -> ()
}]
theorem alive_AndOrXor_2231__A__B__B__C__A___A__B__C  (w : Nat)   : alive_AndOrXor_2231__A__B__B__C__A___A__B__C_src w  ⊑ alive_AndOrXor_2231__A__B__B__C__A___A__B__C_tgt w  := by
  unfold alive_AndOrXor_2231__A__B__B__C__A___A__B__C_src alive_AndOrXor_2231__A__B__B__C__A___A__B__C_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_2231__A__B__B__C__A___A__B__C


-- Name:AndOrXor:2243  ((B | C) & A) | B -> B | (A & C)
-- precondition: true
/-
  %o = or %B, %C
  %op0 = and %o, %A
  %r = or %op0, %B

=>
  %a = and %A, %C
  %o = or %B, %C
  %op0 = and %o, %A
  %r = or %B, %a

-/
def alive_AndOrXor_2243__B__C__A__B___B__A__C_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%A : _, %C : _, %B : _):
  %v1 = "llvm.or" (%B,%C) : (_, _) -> (_)
  %v2 = "llvm.and" (%v1,%A) : (_, _) -> (_)
  %v3 = "llvm.or" (%v2,%B) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]

def alive_AndOrXor_2243__B__C__A__B___B__A__C_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%A : _, %C : _, %B : _):
  %v1 = "llvm.and" (%A,%C) : (_, _) -> (_)
  %v2 = "llvm.or" (%B,%C) : (_, _) -> (_)
  %v3 = "llvm.and" (%v2,%A) : (_, _) -> (_)
  %v4 = "llvm.or" (%B,%v1) : (_, _) -> (_)
  "llvm.return" (%v4) : (_) -> ()
}]
theorem alive_AndOrXor_2243__B__C__A__B___B__A__C  (w : Nat)   : alive_AndOrXor_2243__B__C__A__B___B__A__C_src w  ⊑ alive_AndOrXor_2243__B__C__A__B___B__A__C_tgt w  := by
  unfold alive_AndOrXor_2243__B__C__A__B___B__A__C_src alive_AndOrXor_2243__B__C__A__B___B__A__C_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_2243__B__C__A__B___B__A__C


-- Name:AndOrXor:2247  (~A | ~B) == (~(A & B))
-- precondition: true
/-
  %na = xor %A, -1
  %nb = xor %B, -1
  %r = or %na, %nb

=>
  %a = and %A, %B
  %na = xor %A, -1
  %nb = xor %B, -1
  %r = xor %a, -1

-/
def alive_AndOrXor_2247__A__B__A__B_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%A,%v1) : (_, _) -> (_)
  %v3 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v4 = "llvm.xor" (%B,%v3) : (_, _) -> (_)
  %v5 = "llvm.or" (%v2,%v4) : (_, _) -> (_)
  "llvm.return" (%v5) : (_) -> ()
}]

def alive_AndOrXor_2247__A__B__A__B_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.and" (%A,%B) : (_, _) -> (_)
  %v2 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v3 = "llvm.xor" (%A,%v2) : (_, _) -> (_)
  %v4 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v5 = "llvm.xor" (%B,%v4) : (_, _) -> (_)
  %v6 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v7 = "llvm.xor" (%v1,%v6) : (_, _) -> (_)
  "llvm.return" (%v7) : (_) -> ()
}]
theorem alive_AndOrXor_2247__A__B__A__B  (w : Nat)   : alive_AndOrXor_2247__A__B__A__B_src w  ⊑ alive_AndOrXor_2247__A__B__A__B_tgt w  := by
  unfold alive_AndOrXor_2247__A__B__A__B_src alive_AndOrXor_2247__A__B__A__B_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_2247__A__B__A__B


-- Name:AndOrXor:2263
-- precondition: true
/-
  %op1 = xor %op0, %B
  %r = or %op0, %op1

=>
  %op1 = xor %op0, %B
  %r = or %op0, %B

-/
def alive_AndOrXor_2263_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%B : _, %op0 : _):
  %v1 = "llvm.xor" (%op0,%B) : (_, _) -> (_)
  %v2 = "llvm.or" (%op0,%v1) : (_, _) -> (_)
  "llvm.return" (%v2) : (_) -> ()
}]

def alive_AndOrXor_2263_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%B : _, %op0 : _):
  %v1 = "llvm.xor" (%op0,%B) : (_, _) -> (_)
  %v2 = "llvm.or" (%op0,%B) : (_, _) -> (_)
  "llvm.return" (%v2) : (_) -> ()
}]
theorem alive_AndOrXor_2263  (w : Nat)   : alive_AndOrXor_2263_src w  ⊑ alive_AndOrXor_2263_tgt w  := by
  unfold alive_AndOrXor_2263_src alive_AndOrXor_2263_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_2263


-- Name:AndOrXor:2264
-- precondition: true
/-
  %na = xor %A, -1
  %op1 = xor %na, %B
  %r = or %A, %op1

=>
  %nb = xor %B, -1
  %na = xor %A, -1
  %op1 = xor %na, %B
  %r = or %A, %nb

-/
def alive_AndOrXor_2264_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%A,%v1) : (_, _) -> (_)
  %v3 = "llvm.xor" (%v2,%B) : (_, _) -> (_)
  %v4 = "llvm.or" (%A,%v3) : (_, _) -> (_)
  "llvm.return" (%v4) : (_) -> ()
}]

def alive_AndOrXor_2264_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%B,%v1) : (_, _) -> (_)
  %v3 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v4 = "llvm.xor" (%A,%v3) : (_, _) -> (_)
  %v5 = "llvm.xor" (%v4,%B) : (_, _) -> (_)
  %v6 = "llvm.or" (%A,%v2) : (_, _) -> (_)
  "llvm.return" (%v6) : (_) -> ()
}]
theorem alive_AndOrXor_2264  (w : Nat)   : alive_AndOrXor_2264_src w  ⊑ alive_AndOrXor_2264_tgt w  := by
  unfold alive_AndOrXor_2264_src alive_AndOrXor_2264_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_2264


-- Name:AndOrXor:2265
-- precondition: true
/-
  %op0 = and %A, %B
  %op1 = xor %A, %B
  %r = or %op0, %op1

=>
  %op0 = and %A, %B
  %op1 = xor %A, %B
  %r = or %A, %B

-/
def alive_AndOrXor_2265_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.and" (%A,%B) : (_, _) -> (_)
  %v2 = "llvm.xor" (%A,%B) : (_, _) -> (_)
  %v3 = "llvm.or" (%v1,%v2) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]

def alive_AndOrXor_2265_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.and" (%A,%B) : (_, _) -> (_)
  %v2 = "llvm.xor" (%A,%B) : (_, _) -> (_)
  %v3 = "llvm.or" (%A,%B) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]
theorem alive_AndOrXor_2265  (w : Nat)   : alive_AndOrXor_2265_src w  ⊑ alive_AndOrXor_2265_tgt w  := by
  unfold alive_AndOrXor_2265_src alive_AndOrXor_2265_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_2265


-- Name:AndOrXor:2284
-- precondition: true
/-
  %o = or %A, %B
  %op1 = xor %o, -1
  %r = or %A, %op1

=>
  %not = xor %B, -1
  %o = or %A, %B
  %op1 = xor %o, -1
  %r = or %A, %not

-/
def alive_AndOrXor_2284_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.or" (%A,%B) : (_, _) -> (_)
  %v2 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v3 = "llvm.xor" (%v1,%v2) : (_, _) -> (_)
  %v4 = "llvm.or" (%A,%v3) : (_, _) -> (_)
  "llvm.return" (%v4) : (_) -> ()
}]

def alive_AndOrXor_2284_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%B,%v1) : (_, _) -> (_)
  %v3 = "llvm.or" (%A,%B) : (_, _) -> (_)
  %v4 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v5 = "llvm.xor" (%v3,%v4) : (_, _) -> (_)
  %v6 = "llvm.or" (%A,%v2) : (_, _) -> (_)
  "llvm.return" (%v6) : (_) -> ()
}]
theorem alive_AndOrXor_2284  (w : Nat)   : alive_AndOrXor_2284_src w  ⊑ alive_AndOrXor_2284_tgt w  := by
  unfold alive_AndOrXor_2284_src alive_AndOrXor_2284_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_2284


-- Name:AndOrXor:2285
-- precondition: true
/-
  %o = xor %A, %B
  %op1 = xor %o, -1
  %r = or %A, %op1

=>
  %not = xor %B, -1
  %o = xor %A, %B
  %op1 = xor %o, -1
  %r = or %A, %not

-/
def alive_AndOrXor_2285_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.xor" (%A,%B) : (_, _) -> (_)
  %v2 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v3 = "llvm.xor" (%v1,%v2) : (_, _) -> (_)
  %v4 = "llvm.or" (%A,%v3) : (_, _) -> (_)
  "llvm.return" (%v4) : (_) -> ()
}]

def alive_AndOrXor_2285_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%B,%v1) : (_, _) -> (_)
  %v3 = "llvm.xor" (%A,%B) : (_, _) -> (_)
  %v4 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v5 = "llvm.xor" (%v3,%v4) : (_, _) -> (_)
  %v6 = "llvm.or" (%A,%v2) : (_, _) -> (_)
  "llvm.return" (%v6) : (_) -> ()
}]
theorem alive_AndOrXor_2285  (w : Nat)   : alive_AndOrXor_2285_src w  ⊑ alive_AndOrXor_2285_tgt w  := by
  unfold alive_AndOrXor_2285_src alive_AndOrXor_2285_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_2285


-- Name:AndOrXor:2297
-- precondition: true
/-
  %op0 = and %A, %B
  %na = xor %A, -1
  %op1 = xor %na, %B
  %r = or %op0, %op1

=>
  %na = xor %A, -1
  %op0 = and %A, %B
  %op1 = xor %na, %B
  %r = xor %na, %B

-/
def alive_AndOrXor_2297_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.and" (%A,%B) : (_, _) -> (_)
  %v2 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v3 = "llvm.xor" (%A,%v2) : (_, _) -> (_)
  %v4 = "llvm.xor" (%v3,%B) : (_, _) -> (_)
  %v5 = "llvm.or" (%v1,%v4) : (_, _) -> (_)
  "llvm.return" (%v5) : (_) -> ()
}]

def alive_AndOrXor_2297_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%A,%v1) : (_, _) -> (_)
  %v3 = "llvm.and" (%A,%B) : (_, _) -> (_)
  %v4 = "llvm.xor" (%v2,%B) : (_, _) -> (_)
  %v5 = "llvm.xor" (%v2,%B) : (_, _) -> (_)
  "llvm.return" (%v5) : (_) -> ()
}]
theorem alive_AndOrXor_2297  (w : Nat)   : alive_AndOrXor_2297_src w  ⊑ alive_AndOrXor_2297_tgt w  := by
  unfold alive_AndOrXor_2297_src alive_AndOrXor_2297_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_2297


-- Name:AndOrXor:2367
-- precondition: true
/-
  %op0 = or %A, C1
  %r = or %op0, %op1

=>
  %i = or %A, %op1
  %op0 = or %A, C1
  %r = or %i, C1

-/
def alive_AndOrXor_2367_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%A : _, %C1 : _, %op1 : _):
  %v1 = "llvm.or" (%A,%C1) : (_, _) -> (_)
  %v2 = "llvm.or" (%v1,%op1) : (_, _) -> (_)
  "llvm.return" (%v2) : (_) -> ()
}]

def alive_AndOrXor_2367_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%A : _, %C1 : _, %op1 : _):
  %v1 = "llvm.or" (%A,%op1) : (_, _) -> (_)
  %v2 = "llvm.or" (%A,%C1) : (_, _) -> (_)
  %v3 = "llvm.or" (%v1,%C1) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]
theorem alive_AndOrXor_2367  (w : Nat)   : alive_AndOrXor_2367_src w  ⊑ alive_AndOrXor_2367_tgt w  := by
  unfold alive_AndOrXor_2367_src alive_AndOrXor_2367_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_2367


-- Name:AndOrXor:2416
-- precondition: true
/-
  %x = xor %nx, -1
  %op0 = and %x, %y
  %r = xor %op0, -1

=>
  %ny = xor %y, -1
  %x = xor %nx, -1
  %op0 = and %x, %y
  %r = or %nx, %ny

-/
def alive_AndOrXor_2416_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%nx : _, %y : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%nx,%v1) : (_, _) -> (_)
  %v3 = "llvm.and" (%v2,%y) : (_, _) -> (_)
  %v4 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v5 = "llvm.xor" (%v3,%v4) : (_, _) -> (_)
  "llvm.return" (%v5) : (_) -> ()
}]

def alive_AndOrXor_2416_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%nx : _, %y : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%y,%v1) : (_, _) -> (_)
  %v3 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v4 = "llvm.xor" (%nx,%v3) : (_, _) -> (_)
  %v5 = "llvm.and" (%v4,%y) : (_, _) -> (_)
  %v6 = "llvm.or" (%nx,%v2) : (_, _) -> (_)
  "llvm.return" (%v6) : (_) -> ()
}]
theorem alive_AndOrXor_2416  (w : Nat)   : alive_AndOrXor_2416_src w  ⊑ alive_AndOrXor_2416_tgt w  := by
  unfold alive_AndOrXor_2416_src alive_AndOrXor_2416_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_2416


-- Name:AndOrXor:2417
-- precondition: true
/-
  %x = xor %nx, -1
  %op0 = or %x, %y
  %r = xor %op0, -1

=>
  %ny = xor %y, -1
  %x = xor %nx, -1
  %op0 = or %x, %y
  %r = and %nx, %ny

-/
def alive_AndOrXor_2417_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%nx : _, %y : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%nx,%v1) : (_, _) -> (_)
  %v3 = "llvm.or" (%v2,%y) : (_, _) -> (_)
  %v4 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v5 = "llvm.xor" (%v3,%v4) : (_, _) -> (_)
  "llvm.return" (%v5) : (_) -> ()
}]

def alive_AndOrXor_2417_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%nx : _, %y : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%y,%v1) : (_, _) -> (_)
  %v3 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v4 = "llvm.xor" (%nx,%v3) : (_, _) -> (_)
  %v5 = "llvm.or" (%v4,%y) : (_, _) -> (_)
  %v6 = "llvm.and" (%nx,%v2) : (_, _) -> (_)
  "llvm.return" (%v6) : (_) -> ()
}]
theorem alive_AndOrXor_2417  (w : Nat)   : alive_AndOrXor_2417_src w  ⊑ alive_AndOrXor_2417_tgt w  := by
  unfold alive_AndOrXor_2417_src alive_AndOrXor_2417_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_2417


-- Name:AndOrXor:2429
-- precondition: true
/-
  %op0 = and %x, %y
  %r = xor %op0, -1

=>
  %nx = xor %x, -1
  %ny = xor %y, -1
  %op0 = and %x, %y
  %r = or %nx, %ny

-/
def alive_AndOrXor_2429_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%y : _, %x : _):
  %v1 = "llvm.and" (%x,%y) : (_, _) -> (_)
  %v2 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v3 = "llvm.xor" (%v1,%v2) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]

def alive_AndOrXor_2429_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%y : _, %x : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%x,%v1) : (_, _) -> (_)
  %v3 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v4 = "llvm.xor" (%y,%v3) : (_, _) -> (_)
  %v5 = "llvm.and" (%x,%y) : (_, _) -> (_)
  %v6 = "llvm.or" (%v2,%v4) : (_, _) -> (_)
  "llvm.return" (%v6) : (_) -> ()
}]
theorem alive_AndOrXor_2429  (w : Nat)   : alive_AndOrXor_2429_src w  ⊑ alive_AndOrXor_2429_tgt w  := by
  unfold alive_AndOrXor_2429_src alive_AndOrXor_2429_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_2429


-- Name:AndOrXor:2430
-- precondition: true
/-
  %op0 = or %x, %y
  %r = xor %op0, -1

=>
  %nx = xor %x, -1
  %ny = xor %y, -1
  %op0 = or %x, %y
  %r = and %nx, %ny

-/
def alive_AndOrXor_2430_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%y : _, %x : _):
  %v1 = "llvm.or" (%x,%y) : (_, _) -> (_)
  %v2 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v3 = "llvm.xor" (%v1,%v2) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]

def alive_AndOrXor_2430_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%y : _, %x : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%x,%v1) : (_, _) -> (_)
  %v3 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v4 = "llvm.xor" (%y,%v3) : (_, _) -> (_)
  %v5 = "llvm.or" (%x,%y) : (_, _) -> (_)
  %v6 = "llvm.and" (%v2,%v4) : (_, _) -> (_)
  "llvm.return" (%v6) : (_) -> ()
}]
theorem alive_AndOrXor_2430  (w : Nat)   : alive_AndOrXor_2430_src w  ⊑ alive_AndOrXor_2430_tgt w  := by
  unfold alive_AndOrXor_2430_src alive_AndOrXor_2430_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_2430


-- Name:AndOrXor:2443
-- precondition: true
/-
  %nx = xor %x, -1
  %op0 = ashr %nx, %y
  %r = xor %op0, -1

=>
  %nx = xor %x, -1
  %op0 = ashr %nx, %y
  %r = ashr %x, %y

-/
def alive_AndOrXor_2443_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%y : _, %x : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%x,%v1) : (_, _) -> (_)
  %v3 = "llvm.ashr" (%v2,%y) : (_, _) -> (_)
  %v4 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v5 = "llvm.xor" (%v3,%v4) : (_, _) -> (_)
  "llvm.return" (%v5) : (_) -> ()
}]

def alive_AndOrXor_2443_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%y : _, %x : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%x,%v1) : (_, _) -> (_)
  %v3 = "llvm.ashr" (%v2,%y) : (_, _) -> (_)
  %v4 = "llvm.ashr" (%x,%y) : (_, _) -> (_)
  "llvm.return" (%v4) : (_) -> ()
}]
theorem alive_AndOrXor_2443  (w : Nat)   : alive_AndOrXor_2443_src w  ⊑ alive_AndOrXor_2443_tgt w  := by
  unfold alive_AndOrXor_2443_src alive_AndOrXor_2443_tgt
  simp_alive_peephole
  sorry --apply bitvec_AndOrXor_2443


-- Name:AndOrXor:2453
-- precondition: true
/-
  %op0 = icmp slt %x, %y
  %r = xor %op0, -1

=>
  %op0 = icmp slt %x, %y
  %r = icmp sge %x, %y

-/
-- MANUAL FIX (https://github.com/opencompl/ssa/issues/169)
def alive_AndOrXor_2453_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%y : _, %x : _):
  %v1 = "llvm.icmp.slt" (%x,%y) : (_, _) -> (i1)
  %v2 = "llvm.mlir.constant" () { value = -1 : i1 } :() -> (i1)
  %v3 = "llvm.xor" (%v1,%v2) : (i1, i1) -> (i1)
  "llvm.return" (%v3) : (i1) -> ()
}]

def alive_AndOrXor_2453_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%y : _, %x : _):
  %v1 = "llvm.icmp.slt" (%x,%y) : (_, _) -> (i1)
  %v2 = "llvm.icmp.sge" (%x,%y) : (_, _) -> (i1)
  "llvm.return" (%v2) : (i1) -> ()
}]
theorem alive_AndOrXor_2453  (w : Nat)   : alive_AndOrXor_2453_src w  ⊑ alive_AndOrXor_2453_tgt w  := by
  unfold alive_AndOrXor_2453_src alive_AndOrXor_2453_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_2453


-- Name:AndOrXor:2475
-- precondition: true
/-
  %op0 = sub C, %x
  %r = xor %op0, -1

=>
  %op0 = sub C, %x
  %r = add %x, (-1 - C)

-/
def alive_AndOrXor_2475_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%x : _, %C : _):
  %v1 = "llvm.sub" (%C,%x) : (_, _) -> (_)
  %v2 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v3 = "llvm.xor" (%v1,%v2) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]

def alive_AndOrXor_2475_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%x : _, %C : _):
  %v1 = "llvm.sub" (%C,%x) : (_, _) -> (_)
  %v2 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v3 = "llvm.sub" (%v2,%C) : (_, _) -> (_)
  %v4 = "llvm.add" (%x,%v3) : (_, _) -> (_)
  "llvm.return" (%v4) : (_) -> ()
}]
theorem alive_AndOrXor_2475  (w : Nat)   : alive_AndOrXor_2475_src w  ⊑ alive_AndOrXor_2475_tgt w  := by
  unfold alive_AndOrXor_2475_src alive_AndOrXor_2475_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_2475


-- Name:AndOrXor:2486
-- precondition: true
/-
  %op0 = add %x, C
  %r = xor %op0, -1

=>
  %op0 = add %x, C
  %r = sub (-1 - C), %x

-/
def alive_AndOrXor_2486_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%x : _, %C : _):
  %v1 = "llvm.add" (%x,%C) : (_, _) -> (_)
  %v2 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v3 = "llvm.xor" (%v1,%v2) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]

def alive_AndOrXor_2486_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%x : _, %C : _):
  %v1 = "llvm.add" (%x,%C) : (_, _) -> (_)
  %v2 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v3 = "llvm.sub" (%v2,%C) : (_, _) -> (_)
  %v4 = "llvm.sub" (%v3,%x) : (_, _) -> (_)
  "llvm.return" (%v4) : (_) -> ()
}]
theorem alive_AndOrXor_2486  (w : Nat)   : alive_AndOrXor_2486_src w  ⊑ alive_AndOrXor_2486_tgt w  := by
  unfold alive_AndOrXor_2486_src alive_AndOrXor_2486_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_2486


-- Name:AndOrXor:2581  (B|A)^B -> A & ~B
-- precondition: true
/-
  %op0 = or %a, %op1
  %r = xor %op0, %op1

=>
  %nop1 = xor %op1, -1
  %op0 = or %a, %op1
  %r = and %a, %nop1

-/
def alive_AndOrXor_2581__BAB___A__B_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%a : _, %op1 : _):
  %v1 = "llvm.or" (%a,%op1) : (_, _) -> (_)
  %v2 = "llvm.xor" (%v1,%op1) : (_, _) -> (_)
  "llvm.return" (%v2) : (_) -> ()
}]

def alive_AndOrXor_2581__BAB___A__B_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%a : _, %op1 : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%op1,%v1) : (_, _) -> (_)
  %v3 = "llvm.or" (%a,%op1) : (_, _) -> (_)
  %v4 = "llvm.and" (%a,%v2) : (_, _) -> (_)
  "llvm.return" (%v4) : (_) -> ()
}]
theorem alive_AndOrXor_2581__BAB___A__B  (w : Nat)   : alive_AndOrXor_2581__BAB___A__B_src w  ⊑ alive_AndOrXor_2581__BAB___A__B_tgt w  := by
  unfold alive_AndOrXor_2581__BAB___A__B_src alive_AndOrXor_2581__BAB___A__B_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_2581__BAB___A__B


-- Name:AndOrXor:2587  (B&A)^A -> ~B & A
-- precondition: true
/-
  %op0 = and %a, %op1
  %r = xor %op0, %op1

=>
  %na = xor %a, -1
  %op0 = and %a, %op1
  %r = and %na, %op1

-/
def alive_AndOrXor_2587__BAA___B__A_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%a : _, %op1 : _):
  %v1 = "llvm.and" (%a,%op1) : (_, _) -> (_)
  %v2 = "llvm.xor" (%v1,%op1) : (_, _) -> (_)
  "llvm.return" (%v2) : (_) -> ()
}]

def alive_AndOrXor_2587__BAA___B__A_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%a : _, %op1 : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%a,%v1) : (_, _) -> (_)
  %v3 = "llvm.and" (%a,%op1) : (_, _) -> (_)
  %v4 = "llvm.and" (%v2,%op1) : (_, _) -> (_)
  "llvm.return" (%v4) : (_) -> ()
}]
theorem alive_AndOrXor_2587__BAA___B__A  (w : Nat)   : alive_AndOrXor_2587__BAA___B__A_src w  ⊑ alive_AndOrXor_2587__BAA___B__A_tgt w  := by
  unfold alive_AndOrXor_2587__BAA___B__A_src alive_AndOrXor_2587__BAA___B__A_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_2587__BAA___B__A


-- Name:AndOrXor:2595
-- precondition: true
/-
  %op0 = and %a, %b
  %op1 = or %a, %b
  %r = xor %op0, %op1

=>
  %op0 = and %a, %b
  %op1 = or %a, %b
  %r = xor %a, %b

-/
def alive_AndOrXor_2595_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.and" (%a,%b) : (_, _) -> (_)
  %v2 = "llvm.or" (%a,%b) : (_, _) -> (_)
  %v3 = "llvm.xor" (%v1,%v2) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]

def alive_AndOrXor_2595_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.and" (%a,%b) : (_, _) -> (_)
  %v2 = "llvm.or" (%a,%b) : (_, _) -> (_)
  %v3 = "llvm.xor" (%a,%b) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]
theorem alive_AndOrXor_2595  (w : Nat)   : alive_AndOrXor_2595_src w  ⊑ alive_AndOrXor_2595_tgt w  := by
  unfold alive_AndOrXor_2595_src alive_AndOrXor_2595_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_2595


-- Name:AndOrXor:2607
-- precondition: true
/-
  %na = xor %a, -1
  %nb = xor %b, -1
  %op0 = or %a, %nb
  %op1 = or %na, %b
  %r = xor %op0, %op1

=>
  %na = xor %a, -1
  %nb = xor %b, -1
  %op0 = or %a, %nb
  %op1 = or %na, %b
  %r = xor %a, %b

-/
def alive_AndOrXor_2607_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%a,%v1) : (_, _) -> (_)
  %v3 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v4 = "llvm.xor" (%b,%v3) : (_, _) -> (_)
  %v5 = "llvm.or" (%a,%v4) : (_, _) -> (_)
  %v6 = "llvm.or" (%v2,%b) : (_, _) -> (_)
  %v7 = "llvm.xor" (%v5,%v6) : (_, _) -> (_)
  "llvm.return" (%v7) : (_) -> ()
}]

def alive_AndOrXor_2607_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%a,%v1) : (_, _) -> (_)
  %v3 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v4 = "llvm.xor" (%b,%v3) : (_, _) -> (_)
  %v5 = "llvm.or" (%a,%v4) : (_, _) -> (_)
  %v6 = "llvm.or" (%v2,%b) : (_, _) -> (_)
  %v7 = "llvm.xor" (%a,%b) : (_, _) -> (_)
  "llvm.return" (%v7) : (_) -> ()
}]
theorem alive_AndOrXor_2607  (w : Nat)   : alive_AndOrXor_2607_src w  ⊑ alive_AndOrXor_2607_tgt w  := by
  unfold alive_AndOrXor_2607_src alive_AndOrXor_2607_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_2607


-- Name:AndOrXor:2617
-- precondition: true
/-
  %na = xor %a, -1
  %nb = xor %b, -1
  %op0 = and %a, %nb
  %op1 = and %na, %b
  %r = xor %op0, %op1

=>
  %na = xor %a, -1
  %nb = xor %b, -1
  %op0 = and %a, %nb
  %op1 = and %na, %b
  %r = xor %a, %b

-/
def alive_AndOrXor_2617_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%a,%v1) : (_, _) -> (_)
  %v3 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v4 = "llvm.xor" (%b,%v3) : (_, _) -> (_)
  %v5 = "llvm.and" (%a,%v4) : (_, _) -> (_)
  %v6 = "llvm.and" (%v2,%b) : (_, _) -> (_)
  %v7 = "llvm.xor" (%v5,%v6) : (_, _) -> (_)
  "llvm.return" (%v7) : (_) -> ()
}]

def alive_AndOrXor_2617_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%a,%v1) : (_, _) -> (_)
  %v3 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v4 = "llvm.xor" (%b,%v3) : (_, _) -> (_)
  %v5 = "llvm.and" (%a,%v4) : (_, _) -> (_)
  %v6 = "llvm.and" (%v2,%b) : (_, _) -> (_)
  %v7 = "llvm.xor" (%a,%b) : (_, _) -> (_)
  "llvm.return" (%v7) : (_) -> ()
}]
theorem alive_AndOrXor_2617  (w : Nat)   : alive_AndOrXor_2617_src w  ⊑ alive_AndOrXor_2617_tgt w  := by
  unfold alive_AndOrXor_2617_src alive_AndOrXor_2617_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_2617


-- Name:AndOrXor:2627
-- precondition: true
/-
  %op0 = xor %a, %c
  %op1 = or %a, %b
  %r = xor %op0, %op1

=>
  %na = xor %a, -1
  %and = and %na, %b
  %op0 = xor %a, %c
  %op1 = or %a, %b
  %r = xor %and, %c

-/
def alive_AndOrXor_2627_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%a : _, %c : _, %b : _):
  %v1 = "llvm.xor" (%a,%c) : (_, _) -> (_)
  %v2 = "llvm.or" (%a,%b) : (_, _) -> (_)
  %v3 = "llvm.xor" (%v1,%v2) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]

def alive_AndOrXor_2627_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%a : _, %c : _, %b : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%a,%v1) : (_, _) -> (_)
  %v3 = "llvm.and" (%v2,%b) : (_, _) -> (_)
  %v4 = "llvm.xor" (%a,%c) : (_, _) -> (_)
  %v5 = "llvm.or" (%a,%b) : (_, _) -> (_)
  %v6 = "llvm.xor" (%v3,%c) : (_, _) -> (_)
  "llvm.return" (%v6) : (_) -> ()
}]
theorem alive_AndOrXor_2627  (w : Nat)   : alive_AndOrXor_2627_src w  ⊑ alive_AndOrXor_2627_tgt w  := by
  unfold alive_AndOrXor_2627_src alive_AndOrXor_2627_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_2627


-- Name:AndOrXor:2647
-- precondition: true
/-
  %op0 = and %a, %b
  %op1 = xor %a, %b
  %r = xor %op0, %op1

=>
  %op0 = and %a, %b
  %op1 = xor %a, %b
  %r = or %a, %b

-/
def alive_AndOrXor_2647_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.and" (%a,%b) : (_, _) -> (_)
  %v2 = "llvm.xor" (%a,%b) : (_, _) -> (_)
  %v3 = "llvm.xor" (%v1,%v2) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]

def alive_AndOrXor_2647_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.and" (%a,%b) : (_, _) -> (_)
  %v2 = "llvm.xor" (%a,%b) : (_, _) -> (_)
  %v3 = "llvm.or" (%a,%b) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]
theorem alive_AndOrXor_2647  (w : Nat)   : alive_AndOrXor_2647_src w  ⊑ alive_AndOrXor_2647_tgt w  := by
  unfold alive_AndOrXor_2647_src alive_AndOrXor_2647_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_2647


-- Name:AndOrXor:2658
-- precondition: true
/-
  %nb = xor %b, -1
  %op0 = and %a, %nb
  %na = xor %a, -1
  %r = xor %op0, %na

=>
  %and = and %a, %b
  %nb = xor %b, -1
  %op0 = and %a, %nb
  %na = xor %a, -1
  %r = xor %and, -1

-/
def alive_AndOrXor_2658_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%b,%v1) : (_, _) -> (_)
  %v3 = "llvm.and" (%a,%v2) : (_, _) -> (_)
  %v4 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v5 = "llvm.xor" (%a,%v4) : (_, _) -> (_)
  %v6 = "llvm.xor" (%v3,%v5) : (_, _) -> (_)
  "llvm.return" (%v6) : (_) -> ()
}]

def alive_AndOrXor_2658_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.and" (%a,%b) : (_, _) -> (_)
  %v2 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v3 = "llvm.xor" (%b,%v2) : (_, _) -> (_)
  %v4 = "llvm.and" (%a,%v3) : (_, _) -> (_)
  %v5 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v6 = "llvm.xor" (%a,%v5) : (_, _) -> (_)
  %v7 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v8 = "llvm.xor" (%v1,%v7) : (_, _) -> (_)
  "llvm.return" (%v8) : (_) -> ()
}]
theorem alive_AndOrXor_2658  (w : Nat)   : alive_AndOrXor_2658_src w  ⊑ alive_AndOrXor_2658_tgt w  := by
  unfold alive_AndOrXor_2658_src alive_AndOrXor_2658_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_2658


-- Name:AndOrXor:2663
-- precondition: true
/-
  %op0 = icmp ule %a, %b
  %op1 = icmp ne %a, %b
  %r = xor %op0, %op1

=>
  %op0 = icmp ule %a, %b
  %op1 = icmp ne %a, %b
  %r = icmp uge %a, %b

-/
def alive_AndOrXor_2663_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.icmp.ule" (%a,%b) : (_, _) -> (i1)
  %v2 = "llvm.icmp.ne" (%a,%b) : (_, _) -> (i1)
  %v3 = "llvm.xor" (%v1,%v2) : (i1, i1) -> (i1)
  "llvm.return" (%v3) : (i1) -> ()
}]

def alive_AndOrXor_2663_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.icmp.ule" (%a,%b) : (_, _) -> (i1)
  %v2 = "llvm.icmp.ne" (%a,%b) : (_, _) -> (i1)
  %v3 = "llvm.icmp.uge" (%a,%b) : (_, _) -> (i1)
  "llvm.return" (%v3) : (i1) -> ()
}]
theorem alive_AndOrXor_2663  (w : Nat)   : alive_AndOrXor_2663_src w  ⊑ alive_AndOrXor_2663_tgt w  := by
  unfold alive_AndOrXor_2663_src alive_AndOrXor_2663_tgt
  simp_alive_peephole
  apply bitvec_AndOrXor_2663


-- Name:152
-- precondition: true
/-
  %r = mul %x, -1

=>
  %r = sub 0, %x

-/
def alive_152_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%x : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.mul" (%x,%v1) : (_, _) -> (_)
  "llvm.return" (%v2) : (_) -> ()
}]

def alive_152_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%x : _):
  %v1 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v2 = "llvm.sub" (%v1,%x) : (_, _) -> (_)
  "llvm.return" (%v2) : (_) -> ()
}]
theorem alive_152  (w : Nat)   : alive_152_src w  ⊑ alive_152_tgt w  := by
  unfold alive_152_src alive_152_tgt
  simp_alive_peephole
  sorry --apply bitvec_152


-- Name:229
-- precondition: true
/-
  %Op0 = add %X, C1
  %r = mul %Op0, %Op1

=>
  %mul = mul C1, %Op1
  %tmp = mul %X, %Op1
  %Op0 = add %X, C1
  %r = add %tmp, %mul

-/
def alive_229_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%X : _, %C1 : _, %Op1 : _):
  %v1 = "llvm.add" (%X,%C1) : (_, _) -> (_)
  %v2 = "llvm.mul" (%v1,%Op1) : (_, _) -> (_)
  "llvm.return" (%v2) : (_) -> ()
}]

def alive_229_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%X : _, %C1 : _, %Op1 : _):
  %v1 = "llvm.mul" (%C1,%Op1) : (_, _) -> (_)
  %v2 = "llvm.mul" (%X,%Op1) : (_, _) -> (_)
  %v3 = "llvm.add" (%X,%C1) : (_, _) -> (_)
  %v4 = "llvm.add" (%v2,%v1) : (_, _) -> (_)
  "llvm.return" (%v4) : (_) -> ()
}]
theorem alive_229  (w : Nat)   : alive_229_src w  ⊑ alive_229_tgt w  := by
  unfold alive_229_src alive_229_tgt
  simp_alive_peephole
  apply bitvec_229


-- Name:239
-- precondition: true
/-
  %a = sub 0, %X
  %b = sub 0, %Y
  %r = mul %a, %b

=>
  %a = sub 0, %X
  %b = sub 0, %Y
  %r = mul %X, %Y

-/
def alive_239_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%Y : _, %X : _):
  %v1 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v2 = "llvm.sub" (%v1,%X) : (_, _) -> (_)
  %v3 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v4 = "llvm.sub" (%v3,%Y) : (_, _) -> (_)
  %v5 = "llvm.mul" (%v2,%v4) : (_, _) -> (_)
  "llvm.return" (%v5) : (_) -> ()
}]

def alive_239_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%Y : _, %X : _):
  %v1 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v2 = "llvm.sub" (%v1,%X) : (_, _) -> (_)
  %v3 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v4 = "llvm.sub" (%v3,%Y) : (_, _) -> (_)
  %v5 = "llvm.mul" (%X,%Y) : (_, _) -> (_)
  "llvm.return" (%v5) : (_) -> ()
}]
theorem alive_239  (w : Nat)   : alive_239_src w  ⊑ alive_239_tgt w  := by
  unfold alive_239_src alive_239_tgt
  simp_alive_peephole
  apply bitvec_239


-- Name:275
-- precondition: true
/-
  %div = udiv i5 %X, %Y
  %r = mul %div, %Y

=>
  %rem = urem %X, %Y
  %div = udiv i5 %X, %Y
  %r = sub %X, %rem

-/
def alive_275_src   :=
[alive_icom ()| {
^bb0(%Y : i5, %X : i5):
  %v1 = "llvm.udiv" (%X,%Y) : (i5, i5) -> (i5)
  %v2 = "llvm.mul" (%v1,%Y) : (i5, i5) -> (i5)
  "llvm.return" (%v2) : (i5) -> ()
}]

def alive_275_tgt  :=
[alive_icom ()| {
^bb0(%Y : i5, %X : i5):
  %v1 = "llvm.urem" (%X,%Y) : (i5, i5) -> (i5)
  %v2 = "llvm.udiv" (%X,%Y) : (i5, i5) -> (i5)
  %v3 = "llvm.sub" (%X,%v1) : (i5, i5) -> (i5)
  "llvm.return" (%v3) : (i5) -> ()
}]
theorem alive_275   : alive_275_src ⊑ alive_275_tgt := by
  unfold alive_275_src alive_275_tgt
  simp_alive_peephole
  apply bitvec_275


-- Name:275-2
-- precondition: true
/-
  %div = sdiv i5 %X, %Y
  %r = mul %div, %Y

=>
  %rem = srem %X, %Y
  %div = sdiv i5 %X, %Y
  %r = sub %X, %rem

-/
def alive_275_2_src   :=
[alive_icom ()| {
^bb0(%Y : i5, %X : i5):
  %v1 = "llvm.sdiv" (%X,%Y) : (i5, i5) -> (i5)
  %v2 = "llvm.mul" (%v1,%Y) : (i5, i5) -> (i5)
  "llvm.return" (%v2) : (i5) -> ()
}]

def alive_275_2_tgt  :=
[alive_icom ()| {
^bb0(%Y : i5, %X : i5):
  %v1 = "llvm.srem" (%X,%Y) : (i5, i5) -> (i5)
  %v2 = "llvm.sdiv" (%X,%Y) : (i5, i5) -> (i5)
  %v3 = "llvm.sub" (%X,%v1) : (i5, i5) -> (i5)
  "llvm.return" (%v3) : (i5) -> ()
}]
theorem alive_275_2   : alive_275_2_src ⊑ alive_275_2_tgt := by
  unfold alive_275_2_src alive_275_2_tgt
  simp_alive_peephole
  sorry --apply bitvec_275_2


-- Name:276
-- precondition: true
/-
  %div = sdiv i5 %X, %Y
  %negY = sub 0, %Y
  %r = mul %div, %negY

=>
  %rem = srem %X, %Y
  %div = sdiv i5 %X, %Y
  %negY = sub 0, %Y
  %r = sub %rem, %X

-/
-- MANUAL FIX: https://github.com/opencompl/ssa/issues/169
def alive_276_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%Y : i5, %X : i5):
  %v1 = "llvm.sdiv" (%X,%Y) : (i5, i5) -> (i5)
  %v2 = "llvm.mlir.constant" () { value = 0 : i5 } :() -> (i5)
  %v3 = "llvm.sub" (%v2,%Y) : (i5, i5) -> (i5)
  %v4 = "llvm.mul" (%v1,%v3) : (i5, i5) -> (i5)
  "llvm.return" (%v4) : (i5) -> ()
}]

def alive_276_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%Y : i5, %X : i5):
  %v1 = "llvm.srem" (%X,%Y) : (i5, i5) -> (i5)
  %v2 = "llvm.sdiv" (%X,%Y) : (i5, i5) -> (i5)
  %v3 = "llvm.mlir.constant" () { value = 0 : i5 } :() -> (i5)
  %v4 = "llvm.sub" (%v3,%Y) : (i5, i5) -> (i5)
  %v5 = "llvm.sub" (%v1,%X) : (i5, i5) -> (i5)
  "llvm.return" (%v5) : (i5) -> ()
}]
theorem alive_276  (w : Nat)   : alive_276_src w  ⊑ alive_276_tgt w  := by
  unfold alive_276_src alive_276_tgt
  simp_alive_peephole
  sorry --apply bitvec_276


-- Name:276-2
-- precondition: true
/-
  %div = udiv i5 %X, %Y
  %negY = sub 0, %Y
  %r = mul %div, %negY

=>
  %rem = urem %X, %Y
  %div = udiv i5 %X, %Y
  %negY = sub 0, %Y
  %r = sub %rem, %X

-/
-- MANUAL FIX: https://github.com/opencompl/ssa/issues/169
def alive_276_2_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%Y : i5, %X : i5):
  %v1 = "llvm.udiv" (%X,%Y) : (i5, i5) -> (i5)
  %v2 = "llvm.mlir.constant" () { value = 0 : i5 } :() -> (i5)
  %v3 = "llvm.sub" (%v2,%Y) : (i5, i5) -> (i5)
  %v4 = "llvm.mul" (%v1,%v3) : (i5, i5) -> (i5)
  "llvm.return" (%v4) : (i5) -> ()
}]

def alive_276_2_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%Y : i5, %X : i5):
  %v1 = "llvm.urem" (%X,%Y) : (i5, i5) -> (i5)
  %v2 = "llvm.udiv" (%X,%Y) : (i5, i5) -> (i5)
  %v3 = "llvm.mlir.constant" () { value = 0 : i5 } :() -> (i5)
  %v4 = "llvm.sub" (%v3,%Y) : (i5, i5) -> (i5)
  %v5 = "llvm.sub" (%v1,%X) : (i5, i5) -> (i5)
  "llvm.return" (%v5) : (i5) -> ()
}]
theorem alive_276_2  (w : Nat)   : alive_276_2_src w  ⊑ alive_276_2_tgt w  := by
  unfold alive_276_2_src alive_276_2_tgt
  simp_alive_peephole
  apply bitvec_276_2


-- Name:283
-- precondition: true
/-
  %r = mul i1 %X, %Y

=>
  %r = and %X, %Y

-/
def alive_283_src   :=
[alive_icom ()| {
^bb0(%Y : i1, %X : i1):
  %v1 = "llvm.mul" (%X,%Y) : (i1, i1) -> (i1)
  "llvm.return" (%v1) : (i1) -> ()
}]

def alive_283_tgt  :=
[alive_icom ()| {
^bb0(%Y : i1, %X : i1):
  %v1 = "llvm.and" (%X,%Y) : (i1, i1) -> (i1)
  "llvm.return" (%v1) : (i1) -> ()
}]
theorem alive_283   : alive_283_src ⊑ alive_283_tgt := by
  unfold alive_283_src alive_283_tgt
  simp_alive_peephole
  apply bitvec_283


-- Name:290 & 292
-- precondition: true
/-
  %Op0 = shl 1, %Y
  %r = mul %Op0, %Op1

=>
  %Op0 = shl 1, %Y
  %r = shl %Op1, %Y

-/
def alive_290__292_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%Y : _, %Op1 : _):
  %v1 = "llvm.mlir.constant" () { value = 1 : _ } :() -> (_)
  %v2 = "llvm.shl" (%v1,%Y) : (_, _) -> (_)
  %v3 = "llvm.mul" (%v2,%Op1) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]

def alive_290__292_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%Y : _, %Op1 : _):
  %v1 = "llvm.mlir.constant" () { value = 1 : _ } :() -> (_)
  %v2 = "llvm.shl" (%v1,%Y) : (_, _) -> (_)
  %v3 = "llvm.shl" (%Op1,%Y) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]
theorem alive_290__292  (w : Nat)   : alive_290__292_src w  ⊑ alive_290__292_tgt w  := by
  unfold alive_290__292_src alive_290__292_tgt
  simp_alive_peephole
  all_goals sorry --apply bitvec_290__292


-- Name:820
-- precondition: true
/-
  %Z = srem i9 %X, %Op1
  %Op0 = sub %X, %Z
  %r = sdiv %Op0, %Op1

=>
  %Z = srem i9 %X, %Op1
  %Op0 = sub %X, %Z
  %r = sdiv %X, %Op1

-/
def alive_820_src   :=
[alive_icom ()| {
^bb0(%X : i9, %Op1 : i9):
  %v1 = "llvm.srem" (%X,%Op1) : (i9, i9) -> (i9)
  %v2 = "llvm.sub" (%X,%v1) : (i9, i9) -> (i9)
  %v3 = "llvm.sdiv" (%v2,%Op1) : (i9, i9) -> (i9)
  "llvm.return" (%v3) : (i9) -> ()
}]

def alive_820_tgt  :=
[alive_icom ()| {
^bb0(%X : i9, %Op1 : i9):
  %v1 = "llvm.srem" (%X,%Op1) : (i9, i9) -> (i9)
  %v2 = "llvm.sub" (%X,%v1) : (i9, i9) -> (i9)
  %v3 = "llvm.sdiv" (%X,%Op1) : (i9, i9) -> (i9)
  "llvm.return" (%v3) : (i9) -> ()
}]
theorem alive_820   : alive_820_src ⊑ alive_820_tgt := by
  unfold alive_820_src alive_820_tgt
  simp_alive_peephole
  sorry --apply bitvec_820


-- Name:820'
-- precondition: true
/-
  %Z = urem i9 %X, %Op1
  %Op0 = sub %X, %Z
  %r = udiv %Op0, %Op1

=>
  %Z = urem i9 %X, %Op1
  %Op0 = sub %X, %Z
  %r = udiv %X, %Op1

-/
def alive_820'_src   :=
[alive_icom ()| {
^bb0(%X : i9, %Op1 : i9):
  %v1 = "llvm.urem" (%X,%Op1) : (i9, i9) -> (i9)
  %v2 = "llvm.sub" (%X,%v1) : (i9, i9) -> (i9)
  %v3 = "llvm.udiv" (%v2,%Op1) : (i9, i9) -> (i9)
  "llvm.return" (%v3) : (i9) -> ()
}]

def alive_820'_tgt  :=
[alive_icom ()| {
^bb0(%X : i9, %Op1 : i9):
  %v1 = "llvm.urem" (%X,%Op1) : (i9, i9) -> (i9)
  %v2 = "llvm.sub" (%X,%v1) : (i9, i9) -> (i9)
  %v3 = "llvm.udiv" (%X,%Op1) : (i9, i9) -> (i9)
  "llvm.return" (%v3) : (i9) -> ()
}]
theorem alive_820'   : alive_820'_src ⊑ alive_820'_tgt := by
  unfold alive_820'_src alive_820'_tgt
  simp_alive_peephole
  apply bitvec_820'


-- Name:1030
-- precondition: true
/-
  %r = sdiv %X, -1

=>
  %r = sub 0, %X

-/
def alive_1030_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%X : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.sdiv" (%X,%v1) : (_, _) -> (_)
  "llvm.return" (%v2) : (_) -> ()
}]

def alive_1030_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%X : _):
  %v1 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v2 = "llvm.sub" (%v1,%X) : (_, _) -> (_)
  "llvm.return" (%v2) : (_) -> ()
}]
theorem alive_1030  (w : Nat)   : alive_1030_src w  ⊑ alive_1030_tgt w  := by
  unfold alive_1030_src alive_1030_tgt
  simp_alive_peephole
  sorry -- apply bitvec_1030


-- Name:Select:858
-- precondition: true
/-
  %nota = xor %a, -1
  %r = select i1 %a, %nota, %b

=>
  %nota = xor %a, -1
  %r = and %nota, %b

-/
-- MANUAL FIX (https://github.com/opencompl/ssa/issues/169)
def alive_Select_858_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%a : i1, %b : i1):
  %v1 = "llvm.mlir.constant" () { value = -1 : i1 } :() -> (i1)
  %v2 = "llvm.xor" (%a,%v1) : (i1, i1) -> (i1)
  %v3 = "llvm.select" (%a,%v2,%b) : (i1, i1, i1) -> (i1)
  "llvm.return" (%v3) : (i1) -> ()
}]

def alive_Select_858_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%a,%v1) : (_, _) -> (_)
  %v3 = "llvm.and" (%v2,%b) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]
theorem alive_Select_858  (w : Nat)   : alive_Select_858_src w  ⊑ alive_Select_858_tgt 1  := by
  unfold alive_Select_858_src alive_Select_858_tgt
  simp_alive_peephole
  all_goals sorry --apply bitvec_Select_858


-- Name:Select:859'
-- precondition: true
/-
  %nota = xor %a, -1
  %r = select i1 %a, %b, %nota

=>
  %nota = xor %a, -1
  %r = or %nota, %b

-/
-- MANUAL FIX (https://github.com/opencompl/ssa/issues/169)
def alive_Select_859'_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%a : i1, %b : i1):
  %v1 = "llvm.mlir.constant" () { value = -1 : i1 } :() -> (i1)
  %v2 = "llvm.xor" (%a,%v1) : (i1, i1) -> (i1)
  %v3 = "llvm.select" (%a,%b,%v2) : (i1, i1, i1) -> (i1)
  "llvm.return" (%v3) : (i1) -> ()
}]

def alive_Select_859'_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%a,%v1) : (_, _) -> (_)
  %v3 = "llvm.or" (%v2,%b) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]
theorem alive_Select_859'  (w : Nat)   : alive_Select_859'_src w  ⊑ alive_Select_859'_tgt 1  := by
  unfold alive_Select_859'_src alive_Select_859'_tgt
  simp_alive_peephole
  all_goals sorry --apply bitvec_Select_859'


-- Name:Select:1100
-- precondition: true
/-
  %r = select i1 true, %X, %Y

=>
  %r = %X

-/
def alive_Select_1100_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%Y : _, %X : _):
  %v1 = "llvm.mlir.constant" () { value = 1 : i1 } :() -> (i1)
  %v2 = "llvm.select" (%v1,%X,%Y) : (i1, _, _) -> (_)
  "llvm.return" (%v2) : (_) -> ()
}]

def alive_Select_1100_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%Y : _, %X : _):
  %v1 = "llvm.copy" (%X) : (_) -> (_)
  "llvm.return" (%v1) : (_) -> ()
}]
theorem alive_Select_1100  (w : Nat)   : alive_Select_1100_src w  ⊑ alive_Select_1100_tgt w  := by
  unfold alive_Select_1100_src alive_Select_1100_tgt
  simp_alive_peephole
  all_goals sorry --apply bitvec_Select_1100


-- Name:Select:1105
-- precondition: true
/-
  %r = select i1 false, %X, %Y

=>
  %r = %Y

-/
def alive_Select_1105_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%Y : _, %X : _):
  %v1 = "llvm.mlir.constant" () { value = 0 : i1 } :() -> (i1)
  %v2 = "llvm.select" (%v1,%X,%Y) : (i1, _, _) -> (_)
  "llvm.return" (%v2) : (_) -> ()
}]

def alive_Select_1105_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%Y : _, %X : _):
  %v1 = "llvm.copy" (%Y) : (_) -> (_)
  "llvm.return" (%v1) : (_) -> ()
}]
theorem alive_Select_1105  (w : Nat)   : alive_Select_1105_src w  ⊑ alive_Select_1105_tgt w  := by
  unfold alive_Select_1105_src alive_Select_1105_tgt
  simp_alive_peephole
  all_goals sorry --apply bitvec_Select_1105


-- Name:InstCombineShift: 239
-- precondition: true
/-
  %Op0 = shl %X, C
  %r = lshr %Op0, C

=>
  %Op0 = shl %X, C
  %r = and %X, (-1 u>> C)

-/
def alive_InstCombineShift__239_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%X : _, %C : _):
  %v1 = "llvm.shl" (%X,%C) : (_, _) -> (_)
  %v2 = "llvm.lshr" (%v1,%C) : (_, _) -> (_)
  "llvm.return" (%v2) : (_) -> ()
}]

def alive_InstCombineShift__239_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%X : _, %C : _):
  %v1 = "llvm.shl" (%X,%C) : (_, _) -> (_)
  %v2 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v3 = "llvm.lshr" (%v2,%C) : (_, _) -> (_)
  %v4 = "llvm.and" (%X,%v3) : (_, _) -> (_)
  "llvm.return" (%v4) : (_) -> ()
}]
theorem alive_InstCombineShift__239  (w : Nat)   : alive_InstCombineShift__239_src w  ⊑ alive_InstCombineShift__239_tgt w  := by
  unfold alive_InstCombineShift__239_src alive_InstCombineShift__239_tgt
  simp_alive_peephole
  sorry --apply bitvec_InstCombineShift__239


-- Name:InstCombineShift: 279
-- precondition: true
/-
  %Op0 = lshr %X, C
  %r = shl %Op0, C

=>
  %Op0 = lshr %X, C
  %r = and %X, (-1 << C)

-/
def alive_InstCombineShift__279_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%X : _, %C : _):
  %v1 = "llvm.lshr" (%X,%C) : (_, _) -> (_)
  %v2 = "llvm.shl" (%v1,%C) : (_, _) -> (_)
  "llvm.return" (%v2) : (_) -> ()
}]

def alive_InstCombineShift__279_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%X : _, %C : _):
  %v1 = "llvm.lshr" (%X,%C) : (_, _) -> (_)
  %v2 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v3 = "llvm.shl" (%v2,%C) : (_, _) -> (_)
  %v4 = "llvm.and" (%X,%v3) : (_, _) -> (_)
  "llvm.return" (%v4) : (_) -> ()
}]
theorem alive_InstCombineShift__279  (w : Nat)   : alive_InstCombineShift__279_src w  ⊑ alive_InstCombineShift__279_tgt w  := by
  unfold alive_InstCombineShift__279_src alive_InstCombineShift__279_tgt
  simp_alive_peephole
  sorry --apply bitvec_InstCombineShift__279


-- Name:InstCombineShift: 440
-- precondition: true
/-
  %s = lshr %X, C
  %Op1 = and %s, C2
  %Op0 = xor %Y, %Op1
  %r = shl %Op0, C

=>
  %a = and %X, (C2 << C)
  %y2 = shl %Y, C
  %s = lshr %X, C
  %Op1 = and %s, C2
  %Op0 = xor %Y, %Op1
  %r = xor %a, %y2

-/
def alive_InstCombineShift__440_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%Y : _, %X : _, %C : _, %C2 : _):
  %v1 = "llvm.lshr" (%X,%C) : (_, _) -> (_)
  %v2 = "llvm.and" (%v1,%C2) : (_, _) -> (_)
  %v3 = "llvm.xor" (%Y,%v2) : (_, _) -> (_)
  %v4 = "llvm.shl" (%v3,%C) : (_, _) -> (_)
  "llvm.return" (%v4) : (_) -> ()
}]

def alive_InstCombineShift__440_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%Y : _, %X : _, %C : _, %C2 : _):
  %v1 = "llvm.shl" (%C2,%C) : (_, _) -> (_)
  %v2 = "llvm.and" (%X,%v1) : (_, _) -> (_)
  %v3 = "llvm.shl" (%Y,%C) : (_, _) -> (_)
  %v4 = "llvm.lshr" (%X,%C) : (_, _) -> (_)
  %v5 = "llvm.and" (%v4,%C2) : (_, _) -> (_)
  %v6 = "llvm.xor" (%Y,%v5) : (_, _) -> (_)
  %v7 = "llvm.xor" (%v2,%v3) : (_, _) -> (_)
  "llvm.return" (%v7) : (_) -> ()
}]
theorem alive_InstCombineShift__440  (w : Nat)   : alive_InstCombineShift__440_src w  ⊑ alive_InstCombineShift__440_tgt w  := by
  unfold alive_InstCombineShift__440_src alive_InstCombineShift__440_tgt
  simp_alive_peephole
  all_goals sorry --apply bitvec_InstCombineShift__440


-- Name:InstCombineShift: 476
-- precondition: true
/-
  %shr = lshr %X, C
  %s = and %shr, C2
  %Op0 = or %s, %Y
  %r = shl %Op0, C

=>
  %s2 = shl %Y, C
  %a = and %X, (C2 << C)
  %shr = lshr %X, C
  %s = and %shr, C2
  %Op0 = or %s, %Y
  %r = or %a, %s2

-/
def alive_InstCombineShift__476_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%Y : _, %X : _, %C : _, %C2 : _):
  %v1 = "llvm.lshr" (%X,%C) : (_, _) -> (_)
  %v2 = "llvm.and" (%v1,%C2) : (_, _) -> (_)
  %v3 = "llvm.or" (%v2,%Y) : (_, _) -> (_)
  %v4 = "llvm.shl" (%v3,%C) : (_, _) -> (_)
  "llvm.return" (%v4) : (_) -> ()
}]

def alive_InstCombineShift__476_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%Y : _, %X : _, %C : _, %C2 : _):
  %v1 = "llvm.shl" (%Y,%C) : (_, _) -> (_)
  %v2 = "llvm.shl" (%C2,%C) : (_, _) -> (_)
  %v3 = "llvm.and" (%X,%v2) : (_, _) -> (_)
  %v4 = "llvm.lshr" (%X,%C) : (_, _) -> (_)
  %v5 = "llvm.and" (%v4,%C2) : (_, _) -> (_)
  %v6 = "llvm.or" (%v5,%Y) : (_, _) -> (_)
  %v7 = "llvm.or" (%v3,%v1) : (_, _) -> (_)
  "llvm.return" (%v7) : (_) -> ()
}]
theorem alive_InstCombineShift__476  (w : Nat)   : alive_InstCombineShift__476_src w  ⊑ alive_InstCombineShift__476_tgt w  := by
  unfold alive_InstCombineShift__476_src alive_InstCombineShift__476_tgt
  simp_alive_peephole
  all_goals sorry --apply bitvec_InstCombineShift__476


-- Name:InstCombineShift: 497
-- precondition: true
/-
  %Op0 = xor %X, C2
  %r = lshr %Op0, C

=>
  %s2 = lshr %X, C
  %Op0 = xor %X, C2
  %r = xor %s2, (C2 u>> C)

-/
def alive_InstCombineShift__497_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%X : _, %C : _, %C2 : _):
  %v1 = "llvm.xor" (%X,%C2) : (_, _) -> (_)
  %v2 = "llvm.lshr" (%v1,%C) : (_, _) -> (_)
  "llvm.return" (%v2) : (_) -> ()
}]

def alive_InstCombineShift__497_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%X : _, %C : _, %C2 : _):
  %v1 = "llvm.lshr" (%X,%C) : (_, _) -> (_)
  %v2 = "llvm.xor" (%X,%C2) : (_, _) -> (_)
  %v3 = "llvm.lshr" (%C2,%C) : (_, _) -> (_)
  %v4 = "llvm.xor" (%v1,%v3) : (_, _) -> (_)
  "llvm.return" (%v4) : (_) -> ()
}]
theorem alive_InstCombineShift__497  (w : Nat)   : alive_InstCombineShift__497_src w  ⊑ alive_InstCombineShift__497_tgt w  := by
  unfold alive_InstCombineShift__497_src alive_InstCombineShift__497_tgt
  simp_alive_peephole
  sorry --apply bitvec_InstCombineShift__497


-- Name:InstCombineShift: 497'''
-- precondition: true
/-
  %Op0 = add %X, C2
  %r = shl %Op0, C

=>
  %s2 = shl %X, C
  %Op0 = add %X, C2
  %r = add %s2, (C2 << C)

-/
def alive_InstCombineShift__497'''_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%X : _, %C : _, %C2 : _):
  %v1 = "llvm.add" (%X,%C2) : (_, _) -> (_)
  %v2 = "llvm.shl" (%v1,%C) : (_, _) -> (_)
  "llvm.return" (%v2) : (_) -> ()
}]

def alive_InstCombineShift__497'''_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%X : _, %C : _, %C2 : _):
  %v1 = "llvm.shl" (%X,%C) : (_, _) -> (_)
  %v2 = "llvm.add" (%X,%C2) : (_, _) -> (_)
  %v3 = "llvm.shl" (%C2,%C) : (_, _) -> (_)
  %v4 = "llvm.add" (%v1,%v3) : (_, _) -> (_)
  "llvm.return" (%v4) : (_) -> ()
}]
theorem alive_InstCombineShift__497'''  (w : Nat)   : alive_InstCombineShift__497'''_src w  ⊑ alive_InstCombineShift__497'''_tgt w  := by
  unfold alive_InstCombineShift__497'''_src alive_InstCombineShift__497'''_tgt
  simp_alive_peephole
  sorry --apply bitvec_InstCombineShift__497'''


-- Name:InstCombineShift: 582
-- precondition: true
/-
  %Op0 = shl %X, C
  %r = lshr %Op0, C

=>
  %Op0 = shl %X, C
  %r = and %X, (-1 u>> C)

-/
def alive_InstCombineShift__582_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%X : _, %C : _):
  %v1 = "llvm.shl" (%X,%C) : (_, _) -> (_)
  %v2 = "llvm.lshr" (%v1,%C) : (_, _) -> (_)
  "llvm.return" (%v2) : (_) -> ()
}]

def alive_InstCombineShift__582_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%X : _, %C : _):
  %v1 = "llvm.shl" (%X,%C) : (_, _) -> (_)
  %v2 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v3 = "llvm.lshr" (%v2,%C) : (_, _) -> (_)
  %v4 = "llvm.and" (%X,%v3) : (_, _) -> (_)
  "llvm.return" (%v4) : (_) -> ()
}]
theorem alive_InstCombineShift__582  (w : Nat)   : alive_InstCombineShift__582_src w  ⊑ alive_InstCombineShift__582_tgt w  := by
  unfold alive_InstCombineShift__582_src alive_InstCombineShift__582_tgt
  simp_alive_peephole
  sorry --apply bitvec_InstCombineShift__582
