
import SSA.Projects.InstCombine.LLVM.EDSL
import SSA.Projects.InstCombine.AliveStatements
import SSA.Projects.InstCombine.Refinement
import SSA.Projects.InstCombine.Tactic

open MLIR AST
open Std (BitVec)
open Ctxt (Var)

namespace AliveAutoGenerated
set_option pp.proofs true
set_option pp.proofs.withType true
set_option linter.deprecated false

def src_i1 (w : Nat) :=
[alive_icom| {
^bb0(%a : i1):
  "llvm.return" (%a) : (i1) -> ()
}]

def src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%a : _):
  "llvm.return" (%a) : (_) -> ()
}]

def tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%a : _):
  %v1 = "llvm.mul" (%a,%a) : (_, _) -> (_)
  "llvm.return" (%v1) : (_) -> ()
}]

#check src
#check src_i1

open Ctxt

/-- This one does not have the 'snoc' leftover. -/
theorem ok  : src 1  ⊑ tgt 1  := by
  unfold tgt
  dsimp only [Com.Refinement]
  intros Γv
  change_mlir_context Γv

  simp (config := {failIfUnchanged := false}) only [Com.denote]
  simp (config := {failIfUnchanged := false}) only [Expr.denote]
  simp (config := {failIfUnchanged := false}) only [HVector.denote]
  simp (config := {failIfUnchanged := false}) only [HVector.map]
  simp (config := {failIfUnchanged := false}) only [List.map_eq_map]
  simp (config := {failIfUnchanged := false}) only [Var.zero_eq_last]
  simp (config := {failIfUnchanged := false}) only [Valuation.snoc_last]

  simp (config := {failIfUnchanged := false}) only [OpDenote.denote]

      -- `simp` might close trivial goals, so we use `first | done | ...` to ensure we only run
      -- more tactics when we still have goals to solve, to avoid 'no goals to be solved' errors.
  first
      | done
      | simp (config := {failIfUnchanged := false}) only [Ctxt.Var.toSnoc, Ctxt.Var.last]
        repeat (generalize_or_fail at Γv)
        -- As per the note in `generalize_or_fail`, it might close trivial goals
        -- So, we wrap the next tactic in another `first | done | ...` tactic

  simp (config := {failIfUnchanged := false}) only [
            InstCombine.Op.denote, HVector.getN, HVector.get
          ]

        -- As per the note in `generalize_or_fail`, it might close trivial goals
        -- So, we wrap the next tactic in another `first | done | ...` tactic

  -- Γv✝ : Ctxt.Valuation [InstCombine.MTy.bitvec (ConcreteOrMVar.concrete 1)]
  -- ∀ (e : Option (_root_.BitVec 1)), Com.denote (src 1) Γv✝ ⊑ LLVM.mul e

/-- This one has the 'snoc' leftover. -/
theorem broken  : src_i1 1 ⊑ tgt 1  := by
  unfold tgt
  -- Γv✝ : Ctxt.Valuation [InstCombine.MTy.bitvec (ConcreteOrMVar.concrete 1)]
  -- ∀ (e : Option (_root_.BitVec 1)),
  -- Com.denote (src_i1 1) Γv✝ ⊑ Ctxt.Valuation.snoc Γv✝ (LLVM.mul e e) { val := 0, property := ⋯ }
  dsimp only [Com.Refinement]
  intros Γv
  change_mlir_context Γv

  simp (config := {failIfUnchanged := false}) only [Com.denote]
  simp (config := {failIfUnchanged := false}) only [Expr.denote]
  simp (config := {failIfUnchanged := false}) only [HVector.denote]
  simp (config := {failIfUnchanged := false}) only [HVector.map]
  simp (config := {failIfUnchanged := false}) only [List.map_eq_map]
  simp (config := {failIfUnchanged := false}) only [Var.zero_eq_last]
  simp (config := {failIfUnchanged := false}) only [Valuation.snoc_last] -- <= This one does not fire!

  simp (config := {failIfUnchanged := false}) only [OpDenote.denote]

      -- `simp` might close trivial goals, so we use `first | done | ...` to ensure we only run
      -- more tactics when we still have goals to solve, to avoid 'no goals to be solved' errors.
  first
      | done
      | simp (config := {failIfUnchanged := false}) only [Ctxt.Var.toSnoc, Ctxt.Var.last]
        repeat (generalize_or_fail at Γv)
        -- As per the note in `generalize_or_fail`, it might close trivial goals
        -- So, we wrap the next tactic in another `first | done | ...` tactic

  simp (config := {failIfUnchanged := false}) only [
            InstCombine.Op.denote, HVector.getN, HVector.get
          ]
