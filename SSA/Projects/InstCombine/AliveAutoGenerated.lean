import SSA.Projects.InstCombine.LLVM.EDSL
import SSA.Projects.InstCombine.Tactic
import Mathlib.Tactic
open MLIR AST

namespace AliveAutoGenerated

abbrev ICom.Refinement (src tgt : Com (φ:=0) Γ t) (h : Goedel.toType t = Option α := by rfl) : Prop :=
  ∀ Γv, Bitvec.Refinement (h ▸ src.denote Γv) (h ▸ tgt.denote Γv)

infixr:90 " ⊑ "  => ICom.Refinement

namespace OnlyReturn
def lhs (w : Nat) :=
[mlir_icom (w)| {
^bb0(%C1 : _):
  "llvm.return" (%C1) : (_) -> ()
}]

def rhs (w : Nat):=
[mlir_icom (w)| {
^bb0(%C1 : _):
  "llvm.return" (%C1) : (_) -> ()
}]

open Ctxt (Var) in
theorem refinement (w : Nat) : lhs w ⊑ rhs w := by
  unfold lhs rhs
  intro (Γv : ([.bitvec w] : List InstCombine.Ty) |> Ctxt.Valuation)
  simp [ICom.denote, IExpr.denote, HVector.denote, Var.zero_eq_last, Var.succ_eq_toSnoc,
        Ctxt.snoc, Ctxt.Valuation.snoc_last, Ctxt.ofList, Ctxt.Valuation.snoc_toSnoc,
        HVector.map, OpDenote.denote, IExpr.op_mk, IExpr.args_mk, ICom.Refinement,
        Bind.bind, DialectMorphism.mapTy, MOp.instantiateCom,
        InstCombine.MTy.instantiate, ConcreteOrMVar.instantiate, Vector.get, List.get]
  generalize Γv (Var.last [] (InstCombine.MTy.bitvec (ConcreteOrMVar.concrete w))) = x
  -- simp_alive
  apply Bitvec.Refinement.refl
end OnlyReturn


namespace AddCommutative
def lhs (w : Nat) :=
[mlir_icom (w)| {
^bb0(%X : _, %Y: _):
  %Z = "llvm.add" (%X, %Y) : (_, _) -> (_)
  "llvm.return" (%Z) : (_) -> ()
}]

def rhs (w : Nat):=
[mlir_icom (w)| {
^bb0(%X : _, %Y: _):
  %Z = "llvm.add" (%Y, %X) : (_, _) -> (_)
  "llvm.return" (%Z) : (_) -> ()
}]

open Ctxt (Var) in
theorem refinement (w : Nat) : lhs w ⊑ rhs w := by
  unfold lhs rhs
  intro (Γv : ([.bitvec w, .bitvec w] : List InstCombine.Ty) |> Ctxt.Valuation)
  simp [ICom.denote, IExpr.denote, HVector.denote, Var.zero_eq_last, Var.succ_eq_toSnoc,
        Ctxt.snoc, Ctxt.Valuation.snoc_last, Ctxt.ofList, Ctxt.Valuation.snoc_toSnoc,
        HVector.map, OpDenote.denote, IExpr.op_mk, IExpr.args_mk, ICom.Refinement,
        Bind.bind, DialectMorphism.mapTy, MOp.instantiateCom,
        InstCombine.MTy.instantiate, ConcreteOrMVar.instantiate, Vector.get, List.get]
  sorry
end AddCommutative


-- Name:AddSub:1043
-- precondition: true
/-
  %Y = and %Z, C1
  %X = xor %Y, C1
  %LHS = add %X, 1
  %r = add %LHS, %RHS

=>
  %or = or %Z, ~C1
  %Y = and %Z, C1
  %X = xor %Y, C1
  %LHS = add %X, 1
  %r = sub %RHS, %or

-/
def AddSub_1043_src (w : Nat) :=
[mlir_icom (w)| {
^bb0(%C1 : _, %Z : _, %RHS : _):
  %v1 = "llvm.and" (%Z,%C1) : (_, _) -> (_)
  %v2 = "llvm.xor" (%v1,%C1) : (_, _) -> (_)
  %v3 = "llvm.mlir.constant" () { value = 1 : _ } :() -> (_)
  %v4 = "llvm.add" (%v2,%v3) : (_, _) -> (_)
  %v5 = "llvm.add" (%v4,%RHS) : (_, _) -> (_)
  "llvm.return" (%v5) : (_) -> ()
}]

set_option pp.proofs false
#check AddSub_1043_src
#reduce AddSub_1043_src

#check Com

def AddSub_1043_tgt (w : Nat):=
[mlir_icom (w)| {
^bb0(%C1 : _, %Z : _, %RHS : _):
  %v1 = "llvm.not" (%C1) : (_) -> (_)
  %v2 = "llvm.or" (%Z,%v1) : (_, _) -> (_)
  %v3 = "llvm.and" (%Z,%C1) : (_, _) -> (_)
  %v4 = "llvm.xor" (%v3,%C1) : (_, _) -> (_)
  %v5 = "llvm.mlir.constant" () { value = 1 : _ } :() -> (_)
  %v6 = "llvm.add" (%v4,%v5) : (_, _) -> (_)
  %v7 = "llvm.sub" (%RHS,%v2) : (_, _) -> (_)
  "llvm.return" (%v7) : (_) -> ()
}]

#check Option.bind
theorem MOp.MOp.instantiateCom_unary_bitvec (w : Nat) :
  (MLIR.AST.MOp.instantiateCom (φ := 1)
    { val := [w], property := rfl : Vector Nat 1 }).mapTy (InstCombine.MTy.bitvec (Width.mvar 0)) =
    InstCombine.MTy.bitvec (Width.concrete w) := by
  simp[MOp.instantiateCom, InstCombine.MTy.instantiate, ConcreteOrMVar.instantiate,
      Vector.get]


theorem DerivedContext.ofContext_empty {φ : ℕ} : DerivedContext.ofContext (φ := φ) [] = ⟨[], .zero _⟩ := by
  simp[DerivedContext.ofContext]

theorem List.nthLe_unary_0 (w : α) :
  List.nthLe [w] 0 (by simp) = w := rfl

-- theorem Valuation_snoc {Ty : Type} [Goedel Ty]
--   (Γ' : Ctxt Ty) (α : Ty) (Γv : Ctxt.Valuation (α :: Γ')) :
--   { val : ⟦α⟧ × Ctxt.Valuation Γ' // Γv = val.snd.snoc val.fst } := by
--   simp[Ctxt.Valuation] at Γv
--   let v1 := Γv (Ctxt.Var.last Γ')
--   constructor


/--
- We first generalize `v0...vn`, which gives us names for the accessors of the context.
- Then we `cases` on these, to clear away the case where the variables could be `none`, leaving us with the
  interesting case where the variable is a `some value`.
- At this point, the proof state is what we want. However, the names `x0..xn` are *inaccessible* to the
  user since the names were generated from within the macro.
- So, we choose to revert the variables `x0...xn` so that the user can introduce them as she likes.
- If we directly revert `x0...xn`, we wind up getting a proof state of the form
    `∀ x0 V0 ... xn Vn`, where the `{ Vi }` is pure noise.
- So we first clear the `V0...Vn` equations, and then revert `x0...xn`.
- This gives us a statement of the form `∀ x0... xn, GOAL`
-/
macro "simp_alive" : tactic =>
  `(tactic|
      (
      dsimp only[]
      unfold ICom.Refinement
      intros Γv
      simp only[ICom.denote, IExpr.denote, HVector.denote, OpDenote.denote, InstCombine.Op.denote, HVector.toPair, pairMapM,
        HVector.toTuple]
      simp[bind, Option.bind, pure]
      simp[DerivedContext.ofContext, DerivedContext.snoc, Ctxt.snoc] -- cannot rewrite with simp theorem 'motive is not type correct'
      simp[MOp.instantiateCom, InstCombine.MTy.instantiate, ConcreteOrMVar.instantiate,
          Vector.get, HVector.toSingle, HVector.toTuple]
      simp[List.nthLe]

      try generalize V0 : Γv (Ctxt.Var.last _ _) = v0
      try generalize V1 : Γv (Ctxt.Var.last _ _).toSnoc = v1
      try generalize V2 : Γv (Ctxt.Var.last _ _).toSnoc.toSnoc = v2
      try generalize V3 : Γv (Ctxt.Var.last _ _).toSnoc.toSnoc.toSnoc = v3
      try generalize V4 : Γv (Ctxt.Var.last _ _).toSnoc.toSnoc.toSnoc.toSnoc = v4
      try generalize V5 : Γv (Ctxt.Var.last _ _).toSnoc.toSnoc.toSnoc.toSnoc.toSnoc = v5

      try simp[Goedel.toType] at v0
      try simp[Goedel.toType] at v1
      try simp[Goedel.toType] at v2
      try simp[Goedel.toType] at v3
      try simp[Goedel.toType] at v4
      try simp[Goedel.toType] at v5
      /- cases on variables, eliminating trivial `none` cases. -/
      try cases' v0 with x0 <;> simp
      <;> try cases' v1 with x1 <;> simp
      <;> try cases' v2 with x2 <;> simp
      <;> try cases' v3 with x3 <;> simp
      <;> try cases' v4 with x4 <;> simp
      <;> try cases' v5 with x5 <;> simp
      try clear V0
      try clear V1
      try clear V2
      try clear V3
      try clear V4
      try clear V5

      try revert x0
      try revert x1
      try revert x2
      try revert x3
      try revert x4
      try revert x5
      )
   )

set_option pp.proofs false in
set_option pp.proofs.withType false in
-- set_option maxHeartbeats 900000 in
open Ctxt (Var) in
theorem AddSub_1043_refinement (w : Nat) : AddSub_1043_src w ⊑ AddSub_1043_tgt w := by
  /- unfolding -/
  unfold AddSub_1043_src
  unfold AddSub_1043_tgt
  /- simplification -/
  simp_alive
  sorry

end AliveAutoGenerated