import SSA.Projects.InstCombine.LLVM.EDSL
import SSA.Projects.InstCombine.AliveStatements
import Mathlib.Tactic
open MLIR AST

open Std (BitVec)

namespace AliveAutoGenerated

abbrev ICom.Refinement (src tgt : Com (φ:=0) Γ t) (h : Goedel.toType t = Option α := by rfl) : Prop :=
  ∀ Γv, (h ▸ src.denote Γv) ⊑ (h ▸ tgt.denote Γv)

infixr:90 (priority:=high) " ⊑ "  => ICom.Refinement

/- TODO: is this theorem true? -/
@[simp]
theorem BitVec.ofNat_zero : BitVec.ofNat w 0 = 0 :=
  rfl

@[simp]
theorem one_by_two_is_zero : 1 / 2 = (0 : Nat) := rfl

@[simp]
theorem BitVec.ofNat_one : BitVec.ofNat w 1 = 1 :=
  rfl

#check HVector.toPair
#check pairMapM

/--
- We first generalize `v0...vn`, which gives us names for the accessors of the context.
- Then we `cases` on these, to clear away the case where the variables could be `none`, leaving us with the
  interesting case where the variable is a `some value`.
- At this point, the proof state is what we want. However, the names `x0..xn` are *inaccessible* to the
  user since the names were generated from within the macro.
- So, we choose to revert the variables `x0...xn` so that the user can introduce them as she likes.
- If we directly revert `x0...xn`, we wind up getting a proof state of the form
    `∀ x0 V0 ... xn Vn`, where the `{ Vi }` is pure noise.
- So we first clear the `V0...Vn` equations, and then revert `x0...xn`.
- This gives us a statement of the form `∀ x0... xn, GOAL`
-/
macro "simp_mlir" Γv:ident : tactic =>
  `(tactic|
      (
      dsimp only[]
      unfold ICom.Refinement
      simp_peephole at $Γv
      try simp only[ICom.denote, IExpr.denote, HVector.denote, OpDenote.denote, InstCombine.Op.denote, HVector.toPair, pairMapM,
        HVector.toTuple, BitVec.Refinement]
      try simp[bind, Option.bind, pure]
      try simp[DerivedContext.ofContext, DerivedContext.snoc, Ctxt.snoc] -- cannot rewrite with simp theorem 'motive is not type correct'
      try simp[MOp.instantiateCom, InstCombine.MTy.instantiate, ConcreteOrMVar.instantiate,
          Vector.get, HVector.toSingle, HVector.toTuple]
      try simp[List.nthLe]

      try generalize V0 : Γv (Ctxt.Var.last _ _) = v0
      try generalize V1 : Γv (Ctxt.Var.last _ _).toSnoc = v1
      try generalize V2 : Γv (Ctxt.Var.last _ _).toSnoc.toSnoc = v2
      try generalize V3 : Γv (Ctxt.Var.last _ _).toSnoc.toSnoc.toSnoc = v3
      try generalize V4 : Γv (Ctxt.Var.last _ _).toSnoc.toSnoc.toSnoc.toSnoc = v4
      try generalize V5 : Γv (Ctxt.Var.last _ _).toSnoc.toSnoc.toSnoc.toSnoc.toSnoc = v5

      try simp[Goedel.toType] at v0
      try simp[Goedel.toType] at v1
      try simp[Goedel.toType] at v2
      try simp[Goedel.toType] at v3
      try simp[Goedel.toType] at v4
      try simp[Goedel.toType] at v5
      
      -- /- cases on variables, eliminating trivial `none` cases. -/
      -- try cases' v0 with x0 <;> simp
      -- <;> try cases' v1 with x1 <;> simp
      -- <;> try cases' v2 with x2 <;> simp
      -- <;> try cases' v3 with x3 <;> simp
      -- <;> try cases' v4 with x4 <;> simp
      -- <;> try cases' v5 with x5 <;> simp
      try clear V0
      try clear V1
      try clear V2
      try clear V3
      try clear V4
      try clear V5

      try revert v5
      try revert v4
      try revert v3
      try revert v2
      try revert v1
      try revert v0

      -- try revert x5
      -- try revert x4
      -- try revert x3
      -- try revert x2
      -- try revert x1
      -- try revert x0
      )
   )

namespace OnlyReturn
def lhs (w : Nat) :=
[mlir_icom (w)| {
^bb0(%C1 : _):
  "llvm.return" (%C1) : (_) -> ()
}]

def rhs (w : Nat):=
[mlir_icom (w)| {
^bb0(%C1 : _):
  "llvm.return" (%C1) : (_) -> ()
}]

open Ctxt (Var) in
theorem refinement (w : Nat) : lhs w ⊑ rhs w := by
  dsimp only[ICom.Refinement]
  intros Γv
  simp_peephole [lhs, rhs] at Γv
  intros a
  simp[Std.BitVec.Refinement.refl]
  done

end OnlyReturn

-- Name:AddSub:1043
-- precondition: true
/-
  %Y = and %Z, C1
  %X = xor %Y, C1
  %LHS = add %X, 1
  %r = add %LHS, %RHS

=>
  %or = or %Z, ~C1
  %Y = and %Z, C1
  %X = xor %Y, C1
  %LHS = add %X, 1
  %r = sub %RHS, %or

-/
def AddSub_1043_src (w : Nat) :=
[mlir_icom (w)| {
^bb0(%C1 : _, %Z : _, %RHS : _):
  %v1 = "llvm.and" (%Z,%C1) : (_, _) -> (_)
  %v2 = "llvm.xor" (%v1,%C1) : (_, _) -> (_)
  %v3 = "llvm.mlir.constant" () { value = 1 : _ } :() -> (_)
  %v4 = "llvm.add" (%v2,%v3) : (_, _) -> (_)
  %v5 = "llvm.add" (%v4,%RHS) : (_, _) -> (_)
  "llvm.return" (%v5) : (_) -> ()
}]

def AddSub_1043_tgt (w : Nat):=
[mlir_icom (w)| {
^bb0(%C1 : _, %Z : _, %RHS : _):
  %v1 = "llvm.not" (%C1) : (_) -> (_)
  %v2 = "llvm.or" (%Z,%v1) : (_, _) -> (_)
  %v3 = "llvm.and" (%Z,%C1) : (_, _) -> (_)
  %v4 = "llvm.xor" (%v3,%C1) : (_, _) -> (_)
  %v5 = "llvm.mlir.constant" () { value = 1 : _ } :() -> (_)
  %v6 = "llvm.add" (%v4,%v5) : (_, _) -> (_)
  %v7 = "llvm.sub" (%RHS,%v2) : (_, _) -> (_)
  "llvm.return" (%v7) : (_) -> ()
}]


set_option pp.proofs false in
set_option pp.proofs.withType false in
open Ctxt (Var) in
theorem AddSub_1043_refinement (w : Nat) : AddSub_1043_src w ⊑ AddSub_1043_tgt w := by
  dsimp only[ICom.Refinement]
  intros Γv
  rw[AddSub_1043_src, AddSub_1043_tgt]
  try simp only[ICom.denote, IExpr.denote, HVector.denote, OpDenote.denote, InstCombine.Op.denote, HVector.toPair, pairMapM,
  HVector.toTuple, BitVec.Refinement]
  try simp[bind, Option.bind, pure]
  try simp[DerivedContext.ofContext, DerivedContext.snoc, Ctxt.snoc] -- cannot rewrite with simp theorem 'motive is not type correct'
  try simp[MOp.instantiateCom, InstCombine.MTy.instantiate, ConcreteOrMVar.instantiate,
      Vector.get, HVector.toSingle, HVector.toTuple]
  try simp[List.nthLe]
  simp_peephole at Γv
  try intros v0
  try intros v1
  try intros v2
  try intros v3
  try intros v4
  try intros v5
  try cases' v0 with x0 <;> simp
    <;> try cases' v1 with x1 <;> simp
    <;> try cases' v2 with x2 <;> simp
    <;> try cases' v3 with x3 <;> simp
    <;> try cases' v4 with x4 <;> simp
    <;> try cases' v5 with x5 <;> simp
  apply bitvec_AddSub_1043
  done

end AliveAutoGenerated
