/-
Released under Apache 2.0 license as described in the file LICENSE.
-/
import Mathlib.Tactic.Ring
import Std.Data.BitVec
import Mathlib.Data.BitVec.Lemmas

import SSA.Projects.InstCombine.LLVM.EDSL
import Std.Data.BitVec

attribute [simp_llvm_case_bash]
  BitVec.Refinement.refl BitVec.Refinement.some_some BitVec.Refinement.none_left
  bind_assoc forall_const
  Option.bind_eq_bind Option.none_bind Option.bind_none Option.some_bind Option.pure_def
  BitVec.reduceOfInt Nat.cast_one
/- `reduceOfInt` and `Nat.cast_one` are somewhat questionable additions to this simp-set.
   They are not needed for the case-bashing to succeed, but they are simp-lemmas that were
   previously being applied in `AliveAutoGenerated`, where they closed a few trivial goals,
   so they've been preserved to not change this existing behaviour of `simp_alive_case_bash` -/

/--
`simp_alive_case_bash` transforms a goal of the form
  `∀ (x₁ : Option (BitVec _)) ... (xₙ : Option (BitVec _)), ...`
into a goal about just `BitVec`s, by doing a case distinction on each `Option`.

Then, we `simp`lify each goal, following the assumption that the `none` cases
should generally be trivial, hopefully leaving us with just a single goal:
the one where each option is `some`. -/
syntax "simp_alive_case_bash" : tactic
macro_rules
  | `(tactic| simp_alive_case_bash) => `(tactic|
    first
    | fail_if_success (intro (v : Option (_)))
      -- If there is no variable to introduce, `intro` fails, so the first branch succeeds,
      -- but does nothing. This is similar to `try`, except `first ...` does not swallow any errors
      -- that occur in the later tactics
    | intro (v : Option (_))    -- Introduce the variable,
      rcases v with _|x         -- Do the case distinction
      <;> simp (config:={failIfUnchanged := false}) only [simp_llvm_case_bash]
      --  ^^^^^^^^^^^^^^^^^^^^^^^^ Simplify, in the hopes that the `none` case is trivially closed
      <;> simp_alive_case_bash  -- Recurse, to case bash the next variable (if it exists)
      <;> (try revert x)        -- Finally, revert the variable we got in the `some` case, so that
                                --   we are left with a universally quantified goal of the form:
                                --   `∀ (x₁ : BitVec _) ... (xₙ : BitVec _), ...`
    )


/-- Unfold into the `undef' statements and eliminates as much as possible. -/
macro "simp_alive_undef" : tactic =>
  `(tactic|
      (
        simp (config := {failIfUnchanged := false}) only [
            simp_llvm_option,
            BitVec.Refinement, bind_assoc,
          ]
      )
  )

/- Simplify away the `InstCombine` specific semantics. -/
macro "simp_alive_ops" : tactic =>
  `(tactic|
      (
        simp (config := {failIfUnchanged := false}) only [
            simp_llvm, BitVec.bitvec_minus_one, pure_bind
          ]
      )
  )

macro "alive_auto": tactic =>
  `(tactic|
      (
        intros
        (try simp (config := {decide := false}) [-Std.BitVec.ofNat_eq_ofNat])
        try ring_nf
        try solve | (ext; simp;
                     try cases BitVec.getLsb _ _ <;> try simp;
                     try cases BitVec.getLsb _ _ <;> try simp;
                     try cases BitVec.getLsb _ _ <;> try simp;
                     try cases BitVec.getLsb _ _ <;> try simp;)
      )
   )
