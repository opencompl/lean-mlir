
/-
Released under Apache 2.0 license as described in the file LICENSE.
-/
import SSA.Projects.InstCombine.LLVM.EDSL
import SSA.Projects.InstCombine.AliveStatements
import SSA.Projects.InstCombine.Refinement
import SSA.Projects.InstCombine.Tactic

open MLIR AST
open Std (BitVec)
open Ctxt (Var)

namespace AliveAutoGenerated
set_option pp.proofs false
set_option pp.proofs.withType false
set_option linter.deprecated false



-- Name:AndOrXor:698
-- precondition: true
/-
  %a1 = and %a, %b
  %a2 = and %a, %d
  %op0 = icmp eq %a1, 0
  %op1 = icmp eq %a2, 0
  %r = and %op0, %op1

=>
  %or = or %b, %d
  %a3 = and %a, %or
  %a1 = and %a, %b
  %a2 = and %a, %d
  %op0 = icmp eq %a1, 0
  %op1 = icmp eq %a2, 0
  %r = icmp eq %a3, 0

-/
def alive_AndOrXor_698_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _, %d : _):
  %v1 = "llvm.and" (%a,%b) : (_, _) -> (i1)
  %v2 = "llvm.and" (%a,%d) : (_, _) -> (i1)
  %v3 = "llvm.mlir.constant" () { value = 0 : i1 } :() -> (i1)
  %v4 = "llvm.icmp.eq" (%v1,%v3) : (_, _) -> (i1)
  %v5 = "llvm.mlir.constant" () { value = 0 : i1 } :() -> (i1)
  %v6 = "llvm.icmp.eq" (%v2,%v5) : (_, _) -> (i1)
  %v7 = "llvm.and" (%v4,%v6) : (i1, i1) -> (i1)
  "llvm.return" (%v7) : (i1) -> ()
}]

def alive_AndOrXor_698_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _, %d : _):
  %v1 = "llvm.or" (%b,%d) : (_, _) -> (i1)
  %v2 = "llvm.and" (%a,%v1) : (_, _) -> (i1)
  %v3 = "llvm.and" (%a,%b) : (_, _) -> (_)
  %v4 = "llvm.and" (%a,%d) : (_, _) -> (_)
  %v5 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v6 = "llvm.icmp.eq" (%v3,%v5) : (_, _) -> (i1)
  %v7 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v8 = "llvm.icmp.eq" (%v4,%v7) : (_, _) -> (i1)
  %v9 = "llvm.mlir.constant" () { value = 0 : i1 } :() -> (i1)
  %v10 = "llvm.icmp.eq" (%v2,%v9) : (_, _) -> (i1)
  "llvm.return" (%v10) : (i1) -> ()
}]
theorem alive_AndOrXor_698  (w : Nat)   : alive_AndOrXor_698_src w  ⊑ alive_AndOrXor_698_tgt w  := by
  unfold alive_AndOrXor_698_src alive_AndOrXor_698_tgt
  simp_alive_ssa
  print_goal_as_error
  sorry -- apply bitvec_AndOrXor_698


-- Name:AndOrXor:827
-- precondition: true
/-
  %op0 = icmp eq %a, 0
  %op1 = icmp eq %b, 0
  %r = and %op0, %op1

=>
  %o = or %a, %b
  %op0 = icmp eq %a, 0
  %op1 = icmp eq %b, 0
  %r = icmp eq %o, 0

-/
def alive_AndOrXor_827_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.mlir.constant" () { value = 0 : i1 } :() -> (i1)
  %v2 = "llvm.icmp.eq" (%a,%v1) : (_, _) -> (i1)
  %v3 = "llvm.mlir.constant" () { value = 0 : i1 } :() -> (i1)
  %v4 = "llvm.icmp.eq" (%b,%v3) : (_, _) -> (i1)
  %v5 = "llvm.and" (%v2,%v4) : (i1, i1) -> (i1)
  "llvm.return" (%v5) : (i1) -> ()
}]

def alive_AndOrXor_827_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.or" (%a,%b) : (_, _) -> (i1)
  %v2 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v3 = "llvm.icmp.eq" (%a,%v2) : (_, _) -> (i1)
  %v4 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v5 = "llvm.icmp.eq" (%b,%v4) : (_, _) -> (i1)
  %v6 = "llvm.mlir.constant" () { value = 0 : i1 } :() -> (i1)
  %v7 = "llvm.icmp.eq" (%v1,%v6) : (_, _) -> (i1)
  "llvm.return" (%v7) : (i1) -> ()
}]
theorem alive_AndOrXor_827  (w : Nat)   : alive_AndOrXor_827_src w  ⊑ alive_AndOrXor_827_tgt w  := by
  unfold alive_AndOrXor_827_src alive_AndOrXor_827_tgt
  simp_alive_ssa
  print_goal_as_error
  sorry -- apply bitvec_AndOrXor_827


-- Name:AndOrXor:1704
-- precondition: true
/-
  %cmp1 = icmp eq %B, 0
  %cmp2 = icmp ult %A, %B
  %r = or %cmp1, %cmp2

=>
  %b1 = add %B, -1
  %cmp1 = icmp eq %B, 0
  %cmp2 = icmp ult %A, %B
  %r = icmp uge %b1, %A

-/
def alive_AndOrXor_1704_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.mlir.constant" () { value = 0 : i1 } :() -> (i1)
  %v2 = "llvm.icmp.eq" (%B,%v1) : (_, _) -> (i1)
  %v3 = "llvm.icmp.ult" (%A,%B) : (_, _) -> (i1)
  %v4 = "llvm.or" (%v2,%v3) : (i1, i1) -> (i1)
  "llvm.return" (%v4) : (i1) -> ()
}]

def alive_AndOrXor_1704_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : i1 } :() -> (i1)
  %v2 = "llvm.add" (%B,%v1) : (_, _) -> (i1)
  %v3 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v4 = "llvm.icmp.eq" (%B,%v3) : (_, _) -> (i1)
  %v5 = "llvm.icmp.ult" (%A,%B) : (_, _) -> (i1)
  %v6 = "llvm.icmp.uge" (%v2,%A) : (_, _) -> (i1)
  "llvm.return" (%v6) : (i1) -> ()
}]
theorem alive_AndOrXor_1704  (w : Nat)   : alive_AndOrXor_1704_src w  ⊑ alive_AndOrXor_1704_tgt w  := by
  unfold alive_AndOrXor_1704_src alive_AndOrXor_1704_tgt
  simp_alive_ssa
  print_goal_as_error
  sorry -- apply bitvec_AndOrXor_1704


-- Name:AndOrXor:1705
-- precondition: true
/-
  %cmp1 = icmp eq %B, 0
  %cmp2 = icmp ugt %B, %A
  %r = or %cmp1, %cmp2

=>
  %b1 = add %B, -1
  %cmp1 = icmp eq %B, 0
  %cmp2 = icmp ugt %B, %A
  %r = icmp uge %b1, %A

-/
def alive_AndOrXor_1705_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.mlir.constant" () { value = 0 : i1 } :() -> (i1)
  %v2 = "llvm.icmp.eq" (%B,%v1) : (_, _) -> (i1)
  %v3 = "llvm.icmp.ugt" (%B,%A) : (_, _) -> (i1)
  %v4 = "llvm.or" (%v2,%v3) : (i1, i1) -> (i1)
  "llvm.return" (%v4) : (i1) -> ()
}]

def alive_AndOrXor_1705_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : i1 } :() -> (i1)
  %v2 = "llvm.add" (%B,%v1) : (_, _) -> (i1)
  %v3 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v4 = "llvm.icmp.eq" (%B,%v3) : (_, _) -> (i1)
  %v5 = "llvm.icmp.ugt" (%B,%A) : (_, _) -> (i1)
  %v6 = "llvm.icmp.uge" (%v2,%A) : (_, _) -> (i1)
  "llvm.return" (%v6) : (i1) -> ()
}]
theorem alive_AndOrXor_1705  (w : Nat)   : alive_AndOrXor_1705_src w  ⊑ alive_AndOrXor_1705_tgt w  := by
  unfold alive_AndOrXor_1705_src alive_AndOrXor_1705_tgt
  simp_alive_ssa
  print_goal_as_error
  sorry -- apply bitvec_AndOrXor_1705


-- Name:AndOrXor:1733
-- precondition: true
/-
  %cmp1 = icmp ne %A, 0
  %cmp2 = icmp ne %B, 0
  %r = or %cmp1, %cmp2

=>
  %or = or %A, %B
  %cmp1 = icmp ne %A, 0
  %cmp2 = icmp ne %B, 0
  %r = icmp ne %or, 0

-/
def alive_AndOrXor_1733_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.mlir.constant" () { value = 0 : i1 } :() -> (i1)
  %v2 = "llvm.icmp.ne" (%A,%v1) : (_, _) -> (i1)
  %v3 = "llvm.mlir.constant" () { value = 0 : i1 } :() -> (i1)
  %v4 = "llvm.icmp.ne" (%B,%v3) : (_, _) -> (i1)
  %v5 = "llvm.or" (%v2,%v4) : (i1, i1) -> (i1)
  "llvm.return" (%v5) : (i1) -> ()
}]

def alive_AndOrXor_1733_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%A : _, %B : _):
  %v1 = "llvm.or" (%A,%B) : (_, _) -> (i1)
  %v2 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v3 = "llvm.icmp.ne" (%A,%v2) : (_, _) -> (i1)
  %v4 = "llvm.mlir.constant" () { value = 0 : _ } :() -> (_)
  %v5 = "llvm.icmp.ne" (%B,%v4) : (_, _) -> (i1)
  %v6 = "llvm.mlir.constant" () { value = 0 : i1 } :() -> (i1)
  %v7 = "llvm.icmp.ne" (%v1,%v6) : (_, _) -> (i1)
  "llvm.return" (%v7) : (i1) -> ()
}]
theorem alive_AndOrXor_1733  (w : Nat)   : alive_AndOrXor_1733_src w  ⊑ alive_AndOrXor_1733_tgt w  := by
  unfold alive_AndOrXor_1733_src alive_AndOrXor_1733_tgt
  simp_alive_ssa
  print_goal_as_error
  sorry -- apply bitvec_AndOrXor_1733


-- Name:AndOrXor:2453
-- precondition: true
/-
  %op0 = icmp slt %x, %y
  %r = xor %op0, -1

=>
  %op0 = icmp slt %x, %y
  %r = icmp sge %x, %y

-/
def alive_AndOrXor_2453_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%y : _, %x : _):
  %v1 = "llvm.icmp.slt" (%x,%y) : (_, _) -> (i1)
  %v2 = "llvm.mlir.constant" () { value = -1 : i1 } :() -> (i1)
  %v3 = "llvm.xor" (%v1,%v2) : (i1, _) -> (i1)
  "llvm.return" (%v3) : (i1) -> ()
}]

def alive_AndOrXor_2453_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%y : _, %x : _):
  %v1 = "llvm.icmp.slt" (%x,%y) : (_, _) -> (i1)
  %v2 = "llvm.icmp.sge" (%x,%y) : (_, _) -> (i1)
  "llvm.return" (%v2) : (i1) -> ()
}]
theorem alive_AndOrXor_2453  (w : Nat)   : alive_AndOrXor_2453_src w  ⊑ alive_AndOrXor_2453_tgt w  := by
  unfold alive_AndOrXor_2453_src alive_AndOrXor_2453_tgt
  simp_alive_ssa
  print_goal_as_error
  sorry -- apply bitvec_AndOrXor_2453


-- Name:276
-- precondition: true
/-
  %div = sdiv i5 %X, %Y
  %negY = sub 0, %Y
  %r = mul %div, %negY

=>
  %rem = srem %X, %Y
  %div = sdiv i5 %X, %Y
  %negY = sub 0, %Y
  %r = sub %rem, %X

-/
def alive_276_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%Y : i5, %X : i5):
  %v1 = "llvm.sdiv" (%X,%Y) : (i5, i5) -> (i5)
  %v2 = "llvm.mlir.constant" () { value = 0 : i5 } :() -> (i5)
  %v3 = "llvm.sub" (%v2,%Y) : (_, i5) -> (i5)
  %v4 = "llvm.mul" (%v1,%v3) : (i5, i5) -> (i5)
  "llvm.return" (%v4) : (i5) -> ()
}]

def alive_276_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%Y : i5, %X : i5):
  %v1 = "llvm.srem" (%X,%Y) : (i5, i5) -> (i5)
  %v2 = "llvm.sdiv" (%X,%Y) : (i5, i5) -> (i5)
  %v3 = "llvm.mlir.constant" () { value = 0 : i5 } :() -> (i5)
  %v4 = "llvm.sub" (%v3,%Y) : (_, i5) -> (i5)
  %v5 = "llvm.sub" (%v1,%X) : (i5, i5) -> (i5)
  "llvm.return" (%v5) : (i5) -> ()
}]
theorem alive_276  (w : Nat)   : alive_276_src w  ⊑ alive_276_tgt w  := by
  unfold alive_276_src alive_276_tgt
  simp_alive_ssa
  print_goal_as_error
  sorry -- apply bitvec_276


-- Name:276-2
-- precondition: true
/-
  %div = udiv i5 %X, %Y
  %negY = sub 0, %Y
  %r = mul %div, %negY

=>
  %rem = urem %X, %Y
  %div = udiv i5 %X, %Y
  %negY = sub 0, %Y
  %r = sub %rem, %X

-/
def alive_276_2_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%Y : i5, %X : i5):
  %v1 = "llvm.udiv" (%X,%Y) : (i5, i5) -> (i5)
  %v2 = "llvm.mlir.constant" () { value = 0 : i5 } :() -> (i5)
  %v3 = "llvm.sub" (%v2,%Y) : (_, i5) -> (i5)
  %v4 = "llvm.mul" (%v1,%v3) : (i5, i5) -> (i5)
  "llvm.return" (%v4) : (i5) -> ()
}]

def alive_276_2_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%Y : i5, %X : i5):
  %v1 = "llvm.urem" (%X,%Y) : (i5, i5) -> (i5)
  %v2 = "llvm.udiv" (%X,%Y) : (i5, i5) -> (i5)
  %v3 = "llvm.mlir.constant" () { value = 0 : i5 } :() -> (i5)
  %v4 = "llvm.sub" (%v3,%Y) : (_, i5) -> (i5)
  %v5 = "llvm.sub" (%v1,%X) : (i5, i5) -> (i5)
  "llvm.return" (%v5) : (i5) -> ()
}]
theorem alive_276_2  (w : Nat)   : alive_276_2_src w  ⊑ alive_276_2_tgt w  := by
  unfold alive_276_2_src alive_276_2_tgt
  simp_alive_ssa
  print_goal_as_error
  sorry -- apply bitvec_276_2


-- Name:Select:858
-- precondition: true
/-
  %nota = xor %a, -1
  %r = select i1 %a, %nota, %b

=>
  %nota = xor %a, -1
  %r = and %nota, %b

-/
def alive_Select_858_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%a,%v1) : (_, _) -> (_)
  %v3 = "llvm.select" (%a,%v2,%b) : (_, _, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]

def alive_Select_858_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%a,%v1) : (_, _) -> (_)
  %v3 = "llvm.and" (%v2,%b) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]
theorem alive_Select_858  (w : Nat)   : alive_Select_858_src w  ⊑ alive_Select_858_tgt w  := by
  unfold alive_Select_858_src alive_Select_858_tgt
  simp_alive_ssa
  print_goal_as_error
  sorry -- apply bitvec_Select_858


-- Name:Select:859'
-- precondition: true
/-
  %nota = xor %a, -1
  %r = select i1 %a, %b, %nota

=>
  %nota = xor %a, -1
  %r = or %nota, %b

-/
def alive_Select_859'_src  (w : Nat)   :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%a,%v1) : (_, _) -> (_)
  %v3 = "llvm.select" (%a,%b,%v2) : (_, _, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]

def alive_Select_859'_tgt  (w : Nat)  :=
[alive_icom ( w )| {
^bb0(%a : _, %b : _):
  %v1 = "llvm.mlir.constant" () { value = -1 : _ } :() -> (_)
  %v2 = "llvm.xor" (%a,%v1) : (_, _) -> (_)
  %v3 = "llvm.or" (%v2,%b) : (_, _) -> (_)
  "llvm.return" (%v3) : (_) -> ()
}]
theorem alive_Select_859'  (w : Nat)   : alive_Select_859'_src w  ⊑ alive_Select_859'_tgt w  := by
  unfold alive_Select_859'_src alive_Select_859'_tgt
  simp_alive_ssa
  print_goal_as_error
  sorry -- apply bitvec_Select_859'


