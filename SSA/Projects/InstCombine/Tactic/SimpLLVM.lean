/-
Released under Apache 2.0 license as described in the file LICENSE.
-/
import SSA.Core.Framework.Trace
import SSA.Projects.InstCombine.ForLean
import SSA.Projects.InstCombine.LLVM.EDSL

open Lean
open Lean.Elab.Tactic
open InstCombine

attribute [simp_llvm_case_bash]
  bind_assoc forall_const Nat.cast_one
  PoisonOr.isRefinedBy_self PoisonOr.value_isRefinedBy_value PoisonOr.poison_isRefinedBy
  PoisonOr.poison_bind PoisonOr.bind_poison PoisonOr.value_bind PoisonOr.pure_def PoisonOr.toOption_getSome
  PoisonOr.toOption_getSome

attribute [simp_llvm_split]
  PoisonOr.isRefinedBy_self PoisonOr.value_isRefinedBy_value PoisonOr.poison_isRefinedBy
  PoisonOr.value_bind PoisonOr.poison_bind PoisonOr.bind_poison PoisonOr.pure_def
  PoisonOr.value_inj
  if_if_eq_if_and if_if_eq_if_or
  PoisonOr.toOption_getSome
  PoisonOr.toOption_getSome PoisonOr.toOption_getNone
/- `reduceOfInt` and `Nat.cast_one` are somewhat questionable additions to this simp-set.
   They are not needed for the case-bashing to succeed, but they are simp-lemmas that were
   previously being applied in `AliveAutoGenerated`, where they closed a few trivial goals,
   so they've been preserved to not change this existing behaviour of `simp_alive_case_bash` -/

attribute [simp_llvm_option]
  PoisonOr.value_bind PoisonOr.isRefinedBy_poison_iff
  PoisonOr.value_ne_poison PoisonOr.poison_ne_value

open PoisonOr in
@[simp_llvm_option]
theorem LLVM.IntW.value_isRefinedBy_iff (a : BitVec w) (b? : PoisonOr (BitVec w)) :
    value a ⊑ b? ↔ b? = value a := by
  cases b? <;> (
    simp only [value_isRefinedBy_value, value_inj, isRefinedBy_poison_iff]
    constructor <;> exact Eq.symm
  )

/-- `ensure_only_goal` succeeds, doing nothing, when there is exactly *one* goal.
If there are multiple goals, `ensure_only_goal` fails -/
elab "ensure_only_goal" : tactic =>
  Lean.Elab.Tactic.withMainContext do
    match (← Lean.Elab.Tactic.getGoals) with
    | [_g] => pure ()
    | [] => throwError "expected exactly one goal, found no goals."
    | gs@(_ :: _ :: _) =>
      throwError m!"expected exactly one goal, found multiple goals: '{gs}'."

/--
`simp_alive_case_bash` transforms a goal of the form
  `∀ (x₁ : PoisonOr (BitVec _)) ... (xₙ : PoisonOr (BitVec _)), ...`
into a goal about just `BitVec`s, by doing a case distinction on each `PoisonOr`.

Then, we `simp`lify each goal, following the assumption that the `poison` cases
should generally be trivial, hopefully leaving us with just a single goal:
the one where each option is a `value`. -/
syntax "simp_alive_case_bash'" : tactic
macro_rules
  | `(tactic| simp_alive_case_bash') => `(tactic|
    first
    | fail_if_success (intro (v : PoisonOr (_)))
      -- If there is no variable to introduce, `intro` fails, so the first branch succeeds,
      -- but does nothing. This is similar to `try`, except `first ...` does not swallow any errors
      -- that occur in the later tactics
    | intro (v : PoisonOr (_))  -- Introduce the variable,
      cases' v with x           -- Do the case distinction
      <;> simp (config:={failIfUnchanged := false}) -implicitDefEqProofs only [simp_llvm_case_bash]
      --  ^^^^^^^^^^^^^^^^^^^^^^^^ Simplify, in the hopes that the `poison` case is trivially closed
      <;> simp_alive_case_bash' -- Recurse, to case bash the next variable (if it exists)
      <;> (try revert x)        -- Finally, revert the variable we got in the `value` case, so that
                                --   we are left with a universally quantified goal of the form:
                                --   `∀ (x₁ : BitVec _) ... (xₙ : BitVec _), ...`
    )

def revertIntW (g : MVarId) : MetaM (Array FVarId × MVarId) := do
  let type ← g.getType
  let (_, fvars) ← type.forEachWhere Expr.isFVar collector |>.run {}
  g.revert fvars.toArray
where
  collector (e : Expr) : StateT (Std.HashSet FVarId) MetaM Unit := do
    let fvarId := e.fvarId!
    let typ ← fvarId.getType
    match_expr typ with
    | LLVM.IntW _ =>
      modify fun s => s.insert fvarId
    | _ => return ()

elab "revert_intw" : tactic => withMainContext do
  let g ← getMainGoal
  let (_, g') ← revertIntW g
  replaceMainGoal [g']

syntax "simp_alive_case_bash" : tactic
macro_rules
  | `(tactic| simp_alive_case_bash) => `(tactic|
    (
      revert_intw
      simp_alive_case_bash'
    )
  )

/-! ### Constant Hiding Workaround
The following section defines two tactics, `hide_constants` and `unhide_constants`.
* `hide_constants` will rewrite occurences of `LLVM.const?` or `BitVec.ofInt`
  into an application of a new `hide` function. This function is an *opaque*
  identity function, and serves to block kernel reduction.
* `unhide_constants` does the reverse, and removes all `hide` applications.

This serves as a workaround for https://github.com/leanprover/lean4/issues/8898
-/
namespace HideConstants
open Meta

/-- Definition of `hide` and `hide_eq` -/
opaque hide_def : { hide : α → α // hide = id } := ⟨id, rfl⟩

/--
`hide` is an opaque version of the identity function.
By making it opaque, we prevent the kernel from trying to reduce the argument.
-/
def hide : α → α := hide_def.1

/-- A proof that `hide` is the identity. Note that this is deliberately *not*
a def-eq, since we made `hide` opaque. -/
theorem hide_eq {a : α} : hide a = a := by
  rw [hide, hide_def.2]; rfl

/-- Auxiliary lemmas used in `simpHideFunArgs`. -/
private theorem congr_hide_eq (β : Nat → Type) (w : Nat) : β (hide w) = β w := by
  rw[hide_eq]

/-- Auxiliary lemmas used in `simpHideFunArgs`. -/
private theorem eq_cast_self_hide_hide {α : Type} {β : Nat → Type}
    (f : (w : Nat) → α → β w) (w : Nat) (x : α) :
    f w x = cast (congr_hide_eq β w) (f (hide w) (hide x)) := by
  rw [eq_cast_iff_heq, hide_eq, hide_eq]

/--
Given a function expression `f : (w : Nat) → α → β w` together with argument
expressions `w : Nat` and `x : α` (for arbitrary `α`), ensure the arguments
`w` and `x` are guarded by `hide` to block kernel reduction.
-/
def simpHideFunArgs (f w x β : Expr) : Meta.SimpM Meta.Simp.Step := do
  if w.isAppOf ``hide && x.isAppOf ``hide then
    trace[LeanMLIR.Elab] "{Lean.crossEmoji}: both arguments in {mkApp2 f w x} \
      are already applications of `hide`"
    return .continue

  let expr ← do
    let castProof := mkApp2 (.const ``congr_hide_eq []) β w
    let w' ← mkAppM ``hide #[w]
    let x' ← mkAppM ``hide #[x]
    let fwx' := mkApp2 f w' x'
    mkAppM ``cast #[castProof, fwx']
  let proof ← mkAppM ``eq_cast_self_hide_hide #[f, w, x]
  return .done {
    expr := expr
    proof? := some proof
  }

simproc BitVec.hideOfInt (BitVec.ofInt _ _) := fun e => do
  let_expr BitVec.ofInt w x := e | return .continue
  simpHideFunArgs (mkConst ``BitVec.ofInt) w x (mkConst ``BitVec)

simproc LLVM.hideConst? (LLVM.const? _ _) := fun e => do
  let_expr LLVM.const? w x := e | return .continue
  simpHideFunArgs (mkConst ``LLVM.const?) w x (mkConst ``LLVM.IntW)

macro "hide_constants" : tactic => `(tactic|
  simp -failIfUnchanged -memoize only [BitVec.hideOfInt, LLVM.hideConst?]
  -- --------------------^^^^^^^
  -- NOTE: we have to disable the memoize option, since the simprocs
  -- inspect the parent expressions, which are disregarded by the cache
  -- TODO: we might not need this anymore with the new hiding strategy, since
  --   we no longer inspect the parent context
)

/-- Inverse of `eq_cast_self_hide_hide`, used in `unhide_constants` tactic. -/
protected theorem cast_self_hide_eq {α : Type} {β : Nat → Type}
    (f : (w : Nat) → α → β w) (w : Nat) (x : α) (h : β (hide w) = β w) :
    cast h (f (hide w) x) = f w x := by
  rw [cast_eq_iff_heq, hide_eq]
open HideConstants (cast_self_hide_eq)

macro "unhide_constants" : tactic => `(tactic|
  all_goals simp -failIfUnchanged only [hide_eq, cast_self_hide_eq,
    cast_self_hide_eq (fun w x => PoisonOr.value (BitVec.ofInt w x))]
  -- ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  -- This is the unfolded definition of `LLVM.const?`
  -- We specify it here manually as inference usually won't manage to
  -- instantiate `cast_self_hide_eq` like this without assistance.
)

end HideConstants
export HideConstants (BitVec.hideOfInt LLVM.hideConst?)


/-- Unfold into the `undef' statements and eliminates as much as possible. -/
macro "simp_alive_undef" : tactic =>
  `(tactic|
      (
        hide_constants
        simp (config := {failIfUnchanged := false}) only [
            simp_llvm_option,
            bind_assoc,
            Bool.false_eq_true, false_and, reduceIte,
            (BitVec.ofInt_ofNat)
          ]
      )
  )

attribute [simp_llvm]
  pure_bind
  BitVec.ofInt_neg_one
  PoisonOr.bind_if_then_poison_eq_ite_bind
  PoisonOr.bind_if_else_poison_eq_ite_bind

/- Simplify away the `InstCombine` specific semantics. -/
macro "simp_alive_ops" : tactic =>
  `(tactic|(
      simp (config := {failIfUnchanged := false}) only [
          simp_llvm,
          (BitVec.ofInt_ofNat)
        ]
      unhide_constants
      -- We need to use `BitVec.ofInt_ofNat` again, as it may have been
      -- previously blocked by a `hide`
      simp -failIfUnchanged only [
        (BitVec.ofInt_ofNat), BitVec.ofInt_neg
      ]
    ))
