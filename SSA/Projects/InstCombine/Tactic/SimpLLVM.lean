/-
Released under Apache 2.0 license as described in the file LICENSE.
-/
import SSA.Core.Framework.Trace
import SSA.Projects.InstCombine.ForLean
import SSA.Projects.InstCombine.LLVM.EDSL

open Lean
open Lean.Elab.Tactic

/-! ## `simp_llvm` -/

/--
`simp_llvm` unfolds LLVM semantics functions into monadic bitvector expressions,
simplifying trivial refinements in the process.
-/
macro "simp_llvm" : tactic => `(tactic|(
  simp (config := {failIfUnchanged := false}) only [
    simp_llvm,
    (BitVec.ofInt_ofNat)]
))

attribute [simp_llvm]
  -- PoisonOr.isRefinedBy_poison_iff PoisonOr.value_isRefinedBy_iff
  PoisonOr.poison_isRefinedBy PoisonOr.value_isRefinedBy_value
  PoisonOr.value_ne_poison PoisonOr.poison_ne_value PoisonOr.value_inj
  PoisonOr.value_bind
  PoisonOr.bind_if_then_poison_eq_ite_bind
  PoisonOr.bind_if_else_poison_eq_ite_bind
  bind_assoc Bool.false_eq_true false_and reduceIte

@[deprecated "use `simp_llvm` instead" (since := "2025-05-12")]
macro "simp_alive_ops" : tactic => `(tactic| simp_llvm)
@[deprecated "use `simp_llvm` instead" (since := "2025-05-12")]
macro "simp_alive_undef" : tactic => `(tactic| simp_llvm)

/-! ## `intros_llvm` -/

/--
`intros_llvm` is a simple wrapper around `intros` which whill preserve the names
of quantified variables *and keeps them accessible*.

Crucially, this means this tactic is *not hygienic*, and should likely be
avoided in manual proofs, but we use it in automatically generated proofs to
improve readability.
-/
elab "intros_llvm" : tactic => withMainContext do
  let target ← getMainTarget
  let rec getIdents (names : Array Ident) : Expr → Array Ident
    | .forallE x _ body _ => getIdents (names.push <| mkIdent x) body
    | _ => names
  let names := getIdents #[] target
  evalTactic <|<- `(tactic| intros $names*)

/-! ## `elim_poison_bind`-/

open PoisonOr in
/-- Specialized theorem for use in `elim_poison_bind`.
By specializing it to exactly the shape of goal we need, we both reduce some
boilerplate in its application, and potentially make the proof slightly faster
to check (as the kernel won't need to reduce anything).
-/
theorem LLVM.IntW.bind_isRefinedBy_iff {w : Nat}
    (x : PoisonOr (BitVec w)) (f : BitVec w → PoisonOr (BitVec w))
    (rhs : PoisonOr (BitVec w)) :
    bind x f ⊑ rhs ↔ (∀ x', x = value x' → f x' ⊑ rhs) := by
  cases x <;> simp

open Meta in
/--
`simp_llvm_bind` repeatedly tries to apply `LLVM.IntW.bind_isRefinedBy_if`,
to show that a `PoisonOr`-typed variable *must* be a value (rather than poison).

Whenever the application succeeds, we introduce the new `BitVec` variable using
the same (accessible) name as the `PoisonOr` variable it replaces.
-/
elab "simp_llvm_bind" : tactic => do
  let mut loop := true
  while loop do
    loop ← withMainContext do
      let w ← mkFreshExprMVar none
      let x ← mkFreshExprMVar none
      let f ← mkFreshExprMVar none
      let rhs ← mkFreshExprMVar none
      let lem ← mkAppM ``Iff.mpr #[mkApp4 (mkConst ``LLVM.IntW.bind_isRefinedBy_iff) w x f rhs]
      let newGoals ←
        try (← getMainGoal).apply lem
        catch e =>
          trace[LeanMLIR.Elab] e.toMessageData
          return false

      let x := (← instantiateMVars x).consumeMData
      if !x.isFVar then
        trace[LeanMLIR.Elab] "Expected an fvar, but found: ${x}. Aborting..."
        return false

      replaceMainGoal newGoals
      let xId := mkIdent (← getUnusedUserName `x)
      evalTactic <|<- `(tactic| (
        intro ($xId : BitVec _) h;
        subst h;  -- Eliminate the old variable
        simp (config:={failIfUnchanged := false}) -implicitDefEqProofs only [simp_llvm]
        -- ^^ simplify
      ))
      return true

/-! ## Case Bashing-/

attribute [simp_llvm_case_bash]
  bind_assoc forall_const Nat.cast_one
  PoisonOr.isRefinedBy_self PoisonOr.value_isRefinedBy_value PoisonOr.poison_isRefinedBy
  PoisonOr.poison_bind PoisonOr.bind_poison PoisonOr.value_bind PoisonOr.pure_def

attribute [simp_llvm_split]
  PoisonOr.isRefinedBy_self PoisonOr.value_isRefinedBy_value PoisonOr.poison_isRefinedBy
  PoisonOr.value_bind PoisonOr.poison_bind PoisonOr.bind_poison PoisonOr.pure_def
  PoisonOr.value_inj
  if_if_eq_if_and if_if_eq_if_or
/- `reduceOfInt` and `Nat.cast_one` are somewhat questionable additions to this simp-set.
   They are not needed for the case-bashing to succeed, but they are simp-lemmas that were
   previously being applied in `AliveAutoGenerated`, where they closed a few trivial goals,
   so they've been preserved to not change this existing behaviour of `simp_alive_case_bash` -/

/-- `ensure_only_goal` succeeds, doing nothing, when there is exactly *one* goal.
If there are multiple goals, `ensure_only_goal` fails -/
elab "ensure_only_goal" : tactic =>
  Lean.Elab.Tactic.withMainContext do
    match (← Lean.Elab.Tactic.getGoals) with
    | [_g] => pure ()
    | [] => throwError "expected exactly one goal, found no goals."
    | gs@(_ :: _ :: _) =>
      throwError m!"expected exactly one goal, found multiple goals: '{gs}'."

/--
`simp_alive_case_bash` transforms a goal of the form
  `∀ (x₁ : PoisonOr (BitVec _)) ... (xₙ : PoisonOr (BitVec _)), ...`
into a goal about just `BitVec`s, by doing a case distinction on each `PoisonOr`.

Then, we `simp`lify each goal, following the assumption that the `poison` cases
should generally be trivial, hopefully leaving us with just a single goal:
the one where each option is a `value`. -/
syntax "simp_alive_case_bash'" : tactic
macro_rules
  | `(tactic| simp_alive_case_bash') => `(tactic|
    first
    | fail_if_success (intro (v : PoisonOr (_)))
      -- If there is no variable to introduce, `intro` fails, so the first branch succeeds,
      -- but does nothing. This is similar to `try`, except `first ...` does not swallow any errors
      -- that occur in the later tactics
    | intro (v : PoisonOr (_))  -- Introduce the variable,
      cases' v with x           -- Do the case distinction
      <;> simp (config:={failIfUnchanged := false}) -implicitDefEqProofs only [simp_llvm_case_bash]
      --  ^^^^^^^^^^^^^^^^^^^^^^^^ Simplify, in the hopes that the `poison` case is trivially closed
      <;> simp_alive_case_bash' -- Recurse, to case bash the next variable (if it exists)
      <;> (try revert x)        -- Finally, revert the variable we got in the `value` case, so that
                                --   we are left with a universally quantified goal of the form:
                                --   `∀ (x₁ : BitVec _) ... (xₙ : BitVec _), ...`
    )

def revertIntW (g : MVarId) : MetaM (Array FVarId × MVarId) := do
  let type ← g.getType
  let (_, fvars) ← type.forEachWhere Expr.isFVar collector |>.run {}
  g.revert fvars.toArray
where
  collector (e : Expr) : StateT (Std.HashSet FVarId) MetaM Unit := do
    let fvarId := e.fvarId!
    let typ ← fvarId.getType
    match_expr typ with
    | LLVM.IntW _ =>
      modify fun s => s.insert fvarId
    | _ => return ()

elab "revert_intw" : tactic => do
  let g ← getMainGoal
  let (_, g') ← revertIntW g
  replaceMainGoal [g']

syntax "simp_alive_case_bash" : tactic
macro_rules
  | `(tactic| simp_alive_case_bash) => `(tactic|
    (
      revert_intw
      simp_alive_case_bash'
    )
  )
