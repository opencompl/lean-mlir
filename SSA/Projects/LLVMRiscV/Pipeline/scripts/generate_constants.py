#!/usr/bin/env python3
from pathlib import Path
from dataclasses import dataclass
from typing import List, Callable

"""
This script generates Lean proofs for LLVM peephole rewrites involving constant matching.
"""

HEADER = """-- AUTOGENERATED Lean file

import SSA.Projects.LLVMRiscV.PeepholeRefine
import SSA.Projects.LLVMRiscV.Simpproc
import SSA.Projects.RISCV64.Tactic.SimpRiscV
import SSA.Projects.LLVMRiscV.Pipeline.mkRewrite

open LLVMRiscV

"""

@dataclass
class RewritePattern:
    name: str
    definition: str

@dataclass
class RewriteGroup:
    group_name: str
    patterns: List[RewritePattern]
    type_signature: str  # e.g., "LLVMPeepholeRewriteRefine 64 Γ"
    comment: str
    
    def generate(self) -> str:
        # Generate all individual definitions
        definitions = "\n".join(p.definition for p in self.patterns)
        
        # Generate the list definition
        rewrite_refs = [f"⟨_, {p.name}⟩" for p in self.patterns]
        list_def = f"\ndef {self.group_name} : List (Σ Γ, {self.type_signature}) :=\n  [\n    "
        list_def += ",\n    ".join(rewrite_refs)
        list_def += "\n  ]\n"
        
        return self.comment + definitions + list_def


def generate_sub_to_add_rewrites(max_val: int) -> RewriteGroup:
    #(sub x, C) → (add x, -C)
    patterns = []
    group_name = "sub_to_add"
    comment = """
/-! ### sub_to_add -/

/-- 
Test the rewrite:
  (sub x, C) → (add x, -C)
-/
"""
    
    for i in range(-max_val, max_val + 1):
        name_suffix = f"neg{abs(i)}" if i < 0 else str(i)
        neg_constant = -i
        
        definition = f"""def {group_name}_{name_suffix} : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.sub %x, %c : i64
      llvm.return %1 : i64
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {neg_constant} : i64
      %1 = llvm.add %x, %c : i64
      llvm.return %1 : i64
  }}]
"""
        
        patterns.append(RewritePattern(
            name=f"{group_name}_{name_suffix}",
            definition=definition
        ))
    
    return RewriteGroup(
        group_name=group_name,
        patterns=patterns,
        type_signature="LLVMPeepholeRewriteRefine 64 Γ",
        comment=comment
    )

def generate_mul_to_shl_rewrites(powers: List[int]) -> RewriteGroup:
    #(x * 2) → x >>> 1
    patterns = []
    group_name = "mul_to_shl"
    comment = """
/-! ### mul_to_shl -/

/--
Test the rewrite:
    (x * 2^n) → (x << n)
-/

"""
    
    for n in powers:
        power_of_2 = 2 ** n
        
        definition = f"""def {group_name}_{power_of_2} : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant ({power_of_2}) : i64
      %0 = llvm.mul %x, %c : i64
      llvm.return %0 : i64
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant ({n}) : i64
      %0 = llvm.shl %x, %c : i64
      llvm.return %0 : i64
  }}]
"""
        
        patterns.append(RewritePattern(
            name=f"{group_name}_{power_of_2}",
            definition=definition
        ))
    
    return RewriteGroup(
        group_name=group_name,
        patterns=patterns,
        type_signature="LLVMPeepholeRewriteRefine 64 Γ",
        comment=comment
    )
    
def generate_urem_pow2_rewrites(powers: List[int]) -> RewriteGroup:
    # urem(x, pow2) -> x & (pow2 - 1)
    patterns = []
    group_name = "urem_pow2_to_mask"
    comment = """
/-! ### urem_pow2_to_mask -/

/--
Test the rewrite:
    urem(x, 2^n) -> x & (2^n - 1)
-/

""" 
    for n in powers:
        power_of_2 = 2 ** n
        
        definition = f"""def {group_name}_{power_of_2} : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant ({power_of_2}) : i64
      %0 = llvm.urem %x, %c : i64
      llvm.return %0 : i64
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant ({power_of_2-1}) : i64
      %0 = llvm.and %x, %c : i64
      llvm.return %0 : i64
  }}]
"""
        
        patterns.append(RewritePattern(
            name=f"{group_name}_{power_of_2}",
            definition=definition
        ))
    
    return RewriteGroup(
        group_name=group_name,
        patterns=patterns,
        type_signature="LLVMPeepholeRewriteRefine 64 Γ",
        comment=comment
    )
    
def generate_narrow_binop_rewrites(max_val: int) -> RewriteGroup:
    patterns = []
    group_name = "cast_combines_narrow_binops"
    comment = """
/-! ### cast_combines_narrow_binops -/

/-- 
Test the rewrite:
    trunc (binop X, C) --> binop (trunc X, trunc C)
-/
"""

    for i in range(-max_val, max_val + 1):
        name_suffix = f"neg{abs(i)}" if i < 0 else str(i)
        
        definition = f"""def narrow_binop_add_{name_suffix} : LLVMPeepholeRewriteRefine 32 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %0 = llvm.add %x, %c : i64
      %1 = llvm.trunc %0 : i64 to i32
      llvm.return %1 : i32
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %0 = llvm.trunc %x : i64 to i32
      %1 = llvm.trunc %c : i64 to i32
      %2 = llvm.add %0, %1 : i32
      llvm.return %2 : i32
  }}]
"""
        
        patterns.append(RewritePattern(
            name=f"narrow_binop_add_{name_suffix}",
            definition=definition
        ))
        
        definition = f"""def narrow_binop_sub_{name_suffix} : LLVMPeepholeRewriteRefine 32 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %0 = llvm.sub %x, %c : i64
      %1 = llvm.trunc %0 : i64 to i32
      llvm.return %1 : i32
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %0 = llvm.trunc %x : i64 to i32
      %1 = llvm.trunc %c : i64 to i32
      %2 = llvm.sub %0, %1 : i32
      llvm.return %2 : i32
  }}]
"""
        
        patterns.append(RewritePattern(
            name=f"narrow_binop_sub_{name_suffix}",
            definition=definition
        ))
        
        definition = f"""def narrow_binop_mul_{name_suffix} : LLVMPeepholeRewriteRefine 32 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %0 = llvm.mul %x, %c : i64
      %1 = llvm.trunc %0 : i64 to i32
      llvm.return %1 : i32
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %0 = llvm.trunc %x : i64 to i32
      %1 = llvm.trunc %c : i64 to i32
      %2 = llvm.mul %0, %1 : i32
      llvm.return %2 : i32
  }}]
"""
 
        patterns.append(RewritePattern(
            name=f"narrow_binop_mul_{name_suffix}",
            definition=definition
        ))
        
        definition = f"""def narrow_binop_and_{name_suffix} : LLVMPeepholeRewriteRefine 32 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %0 = llvm.and %x, %c : i64
      %1 = llvm.trunc %0 : i64 to i32
      llvm.return %1 : i32
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %0 = llvm.trunc %x : i64 to i32
      %1 = llvm.trunc %c : i64 to i32
      %2 = llvm.and %0, %1 : i32
      llvm.return %2 : i32
  }}]
"""
 
        patterns.append(RewritePattern(
            name=f"narrow_binop_and_{name_suffix}",
            definition=definition
        ))
        
        definition = f"""def narrow_binop_or_{name_suffix} : LLVMPeepholeRewriteRefine 32 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %0 = llvm.or %x, %c : i64
      %1 = llvm.trunc %0 : i64 to i32
      llvm.return %1 : i32
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %0 = llvm.trunc %x : i64 to i32
      %1 = llvm.trunc %c : i64 to i32
      %2 = llvm.or %0, %1 : i32
      llvm.return %2 : i32
  }}]
"""
 
        patterns.append(RewritePattern(
            name=f"narrow_binop_or_{name_suffix}",
            definition=definition
        ))
        
        definition = f"""def narrow_binop_xor_{name_suffix} : LLVMPeepholeRewriteRefine 32 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %0 = llvm.xor %x, %c : i64
      %1 = llvm.trunc %0 : i64 to i32
      llvm.return %1 : i32
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %0 = llvm.trunc %x : i64 to i32
      %1 = llvm.trunc %c : i64 to i32
      %2 = llvm.xor %0, %1 : i32
      llvm.return %2 : i32
  }}]
"""
 
        patterns.append(RewritePattern(
            name=f"narrow_binop_xor_{name_suffix}",
            definition=definition
        ))
    
    return RewriteGroup(
        group_name=group_name,
        patterns=patterns,
        type_signature="LLVMPeepholeRewriteRefine 64 Γ",
        comment=comment
    )
    
REWRITE_GENERATORS = [
    lambda: generate_sub_to_add_rewrites(max_val=50),
    lambda: generate_mul_to_shl_rewrites(powers=list(range(0, 64))),
    lambda: generate_urem_pow2_rewrites(powers=list(range(0, 64))),
    lambda: generate_narrow_binop_rewrites(max_val=50),
]


def generate_all_rewrites() -> str:
    sections = []
    
    for generator in REWRITE_GENERATORS:
        group = generator()
        sections.append(group.generate())
    
    return "\n\n".join(sections)


def main():
    script_dir = Path(__file__).parent
    parent_dir = script_dir.parent
    output_file = parent_dir / "ConstantMatching.lean"
    
    content = HEADER + generate_all_rewrites()
    
    with open(output_file, "w") as f:
        f.write(content)

if __name__ == "__main__":
    main()
    
