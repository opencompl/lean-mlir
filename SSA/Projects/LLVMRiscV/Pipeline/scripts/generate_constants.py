#!/usr/bin/env python3
from pathlib import Path
from dataclasses import dataclass
from typing import List, Callable

"""
This script generates Lean proofs for LLVM peephole rewrites involving constant matching.
"""

HEADER = """-- AUTOGENERATED Lean file

import SSA.Projects.LLVMRiscV.PeepholeRefine
import SSA.Projects.LLVMRiscV.Simpproc
import SSA.Projects.RISCV64.Tactic.SimpRiscV
import SSA.Projects.LLVMRiscV.Pipeline.mkRewrite

open LLVMRiscV

"""

@dataclass
class RewritePattern:
    name: str
    definition: str

@dataclass
class RewriteGroup:
    group_name: str
    patterns: List[RewritePattern]
    type_signature: str  # e.g., "LLVMPeepholeRewriteRefine 64 Γ"
    comment: str
    
    def generate(self) -> str:
        # Generate all individual definitions
        definitions = "\n".join(p.definition for p in self.patterns)
        
        # Generate the list definition
        rewrite_refs = [f"⟨_, {p.name}⟩" for p in self.patterns]
        list_def = f"\ndef {self.group_name} : List (Σ Γ, {self.type_signature}) :=\n  [\n    "
        list_def += ",\n    ".join(rewrite_refs)
        list_def += "\n  ]\n"
        
        return self.comment + definitions + list_def


def generate_sub_to_add_rewrites(max_val: int) -> RewriteGroup:
    #(sub x, C) → (add x, -C)
    patterns = []
    group_name = "sub_to_add"
    comment = """
/-! ### sub_to_add -/

/-- 
Test the rewrite:
  (sub x, C) → (add x, -C)
-/
"""
    
    for i in range(-max_val, max_val + 1):
        name_suffix = f"neg{abs(i)}" if i < 0 else str(i)
        neg_constant = -i
        
        definition = f"""def {group_name}_{name_suffix} : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.sub %x, %c : i64
      llvm.return %1 : i64
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {neg_constant} : i64
      %1 = llvm.add %x, %c : i64
      llvm.return %1 : i64
  }}]
"""
        
        patterns.append(RewritePattern(
            name=f"{group_name}_{name_suffix}",
            definition=definition
        ))
    
    return RewriteGroup(
        group_name=group_name,
        patterns=patterns,
        type_signature="LLVMPeepholeRewriteRefine 64 Γ",
        comment=comment
    )

def generate_mul_to_shl_rewrites(powers: List[int]) -> RewriteGroup:
    #(x * 2) → x >>> 1
    patterns = []
    group_name = "mul_to_shl"
    comment = """
/-! ### mul_to_shl -/

/--
Test the rewrite:
    (x * 2^n) → (x << n)
-/

"""
    
    for n in powers:
        power_of_2 = 2 ** n
        
        definition = f"""def {group_name}_{power_of_2} : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant ({power_of_2}) : i64
      %0 = llvm.mul %x, %c : i64
      llvm.return %0 : i64
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant ({n}) : i64
      %0 = llvm.shl %x, %c : i64
      llvm.return %0 : i64
  }}]
"""
        
        patterns.append(RewritePattern(
            name=f"{group_name}_{power_of_2}",
            definition=definition
        ))
    
    return RewriteGroup(
        group_name=group_name,
        patterns=patterns,
        type_signature="LLVMPeepholeRewriteRefine 64 Γ",
        comment=comment
    )
    
def generate_urem_pow2_rewrites(powers: List[int]) -> RewriteGroup:
    # urem(x, pow2) -> x & (pow2 - 1)
    patterns = []
    group_name = "urem_pow2_to_mask"
    comment = """
/-! ### urem_pow2_to_mask -/

/--
Test the rewrite:
    urem(x, 2^n) -> x & (2^n - 1)
-/

""" 
    for n in powers:
        power_of_2 = 2 ** n
        
        definition = f"""def {group_name}_{power_of_2} : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant ({power_of_2}) : i64
      %0 = llvm.urem %x, %c : i64
      llvm.return %0 : i64
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant ({power_of_2-1}) : i64
      %0 = llvm.and %x, %c : i64
      llvm.return %0 : i64
  }}]
"""
        
        patterns.append(RewritePattern(
            name=f"{group_name}_{power_of_2}",
            definition=definition
        ))
    
    return RewriteGroup(
        group_name=group_name,
        patterns=patterns,
        type_signature="LLVMPeepholeRewriteRefine 64 Γ",
        comment=comment
    )
    
def generate_canonicalize_icmp(max_val: int) -> RewriteGroup:
    patterns = []
    group_name = "canonicalize_icmp"
    comment = """
/-! ### canonicalize_icmp -/

/-- 
Test the rewrite:
  (cmp C, x) → (cmp x, C)
-/
"""
    
    for i in range(-max_val, max_val + 1):
        name_suffix = f"neg{abs(i)}" if i < 0 else str(i)
        
        definition = f"""def {group_name}_eq_{name_suffix} : LLVMPeepholeRewriteRefine 1 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.eq %c, %x : i64
      llvm.return %1 : i1
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.eq %x, %c : i64
      llvm.return %1 : i1
  }}]
"""
        
        patterns.append(RewritePattern(
            name=f"{group_name}_eq_{name_suffix}",
            definition=definition
        ))
        
        definition = f"""def {group_name}_ne_{name_suffix} : LLVMPeepholeRewriteRefine 1 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.ne %c, %x : i64
      llvm.return %1 : i1
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.ne %x, %c : i64
      llvm.return %1 : i1
  }}]
"""
        patterns.append(RewritePattern(
            name=f"{group_name}_ne_{name_suffix}",
            definition=definition
        ))
        
        definition = f"""def {group_name}_uge_{name_suffix} : LLVMPeepholeRewriteRefine 1 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.uge %c, %x : i64
      llvm.return %1 : i1
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.ule %x, %c : i64
      llvm.return %1 : i1
  }}]
"""

        patterns.append(RewritePattern(
            name=f"{group_name}_uge_{name_suffix}",
            definition=definition
        ))
        
        definition = f"""def {group_name}_ugt_{name_suffix} : LLVMPeepholeRewriteRefine 1 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.ugt %c, %x : i64
      llvm.return %1 : i1
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.ult %x, %c : i64
      llvm.return %1 : i1
  }}]
"""
        
        patterns.append(RewritePattern(
            name=f"{group_name}_ugt_{name_suffix}",
            definition=definition
        ))
        
        definition = f"""def {group_name}_ult_{name_suffix} : LLVMPeepholeRewriteRefine 1 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.ult %c, %x : i64
      llvm.return %1 : i1
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.ugt %x, %c : i64
      llvm.return %1 : i1
  }}]
"""
        
        patterns.append(RewritePattern(
            name=f"{group_name}_ult_{name_suffix}",
            definition=definition
        ))
        
        definition = f"""def {group_name}_ule_{name_suffix} : LLVMPeepholeRewriteRefine 1 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.ule %c, %x : i64
      llvm.return %1 : i1
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.uge %x, %c : i64
      llvm.return %1 : i1
  }}]
"""
        
        patterns.append(RewritePattern(
            name=f"{group_name}_ule_{name_suffix}",
            definition=definition
        ))
        
        definition = f"""def {group_name}_sgt_{name_suffix} : LLVMPeepholeRewriteRefine 1 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.sgt %c, %x : i64
      llvm.return %1 : i1
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.slt %x, %c : i64
      llvm.return %1 : i1
  }}]
"""
        
        patterns.append(RewritePattern(
            name=f"{group_name}_sgt_{name_suffix}",
            definition=definition
        ))
        
        definition = f"""def {group_name}_sge_{name_suffix} : LLVMPeepholeRewriteRefine 1 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.sge %c, %x : i64
      llvm.return %1 : i1
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.sle %x, %c : i64
      llvm.return %1 : i1
  }}]
"""
        
        patterns.append(RewritePattern(
            name=f"{group_name}_sge_{name_suffix}",
            definition=definition
        ))
        
        definition = f"""def {group_name}_slt_{name_suffix} : LLVMPeepholeRewriteRefine 1 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.slt %c, %x : i64
      llvm.return %1 : i1
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.sgt %x, %c : i64
      llvm.return %1 : i1
  }}]
"""
        
        patterns.append(RewritePattern(
            name=f"{group_name}_slt_{name_suffix}",
            definition=definition
        ))
        
        definition = f"""def {group_name}_sle_{name_suffix} : LLVMPeepholeRewriteRefine 1 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.sle %c, %x : i64
      llvm.return %1 : i1
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.sge %x, %c : i64
      llvm.return %1 : i1
  }}]
"""
        
        patterns.append(RewritePattern(
            name=f"{group_name}_sle_{name_suffix}",
            definition=definition
        ))
    
    return RewriteGroup(
        group_name=group_name,
        patterns=patterns,
        type_signature="LLVMPeepholeRewriteRefine 1 Γ",
        comment=comment
    )
    
def generate_integer_reassoc_combines(max_val: int) -> RewriteGroup:
    patterns = []
    group_name = "irc_constants"
    comment = """
/-! ### integer_reassoc_combines_constants -/

/-
Test the rewrite:
 fold (A+C1)-C2 -> A+(C1-C2)
 fold C2-(A+C1) -> (C2-C1)-A
 fold (A-C1)-C2 -> A-(C1+C2)
 fold (C1-A)-C2 -> (C1-C2)-A
 fold ((A-C1)+C2) -> (A+(C2-C1))
-/
"""
    for i in range(-max_val, max_val + 1):
        name_suffix_i = f"neg{abs(i)}" if i < 0 else str(i)
        for j in range(-max_val, max_val + 1):
            name_suffix_j = f"neg{abs(j)}" if j < 0 else str(j)
            name = f"{name_suffix_i}_{name_suffix_j}"
            definition = f"""
def {group_name}_APlusC1MinusC2_{name} : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant ({i}) : i64
      %c2 = llvm.mlir.constant ({j}) : i64
      %0 = llvm.add %a, %c1 : i64
      %1 = llvm.sub %0, %c2 : i64
      llvm.return %1 : i64
  }}]
  rhs := [LV| {{
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant ({i}) : i64
      %c2 = llvm.mlir.constant ({j}) : i64
      %0 = llvm.sub %c1, %c2 : i64
      %1 = llvm.add %a, %0 : i64
      llvm.return %1 : i64
  }}]"""
            patterns.append(RewritePattern(
                name=f"{group_name}_APlusC1MinusC2_{name}",
                definition=definition
            ))

            definition = f"""
def {group_name}_C2MinusAPlusC1_{name} : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant ({i}) : i64
      %c2 = llvm.mlir.constant ({j}) : i64
      %0 = llvm.add %a, %c1 : i64
      %1 = llvm.sub %c2, %0 : i64
      llvm.return %1 : i64
  }}]
  rhs := [LV| {{
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant ({i}) : i64
      %c2 = llvm.mlir.constant ({j}) : i64
      %0 = llvm.sub %c2, %c1 : i64
      %1 = llvm.sub %0, %a : i64
      llvm.return %1 : i64
  }}]"""
            patterns.append(RewritePattern(
                name=f"{group_name}_C2MinusAPlusC1_{name}",
                definition=definition
            ))

            definition = f"""
def {group_name}_AMinusC1MinusC2_{name} : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant ({i}) : i64
      %c2 = llvm.mlir.constant ({j}) : i64
      %0 = llvm.sub %a, %c1 : i64
      %1 = llvm.sub %0, %c2 : i64
      llvm.return %1 : i64
  }}]
  rhs := [LV| {{
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant ({i}) : i64
      %c2 = llvm.mlir.constant ({j}) : i64
      %0 = llvm.add %c1, %c2 : i64
      %1 = llvm.sub %a, %0 : i64
      llvm.return %1 : i64
  }}]"""
            patterns.append(RewritePattern(
                name=f"{group_name}_AMinusC1MinusC2_{name}",
                definition=definition
            ))

            definition = f"""
def {group_name}_C1Minus2MinusC2_{name} : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant ({i}) : i64
      %c2 = llvm.mlir.constant ({j}) : i64
      %0 = llvm.sub %c1, %a : i64
      %1 = llvm.sub %0, %c2 : i64
      llvm.return %1 : i64
  }}]
  rhs := [LV| {{
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant ({i}) : i64
      %c2 = llvm.mlir.constant ({j}) : i64
      %0 = llvm.sub %c1, %c2 : i64
      %1 = llvm.sub %0, %a : i64
      llvm.return %1 : i64
  }}]"""
            patterns.append(RewritePattern(
                name=f"{group_name}_C1Minus2MinusC2_{name}",
                definition=definition
            ))

            definition = f"""
def {group_name}_AMinusC1PlusC2_{name} : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant ({i}) : i64
      %c2 = llvm.mlir.constant ({j}) : i64
      %0 = llvm.sub %a, %c1 : i64
      %1 = llvm.add %0, %c2 : i64
      llvm.return %1 : i64
  }}]
  rhs := [LV| {{
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant ({i}) : i64
      %c2 = llvm.mlir.constant ({j}) : i64
      %0 = llvm.sub %c2, %c1 : i64
      %1 = llvm.add %a, %0 : i64
      llvm.return %1 : i64
  }}]"""
            patterns.append(RewritePattern(
                name=f"{group_name}_AMinusC1PlusC2_{name}",
                definition=definition
            ))


    return RewriteGroup(
        group_name=group_name,
        patterns=patterns,
        type_signature="LLVMPeepholeRewriteRefine 64 Γ",
        comment=comment
    )
    
REWRITE_GENERATORS = [
    lambda: generate_sub_to_add_rewrites(max_val=50),
    lambda: generate_mul_to_shl_rewrites(powers=list(range(0, 64))),
    lambda: generate_urem_pow2_rewrites(powers=list(range(0, 64))),
    lambda: generate_canonicalize_icmp(max_val=5),
    lambda: generate_integer_reassoc_combines(max_val=2),
]

def generate_all_rewrites() -> str:
    sections = []

    for generator in REWRITE_GENERATORS:
      group = generator()
      sections.append(group.generate())

    body = "".join(sections)
    body += """
/-- We group all the rewrites that depend constant folding to optimize the program. Without constant folding, these rewrites would either increase the instruction count, or do not result in any optimization. -/
def GlobalISelPostLegalizerCombinerConstantFolding :
  List (Σ Γ, Σ ty, PeepholeRewrite LLVMPlusRiscV Γ ty) :=
    (List.map (fun ⟨_,y⟩ => mkRewrite (LLVMToRiscvPeepholeRewriteRefine.toPeepholeUNSOUND y))
    irc_constants)
    """
    return body

       
def main():
    script_dir = Path(__file__).parent
    parent_dir = script_dir.parent
    output_file = parent_dir / "ConstantMatching.lean"
    
    content = HEADER + generate_all_rewrites()
    
    with open(output_file, "w") as f:
        f.write(content)

if __name__ == "__main__":
    main()
    
