#!/usr/bin/env python3
from pathlib import Path
from dataclasses import dataclass
from typing import List, Callable

"""
This script generates Lean proofs for LLVM peephole rewrites involving constant matching.
"""

HEADER = """-- AUTOGENERATED Lean file

import SSA.Projects.LLVMRiscV.PeepholeRefine
import SSA.Projects.LLVMRiscV.Simpproc
import SSA.Projects.RISCV64.Tactic.SimpRiscV
import SSA.Projects.LLVMRiscV.Pipeline.mkRewrite

open LLVMRiscV

@[simp_riscv] lemma toType_bv : TyDenote.toType (Ty.riscv (.bv)) = BitVec 64 := rfl
@[simp_riscv] lemma id_eq1 {α : Type} (x y : α) :  @Eq (Id α) x y = (x = y):= by simp only

structure RISCVPeepholeRewrite (Γ : List Ty) where
  lhs : Com LLVMPlusRiscV Γ .pure [Ty.riscv .bv]
  rhs : Com LLVMPlusRiscV Γ .pure [Ty.riscv .bv]
  correct : lhs.denote = rhs.denote := by simp_lowering <;> bv_decide

def RISCVPeepholeRewriteToRiscvPeephole (self : RISCVPeepholeRewrite Γ) :
    PeepholeRewrite LLVMPlusRiscV Γ [Ty.riscv .bv] where
  lhs := self.lhs
  rhs := self.rhs
  correct := self.correct

"""

@dataclass
class RewritePattern:
    name: str
    definition: str

@dataclass
class RewriteGroup:
    group_name: str
    patterns: List[RewritePattern]
    type_signature: str  # e.g., "LLVMPeepholeRewriteRefine 64 Γ"
    comment: str
    
    def generate(self) -> str:
        # Generate all individual definitions
        definitions = "\n".join(p.definition for p in self.patterns)
        
        # Generate the list definition
        rewrite_refs = [f"⟨_, {p.name}⟩" for p in self.patterns]
        list_def = f"\ndef {self.group_name} : List (Σ Γ, {self.type_signature}) :=\n  [\n    "
        list_def += ",\n    ".join(rewrite_refs)
        list_def += "\n  ]\n"
        
        return self.comment + definitions + list_def


def generate_sub_to_add_rewrites(max_val: int) -> RewriteGroup:
    #(sub x, C) → (add x, -C)
    patterns = []
    group_name = "sub_to_add"
    comment = """
/-! ### sub_to_add -/

/-- 
Test the rewrite:
  (sub x, C) → (add x, -C)
-/
"""
    
    for i in range(-max_val, max_val + 1):
        name_suffix = f"neg{abs(i)}" if i < 0 else str(i)
        neg_constant = -i
        
        definition = f"""def {group_name}_{name_suffix} : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.sub %x, %c : i64
      llvm.return %1 : i64
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {neg_constant} : i64
      %1 = llvm.add %x, %c : i64
      llvm.return %1 : i64
  }}]
"""
        
        patterns.append(RewritePattern(
            name=f"{group_name}_{name_suffix}",
            definition=definition
        ))
    
    return RewriteGroup(
        group_name=group_name,
        patterns=patterns,
        type_signature="LLVMPeepholeRewriteRefine 64 Γ",
        comment=comment
    )

def generate_mul_to_shl_rewrites(powers: List[int]) -> RewriteGroup:
    #(x * 2) → x >>> 1
    patterns = []
    group_name = "mul_to_shl"
    comment = """
/-! ### mul_to_shl -/

/--
Test the rewrite:
    (x * 2^n) → (x << n)
-/
"""

    for n in powers:
        power_of_2 = 2 ** n
        
        definition = f"""def {group_name}_{power_of_2} : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant ({power_of_2}) : i64
      %0 = llvm.mul %x, %c : i64
      llvm.return %0 : i64
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant ({n}) : i64
      %0 = llvm.shl %x, %c : i64
      llvm.return %0 : i64
  }}]
"""
        
        patterns.append(RewritePattern(
            name=f"{group_name}_{power_of_2}",
            definition=definition
        ))
    
    return RewriteGroup(
        group_name=group_name,
        patterns=patterns,
        type_signature="LLVMPeepholeRewriteRefine 64 Γ",
        comment=comment
    )
    
def generate_urem_pow2_rewrites(powers: List[int]) -> RewriteGroup:
    # urem(x, pow2) -> x & (pow2 - 1)
    patterns = []
    group_name = "urem_pow2_to_mask"
    comment = """
/-! ### urem_pow2_to_mask -/

/--
Test the rewrite:
    urem(x, 2^n) -> x & (2^n - 1)
-/
""" 
    for n in powers:
        power_of_2 = 2 ** n
        
        definition = f"""def {group_name}_{power_of_2} : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant ({power_of_2}) : i64
      %0 = llvm.urem %x, %c : i64
      llvm.return %0 : i64
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant ({power_of_2-1}) : i64
      %0 = llvm.and %x, %c : i64
      llvm.return %0 : i64
  }}]
"""
        
        patterns.append(RewritePattern(
            name=f"{group_name}_{power_of_2}",
            definition=definition
        ))
    
    return RewriteGroup(
        group_name=group_name,
        patterns=patterns,
        type_signature="LLVMPeepholeRewriteRefine 64 Γ",
        comment=comment
    )
    
def generate_canonicalize_icmp(max_val: int) -> RewriteGroup:
    patterns = []
    group_name = "canonicalize_icmp"
    comment = """
/-! ### canonicalize_icmp -/

/-- 
Test the rewrite:
  (cmp C, x) → (cmp x, C)
-/
"""
    
    for i in range(-max_val, max_val + 1):
        name_suffix = f"neg{abs(i)}" if i < 0 else str(i)
        
        definition = f"""def {group_name}_eq_{name_suffix} : LLVMPeepholeRewriteRefine 1 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.eq %c, %x : i64
      llvm.return %1 : i1
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.eq %x, %c : i64
      llvm.return %1 : i1
  }}]
"""
        
        patterns.append(RewritePattern(
            name=f"{group_name}_eq_{name_suffix}",
            definition=definition
        ))
        
        definition = f"""def {group_name}_ne_{name_suffix} : LLVMPeepholeRewriteRefine 1 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.ne %c, %x : i64
      llvm.return %1 : i1
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.ne %x, %c : i64
      llvm.return %1 : i1
  }}]
"""
        patterns.append(RewritePattern(
            name=f"{group_name}_ne_{name_suffix}",
            definition=definition
        ))
        
        definition = f"""def {group_name}_uge_{name_suffix} : LLVMPeepholeRewriteRefine 1 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.uge %c, %x : i64
      llvm.return %1 : i1
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.ule %x, %c : i64
      llvm.return %1 : i1
  }}]
"""

        patterns.append(RewritePattern(
            name=f"{group_name}_uge_{name_suffix}",
            definition=definition
        ))
        
        definition = f"""def {group_name}_ugt_{name_suffix} : LLVMPeepholeRewriteRefine 1 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.ugt %c, %x : i64
      llvm.return %1 : i1
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.ult %x, %c : i64
      llvm.return %1 : i1
  }}]
"""
        
        patterns.append(RewritePattern(
            name=f"{group_name}_ugt_{name_suffix}",
            definition=definition
        ))
        
        definition = f"""def {group_name}_ult_{name_suffix} : LLVMPeepholeRewriteRefine 1 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.ult %c, %x : i64
      llvm.return %1 : i1
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.ugt %x, %c : i64
      llvm.return %1 : i1
  }}]
"""
        
        patterns.append(RewritePattern(
            name=f"{group_name}_ult_{name_suffix}",
            definition=definition
        ))
        
        definition = f"""def {group_name}_ule_{name_suffix} : LLVMPeepholeRewriteRefine 1 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.ule %c, %x : i64
      llvm.return %1 : i1
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.uge %x, %c : i64
      llvm.return %1 : i1
  }}]
"""
        
        patterns.append(RewritePattern(
            name=f"{group_name}_ule_{name_suffix}",
            definition=definition
        ))
        
        definition = f"""def {group_name}_sgt_{name_suffix} : LLVMPeepholeRewriteRefine 1 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.sgt %c, %x : i64
      llvm.return %1 : i1
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.slt %x, %c : i64
      llvm.return %1 : i1
  }}]
"""
        
        patterns.append(RewritePattern(
            name=f"{group_name}_sgt_{name_suffix}",
            definition=definition
        ))
        
        definition = f"""def {group_name}_sge_{name_suffix} : LLVMPeepholeRewriteRefine 1 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.sge %c, %x : i64
      llvm.return %1 : i1
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.sle %x, %c : i64
      llvm.return %1 : i1
  }}]
"""
        
        patterns.append(RewritePattern(
            name=f"{group_name}_sge_{name_suffix}",
            definition=definition
        ))
        
        definition = f"""def {group_name}_slt_{name_suffix} : LLVMPeepholeRewriteRefine 1 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.slt %c, %x : i64
      llvm.return %1 : i1
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.sgt %x, %c : i64
      llvm.return %1 : i1
  }}]
"""
        
        patterns.append(RewritePattern(
            name=f"{group_name}_slt_{name_suffix}",
            definition=definition
        ))
        
        definition = f"""def {group_name}_sle_{name_suffix} : LLVMPeepholeRewriteRefine 1 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.sle %c, %x : i64
      llvm.return %1 : i1
  }}]
  rhs := [LV| {{
    ^entry (%x: i64):
      %c = llvm.mlir.constant {i} : i64
      %1 = llvm.icmp.sge %x, %c : i64
      llvm.return %1 : i1
  }}]
"""

        patterns.append(RewritePattern(
            name=f"{group_name}_sle_{name_suffix}",
            definition=definition
        ))
    
    return RewriteGroup(
        group_name=group_name,
        patterns=patterns,
        type_signature="LLVMPeepholeRewriteRefine 1 Γ",
        comment=comment
    )
    
def generate_mulh_to_lshr(powers: List[int]) -> RewriteGroup:
    patterns = []
    group_name = "mulh_to_lshr"
    comment = """
/-! ### mulh_to_lshr -/
""" 
    for n in powers:
        power_of_2 = 2 ** n
        
        definition = f"""def {group_name}_{power_of_2} : RISCVPeepholeRewrite [Ty.riscv (.bv)] where
  lhs := [LV| {{
    ^entry (%x: !riscv.reg):
      %c = li ({power_of_2}) : !riscv.reg
      %0 = mulh %c, %x : !riscv.reg
      ret %0 : !riscv.reg
  }}]
  rhs := [LV| {{
    ^entry (%x: !riscv.reg):
      %c = li ({64 - n}) : !riscv.reg
      %0 = sra %x, %c : !riscv.reg
      ret %0 : !riscv.reg
  }}]
"""
        
        patterns.append(RewritePattern(
            name=f"{group_name}_{power_of_2}",
            definition=definition
        ))
    
    return RewriteGroup(
        group_name=group_name,
        patterns=patterns,
        type_signature="RISCVPeepholeRewrite Γ",
        comment=comment
    )
    
REWRITE_GENERATORS = [
    lambda: generate_sub_to_add_rewrites(max_val=5),
    lambda: generate_mul_to_shl_rewrites(powers=list(range(0, 10))),
    lambda: generate_urem_pow2_rewrites(powers=list(range(0, 10))),
    lambda: generate_canonicalize_icmp(max_val=5),
    lambda: generate_mulh_to_lshr(powers=list(range(1, 10))),
]

def generate_all_rewrites() -> str:
    sections = []

    for generator in REWRITE_GENERATORS:
        group = generator()
        sections.append(group.generate())
    
    return "".join(sections)
       
def main():
    script_dir = Path(__file__).parent
    parent_dir = script_dir.parent
    output_file = parent_dir / "ConstantMatching.lean"
    
    content = HEADER + generate_all_rewrites()
    
    with open(output_file, "w") as f:
        f.write(content)

if __name__ == "__main__":
    main()
    
