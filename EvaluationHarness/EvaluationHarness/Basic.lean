import Lean

/-!
# Evaluation Harness

This file defines the `#evaluation in ...` command wrapper, for easier evaluation.
-/
namespace EvaluationHarness

open Lean Meta Elab Command

/--
`SimpleMessage` contains the subset of fields from `SerialMessage` that we
wish to include in the logged output.
-/
protected structure SimpleMessage where
  severity: MessageSeverity
  data: String
  caption: String
  pos: Position
deriving ToJson, FromJson

protected structure Messages where
  messages : List SerialMessage

open EvaluationHarness (Messages SimpleMessage)

/-! ## Message Collection -/

/--
Given a monadic action `cmd : CommandElabM Unit`, run the action, collect all
messages (trace, info, warning and error messages) that the action logged, and
return those. The collected messages are *not* left in the environment.
-/
protected def collectMessages (runCmd : CommandElabM Unit) : CommandElabM Messages := do
  -- NOTE: the following is largely copied from the `#guard_msgs in` command,
  --       with some slight adaptations

  let initMsgs ← modifyGet fun st => (st.messages, { st with messages := {} })
  -- do not forward snapshot as we don't want messages assigned to it to leak outside
  withReader ({ · with snap? := none }) runCmd
  -- collect sync and async messages
  let msgs := (← get).messages ++
    (← get).snapshotTasks.foldl (· ++ ·.get.getAll.foldl (· ++ ·.diagnostics.msgLog) default) {}
  -- clear async messages as we don't want them to leak outside, and
  -- reset messages to initial state
  modify ({ · with
    snapshotTasks := #[]
    messages := initMsgs
  })
  let messages ← msgs.toList
    |>.filter (!·.isSilent)
    |>.mapM (·.serialize)
  return { messages }
open EvaluationHarness (collectMessages)

def Messages.toSimple (self : Messages) : List SimpleMessage :=
  self.messages.map fun m => { m with }

def Messages.toJson (self : Messages) : Json :=
  ToJson.toJson self.toSimple

/-! ## EvaluationConfig -/

structure EvaluationConfig where
  strategy: Option String := none
  outputAsLog: Bool := false
deriving Inhabited

syntax evalConfigElem :=
  ("strategy" " := " str)
syntax evalConfig := "(" evalConfigElem,* ")"

def parseEvaluationConfig (cfgElems : TSyntax ``evalConfig) : EvaluationConfig := Id.run <| do
  let mut cfg := { }
  let `(evalConfig| ( $cfgElems,* ) ) := cfgElems
    | return cfg
  for cfgElem in cfgElems.getElems do
    cfg := match cfgElem with
    | `(evalConfigElem| strategy := $s) =>
        { cfg with strategy := some s.getString }
    | _ =>
        panic! "Unknown configuration option: {elem}"

  return cfg


/-! ## EvaluationInfo -/

structure EvaluationInfo where
  filename: String
  /-- The line number on which `#evaluation in cmd` occurred. -/
  line: Nat
  /-- The collected messages generated by command `cmd`. -/
  messages: List SimpleMessage
  /-- Whether any errors were raised by `cmd`. -/
  hasErrors: Bool
  -- TODO: `data` field for more structured data reporting
  /--
  The name of the elaborated definition/theorem, or `none` if the command
  was neither definition nor theorem.
  -/
  name : Option String
  /--
  An optional user-defined string that can be embedded in the output,
  see `EvaluationConfig` for details.
  -/
  strategy : Option String
deriving ToJson, FromJson

open Lean.Parser.Command in
/--
If `cmd` is a `def` or `theorem`, return the name of the defininition/theorem.
-/
def getDefLikeName? (cmd : TSyntax `command) : Option String :=
  let raw := cmd.raw
  let kind := raw.getKind
  if kind == ``declaration then
    let name := raw[1]![1]![0]!.getId
    some <| name.eraseMacroScopes.toString
  else
    none

def evalEvaluation (cmd : TSyntax `command) (config : EvaluationConfig) : CommandElabM Unit := do
  let msgs ← collectMessages do
    elabCommand cmd
  let info : EvaluationInfo := {
    filename := ← getFileName
    line := (← getRefPosition).line
    messages := msgs.toSimple
    hasErrors := msgs.messages.any (·.severity == .error)
    name := getDefLikeName? cmd
    strategy := config.strategy
  }
  IO.println s!"{toJson info}"

/--
`#evalation in cmd` captures the messages generated by the command `cmd`, and
serializes them into a single json object, together with some extra metadata
such as the name of the current file.

See `EvluationConfig` for details on extra configuration options.
-/
syntax "#evaluation" (evalConfig)? "in" command : command
elab_rules : command
| `(#evaluation in $cmd:command) => evalEvaluation cmd { }
| `(#evaluation $cfg in $cmd:command) => do
    let cfg := parseEvaluationConfig cfg
    evalEvaluation cmd cfg
