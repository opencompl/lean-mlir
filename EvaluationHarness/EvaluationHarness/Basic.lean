import Lean

import EvaluationHarness.Options

/-!
# Evaluation Harness

This file defines the `#evaluation in ...` command wrapper, for easier evaluation.
-/
namespace EvaluationHarness

open Lean Meta Elab Command

/--
`SimpleMessage` contains the subset of fields from `SerialMessage` that we
wish to include in the logged output.
-/
protected structure SimpleMessage where
  severity: MessageSeverity
  data: String
  caption: String
  pos: Position
deriving ToJson, FromJson

protected structure Messages where
  messages : List SerialMessage

open EvaluationHarness (Messages SimpleMessage)

/-! ## Message Collection -/

/--
Given a monadic action `cmd : CommandElabM Unit`, run the action, collect all
messages (trace, info, warning and error messages) that the action logged, and
return those. The collected messages are *not* left in the environment.
-/
protected def collectMessages (runCmd : CommandElabM α) : CommandElabM (α × Messages) := do
  -- NOTE: the following is largely copied from the `#guard_msgs in` command,
  --       with some slight adaptations

  let initMsgs ← modifyGet fun st => (st.messages, { st with messages := {} })
  -- do not forward snapshot as we don't want messages assigned to it to leak outside
  let ret ← withReader ({ · with snap? := none }) runCmd
  -- collect sync and async messages
  let msgs := (← get).messages ++
    (← get).snapshotTasks.foldl (· ++ ·.get.getAll.foldl (· ++ ·.diagnostics.msgLog) default) {}
  -- clear async messages as we don't want them to leak outside, and
  -- reset messages to initial state
  modify ({ · with
    snapshotTasks := #[]
    messages := initMsgs
  })
  let messages ← msgs.toList
    |>.filter (!·.isSilent)
    |>.mapM (·.serialize)
  return ⟨ret, { messages }⟩
open EvaluationHarness (collectMessages)

variable {m} [Monad m] [MonadOptions m] in
def Messages.toSimple (self : Messages) : m (Option <| List SimpleMessage) := do
  if (← getBoolOption `evaluation.includeMessages true) then
    let includePosition ← getBoolOption `evaluation.includePosition true
    some <$> self.messages.mapM fun m =>
      return { m with
        pos := if includePosition then m.pos else ⟨0, 0⟩
      }
  else
    return none

/-! ## EvaluationConfig -/

structure EvaluationConfig where
  strategy: Option String := none
deriving Inhabited

syntax evalConfigElem :=
  ("strategy" " := " str)
syntax evalConfig := "(" evalConfigElem,* ")"

def parseEvaluationConfig (cfgElems : TSyntax ``evalConfig) : EvaluationConfig := Id.run <| do
  let mut cfg := { }
  let `(evalConfig| ( $cfgElems,* ) ) := cfgElems
    | return cfg
  for cfgElem in cfgElems.getElems do
    cfg := match cfgElem with
    | `(evalConfigElem| strategy := $s) =>
        { cfg with strategy := some s.getString }
    | _ =>
        panic! "Unknown configuration option: {elem}"

  return cfg


/-! ## EvaluationInfo -/

structure EvaluationInfo where
  filename: String
  /-- The line number on which `#evaluation in cmd` occurred. -/
  line: Nat
  /--
  The collected messages generated by command `cmd`, or
  `none` when the `evaluation.includeMessages` option is set to `false`.
  -/
  messages: Option (List SimpleMessage)
  /--
  Whether any errors were raised by `cmd`.

  NOTE: this is reported regardless of the `includeMessages` option.
  -/
  hasErrors: Bool
  /--
  The time elapsed while elaborating `cmd`, or `none` when the
  `evaluation.includeWalltime` option is set to `false` (which is the default).
  -/
  wallTime : Option Float
  -- TODO: `data` field for more structured data reporting
  /--
  The name of the elaborated definition/theorem, or `none` if the command
  was neither definition nor theorem.
  -/
  name : Option String
  /--
  An optional user-defined string that can be embedded in the output,
  see `EvaluationConfig` for details.
  -/
  strategy : Option String
deriving ToJson, FromJson

open Lean.Parser.Command in
/--
If `cmd` is a `def` or `theorem`, return the name of the defininition/theorem.
-/
def getDefLikeName? (cmd : TSyntax `command) : Option String :=
  let raw := cmd.raw
  let kind := raw.getKind
  if kind == ``declaration then
    let name := raw[1]![1]![0]!.getId
    some <| name.eraseMacroScopes.toString
  else
    none

/--
Run `cmd` and return the elapsed wall-time, or run the command but return `none`
when the `evaluation.includeWalltime` option is set to `false` (which is the
default).
-/
def measureWallTime (cmd : CommandElabM Unit) : CommandElabM (Option Float) := do
  if (← getBoolOption `evaluation.includeWallTime false) then
    let t1 ← IO.monoNanosNow
    cmd
    let t2 ← IO.monoNanosNow
    return some (deltaInMs t2 t1)
  else
    cmd
    return none
where
  deltaInMs (now past : Nat) : Float :=
    (Float.ofNat <| now - past) / 1000000.0

def evalEvaluation (cmd : TSyntax `command) (config : EvaluationConfig) : CommandElabM Unit := do
  let (wallTime, msgs) ← collectMessages <| measureWallTime <| do
    elabCommand cmd
  let info : EvaluationInfo := {
    filename := ← getFileName
    line :=← getRefLine
    messages := ← msgs.toSimple
    hasErrors := msgs.messages.any (·.severity == .error)
    wallTime
    name := getDefLikeName? cmd
    strategy := config.strategy
  }
  let info := s!"{toJson info}"
  if (← getBoolOption `evaluation.outputAsLog) then
    logInfo info
  else
    IO.println info
where
  getRefLine {m} [Monad m] [MonadOptions m] [MonadLog m] : m Nat := do
    if (← getBoolOption `evaluation.includePosition true) then
      return (← getRefPosition).line
    else
      return 0

/--
`#evalation in cmd` captures the messages generated by the command `cmd`, and
serializes them into a single json object, together with some extra metadata
such as the name of the current file.

See `EvluationConfig` for details on extra configuration options.
-/
syntax "#evaluation" (evalConfig)? "in" command : command
elab_rules : command
| `(#evaluation in $cmd:command) => evalEvaluation cmd { }
| `(#evaluation $cfg in $cmd:command) => do
    let cfg := parseEvaluationConfig cfg
    evalEvaluation cmd cfg
