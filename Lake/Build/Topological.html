<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="stylesheet" href="../.././src/pygments.css"></link><link rel="shortcut icon" href="../.././favicon.ico"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Lake.Build.Topological</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Lake.Build.Topological";</script><script type="module" src="../.././search.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label>Documentation</h1><p class="header_filename break_within"><span class="name">Lake</span>.<span class="name">Build</span>.<span class="name">Topological</span></p><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;
            <button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><h3><a class="break_within" href="#top"><span class="name">Lake</span>.<span class="name">Build</span>.<span class="name">Topological</span></a></h3><p class="gh_nav_link"><a href="https://example.com">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Lake/Util/Cycle.html">Lake.Util.Cycle</a></li><li><a href="../.././Lake/Util/EquipT.html">Lake.Util.EquipT</a></li><li><a href="../.././Lake/Util/Store.html">Lake.Util.Store</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Lake.Build.Topological" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lake.DFetchFn"><span class="name">Lake</span>.<span class="name">DFetchFn</span></a></div><div class="nav_link"><a class="break_within" href="#Lake.DFetchT"><span class="name">Lake</span>.<span class="name">DFetchT</span></a></div><div class="nav_link"><a class="break_within" href="#Lake.FetchT"><span class="name">Lake</span>.<span class="name">FetchT</span></a></div><div class="nav_link"><a class="break_within" href="#Lake.DRecFetchFn"><span class="name">Lake</span>.<span class="name">DRecFetchFn</span></a></div><div class="nav_link"><a class="break_within" href="#Lake.RecFetchFn"><span class="name">Lake</span>.<span class="name">RecFetchFn</span></a></div><div class="nav_link"><a class="break_within" href="#Lake.recFetch"><span class="name">Lake</span>.<span class="name">recFetch</span></a></div><div class="nav_link"><a class="break_within" href="#Lake.recFetchAcyclic"><span class="name">Lake</span>.<span class="name">recFetchAcyclic</span></a></div><div class="nav_link"><a class="break_within" href="#Lake.recFetchMemoize"><span class="name">Lake</span>.<span class="name">recFetchMemoize</span></a></div><div class="nav_link"><a class="break_within" href="#Lake.buildAcyclic"><span class="name">Lake</span>.<span class="name">buildAcyclic</span></a></div><div class="nav_link"><a class="break_within" href="#Lake.buildDTop"><span class="name">Lake</span>.<span class="name">buildDTop</span></a></div><div class="nav_link"><a class="break_within" href="#Lake.buildTop"><span class="name">Lake</span>.<span class="name">buildTop</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Topological-Suspending-Recursive-Builder">Topological / Suspending Recursive Builder <a class="hover-link" href="#Topological-Suspending-Recursive-Builder">#</a></h1><p>This module defines a recursive build function that topologically
(ι.e., via a depth-first search with memoization) builds the elements of
a build store.</p><p>This is called a suspending scheduler in <em>Build systems à la carte</em>.</p></div><div class="mod_doc"><h2 class="markdown-heading" id="Recursive-Fetching">Recursive Fetching <a class="hover-link" href="#Recursive-Fetching">#</a></h2><p>In this section, we define the primitives that make up a builder.</p></div><div class="decl" id="Lake.DFetchFn"><div class="def"><div class="gh_link"><a href="https://example.com#L36-L37">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Lake/Build/Topological.html#Lake.DFetchFn"><span class="name">Lake</span>.<span class="name">DFetchFn</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(β : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Type</a> v</span>)</span></span>
<span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../.././foundational_types.html">Type</a> v → <a href="../.././foundational_types.html">Type</a> w</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> (maxuw)</div></div><p>A dependently typed monadic <em>fetch</em> function.</p><p>That is, a function within the monad <code>m</code> and takes an input <code>a : α</code>
describing what to fetch and and produces some output <code>b : β a</code> (dependently
typed) or <code>b : B</code> (not) describing what was fetched. All build functions are
fetch functions, but not all fetch functions need build something.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.DFetchFn">Lake.DFetchFn</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">m</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> (<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">m</span> (<span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lake.DFetchFn" class="instances-for-list"></ul></details></div></div><div class="mod_doc"><p>In order to nest builds / fetches within one another,
we equip the monad <code>m</code> with a fetch function of its own.</p></div><div class="decl" id="Lake.DFetchT"><div class="def"><div class="gh_link"><a href="https://example.com#L45-L46">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Lake/Build/Topological.html#Lake.DFetchT"><span class="name">Lake</span>.<span class="name">DFetchT</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(β : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Type</a> v</span>)</span></span>
<span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../.././foundational_types.html">Type</a> v → <a href="../.././foundational_types.html">Type</a> w</span>)</span></span>
<span class="decl_args">
<span class="fn">(α : <a href="../.././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> (max(maxwu)w)</div></div><p>A transformer that equips a monad with a <code><a href="../.././Lake/Build/Topological.html#Lake.DFetchFn">DFetchFn</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.DFetchT">Lake.DFetchT</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">m</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lake/Util/EquipT.html#Lake.EquipT">Lake.EquipT</a> (<span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.DFetchFn">Lake.DFetchFn</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">m</span></span>) <span class="fn">m</span></span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lake.DFetchT" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lake.FetchT"><div class="def"><div class="gh_link"><a href="https://example.com#L49-L50">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Lake/Build/Topological.html#Lake.FetchT"><span class="name">Lake</span>.<span class="name">FetchT</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href="../.././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../.././foundational_types.html">Type</a> v → <a href="../.././foundational_types.html">Type</a> w</span>)</span></span>
<span class="decl_args">
<span class="fn">(α : <a href="../.././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> (max(maxwu)w)</div></div><p>A <code><a href="../.././Lake/Build/Topological.html#Lake.DFetchT">DFetchT</a></code> that is not dependently typed.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.FetchT">Lake.FetchT</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">m</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.DFetchT">Lake.DFetchT</a> <span class="fn">α</span> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn">β</span></span>) <span class="fn">m</span></span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lake.FetchT" class="instances-for-list"></ul></details></div></div><div class="mod_doc"><p>We can then use the such a monad as the basis for a fetch function itself.</p></div><div class="decl" id="Lake.DRecFetchFn"><div class="def"><div class="gh_link"><a href="https://example.com#L61-L62">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Lake/Build/Topological.html#Lake.DRecFetchFn"><span class="name">Lake</span>.<span class="name">DRecFetchFn</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(β : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Type</a> v</span>)</span></span>
<span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../.././foundational_types.html">Type</a> v → <a href="../.././foundational_types.html">Type</a> w</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> (maxuwu)</div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.DRecFetchFn">Lake.DRecFetchFn</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">m</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.DFetchFn">Lake.DFetchFn</a> <span class="fn">α</span> <span class="fn">β</span> (<span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.DFetchT">Lake.DFetchT</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">m</span></span>)</span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lake.DRecFetchFn" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lake.RecFetchFn"><div class="def"><div class="gh_link"><a href="https://example.com#L65-L66">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Lake/Build/Topological.html#Lake.RecFetchFn"><span class="name">Lake</span>.<span class="name">RecFetchFn</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href="../.././foundational_types.html">Type</a> v)</span></span>
<span class="decl_args">
<span class="fn">(m : <span class="fn"><a href="../.././foundational_types.html">Type</a> v → <a href="../.././foundational_types.html">Type</a> w</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> (maxuw)</div></div><p>A <code><a href="../.././Lake/Build/Topological.html#Lake.DRecFetchFn">DRecFetchFn</a></code> that is not dependently typed.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.RecFetchFn">Lake.RecFetchFn</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">m</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">α</span> → <span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.FetchT">Lake.FetchT</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">m</span> <span class="fn">β</span></span></span>)</span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lake.RecFetchFn" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lake.recFetch"><div class="opaque"><div class="gh_link"><a href="https://example.com#L69-L71">source</a></div><div class="attributes">@[specialize #[]]</div>
<div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Lake/Build/Topological.html#Lake.recFetch"><span class="name">Lake</span>.<span class="name">recFetch</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><a href="../.././foundational_types.html">Type</a> u → <a href="../.././foundational_types.html">Type</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Type</a> u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">∀ (<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u), <span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> (<span class="fn"><span class="fn">m</span> <span class="fn">α</span></span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(fetch : <span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.DRecFetchFn">Lake.DRecFetchFn</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">m</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.DFetchFn">Lake.DFetchFn</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">m</span></span></div></div><p>A <code><a href="../.././Lake/Build/Topological.html#Lake.DFetchFn">DFetchFn</a></code> that provides its base <code><a href="../.././Lake/Build/Topological.html#Lake.DRecFetchFn">DRecFetchFn</a></code> with itself.</p></div></div><div class="mod_doc"><p>The basic <code><a href="../.././Lake/Build/Topological.html#Lake.recFetch">recFetch</a></code> can fail to terminate in a variety of ways,
it can even cycle (i.e., <code>a</code> fetches <code>b</code> which fetches <code>a</code>). Thus, we
define the <code>acyclicRecFetch</code> below to guard against such cases.</p></div><div class="decl" id="Lake.recFetchAcyclic"><div class="def"><div class="gh_link"><a href="https://example.com#L87-L95">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lake/Build/Topological.html#Lake.recFetchAcyclic"><span class="name">Lake</span>.<span class="name">recFetchAcyclic</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{κ : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><a href="../.././foundational_types.html">Type</a> u_1 → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Type</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">κ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(keyOf : <span class="fn"><span class="fn">α</span> → <span class="fn">κ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(fetch : <span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.DRecFetchFn">Lake.DRecFetchFn</a> <span class="fn">α</span> <span class="fn">β</span> (<span class="fn"><a href="../.././Lake/Util/Cycle.html#Lake.CycleT">Lake.CycleT</a> <span class="fn">κ</span> <span class="fn">m</span></span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.DFetchFn">Lake.DFetchFn</a> <span class="fn">α</span> <span class="fn">β</span> (<span class="fn"><a href="../.././Lake/Util/Cycle.html#Lake.CycleT">Lake.CycleT</a> <span class="fn">κ</span> <span class="fn">m</span></span>)</span></div></div><p>A <code><a href="../.././Lake/Build/Topological.html#Lake.recFetch">recFetch</a></code> augmented by a <code>CycleT</code> to guard against recursive cycles.
If the set of visited keys is finite, this function should provably terminate.</p><p>We use <code>keyOf</code> to the derive the unique key of a fetch from its descriptor
<code>a : α</code>. We do this because descriptors may not be comparable and/or contain
more information than necessary to determine uniqueness.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.recFetchAcyclic">Lake.recFetchAcyclic</a> <span class="fn">keyOf</span> <span class="fn">fetch</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.recFetch">Lake.recFetch</a> <span class="fn">fun <span class="fn">a</span> <span class="fn">recurse</span> =&gt <span class="fn"><a href="../.././Lake/Util/Cycle.html#Lake.guardCycle">Lake.guardCycle</a> (<span class="fn"><span class="fn">keyOf</span> <span class="fn">a</span></span>) <span class="fn">fun <span class="fn">stack</span> =&gt <span class="fn"><span class="fn">fetch</span> <span class="fn">a</span> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><a href="../.././Init/Prelude.html#liftM">liftM</a> (<span class="fn"><span class="fn">recurse</span> <span class="fn">x</span> <span class="fn">stack</span></span>)</span></span>) <span class="fn">stack</span></span></span></span></span></span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lake.recFetchAcyclic" class="instances-for-list"></ul></details></div></div><div class="mod_doc"><p>When building, we usually do not want to build the same thing twice during
a single build pass. At the same time, separate builds may both wish to fetch
the same thing. Thus, we need to store past build results to return them upon
future fetches. This is what <code><a href="../.././Lake/Build/Topological.html#Lake.recFetchMemoize">recFetchMemoize</a></code> below does.</p></div><div class="decl" id="Lake.recFetchMemoize"><div class="def"><div class="gh_link"><a href="https://example.com#L108-L112">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lake/Build/Topological.html#Lake.recFetchMemoize"><span class="name">Lake</span>.<span class="name">recFetchMemoize</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{κ : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><a href="../.././foundational_types.html">Type</a> u_1 → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">κ</span> → <a href="../.././foundational_types.html">Type</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">κ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Lake/Util/Store.html#Lake.MonadDStore">Lake.MonadDStore</a> <span class="fn">κ</span> <span class="fn">β</span> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(keyOf : <span class="fn"><span class="fn">α</span> → <span class="fn">κ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(fetch : <span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.DRecFetchFn">Lake.DRecFetchFn</a> <span class="fn">α</span> (<span class="fn">fun <span class="fn">a</span> =&gt <span class="fn"><span class="fn">β</span> (<span class="fn"><span class="fn">keyOf</span> <span class="fn">a</span></span>)</span></span>) (<span class="fn"><a href="../.././Lake/Util/Cycle.html#Lake.CycleT">Lake.CycleT</a> <span class="fn">κ</span> <span class="fn">m</span></span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.DFetchFn">Lake.DFetchFn</a> <span class="fn">α</span> (<span class="fn">fun <span class="fn">a</span> =&gt <span class="fn"><span class="fn">β</span> (<span class="fn"><span class="fn">keyOf</span> <span class="fn">a</span></span>)</span></span>) (<span class="fn"><a href="../.././Lake/Util/Cycle.html#Lake.CycleT">Lake.CycleT</a> <span class="fn">κ</span> <span class="fn">m</span></span>)</span></div></div><p><code><a href="../.././Lake/Build/Topological.html#Lake.recFetchAcyclic">recFetchAcyclic</a></code> augmented with a <code>MonadDStore</code> to
memoize fetch results and thus avoid computing the same result twice.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.recFetchMemoize">Lake.recFetchMemoize</a> <span class="fn">keyOf</span> <span class="fn">fetch</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.recFetchAcyclic">Lake.recFetchAcyclic</a> <span class="fn">keyOf</span> <span class="fn">fun <span class="fn">a</span> <span class="fn">recurse</span> =&gt <span class="fn"><a href="../.././Lake/Util/Store.html#Lake.fetchOrCreate">Lake.fetchOrCreate</a> (<span class="fn"><span class="fn">keyOf</span> <span class="fn">a</span></span>) (<span class="fn"><span class="fn">fetch</span> <span class="fn">a</span> <span class="fn">recurse</span></span>)</span></span></span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lake.recFetchMemoize" class="instances-for-list"></ul></details></div></div><div class="mod_doc"><h2 class="markdown-heading" id="Building">Building <a class="hover-link" href="#Building">#</a></h2><p>In this section, we use the abstractions we have just created to define
the desired topological recursive build function (a.k.a. a suspending scheduler).</p></div><div class="decl" id="Lake.buildAcyclic"><div class="def"><div class="gh_link"><a href="https://example.com#L122-L124">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lake/Build/Topological.html#Lake.buildAcyclic"><span class="name">Lake</span>.<span class="name">buildAcyclic</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{κ : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><a href="../.././foundational_types.html">Type</a> u_1 → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">κ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(keyOf : <span class="fn"><span class="fn">α</span> → <span class="fn">κ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(build : <span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.RecFetchFn">Lake.RecFetchFn</a> <span class="fn">α</span> <span class="fn">β</span> (<span class="fn"><a href="../.././Lake/Util/Cycle.html#Lake.CycleT">Lake.CycleT</a> <span class="fn">κ</span> <span class="fn">m</span></span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Control/Except.html#ExceptT">ExceptT</a> (<span class="fn"><a href="../.././Lake/Util/Cycle.html#Lake.Cycle">Lake.Cycle</a> <span class="fn">κ</span></span>) <span class="fn">m</span> <span class="fn">β</span></span></div></div><p>Recursively builds objects for the keys <code>κ</code>, avoiding cycles.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.buildAcyclic">Lake.buildAcyclic</a> <span class="fn">keyOf</span> <span class="fn">a</span> <span class="fn">build</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.recFetchAcyclic">Lake.recFetchAcyclic</a> <span class="fn">keyOf</span> <span class="fn">build</span> <span class="fn">a</span> <span class="fn">[]</span></span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lake.buildAcyclic" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lake.buildDTop"><div class="def"><div class="gh_link"><a href="https://example.com#L127-L130">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lake/Build/Topological.html#Lake.buildDTop"><span class="name">Lake</span>.<span class="name">buildDTop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{κ : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><a href="../.././foundational_types.html">Type</a> u_1 → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(β : <span class="fn"><span class="fn">κ</span> → <a href="../.././foundational_types.html">Type</a> u_1</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">κ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Lake/Util/Store.html#Lake.MonadDStore">Lake.MonadDStore</a> <span class="fn">κ</span> <span class="fn">β</span> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(keyOf : <span class="fn"><span class="fn">α</span> → <span class="fn">κ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(build : <span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.DRecFetchFn">Lake.DRecFetchFn</a> <span class="fn">α</span> (<span class="fn">fun <span class="fn">a</span> =&gt <span class="fn"><span class="fn">β</span> (<span class="fn"><span class="fn">keyOf</span> <span class="fn">a</span></span>)</span></span>) (<span class="fn"><a href="../.././Lake/Util/Cycle.html#Lake.CycleT">Lake.CycleT</a> <span class="fn">κ</span> <span class="fn">m</span></span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Control/Except.html#ExceptT">ExceptT</a> (<span class="fn"><a href="../.././Lake/Util/Cycle.html#Lake.Cycle">Lake.Cycle</a> <span class="fn">κ</span></span>) <span class="fn">m</span> (<span class="fn"><span class="fn">β</span> (<span class="fn"><span class="fn">keyOf</span> <span class="fn">a</span></span>)</span>)</span></div></div><p>Dependently typed version of <code><a href="../.././Lake/Build/Topological.html#Lake.buildTop">buildTop</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.buildDTop">Lake.buildDTop</a> <span class="fn">β</span> <span class="fn">keyOf</span> <span class="fn">a</span> <span class="fn">build</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.recFetchMemoize">Lake.recFetchMemoize</a> <span class="fn">keyOf</span> <span class="fn">build</span> <span class="fn">a</span> <span class="fn">[]</span></span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lake.buildDTop" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lake.buildTop"><div class="def"><div class="gh_link"><a href="https://example.com#L137-L139">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lake/Build/Topological.html#Lake.buildTop"><span class="name">Lake</span>.<span class="name">buildTop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{κ : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><a href="../.././foundational_types.html">Type</a> u_1 → <a href="../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">κ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href="../.././Lake/Util/Store.html#Lake.MonadStore">Lake.MonadStore</a> <span class="fn">κ</span> <span class="fn">β</span> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(keyOf : <span class="fn"><span class="fn">α</span> → <span class="fn">κ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(build : <span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.RecFetchFn">Lake.RecFetchFn</a> <span class="fn">α</span> <span class="fn">β</span> (<span class="fn"><a href="../.././Lake/Util/Cycle.html#Lake.CycleT">Lake.CycleT</a> <span class="fn">κ</span> <span class="fn">m</span></span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Control/Except.html#ExceptT">ExceptT</a> (<span class="fn"><a href="../.././Lake/Util/Cycle.html#Lake.Cycle">Lake.Cycle</a> <span class="fn">κ</span></span>) <span class="fn">m</span> <span class="fn">β</span></span></div></div><p>Recursively fills a <code>MonadStore</code> of key-object pairs by
building objects topologically (ι.e., depth-first with memoization).
If a cycle is detected, the list of keys traversed is thrown.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.buildTop">Lake.buildTop</a> <span class="fn">keyOf</span> <span class="fn">a</span> <span class="fn">build</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lake/Build/Topological.html#Lake.recFetchMemoize">Lake.recFetchMemoize</a> <span class="fn">keyOf</span> <span class="fn">build</span> <span class="fn">a</span> <span class="fn">[]</span></span></span></li></ul></details><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lake.buildTop" class="instances-for-list"></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>