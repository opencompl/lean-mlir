<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="stylesheet" href="../.././src/pygments.css"></link><link rel="shortcut icon" href="../.././favicon.ico"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Lean.Elab.Match</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Lean.Elab.Match";</script><script type="module" src="../.././search.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label>Documentation</h1><p class="header_filename break_within"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Match</span></p><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;
            <button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><h3><a class="break_within" href="#top"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Match</span></a></h3><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/Match.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Lean/Elab/BindersUtil.html">Lean.Elab.BindersUtil</a></li><li><a href="../.././Lean/Elab/PatternVar.html">Lean.Elab.PatternVar</a></li><li><a href="../.././Lean/Elab/SyntheticMVars.html">Lean.Elab.SyntheticMVars</a></li><li><a href="../.././Lean/Meta/ForEachExpr.html">Lean.Meta.ForEachExpr</a></li><li><a href="../.././Lean/Meta/GeneralizeVars.html">Lean.Meta.GeneralizeVars</a></li><li><a href="../.././Lean/Util/ForEachExprWhere.html">Lean.Util.ForEachExprWhere</a></li><li><a href="../.././Lean/Elab/Quotation/Precheck.html">Lean.Elab.Quotation.Precheck</a></li><li><a href="../.././Lean/Meta/Match/Match.html">Lean.Meta.Match.Match</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Lean.Elab.Match" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.isAtomicDiscr"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">isAtomicDiscr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.Discr"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">Discr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.instInhabitedDiscr"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">instInhabitedDiscr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.ElabMatchTypeAndDiscrsResult"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">ElabMatchTypeAndDiscrsResult</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.expandMacrosInPatterns"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">expandMacrosInPatterns</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.elabInaccessible"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">elabInaccessible</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.precheckMatch"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">precheckMatch</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.PatternVarDecl"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">PatternVarDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.PatternElabException"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">PatternElabException</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.ToDepElimPattern.State"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">ToDepElimPattern</span>.<span class="name">State</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.ToDepElimPattern.Context"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">ToDepElimPattern</span>.<span class="name">Context</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.ToDepElimPattern.M"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">ToDepElimPattern</span>.<span class="name">M</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.ToDepElimPattern.isExplicitPatternVar"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">ToDepElimPattern</span>.<span class="name">isExplicitPatternVar</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.ToDepElimPattern.normalize"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">ToDepElimPattern</span>.<span class="name">normalize</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.ToDepElimPattern.normalize.addVar"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">ToDepElimPattern</span>.<span class="name">normalize</span>.<span class="name">addVar</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.ToDepElimPattern.normalize.processVar"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">ToDepElimPattern</span>.<span class="name">normalize</span>.<span class="name">processVar</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.ToDepElimPattern.normalize.processInaccessible"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">ToDepElimPattern</span>.<span class="name">normalize</span>.<span class="name">processInaccessible</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.ToDepElimPattern.TopSort.State"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">ToDepElimPattern</span>.<span class="name">TopSort</span>.<span class="name">State</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.ToDepElimPattern.TopSortM"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">ToDepElimPattern</span>.<span class="name">TopSortM</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.ToDepElimPattern.savePatternInfo"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">ToDepElimPattern</span>.<span class="name">savePatternInfo</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.ToDepElimPattern.savePatternInfo.go"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">ToDepElimPattern</span>.<span class="name">savePatternInfo</span>.<span class="name">go</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.ToDepElimPattern.main"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">ToDepElimPattern</span>.<span class="name">main</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.ToDepElimPattern.main.pack"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">ToDepElimPattern</span>.<span class="name">main</span>.<span class="name">pack</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.ToDepElimPattern.main.unpack"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">ToDepElimPattern</span>.<span class="name">main</span>.<span class="name">unpack</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.ToDepElimPattern.main.unpack.go"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">ToDepElimPattern</span>.<span class="name">main</span>.<span class="name">unpack</span>.<span class="name">go</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.withDepElimPatterns"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">withDepElimPatterns</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.GeneralizeResult"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">GeneralizeResult</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.mkMatcher"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">mkMatcher</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.match.ignoreUnusedAlts"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">match</span>.<span class="name">ignoreUnusedAlts</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.reportMatcherResultErrors"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">reportMatcherResultErrors</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.elabMatch"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">elabMatch</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.elabMatch.elabMatchDefault"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">elabMatch</span>.<span class="name">elabMatchDefault</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.elabNoMatch"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">elabNoMatch</span></a></div></nav><main>
<div class="decl" id="Lean.Elab.Term.isAtomicDiscr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/Match.lean#L45-L50">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Match.html#Lean.Elab.Term.isAtomicDiscr"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">isAtomicDiscr</span></a></span><span class="decl_args">
<span class="fn">(discr : <a href="../.././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <a href="../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Remark: if the discriminat is <code>Systax.missing</code>, we abort the elaboration of the <code>match</code>-expression.
This can happen due to error recovery. Example</p><pre><code>example : (p ∨ p) → p := fun h => match
</code></pre><p>If we don't abort, the elaborator loops because we will keep trying to expand</p><pre><code>match
</code></pre><p>into</p><pre><code>let d := <Syntax.missing>; match
</code></pre><p>Recall that <code>Syntax.setArg stx i arg</code> is a no-op when <code>i</code> is out-of-bounds.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Elab.Term.Discr"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/Match.lean#L57-L61">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Match.html#Lean.Elab.Term.Discr"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">Discr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="Lean.Elab.Term.Discr.mk"><li id="Lean.Elab.Term.Discr.expr" class="structure_field"><div class="structure_field_info">expr : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></div></li><li id="Lean.Elab.Term.Discr.h?" class="structure_field"><div class="structure_field_doc"><p><code>some h</code> if discriminant is annotated with the <code>h : </code> notation.</p></div><div class="structure_field_info">h? : <span class="fn"><a href="../.././Init/Prelude.html#Option">Option</a> <a href="../.././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></span></div></li></ul><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Elab.Term.Discr" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Elab.Term.instInhabitedDiscr"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/Match.lean#L61-L61">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Match.html#Lean.Elab.Term.instInhabitedDiscr"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">instInhabitedDiscr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../.././Lean/Elab/Match.html#Lean.Elab.Term.Discr">Lean.Elab.Term.Discr</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Elab/Match.html#Lean.Elab.Term.instInhabitedDiscr">Lean.Elab.Term.instInhabitedDiscr</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">{ <span class="fn">expr</span> := <span class="fn">default</span>, <span class="fn">h?</span> := <span class="fn">default</span> }</span> }</span></span></li></ul></details></div></div><div class="decl" id="Lean.Elab.Term.ElabMatchTypeAndDiscrsResult"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/Match.lean#L63-L69">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Match.html#Lean.Elab.Term.ElabMatchTypeAndDiscrsResult"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">ElabMatchTypeAndDiscrsResult</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="Lean.Elab.Term.ElabMatchTypeAndDiscrsResult.mk"><li id="Lean.Elab.Term.ElabMatchTypeAndDiscrsResult.discrs" class="structure_field"><div class="structure_field_info">discrs : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Elab/Match.html#Lean.Elab.Term.Discr">Lean.Elab.Term.Discr</a></span></div></li><li id="Lean.Elab.Term.ElabMatchTypeAndDiscrsResult.matchType" class="structure_field"><div class="structure_field_info">matchType : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></div></li><li id="Lean.Elab.Term.ElabMatchTypeAndDiscrsResult.isDep" class="structure_field"><div class="structure_field_doc"><p><code>true</code> when performing dependent elimination. We use this to decide whether we optimize the "match unit" case.
See <code>isMatchUnit?</code>.</p></div><div class="structure_field_info">isDep : <a href="../.././Init/Prelude.html#Bool">Bool</a></div></li><li id="Lean.Elab.Term.ElabMatchTypeAndDiscrsResult.alts" class="structure_field"><div class="structure_field_info">alts : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Elab/MatchAltView.html#Lean.Elab.Term.MatchAltView">Lean.Elab.Term.MatchAltView</a></span></div></li></ul><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Elab.Term.ElabMatchTypeAndDiscrsResult" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Elab.Term.expandMacrosInPatterns"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/Match.lean#L133-L136">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Match.html#Lean.Elab.Term.expandMacrosInPatterns"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">expandMacrosInPatterns</span></a></span><span class="decl_args">
<span class="fn">(matchAlts : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Elab/MatchAltView.html#Lean.Elab.Term.MatchAltView">Lean.Elab.Term.MatchAltView</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Lean.MacroM">Lean.MacroM</a> (<span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Elab/MatchAltView.html#Lean.Elab.Term.MatchAltView">Lean.Elab.Term.MatchAltView</a></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Elab.Term.elabInaccessible"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/Match.lean#L155-L157">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Match.html#Lean.Elab.Term.elabInaccessible"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">elabInaccessible</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElab">Lean.Elab.Term.TermElab</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lean/Elab/Match.html#Lean.Elab.Term.elabInaccessible">Lean.Elab.Term.elabInaccessible</a> <span class="fn">stx</span> <span class="fn">expectedType?</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let e ← <span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.elabTerm">Lean.Elab.Term.elabTerm</a> <span class="fn"><span class="fn">stx</span>[<span class="fn">1</span>]</span> <span class="fn">expectedType?</span> <a href="../.././Init/Prelude.html#Bool.true">true</a> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>
  <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> (<span class="fn"><a href="../.././Lean/Expr.html#Lean.mkInaccessible">Lean.mkInaccessible</a> <span class="fn">e</span></span>)</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Elab.Term.precheckMatch"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/Match.lean#L160-L168">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Match.html#Lean.Elab.Term.precheckMatch"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">precheckMatch</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Elab/Quotation/Precheck.html#Lean.Elab.Term.Quotation.Precheck">Lean.Elab.Term.Quotation.Precheck</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Elab.Term.PatternVarDecl"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/Match.lean#L171-L172">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Match.html#Lean.Elab.Term.PatternVarDecl"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">PatternVarDecl</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="Lean.Elab.Term.PatternVarDecl.mk"><li id="Lean.Elab.Term.PatternVarDecl.fvarId" class="structure_field"><div class="structure_field_info">fvarId : <a href="../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a></div></li></ul><p>We convert the collected <code>PatternVar</code>s intro <code><a href="../.././Lean/Elab/Match.html#Lean.Elab.Term.PatternVarDecl">PatternVarDecl</a></code></p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Elab.Term.PatternVarDecl" class="instances-for-list"></ul></details></div></div><div class="mod_doc"><p>Remark: when performing dependent pattern matching, we often had to write code such as</p><pre><code class="language-lean">def Vec.map' (f : α → β) (xs : Vec α n) : Vec β n :=
  match n, xs with
  | _, nil       => nil
  | _, cons a as => cons (f a) (map' f as)
</code></pre><p>We had to include <code>n</code> and the <code>_</code>s because the type of <code>xs</code> depends on <code>n</code>.
Moreover, <code>nil</code> and <code>cons a as</code> have different types.
This was quite tedious. So, we have implemented an automatic "discriminant refinement procedure".
The procedure is based on the observation that we get a type error whenenver we forget to include <code>_</code>s
and the indices a discriminant depends on. So, we catch the exception, check whether the type of the discriminant
is an indexed family, and add their indices as new discriminants.</p><p>The current implementation, adds indices as they are found, and does not
try to "sort" the new discriminants.</p><p>If the refinement process fails, we report the original error message.</p></div><div class="decl" id="Lean.Elab.Term.PatternElabException"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/Match.lean#L209-L212">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Match.html#Lean.Elab.Term.PatternElabException"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">PatternElabException</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="Lean.Elab.Term.PatternElabException.mk"><li id="Lean.Elab.Term.PatternElabException.ex" class="structure_field"><div class="structure_field_info">ex : <a href="../.././Lean/Exception.html#Lean.Exception">Lean.Exception</a></div></li><li id="Lean.Elab.Term.PatternElabException.patternIdx" class="structure_field"><div class="structure_field_info">patternIdx : <a href="../.././Init/Prelude.html#Nat">Nat</a></div></li><li id="Lean.Elab.Term.PatternElabException.pathToIndex" class="structure_field"><div class="structure_field_info">pathToIndex : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Init/Prelude.html#Nat">Nat</a></span></div></li></ul><p>Auxiliary structure for storing an type mismatch exception when processing the
pattern #<code>idx</code> of some alternative.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Elab.Term.PatternElabException" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Elab.Term.ToDepElimPattern.State"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/Match.lean#L363-L364">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.State"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">ToDepElimPattern</span>.<span class="name">State</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="Lean.Elab.Term.ToDepElimPattern.State.mk"><li id="Lean.Elab.Term.ToDepElimPattern.State.patternVars" class="structure_field"><div class="structure_field_info">patternVars : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></li></ul><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Elab.Term.ToDepElimPattern.State" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Elab.Term.ToDepElimPattern.Context"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/Match.lean#L366-L376">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.Context"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">ToDepElimPattern</span>.<span class="name">Context</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="Lean.Elab.Term.ToDepElimPattern.Context.mk"><li id="Lean.Elab.Term.ToDepElimPattern.Context.userName" class="structure_field"><div class="structure_field_doc"><p>When visiting an assigned metavariable, if it has an user-name. We save it here.
We want to preserve these user-names when generating new pattern variables.</p></div><div class="structure_field_info">userName : <a href="../.././Init/Prelude.html#Lean.Name">Lean.Name</a></div></li><li id="Lean.Elab.Term.ToDepElimPattern.Context.explicitPatternVars" class="structure_field"><div class="structure_field_doc"><p>Pattern variables that were explicitly provided by the user.
Recall that implicit parameters and <code>_</code> are elaborated as metavariables, and then converted into pattern variables
by the <code><a href="../.././Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.normalize">normalize</a></code> procedure.</p></div><div class="structure_field_info">explicitPatternVars : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a></span></div></li></ul><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Elab.Term.ToDepElimPattern.Context" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Elab.Term.ToDepElimPattern.M"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/Match.lean#L378-L378">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.M"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">ToDepElimPattern</span>.<span class="name">M</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../.././foundational_types.html">Type</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.M">Lean.Elab.Term.ToDepElimPattern.M</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#ReaderT">ReaderT</a> <a href="../.././Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.Context">Lean.Elab.Term.ToDepElimPattern.Context</a>
    (<span class="fn"><a href="../.././Init/Control/StateRef.html#StateRefT'">StateRefT'</a> <a href="../.././Init/System/IO.html#IO.RealWorld">IO.RealWorld</a> <a href="../.././Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.State">Lean.Elab.Term.ToDepElimPattern.State</a> <a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Elab.Term.ToDepElimPattern.isExplicitPatternVar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/Match.lean#L381-L385">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.isExplicitPatternVar"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">ToDepElimPattern</span>.<span class="name">isExplicitPatternVar</span></a></span><span class="decl_args">
<span class="fn">(e : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.M">Lean.Elab.Term.ToDepElimPattern.M</a> <a href="../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Return true iff <code>e</code> is an explicit pattern variable provided by the user.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Elab.Term.ToDepElimPattern.normalize"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/Match.lean#L455-L540">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.normalize"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">ToDepElimPattern</span>.<span class="name">normalize</span></a></span><span class="decl_args">
<span class="fn">(e : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.M">Lean.Elab.Term.ToDepElimPattern.M</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Normalize the pattern and collect all patterns variables (explicit and implicit).
This method is the one that decides where the inaccessible annotations must be inserted.
The pattern variables are both free variables (for explicit pattern variables) and metavariables (for implicit ones).
Recall that <code>mkLambdaFVars</code> now allows us to abstract both free variables and metavariables.</p></div></div><div class="decl" id="Lean.Elab.Term.ToDepElimPattern.normalize.addVar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/Match.lean#L507-L510">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.normalize.addVar"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">ToDepElimPattern</span>.<span class="name">normalize</span>.<span class="name">addVar</span></a></span><span class="decl_args">
<span class="fn">(e : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.M">Lean.Elab.Term.ToDepElimPattern.M</a> <a href="../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Elab.Term.ToDepElimPattern.normalize.processVar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/Match.lean#L512-L520">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.normalize.processVar"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">ToDepElimPattern</span>.<span class="name">normalize</span>.<span class="name">processVar</span></a></span><span class="decl_args">
<span class="fn">(e : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.M">Lean.Elab.Term.ToDepElimPattern.M</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Elab.Term.ToDepElimPattern.normalize.processInaccessible"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/Match.lean#L522-L540">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.normalize.processInaccessible"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">ToDepElimPattern</span>.<span class="name">normalize</span>.<span class="name">processInaccessible</span></a></span><span class="decl_args">
<span class="fn">(e : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.M">Lean.Elab.Term.ToDepElimPattern.M</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div></div></div><div class="decl" id="Lean.Elab.Term.ToDepElimPattern.TopSort.State"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/Match.lean#L586-L589">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.TopSort.State"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">ToDepElimPattern</span>.<span class="name">TopSort</span>.<span class="name">State</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="Lean.Elab.Term.ToDepElimPattern.TopSort.State.mk"><li id="Lean.Elab.Term.ToDepElimPattern.TopSort.State.visitedFVars" class="structure_field"><div class="structure_field_info">visitedFVars : <a href="../.././Lean/Expr.html#Lean.FVarIdSet">Lean.FVarIdSet</a></div></li><li id="Lean.Elab.Term.ToDepElimPattern.TopSort.State.visitedMVars" class="structure_field"><div class="structure_field_info">visitedMVars : <a href="../.././Lean/Expr.html#Lean.MVarIdSet">Lean.MVarIdSet</a></div></li><li id="Lean.Elab.Term.ToDepElimPattern.TopSort.State.result" class="structure_field"><div class="structure_field_info">result : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></li></ul><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Elab.Term.ToDepElimPattern.TopSort.State" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Elab.Term.ToDepElimPattern.TopSortM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/Match.lean#L591-L591">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.TopSortM"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">ToDepElimPattern</span>.<span class="name">TopSortM</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../.././foundational_types.html">Type</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.TopSortM">Lean.Elab.Term.ToDepElimPattern.TopSortM</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Control/StateRef.html#StateRefT'">StateRefT'</a> <a href="../.././Init/System/IO.html#IO.RealWorld">IO.RealWorld</a> <a href="../.././Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.TopSort.State">Lean.Elab.Term.ToDepElimPattern.TopSort.State</a> <a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a></span></span></li></ul></details></div></div><div class="decl" id="Lean.Elab.Term.ToDepElimPattern.savePatternInfo"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/Match.lean#L631-L651">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.savePatternInfo"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">ToDepElimPattern</span>.<span class="name">savePatternInfo</span></a></span><span class="decl_args">
<span class="fn">(p : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Save pattern information in the info tree, and remove <code>patternWithRef?</code> annotations.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.savePatternInfo">Lean.Elab.Term.ToDepElimPattern.savePatternInfo</a> <span class="fn">p</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#ReaderT.run">ReaderT.run</a> (<span class="fn"><a href="../.././Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.savePatternInfo.go">Lean.Elab.Term.ToDepElimPattern.savePatternInfo.go</a> <span class="fn">p</span></span>) <a href="../.././Init/Prelude.html#Bool.false">false</a></span></span></li></ul></details></div></div><div class="decl" id="Lean.Elab.Term.ToDepElimPattern.savePatternInfo.go"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/Match.lean#L635-L651">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.savePatternInfo.go"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">ToDepElimPattern</span>.<span class="name">savePatternInfo</span>.<span class="name">go</span></a></span><span class="decl_args">
<span class="fn">(p : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#ReaderT">ReaderT</a> <a href="../.././Init/Prelude.html#Bool">Bool</a> <a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>The <code><a href="../.././Init/Prelude.html#Bool">Bool</a></code> context is true iff we are inside of an "inaccessible" pattern.</p></div></div><div class="decl" id="Lean.Elab.Term.ToDepElimPattern.main"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/Match.lean#L662-L716">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.main"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">ToDepElimPattern</span>.<span class="name">main</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(patternVarDecls : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Elab/Match.html#Lean.Elab.Term.PatternVarDecl">Lean.Elab.Term.PatternVarDecl</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(ps : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(matchType : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(k : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/LocalContext.html#Lean.LocalDecl">Lean.LocalDecl</a></span> → <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Meta/Match/Basic.html#Lean.Meta.Match.Pattern">Lean.Meta.Match.Pattern</a></span> → <span class="fn"><a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <span class="fn">α</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <span class="fn">α</span></span></div></div><p>Main method for <code><a href="../.././Lean/Elab/Match.html#Lean.Elab.Term.withDepElimPatterns">withDepElimPatterns</a></code>.</p><ul>
<li><code>PatternVarDecls</code>: are the explicit pattern variables provided by the user.</li>
<li><code>ps</code>: are the patterns provided by the user.</li>
<li><code><a href="../.././Lean/Elab/Match.html#Lean.Elab.Term.ElabMatchTypeAndDiscrsResult.matchType">matchType</a></code>: the expected typ for this branch. It depends on the explicit pattern variables and the implicit ones that are still represented as metavariables,
and are found by this function.</li>
<li><code>k</code> is the continuation that is executed in an updated local context with the all pattern variables (explicit and implicit). Note that, <code>patternVarDecls</code> are all
replaced since they may depend on implicit pattern variables (i.e., metavariables) that are converted into new free variables by this method.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Elab.Term.ToDepElimPattern.main.pack"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/Match.lean#L681-L703">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.main.pack"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">ToDepElimPattern</span>.<span class="name">main</span>.<span class="name">pack</span></a></span><span class="decl_args">
<span class="fn">(patternVars : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(ps : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(matchType : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Elab.Term.ToDepElimPattern.main.unpack"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/Match.lean#L705-L716">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.main.unpack"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">ToDepElimPattern</span>.<span class="name">main</span>.<span class="name">unpack</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(packed : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(k : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span> → <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span> → <span class="fn"><a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <span class="fn">α</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.main.unpack">Lean.Elab.Term.ToDepElimPattern.main.unpack</a> <span class="fn">packed</span> <span class="fn">k</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.main.unpack.go">Lean.Elab.Term.ToDepElimPattern.main.unpack.go</a> <span class="fn">k</span> <span class="fn">packed</span> <span class="fn">#[]</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Elab.Term.ToDepElimPattern.main.unpack.go"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/Match.lean#L706-L715">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.main.unpack.go"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">ToDepElimPattern</span>.<span class="name">main</span>.<span class="name">unpack</span>.<span class="name">go</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(k : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span> → <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span> → <span class="fn"><a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <span class="fn">α</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(packed : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(patternVars : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <span class="fn">α</span></span></div></div></div></div><div class="decl" id="Lean.Elab.Term.withDepElimPatterns"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/Match.lean#L720-L721">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Match.html#Lean.Elab.Term.withDepElimPatterns"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">withDepElimPatterns</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(patternVarDecls : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Elab/Match.html#Lean.Elab.Term.PatternVarDecl">Lean.Elab.Term.PatternVarDecl</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(ps : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(matchType : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(k : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/LocalContext.html#Lean.LocalDecl">Lean.LocalDecl</a></span> → <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Meta/Match/Basic.html#Lean.Meta.Match.Pattern">Lean.Meta.Match.Pattern</a></span> → <span class="fn"><a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <span class="fn">α</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lean/Elab/Match.html#Lean.Elab.Term.withDepElimPatterns">Lean.Elab.Term.withDepElimPatterns</a> <span class="fn">patternVarDecls</span> <span class="fn">ps</span> <span class="fn">matchType</span> <span class="fn">k</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.main">Lean.Elab.Term.ToDepElimPattern.main</a> <span class="fn">patternVarDecls</span> <span class="fn">ps</span> <span class="fn">matchType</span> <span class="fn">k</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Elab.Term.GeneralizeResult"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/Match.lean#L817-L823">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Match.html#Lean.Elab.Term.GeneralizeResult"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">GeneralizeResult</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="Lean.Elab.Term.GeneralizeResult.mk"><li id="Lean.Elab.Term.GeneralizeResult.discrs" class="structure_field"><div class="structure_field_info">discrs : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Elab/Match.html#Lean.Elab.Term.Discr">Lean.Elab.Term.Discr</a></span></div></li><li id="Lean.Elab.Term.GeneralizeResult.toClear" class="structure_field"><div class="structure_field_doc"><p><code>FVarId</code>s of the variables that have been generalized. We store them to clear after in each branch.</p></div><div class="structure_field_info">toClear : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Expr.html#Lean.FVarId">Lean.FVarId</a></span></div></li><li id="Lean.Elab.Term.GeneralizeResult.matchType" class="structure_field"><div class="structure_field_info">matchType : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></div></li><li id="Lean.Elab.Term.GeneralizeResult.altViews" class="structure_field"><div class="structure_field_info">altViews : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Elab/MatchAltView.html#Lean.Elab.Term.MatchAltView">Lean.Elab.Term.MatchAltView</a></span></div></li><li id="Lean.Elab.Term.GeneralizeResult.refined" class="structure_field"><div class="structure_field_info">refined : <a href="../.././Init/Prelude.html#Bool">Bool</a></div></li></ul><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Elab.Term.GeneralizeResult" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Elab.Term.mkMatcher"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/Match.lean#L981-L982">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Match.html#Lean.Elab.Term.mkMatcher"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">mkMatcher</span></a></span><span class="decl_args">
<span class="fn">(input : <a href="../.././Lean/Meta/Match/Match.html#Lean.Meta.Match.MkMatcherInput">Lean.Meta.Match.MkMatcherInput</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <a href="../.././Lean/Meta/Match/Basic.html#Lean.Meta.Match.MatcherResult">Lean.Meta.Match.MatcherResult</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lean/Elab/Match.html#Lean.Elab.Term.mkMatcher">Lean.Elab.Term.mkMatcher</a> <span class="fn">input</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#liftM">liftM</a> (<span class="fn"><a href="../.././Lean/Meta/Match/Match.html#Lean.Meta.Match.mkMatcher">Lean.Meta.Match.mkMatcher</a> <span class="fn">input</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Elab.Term.match.ignoreUnusedAlts"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/Match.lean#L984-L987">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Match.html#Lean.Elab.Term.match.ignoreUnusedAlts"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">match</span>.<span class="name">ignoreUnusedAlts</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Data/Options.html#Lean.Option">Lean.Option</a> <a href="../.././Init/Prelude.html#Bool">Bool</a></span></div></div></div></div><div class="decl" id="Lean.Elab.Term.reportMatcherResultErrors"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/Match.lean#L989-L999">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Match.html#Lean.Elab.Term.reportMatcherResultErrors"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">reportMatcherResultErrors</span></a></span><span class="decl_args">
<span class="fn">(altLHSS : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Meta/Match/Basic.html#Lean.Meta.Match.AltLHS">Lean.Meta.Match.AltLHS</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(result : <a href="../.././Lean/Meta/Match/Basic.html#Lean.Meta.Match.MatcherResult">Lean.Meta.Match.MatcherResult</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <a href="../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Elab.Term.elabMatch"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/Match.lean#L1217-L1234">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Match.html#Lean.Elab.Term.elabMatch"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">elabMatch</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElab">Lean.Elab.Term.TermElab</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Elab.Term.elabMatch.elabMatchDefault"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/Match.lean#L1223-L1234">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Match.html#Lean.Elab.Term.elabMatch.elabMatchDefault"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">elabMatch</span>.<span class="name">elabMatchDefault</span></a></span><span class="decl_args">
<span class="fn">(stx : <a href="../.././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(expectedType? : <span class="fn"><a href="../.././Init/Prelude.html#Option">Option</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Elab.Term.elabNoMatch"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/Match.lean#L1240-L1250">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Match.html#Lean.Elab.Term.elabNoMatch"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">elabNoMatch</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElab">Lean.Elab.Term.TermElab</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>