<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="stylesheet" href="../.././src/pygments.css"></link><link rel="shortcut icon" href="../.././favicon.ico"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Lean.Meta.ExprDefEq</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Lean.Meta.ExprDefEq";</script><script type="module" src="../.././search.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label>Documentation</h1><p class="header_filename break_within"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">ExprDefEq</span></p><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;
            <button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><h3><a class="break_within" href="#top"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">ExprDefEq</span></a></h3><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/ExprDefEq.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Lean/Meta/Offset.html">Lean.Meta.Offset</a></li><li><a href="../.././Lean/Meta/UnificationHint.html">Lean.Meta.UnificationHint</a></li><li><a href="../.././Lean/Util/OccursCheck.html">Lean.Util.OccursCheck</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Lean.Meta.ExprDefEq" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.isAbstractedUnassignedMVar"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">isAbstractedUnassignedMVar</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.isDefEqNative"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">isDefEqNative</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.isDefEqNat"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">isDefEqNat</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.isDefEqStringLit"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">isDefEqStringLit</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.isEtaUnassignedMVar"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">isEtaUnassignedMVar</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.DefEqArgsFirstPassResult"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">DefEqArgsFirstPassResult</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.isDefEqBindingDomain"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">isDefEqBindingDomain</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.isDefEqBindingDomain.loop"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">isDefEqBindingDomain</span>.<span class="name">loop</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.mkAuxMVar"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">mkAuxMVar</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.CheckAssignment.checkAssignmentExceptionId"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">CheckAssignment</span>.<span class="name">checkAssignmentExceptionId</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.CheckAssignment.outOfScopeExceptionId"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">CheckAssignment</span>.<span class="name">outOfScopeExceptionId</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.CheckAssignment.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">CheckAssignment</span>.<span class="name">State</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.CheckAssignment.Context"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">CheckAssignment</span>.<span class="name">Context</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.CheckAssignment.CheckAssignmentM"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">CheckAssignment</span>.<span class="name">CheckAssignmentM</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.CheckAssignment.throwCheckAssignmentFailure"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">CheckAssignment</span>.<span class="name">throwCheckAssignmentFailure</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.CheckAssignment.throwOutOfScopeFVar"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">CheckAssignment</span>.<span class="name">throwOutOfScopeFVar</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.CheckAssignment.instMonadCacheExprCheckAssignmentM"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">CheckAssignment</span>.<span class="name">instMonadCacheExprCheckAssignmentM</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.CheckAssignment.run"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">CheckAssignment</span>.<span class="name">run</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.CheckAssignment.checkFVar"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">CheckAssignment</span>.<span class="name">checkFVar</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.CheckAssignment.checkMVar"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">CheckAssignment</span>.<span class="name">checkMVar</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.CheckAssignment.assignToConstFun"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">CheckAssignment</span>.<span class="name">assignToConstFun</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.CheckAssignment.checkAssignmentAux"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">CheckAssignment</span>.<span class="name">checkAssignmentAux</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.CheckAssignment.checkApp"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">CheckAssignment</span>.<span class="name">checkApp</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.CheckAssignment.check"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">CheckAssignment</span>.<span class="name">check</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.CheckAssignmentQuick.check"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">CheckAssignmentQuick</span>.<span class="name">check</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.CheckAssignmentQuick.check.visit"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">CheckAssignmentQuick</span>.<span class="name">check</span>.<span class="name">visit</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.checkAssignment"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">checkAssignment</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.whenUndefDo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">whenUndefDo</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.isExprDefEqAuxImpl"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">isExprDefEqAuxImpl</span></a></div></nav><main>
<div class="decl" id="Lean.Meta.isAbstractedUnassignedMVar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/ExprDefEq.lean#L21-L31">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.isAbstractedUnassignedMVar"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">isAbstractedUnassignedMVar</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Init/Prelude.html#Bool">Bool</a></span></span></div></div><p>Return <code>true</code> if <code>e</code> is of the form <code>fun (x_1 ... x_n) => ?m y_1 ... y_k)</code>, and <code>?m</code> is unassigned.
Remark: <code>n</code>, <code>k</code> may be 0.
This function is used to filter unification problems in
<code>isDefEqArgs</code>/<code>isDefEqEtaStruct</code> where we can assign proofs.
If one side is of the form described above, then we can likely assign <code>?m</code>.
But it it's not, we would most likely apply proof irrelevance, which is
usually very expensive since it needs to unify the types as well.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.isAbstractedUnassignedMVar">Lean.Meta.isAbstractedUnassignedMVar</a> (<span class="fn"><a href="../.././Lean/Expr.html#Lean.Expr.lam">Lean.Expr.lam</a> <span class="fn">binderName</span> <span class="fn">binderType</span> <span class="fn">b</span> <span class="fn">binderInfo</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.isAbstractedUnassignedMVar">Lean.Meta.isAbstractedUnassignedMVar</a> <span class="fn">b</span></span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.isAbstractedUnassignedMVar">Lean.Meta.isAbstractedUnassignedMVar</a> (<span class="fn"><a href="../.././Lean/Expr.html#Lean.Expr.app">Lean.Expr.app</a> <span class="fn">a</span> <span class="fn">arg</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.isAbstractedUnassignedMVar">Lean.Meta.isAbstractedUnassignedMVar</a> <span class="fn">a</span></span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.isAbstractedUnassignedMVar">Lean.Meta.isAbstractedUnassignedMVar</a> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span></span></li></ul></details></div></div><div class="decl" id="Lean.Meta.isDefEqNative"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/ExprDefEq.lean#L118-L126">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.isDefEqNative"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">isDefEqNative</span></a></span><span class="decl_args">
<span class="fn">(s : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(t : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Lean/Data/LBool.html#Lean.LBool">Lean.LBool</a></span></div></div><p>Support for <code><a href="../.././Init/Core.html#Lean.reduceBool">Lean.reduceBool</a></code> and <code><a href="../.././Init/Core.html#Lean.reduceNat">Lean.reduceNat</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Meta.isDefEqNat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/ExprDefEq.lean#L129-L140">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.isDefEqNat"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">isDefEqNat</span></a></span><span class="decl_args">
<span class="fn">(s : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(t : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Lean/Data/LBool.html#Lean.LBool">Lean.LBool</a></span></div></div><p>Support for reducing Nat basic operations.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Meta.isDefEqStringLit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/ExprDefEq.lean#L143-L150">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.isDefEqStringLit"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">isDefEqStringLit</span></a></span><span class="decl_args">
<span class="fn">(s : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(t : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Lean/Data/LBool.html#Lean.LBool">Lean.LBool</a></span></div></div><p>Support for constraints of the form <code>("..." =?= <a href="../.././Init/Prelude.html#String.mk">String.mk</a> cs)</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Meta.isEtaUnassignedMVar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/ExprDefEq.lean#L155-L164">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.isEtaUnassignedMVar"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">isEtaUnassignedMVar</span></a></span><span class="decl_args">
<span class="fn">(e : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Return <code>true</code> if <code>e</code> is of the form <code>fun (x_1 ... x_n) => ?m x_1 ... x_n)</code>, and <code>?m</code> is unassigned.
Remark: <code>n</code> may be 0.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Meta.DefEqArgsFirstPassResult"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/ExprDefEq.lean#L175-L208">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.DefEqArgsFirstPassResult"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">DefEqArgsFirstPassResult</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><ul class="constructors"><li class="constructor" id="Lean.Meta.DefEqArgsFirstPassResult.failed"><div class="inductive_ctor_doc"><p>Failed to establish that explicit arguments are def-eq.
Remark: higher output parameters, and parameters that depend on them
are postponed.</p></div>failed: <a href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.DefEqArgsFirstPassResult">Lean.Meta.DefEqArgsFirstPassResult</a></li><li class="constructor" id="Lean.Meta.DefEqArgsFirstPassResult.ok"><div class="inductive_ctor_doc"><p>Succeeded. The array <code>postponedImplicit</code> contains the position
of the implicit arguments for which def-eq has been postponed.
<code>postponedHO</code> contains the higher order output parameters, and parameters
that depend on them. They should be processed after the implict ones.
<code>postponedHO</code> is used to handle applications involving functions that
contain higher order output parameters. Example:</p><pre><code class="language-lean">getElem :
  {cont : Type u_1} → {idx : Type u_2} → {elem : Type u_3} →
  {dom : cont → idx → Prop} → [self : <a href="../.././Init/Prelude.html#GetElem">GetElem</a> cont idx elem dom] →
  (xs : cont) → (i : idx) → (h : dom xs i) → elem
</code></pre><p>The argumengs <code>dom</code> and <code>h</code> must be processed after all implicit arguments
otherwise higher-order unification problems are generated. See issue #1299,
when trying to solve</p><pre><code>getElem ?a ?i ?h =?= getElem a i (Fin.val_lt_of_le i ...)
</code></pre><p>we have to solve the constraint</p><pre><code>?dom a i.val =?= <a href="../.././Init/Prelude.html#LT.lt">LT.lt</a> i.val (Array.size a)
</code></pre><p>by solving after the instance has been synthesized, we reduce this constraint to
a simple check.</p></div>ok: <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Init/Prelude.html#Nat">Nat</a></span> → <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Init/Prelude.html#Nat">Nat</a></span> → <a href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.DefEqArgsFirstPassResult">Lean.Meta.DefEqArgsFirstPassResult</a></span></li></ul><p>Result type for <code>isDefEqArgsFirstPass</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Meta.DefEqArgsFirstPassResult" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Meta.isDefEqBindingDomain"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/ExprDefEq.lean#L319-L334">source</a></div><div class="attributes">@[specialize #[]]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.isDefEqBindingDomain"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">isDefEqBindingDomain</span></a></span><span class="decl_args">
<span class="fn">(fvars : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(ds₂ : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(k : <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Init/Prelude.html#Bool">Bool</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Check whether the types of the free variables at <code><a href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.Context.fvars">fvars</a></code> are
definitionally equal to the types at <code>ds₂</code>.</p><p>Pre: <code>fvars.size == ds₂.size</code></p><p>This method also updates the set of local instances, and invokes
the continuation <code>k</code> with the updated set.</p><p>We can't use <code>withNewLocalInstances</code> because the <code>isDeq fvarType d₂</code>
may use local instances.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.isDefEqBindingDomain">Lean.Meta.isDefEqBindingDomain</a> <span class="fn">fvars</span> <span class="fn">ds₂</span> <span class="fn">k</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.isDefEqBindingDomain.loop">Lean.Meta.isDefEqBindingDomain.loop</a> <span class="fn">fvars</span> <span class="fn">ds₂</span> <span class="fn">k</span> <span class="fn">0</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Meta.isDefEqBindingDomain.loop"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/ExprDefEq.lean#L320-L333">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.isDefEqBindingDomain.loop"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">isDefEqBindingDomain</span>.<span class="name">loop</span></a></span><span class="decl_args">
<span class="fn">(fvars : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(ds₂ : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(k : <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Init/Prelude.html#Bool">Bool</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <a href="../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Init/Prelude.html#Bool">Bool</a></span></div></div></div></div><div class="mod_doc"><p>Each metavariable is declared in a particular local context.
We use the notation <code>C |- ?m : t</code> to denote a metavariable <code>?m</code> that
was declared at the local context <code>C</code> with type <code>t</code> (see <code>MetavarDecl</code>).
We also use <code>?m@C</code> as a shorthand for <code>C |- ?m : t</code> where <code>t</code> is the type of <code>?m</code>.</p><p>The following method process the unification constraint</p><pre><code>   ?m@C a₁ ... aₙ =?= t
</code></pre><p>We say the unification constraint is a pattern IFF</p><pre><code>1) `a₁ ... aₙ` are pairwise distinct free variables that are ​*not*​ let-variables.
2) `a₁ ... aₙ` are not in `C`
3) `t` only contains free variables in `C` and/or `{a₁, ..., aₙ}`
4) For every metavariable `?m'@C'` occurring in `t`, `C'` is a subprefix of `C`
5) `?m` does not occur in `t`
​*not*​ let-variables.
2) `a₁ ... aₙ` are not in `C`
3) `t` only contains free variables in `C` and/or `{a₁, ..., aₙ}`
4) For every metavariable `?m'@C'` occurring in `t`, `C'` is a subprefix of `C`
5) `?m` does not occur in `t`
​ let-variables.
2) `a₁ ... aₙ` are <a href="../.././Init/Prelude.html#not">not</a> in `C`
3) `t` only contains free variables in `C` and/or `{a₁, ..., aₙ}`
4) For every metavariable `?m'@C'` occurring in `t`, `C'` is a subprefix of `C`
5) `?m` does <a href="../.././Init/Prelude.html#not">not</a> occur in `t`
</code></pre><p>Claim: we don't have to check free variable declarations. That is,
if <code>t</code> contains a reference to <code>x : A := v</code>, we don't need to check <code>v</code>.
Reason: The reference to <code>x</code> is a free variable, and it must be in <code>C</code> (by 1 and 3).
If <code>x</code> is in <code>C</code>, then any metavariable occurring in <code>v</code> must have been defined in a strict subprefix of <code>C</code>.
So, condition 4 and 5 are satisfied.</p><p>If the conditions above have been satisfied, then the
solution for the unification constrain is</p><pre><code>?m := fun a₁ ... aₙ => t
</code></pre><p>Now, we consider some workarounds/approximations.</p><p>A1) Suppose <code>t</code> contains a reference to <code>x : A := v</code> and <code>x</code> is not in <code>C</code> (failed condition 3)
(precise) solution: unfold <code>x</code> in <code>t</code>.</p><p>A2) Suppose some <code>aᵢ</code> is in <code>C</code> (failed condition 2)
(approximated) solution (when <code>config.quasiPatternApprox</code> is set to true) :
ignore condition and also use</p><pre><code>    ?m := fun a₁ ... aₙ => t
</code></pre><p>Here is an example where this approximation fails:
Given <code>C</code> containing <code>a : nat</code>, consider the following two constraints
?m@C a =?= a
?m@C b =?= a</p><p>If we use the approximation in the first constraint, we get
?m := fun x => x
when we apply this solution to the second one we get a failure.</p><p>IMPORTANT: When applying this approximation we need to make sure the
abstracted term <code>fun a₁ ... aₙ => t</code> is type correct. The check
can only be skipped in the pattern case described above. Consider
the following example. Given the local context</p><pre><code>  (α : Type) (a : α)
</code></pre><p>we try to solve</p><pre><code> ?m α =?= @id α a
</code></pre><p>If we use the approximation above we obtain:</p><pre><code> ?m := (fun α' => @id α' a)
</code></pre><p>which is a type incorrect term. <code>a</code> has type <code>α</code> but it is expected to have
type <code>α'</code>.</p><p>The problem occurs because the right hand side contains a free variable
<code>a</code> that depends on the free variable <code>α</code> being abstracted. Note that
this dependency cannot occur in patterns.</p><p>We can address this by type checking
the term after abstraction. This is not a significant performance
bottleneck because this case doesn't happen very often in practice
(262 times when compiling stdlib on Jan 2018). The second example
is trickier, but it also occurs less frequently (8 times when compiling
stdlib on Jan 2018, and all occurrences were at Init/Control when
we define monads and auxiliary combinators for them).
We considered three options for the addressing the issue on the second example:</p><p>A3) <code>a₁ ... aₙ</code> are not pairwise distinct (failed condition 1).
In Lean3, we would try to approximate this case using an approach similar to A2.
However, this approximation complicates the code, and is never used in the
Lean3 stdlib and mathlib.</p><p>A4) <code>t</code> contains a metavariable <code>?m'@C'</code> where <code>C'</code> is not a subprefix of <code>C</code>.
If <code>?m'</code> is assigned, we substitute.
If not, we create an auxiliary metavariable with a smaller scope.
Actually, we let <code>elimMVarDeps</code> at <code>MetavarContext.lean</code> to perform this step.</p><p>A5) If some <code>aᵢ</code> is not a free variable,
then we use first-order unification (if <code>config.foApprox</code> is set to true)</p><pre><code>   ?m a_1 ... a_i a_{i+1} ... a_{i+k} =?= f b_1 ... b_k
</code></pre><p>reduces to</p><pre><code>   ?M a_1 ... a_i =?= f
   a_{i+1}        =?= b_1
   ...
   a_{i+k}        =?= b_k
</code></pre><p>A6) If (m =?= v) is of the form</p><pre><code>    ?m a_1 ... a_n =?= ?m b_1 ... b_k

 then we use first-order unification (if `config.foApprox` is set to true)
</code></pre><p>A7) When <code>foApprox</code>, we may use another approximation (<code>constApprox</code>) for solving constraints of the form
<code>?m s₁ ... sₙ =?= t</code>
where <code>s₁ ... sₙ</code> are arbitrary terms. We solve them by assigning the constant function to <code>?m</code>.
<code>?m := fun _ ... _ => t</code></p><pre><code> In general, this approximation may produce bad solutions, <a href="../.././Init/Prelude.html#and">and</a> may prevent coercions from being tried.
 For example, consider the term `pure (x > 0)` with inferred type `?m Prop` <a href="../.././Init/Prelude.html#and">and</a> expected type `IO Bool`.
 In this situation, the
 elaborator generates the unification constraint
 ```
 ?m Prop =?= <a href="../.././Init/System/IO.html#IO">IO</a> <a href="../.././Init/Prelude.html#Bool">Bool</a>
 ```
 It is <a href="../.././Init/Prelude.html#not">not</a> a higher-order pattern, nor first-order approximation is applicable. However, constant approximation
 produces the bogus solution `?m := fun _ => <a href="../.././Init/System/IO.html#IO">IO</a> Bool`, <a href="../.././Init/Prelude.html#and">and</a> prevents the system from using the coercion from
 the decidable proposition `x > 0` to `Bool`.

 On the other hand, the constant approximation is desirable for elaborating the term
 ```
 let f (x : _) := pure "hello"; f ()
 ```
 with expected type `IO String`.
 In this example, the following unification contraint is generated.
 ```
 ?m () <a href="../.././Init/Prelude.html#String">String</a> =?= <a href="../.././Init/System/IO.html#IO">IO</a> <a href="../.././Init/Prelude.html#String">String</a>
 ```
 It is <a href="../.././Init/Prelude.html#not">not</a> a higher-order pattern, first-order approximation reduces it to
 ```
 ?m () =?= <a href="../.././Init/System/IO.html#IO">IO</a>
 ```
 which fails to be solved. However, constant approximation solves it by assigning
 ```
 ?m := fun _ => <a href="../.././Init/System/IO.html#IO">IO</a>
 ```
 Note that `f`s type is `(x : ?α) -> ?m x String`. The metavariable `?m` may depend on `x`.
 If `constApprox` is set to true, we use constant approximation. Otherwise, we use a heuristic to decide
 whether we should apply it <a href="../.././Init/Prelude.html#or">or</a> not. The heuristic is based on <a href="../.././Init/Control/Except.html#observing">observing</a> where the constraints above come from.
 In the first example, the constraint `?m Prop =?= <a href="../.././Init/System/IO.html#IO">IO</a> Bool` come from polymorphic method where `?m` is expected to
 be a **function** of type `Type -> Type`. In the second example, the first argument of `?m` is used to model
 a **potential** dependency on `x`. By using constant approximation here, we are just saying the type of `f`
 does **not** depend on `x`. We claim this is a reasonable approximation in practice. Moreover, it is expected
 by any functional programmer used to non-dependently type languages (e.g., Haskell).
 We distinguish the two cases above by using the field `numScopeArgs` at `MetavarDecl`. This fiels tracks
 how many metavariable arguments are representing dependencies.
</code></pre></div><div class="decl" id="Lean.Meta.mkAuxMVar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/ExprDefEq.lean#L656-L657">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.mkAuxMVar"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">mkAuxMVar</span></a></span><span class="decl_args">
<span class="fn">(lctx : <a href="../.././Lean/LocalContext.html#Lean.LocalContext">Lean.LocalContext</a>)</span></span>
<span class="decl_args">
<span class="fn">(localInsts : <a href="../.././Lean/MetavarContext.html#Lean.LocalInstances">Lean.LocalInstances</a>)</span></span>
<span class="decl_args">
<span class="fn">(type : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(numScopeArgs : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Init/Prelude.html#Nat">Nat</a> <span class="fn">0</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.mkAuxMVar">Lean.Meta.mkAuxMVar</a> <span class="fn">lctx</span> <span class="fn">localInsts</span> <span class="fn">type</span> <span class="fn">numScopeArgs</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.mkFreshExprMVarAt">Lean.Meta.mkFreshExprMVarAt</a> <span class="fn">lctx</span> <span class="fn">localInsts</span> <span class="fn">type</span> <a href="../.././Lean/MetavarContext.html#Lean.MetavarKind.natural">Lean.MetavarKind.natural</a> <a href="../.././Init/Prelude.html#Lean.Name.anonymous">Lean.Name.anonymous</a> <span class="fn">numScopeArgs</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Meta.CheckAssignment.checkAssignmentExceptionId"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/ExprDefEq.lean#L661-L661">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.checkAssignmentExceptionId"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">CheckAssignment</span>.<span class="name">checkAssignmentExceptionId</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/InternalExceptionId.html#Lean.InternalExceptionId">Lean.InternalExceptionId</a></div></div></div></div><div class="decl" id="Lean.Meta.CheckAssignment.outOfScopeExceptionId"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/ExprDefEq.lean#L662-L662">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.outOfScopeExceptionId"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">CheckAssignment</span>.<span class="name">outOfScopeExceptionId</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/InternalExceptionId.html#Lean.InternalExceptionId">Lean.InternalExceptionId</a></div></div></div></div><div class="decl" id="Lean.Meta.CheckAssignment.State"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/ExprDefEq.lean#L664-L665">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">CheckAssignment</span>.<span class="name">State</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="Lean.Meta.CheckAssignment.State.mk"><li id="Lean.Meta.CheckAssignment.State.cache" class="structure_field"><div class="structure_field_info">cache : <span class="fn"><a href="../.././Lean/Expr.html#Lean.ExprStructMap">Lean.ExprStructMap</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></li></ul><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Meta.CheckAssignment.State" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Meta.CheckAssignment.Context"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/ExprDefEq.lean#L667-L672">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.Context"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">CheckAssignment</span>.<span class="name">Context</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="Lean.Meta.CheckAssignment.Context.mk"><li id="Lean.Meta.CheckAssignment.Context.mvarId" class="structure_field"><div class="structure_field_info">mvarId : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></div></li><li id="Lean.Meta.CheckAssignment.Context.mvarDecl" class="structure_field"><div class="structure_field_info">mvarDecl : <a href="../.././Lean/MetavarContext.html#Lean.MetavarDecl">Lean.MetavarDecl</a></div></li><li id="Lean.Meta.CheckAssignment.Context.fvars" class="structure_field"><div class="structure_field_info">fvars : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></li><li id="Lean.Meta.CheckAssignment.Context.hasCtxLocals" class="structure_field"><div class="structure_field_info">hasCtxLocals : <a href="../.././Init/Prelude.html#Bool">Bool</a></div></li><li id="Lean.Meta.CheckAssignment.Context.rhs" class="structure_field"><div class="structure_field_info">rhs : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></div></li></ul><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Meta.CheckAssignment.Context" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Meta.CheckAssignment.CheckAssignmentM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/ExprDefEq.lean#L674-L674">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.CheckAssignmentM"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">CheckAssignment</span>.<span class="name">CheckAssignmentM</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../.././foundational_types.html">Type</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.CheckAssignmentM">Lean.Meta.CheckAssignment.CheckAssignmentM</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#ReaderT">ReaderT</a> <a href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.Context">Lean.Meta.CheckAssignment.Context</a> (<span class="fn"><a href="../.././Init/Control/StateRef.html#StateRefT'">StateRefT'</a> <a href="../.././Init/System/IO.html#IO.RealWorld">IO.RealWorld</a> <a href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.State">Lean.Meta.CheckAssignment.State</a> <a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Meta.CheckAssignment.throwCheckAssignmentFailure"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/ExprDefEq.lean#L676-L677">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.throwCheckAssignmentFailure"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">CheckAssignment</span>.<span class="name">throwCheckAssignmentFailure</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.CheckAssignmentM">Lean.Meta.CheckAssignment.CheckAssignmentM</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Lean.Meta.CheckAssignment.throwCheckAssignmentFailure</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#MonadExcept.throw">throw</a> (<span class="fn"><a href="../.././Lean/Exception.html#Lean.Exception.internal">Lean.Exception.internal</a> <a href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.checkAssignmentExceptionId">Lean.Meta.CheckAssignment.checkAssignmentExceptionId</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Meta.CheckAssignment.throwOutOfScopeFVar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/ExprDefEq.lean#L679-L680">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.throwOutOfScopeFVar"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">CheckAssignment</span>.<span class="name">throwOutOfScopeFVar</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.CheckAssignmentM">Lean.Meta.CheckAssignment.CheckAssignmentM</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Lean.Meta.CheckAssignment.throwOutOfScopeFVar</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#MonadExcept.throw">throw</a> (<span class="fn"><a href="../.././Lean/Exception.html#Lean.Exception.internal">Lean.Exception.internal</a> <a href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.outOfScopeExceptionId">Lean.Meta.CheckAssignment.outOfScopeExceptionId</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Meta.CheckAssignment.instMonadCacheExprCheckAssignmentM"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/ExprDefEq.lean#L688-L690">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.instMonadCacheExprCheckAssignmentM"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">CheckAssignment</span>.<span class="name">instMonadCacheExprCheckAssignmentM</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Util/MonadCache.html#Lean.MonadCache">Lean.MonadCache</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> <a href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.CheckAssignmentM">Lean.Meta.CheckAssignment.CheckAssignmentM</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.instMonadCacheExprCheckAssignmentM">Lean.Meta.CheckAssignment.instMonadCacheExprCheckAssignmentM</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">findCached?</span> := <a href="../.././Lean/Meta/ExprDefEq.html#_private.Lean.Meta.ExprDefEq.0.Lean.Meta.CheckAssignment.findCached?">Lean.Meta.CheckAssignment.findCached?</a>, <span class="fn">cache</span> := <a href="../.././Lean/Meta/ExprDefEq.html#_private.Lean.Meta.ExprDefEq.0.Lean.Meta.CheckAssignment.cache">Lean.Meta.CheckAssignment.cache</a> }</span></span></li></ul></details></div></div><div class="decl" id="Lean.Meta.CheckAssignment.run"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/ExprDefEq.lean#L696-L703">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.run"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">CheckAssignment</span>.<span class="name">run</span></a></span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.CheckAssignmentM">Lean.Meta.CheckAssignment.CheckAssignmentM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(mvarId : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(fvars : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(hasCtxLocals : <a href="../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(v : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> (<span class="fn"><a href="../.././Init/Prelude.html#Option">Option</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Meta.CheckAssignment.checkFVar"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/ExprDefEq.lean#L707-L720">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.checkFVar"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">CheckAssignment</span>.<span class="name">checkFVar</span></a></span><span class="decl_args">
<span class="fn">(fvar : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.CheckAssignmentM">Lean.Meta.CheckAssignment.CheckAssignmentM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div></div></div><div class="decl" id="Lean.Meta.CheckAssignment.checkMVar"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/ExprDefEq.lean#L722-L779">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.checkMVar"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">CheckAssignment</span>.<span class="name">checkMVar</span></a></span><span class="decl_args">
<span class="fn">(mvar : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.CheckAssignmentM">Lean.Meta.CheckAssignment.CheckAssignmentM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div></div></div><div class="decl" id="Lean.Meta.CheckAssignment.assignToConstFun"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/ExprDefEq.lean#L787-L795">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.assignToConstFun"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">CheckAssignment</span>.<span class="name">assignToConstFun</span></a></span><span class="decl_args">
<span class="fn">(mvar : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(numArgs : <a href="../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(newMVar : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Auxiliary function used to "fix" subterms of the form <code>?m x_1 ... x_n</code> where <code>x_i</code>s are free variables,
and one of them is out-of-scope.
See <code>Expr.app</code> case at <code><a href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.check">check</a></code>.
If <code>ctxApprox</code> is true, then we solve this case by creating a fresh metavariable ?n with the correct scope,
an assigning <code>?m := fun _ ... _ => ?n</code></p></div></div><div class="decl" id="Lean.Meta.CheckAssignment.checkAssignmentAux"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/ExprDefEq.lean#L798-L799">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.checkAssignmentAux"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">CheckAssignment</span>.<span class="name">checkAssignmentAux</span></a></span><span class="decl_args">
<span class="fn">(mvarId : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(fvars : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(hasCtxLocals : <a href="../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(v : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> (<span class="fn"><a href="../.././Init/Prelude.html#Option">Option</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></div></div></div></div><div class="decl" id="Lean.Meta.CheckAssignment.checkApp"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/ExprDefEq.lean#L801-L829">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.checkApp"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">CheckAssignment</span>.<span class="name">checkApp</span></a></span><span class="decl_args">
<span class="fn">(e : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.CheckAssignmentM">Lean.Meta.CheckAssignment.CheckAssignmentM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div></div></div><div class="decl" id="Lean.Meta.CheckAssignment.check"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/ExprDefEq.lean#L831-L866">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.check"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">CheckAssignment</span>.<span class="name">check</span></a></span><span class="decl_args">
<span class="fn">(e : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.CheckAssignmentM">Lean.Meta.CheckAssignment.CheckAssignmentM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div></div></div><div class="decl" id="Lean.Meta.CheckAssignmentQuick.check"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/ExprDefEq.lean#L885-L920">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignmentQuick.check"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">CheckAssignmentQuick</span>.<span class="name">check</span></a></span><span class="decl_args">
<span class="fn">(hasCtxLocals : <a href="../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(mctx : <a href="../.././Lean/MetavarContext.html#Lean.MetavarContext">Lean.MetavarContext</a>)</span></span>
<span class="decl_args">
<span class="fn">(lctx : <a href="../.././Lean/LocalContext.html#Lean.LocalContext">Lean.LocalContext</a>)</span></span>
<span class="decl_args">
<span class="fn">(mvarDecl : <a href="../.././Lean/MetavarContext.html#Lean.MetavarDecl">Lean.MetavarDecl</a>)</span></span>
<span class="decl_args">
<span class="fn">(mvarId : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(fvars : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(e : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Bool">Bool</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignmentQuick.check">Lean.Meta.CheckAssignmentQuick.check</a> <span class="fn">hasCtxLocals</span> <span class="fn">mctx</span> <span class="fn">lctx</span> <span class="fn">mvarDecl</span> <span class="fn">mvarId</span> <span class="fn">fvars</span> <span class="fn">e</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignmentQuick.check.visit">Lean.Meta.CheckAssignmentQuick.check.visit</a> <span class="fn">hasCtxLocals</span> <span class="fn">mctx</span> <span class="fn">lctx</span> <span class="fn">mvarDecl</span> <span class="fn">mvarId</span> <span class="fn">fvars</span> <span class="fn">e</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Meta.CheckAssignmentQuick.check.visit"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/ExprDefEq.lean#L888-L919">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignmentQuick.check.visit"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">CheckAssignmentQuick</span>.<span class="name">check</span>.<span class="name">visit</span></a></span><span class="decl_args">
<span class="fn">(hasCtxLocals : <a href="../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(mctx : <a href="../.././Lean/MetavarContext.html#Lean.MetavarContext">Lean.MetavarContext</a>)</span></span>
<span class="decl_args">
<span class="fn">(lctx : <a href="../.././Lean/LocalContext.html#Lean.LocalContext">Lean.LocalContext</a>)</span></span>
<span class="decl_args">
<span class="fn">(mvarDecl : <a href="../.././Lean/MetavarContext.html#Lean.MetavarDecl">Lean.MetavarDecl</a>)</span></span>
<span class="decl_args">
<span class="fn">(mvarId : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(fvars : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(e : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Bool">Bool</a></div></div></div></div><div class="decl" id="Lean.Meta.checkAssignment"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/ExprDefEq.lean#L933-L950">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.checkAssignment"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">checkAssignment</span></a></span><span class="decl_args">
<span class="fn">(mvarId : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(fvars : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(v : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> (<span class="fn"><a href="../.././Init/Prelude.html#Option">Option</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></div></div><p>Auxiliary function for handling constraints of the form <code>?m a₁ ... aₙ =?= v</code>.
It will check whether we can perform the assignment</p><pre><code>?m := fun <a href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.Context.fvars">fvars</a> => v
</code></pre><p>The result is <code>none</code> if the assignment can't be performed.
The result is <code>some newV</code> where <code>newV</code> is a possibly updated <code>v</code>. This method may need
to unfold let-declarations.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Meta.whenUndefDo"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/ExprDefEq.lean#L1661-L1666">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.whenUndefDo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">whenUndefDo</span></a></span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Lean/Data/LBool.html#Lean.LBool">Lean.LBool</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(k : <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Init/Prelude.html#Bool">Bool</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Init/Prelude.html#Bool">Bool</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.whenUndefDo">Lean.Meta.whenUndefDo</a> <span class="fn">x</span> <span class="fn">k</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let status ← <span class="fn">x</span>
  <span class="fn">match <span class="fn">status</span> with
    | <a href="../.././Lean/Data/LBool.html#Lean.LBool.undef">Lean.LBool.true</a> =&gt <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>
    | <a href="../.././Lean/Data/LBool.html#Lean.LBool.undef">Lean.LBool.false</a> =&gt <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span>
    | <a href="../.././Lean/Data/LBool.html#Lean.LBool.undef">Lean.LBool.undef</a> =&gt <a href="../.././Lean/Data/LBool.html#Lean.LBool.undef">k</a></span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Meta.isExprDefEqAuxImpl"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/ExprDefEq.lean#L1813-L1855">source</a></div><div class="attributes">@[export lean_is_expr_def_eq]</div>
<div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Meta/ExprDefEq.html#Lean.Meta.isExprDefEqAuxImpl"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">isExprDefEqAuxImpl</span></a></span><span class="decl_args">
<span class="fn">(t : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(s : <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Init/Prelude.html#Bool">Bool</a></span></div></div></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>