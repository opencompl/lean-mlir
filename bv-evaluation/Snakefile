#!/usr/bin/env python3
import argparse
import os
import random
import subprocess
import concurrent.futures
import shutil
import multiprocessing
import psutil
import time
import threading
import platform
from functools import partial
from pathlib import Path
import sys
from runwithlimits import *
from snakelib import *

configfile: "config.yaml"
workdir: "../"

HACKERSDELIGHT_FILE_NAMES, = glob_wildcards(git_root() / "SSA/Projects/InstCombine/HackersDelight/{file}.lean")
hdel_nreps = config["hdel_nreps"]


onstart:
    shell("elan --version")
    shell("cd {git_root()} && lake exe cache get && lake build")
    shell("uv --version")
    shell("bitwuzla --version")

rule hdel_compare_make_lean:
  params:
      sed=sed(),
      git_root=git_root(),
  input:
    git_root() / "SSA/Projects/InstCombine/HackersDelight/{file}.lean"
  output:
     git_root() / "bv-evaluation/results/HackersDelight/{file}_{width}_{hdel_nreps}.lean"
  log:
      "logs/compare_make_lean_{file}_{width}_{hdel_nreps}.log"
  shell:
    "cp {input} {output} && "
    "{params.sed} -i  -e \"s/all_goals sorry/all_goals bv_compare'/g\" -e \"s/WIDTH/{wildcards.width}/g\" {output} "


rule hdel_compare_make_output:
  params:
      git_root=git_root(),
  input:
    infile=lambda wc: git_root / f"bv-evaluation/results/HackersDelight/{wc.file}_{wc.width}_{hdel_nreps}.lean",
  output:
    git_root() / "bv-evaluation/results/HackersDelight/{file}_{width}_r{r}.txt"
  log:
      "logs/hdel_compare_make_output_{file}_{width}_{r}.log"
  resources:
  # TODO: actually impose memory and time limit, using a python script.
  # shell:
  #     "lake 2>&1 lean {input[1]} -XXX  | tee {output} | tee {log}"
  run:
    cmd = ["lake", "lean", "-XX",  input["infile"]]
    try:
      status, stdout, stderr = run_with_limits(cmd=cmd,
          cwd=params.git_root,
          timeout=int(config["hdel_timeout_sec"]),
          memout_mb=int(config["hdel_memout_mb"]))
      if not isinstance(status, int) or status != 0:
          with open(log[0], "w") as logf:
            logf.write(f"Running hackersdelight file (command '{cmd}') failed with status '{status}'")
            logf.write(stdout)
            logf.write(stderr)
          sys.exit(1)
      with open(output[0], "w") as f:
          f.write(stdout)
          f.write(stderr)
    except Exception as e:
      with open(log[0], "w") as logf:
        logf.write(str(e))
      sys.exit(1)


# We can eventually split these, if we carefully understand the naming convention
# of 'collect' for hacker's delight.
# We currently make a monolithic job that runs both collect and plot,
# Since the naming convention is a little opaque to @bollu.
rule hdel_collect_and_plot:
  input:
    expand(git_root() / "bv-evaluation/results/HackersDelight/{file}_{width}_r{r}.txt",
      file=HACKERSDELIGHT_FILE_NAMES,
      width=config["hdel_bv_widths"],
      r=range(hdel_nreps))
  params:
    nreps = lambda wc: hdel_nreps,
    nthreads = lambda wc: config["hdel_nthreads"]
  output:
    tex=git_root() / "bv-evaluation/performance-hackersdelight.tex",
    pdf_stacked=git_root() / "bv-evaluation/plots/bv_decide_stacked_perc_HackersDelight_bvw64.pdf"
    # TODO: track the exact files generated by 'collect.py'.
    # We currently just bother asking for the two outputs we care for.
  log:
    "logs/collect.log"
  shell:
    "./collect.py hackersdelight ./plot.py hackersdelight 2>&1 > {log}"


rule all:
  input:
    rules.hdel_collect_and_plot.output
  default_target: True

