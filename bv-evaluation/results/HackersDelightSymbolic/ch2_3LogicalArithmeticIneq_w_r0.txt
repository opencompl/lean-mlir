⚠ [881/899] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [884/899] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:349:4: declaration uses 'sorry'
⚠ [885/899] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:26:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:33:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:40:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:43:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:54:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:58:8: declaration uses 'sorry'
⚠ [891/899] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:56:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:129:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:164:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:198:6: declaration uses 'sorry'
⚠ [892/899] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.523541 ms, MSGSTART 
    no applicable extensionality theorem found for
      Bool MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 15.478458 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 11.722917 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 61.239292 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 12.654416 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.485459 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 33.589750 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom (AutoStructs.Relation.unsigned AutoStructs.RelationOrdering.le)
            ((AutoStructs.Term.var 0).or (AutoStructs.Term.var 1))
            ((AutoStructs.Term.var 0).add (AutoStructs.Term.var 1))) =
        true
    is false MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 65.833125 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (x ||| y >ᵤ x + y)]
    Consider the following assignment:
    BitVec.ofBool (x ||| y >ᵤ x + y) = 0x1#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 251.077875 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:25:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.614458 ms, MSGSTART 
    no applicable extensionality theorem found for
      Bool MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 15.005334 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 11.589042 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 64.938958 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 12.058042 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.739500 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 33.582208 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom (AutoStructs.Relation.unsigned AutoStructs.RelationOrdering.lt)
            ((AutoStructs.Term.var 0).add (AutoStructs.Term.var 1))
            ((AutoStructs.Term.var 0).or (AutoStructs.Term.var 1))) =
        true
    is false MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 64.364125 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (x ||| y >ᵤ x + y)]
    Consider the following assignment:
    BitVec.ofBool (x ||| y >ᵤ x + y) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 259.662041 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:30:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.620042 ms, MSGSTART 
    no applicable extensionality theorem found for
      Bool MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 14.113291 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 9.977083 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 71.539167 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 11.885875 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.420916 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 43.148375 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom (AutoStructs.Relation.unsigned AutoStructs.RelationOrdering.le)
            (AutoStructs.Term.var 0) ((AutoStructs.Term.var 1).xor (AutoStructs.Term.var 2))) =
        true
    is false MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 73.961708 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       ((if (x + -y).getLsbD (w - 1) = true then -(x + -y) else x + -y) >ᵤ x ^^^ y)]
    Consider the following assignment:
    BitVec.ofBool ((if (x + -y).getLsbD (w - 1) = true then -(x + -y) else x + -y) >ᵤ x ^^^ y) = 0x1#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 283.223708 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:35:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 2.129583 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      x = y ↔ ((x - y).abs - 1#w).msb = true MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 8.770833 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 5.596875 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 81.010000 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 21.647208 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 8.289958 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      a ≥ 0
      a - b ≤ -1
    where
     a := ↑y.toNat
     b := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 54.888791 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.binop AutoStructs.Binop.equiv
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) (AutoStructs.Term.var 1))
            (AutoStructs.Formula.msbSet ((AutoStructs.Term.var 2).sub AutoStructs.Term.one))) =
        true
    is false MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 78.586125 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (((if (x + -y).getLsbD (w - 1) = true then -(x + -y) else x + -y) + -1#w).getLsbD (w - 1)),
     BitVec.ofBool (x == y)]
    Consider the following assignment:
    BitVec.ofBool (x == y) = 0x1#1
    BitVec.ofBool (((if (x + -y).getLsbD (w - 1) = true then -(x + -y) else x + -y) + -1#w).getLsbD (w - 1)) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 332.232041 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:40:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.926917 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      x = y ↔ 0 < w ∧ (x - y).msb = false ∧ (-x + y).msb = false MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 16.158083 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 23.009125 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 78.721083 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 36.287125 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 8.522542 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      a ≥ 0
      a - b ≤ -1
    where
     a := ↑y.toNat
     b := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 28.436959 ms, MSGSTART 
    Unsupported syntax 0 < w === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app (Lean.Expr.const `LT.lt [Lean.Level.zero]) (Lean.Expr.const `Nat []))
          (Lean.Expr.const `instLTNat []))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
            (Lean.Expr.lit (Lean.Literal.natVal 0)))
          (Lean.Expr.app
            (Lean.Expr.app (Lean.Expr.const `Zero.toOfNat0 [Lean.Level.zero]) (Lean.Expr.const `Nat []))
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `MulZeroClass.toZero [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `NonUnitalNonAssocSemiring.toMulZeroClass [Lean.Level.zero])
                  (Lean.Expr.const `Nat []))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `NonAssocSemiring.toNonUnitalNonAssocSemiring [Lean.Level.zero])
                    (Lean.Expr.const `Nat []))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `Semiring.toNonAssocSemiring [Lean.Level.zero])
                      (Lean.Expr.const `Nat []))
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `CommSemiring.toSemiring [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.const `Nat.instCommSemiring [])))))))))
      (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 133551)) MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 12.515625 ms, MSGSTART 
    None of the hypotheses are in the supported BitVec fragment.
    There are two potential fixes for this:
    1. If you are using custom BitVec constructs simplify them to built-in ones.
    2. If your problem is using only built-in ones it might currently be out of reach.
       Consider expressing it in terms of different operations that are better supported. MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 283.569458 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:45:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.532875 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      ¬x = y ↔ (-(x - y).abs).msb = true MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 7.872792 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 6.994416 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 77.960208 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 26.054459 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 8.607250 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑y.toNat
     b := ↑x.toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 57.524125 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.binop AutoStructs.Binop.equiv
            (AutoStructs.Formula.unop AutoStructs.Unop.neg
              (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) (AutoStructs.Term.var 1)))
            (AutoStructs.Formula.msbSet (AutoStructs.Term.var 2).neg)) =
        true
    is false MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 81.331875 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (x == y),
     BitVec.ofBool ((-if (x + -y).getLsbD (w - 1) = true then -(x + -y) else x + -y).getLsbD (w - 1))]
    Consider the following assignment:
    BitVec.ofBool (x == y) = 0x1#1
    BitVec.ofBool ((-if (x + -y).getLsbD (w - 1) = true then -(x + -y) else x + -y).getLsbD (w - 1)) = 0x1#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 338.133750 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:55:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.635250 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      (y >ₛ x) = true ↔ ¬(x - y).msb = ((x.msb ^^ y.msb) && ((x - y).msb ^^ x.msb)) MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 10.891750 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 11.099875 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 71.995833 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 64.963917 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.892791 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 17.973834 ms, MSGSTART 
    Equality (x - y).msb = ((x.msb ^^ y.msb) && ((x - y).msb ^^ x.msb)) has a strange type MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 79.868417 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (y >ᵤ x),
     BitVec.ofBool (x.getLsbD (w - 1)),
     BitVec.ofBool (y.getLsbD (w - 1)),
     BitVec.ofBool ((x + -y).getLsbD (w - 1))]
    Consider the following assignment:
    BitVec.ofBool (x.getLsbD (w - 1)) = 0x1#1
    BitVec.ofBool (y.getLsbD (w - 1)) = 0x1#1
    BitVec.ofBool (y >ᵤ x) = 0x1#1
    BitVec.ofBool ((x + -y).getLsbD (w - 1)) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 334.333333 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:60:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.722375 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      (y >ₛ x) = true ↔ x.msb = true ∧ 0 < w ∧ y.msb = false ∨ (0 < w ∧ x.msb = y.msb) ∧ (x - y).msb = true MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 9.462708 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 13.390166 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 72.710666 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 56.672250 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 8.857084 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 21.685458 ms, MSGSTART 
    Unsupported syntax 0 < w === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app (Lean.Expr.const `LT.lt [Lean.Level.zero]) (Lean.Expr.const `Nat []))
          (Lean.Expr.const `instLTNat []))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
            (Lean.Expr.lit (Lean.Literal.natVal 0)))
          (Lean.Expr.app
            (Lean.Expr.app (Lean.Expr.const `Zero.toOfNat0 [Lean.Level.zero]) (Lean.Expr.const `Nat []))
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `MulZeroClass.toZero [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `NonUnitalNonAssocSemiring.toMulZeroClass [Lean.Level.zero])
                  (Lean.Expr.const `Nat []))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `NonAssocSemiring.toNonUnitalNonAssocSemiring [Lean.Level.zero])
                    (Lean.Expr.const `Nat []))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `Semiring.toNonAssocSemiring [Lean.Level.zero])
                      (Lean.Expr.const `Nat []))
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `CommSemiring.toSemiring [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.const `Nat.instCommSemiring [])))))))))
      (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 274193)) MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 13.587334 ms, MSGSTART 
    None of the hypotheses are in the supported BitVec fragment.
    There are two potential fixes for this:
    1. If you are using custom BitVec constructs simplify them to built-in ones.
    2. If your problem is using only built-in ones it might currently be out of reach.
       Consider expressing it in terms of different operations that are better supported. MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 266.929333 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:65:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.640667 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      (y ≥ₛ x) = true ↔ (x.msb = true ∨ 0 < w ∧ y.msb = false) ∧ (¬x.msb = y.msb ∨ 0 < w ∧ (y - x).msb = false) MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 9.298292 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 13.088834 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 75.208875 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 59.908084 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.493416 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 23.037083 ms, MSGSTART 
    Unsupported syntax 0 < w === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app (Lean.Expr.const `LT.lt [Lean.Level.zero]) (Lean.Expr.const `Nat []))
          (Lean.Expr.const `instLTNat []))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
            (Lean.Expr.lit (Lean.Literal.natVal 0)))
          (Lean.Expr.app
            (Lean.Expr.app (Lean.Expr.const `Zero.toOfNat0 [Lean.Level.zero]) (Lean.Expr.const `Nat []))
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `MulZeroClass.toZero [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `NonUnitalNonAssocSemiring.toMulZeroClass [Lean.Level.zero])
                  (Lean.Expr.const `Nat []))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `NonAssocSemiring.toNonUnitalNonAssocSemiring [Lean.Level.zero])
                    (Lean.Expr.const `Nat []))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `Semiring.toNonAssocSemiring [Lean.Level.zero])
                      (Lean.Expr.const `Nat []))
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `CommSemiring.toSemiring [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.const `Nat.instCommSemiring [])))))))))
      (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 319645)) MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 15.016500 ms, MSGSTART 
    None of the hypotheses are in the supported BitVec fragment.
    There are two potential fixes for this:
    1. If you are using custom BitVec constructs simplify them to built-in ones.
    2. If your problem is using only built-in ones it might currently be out of reach.
       Consider expressing it in terms of different operations that are better supported. MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 267.124250 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:70:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.481625 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      (y >ᵤ x) = true ↔ (0 < w ∧ x.msb = false) ∧ y.msb = true ∨ (0 < w ∧ x.msb = y.msb) ∧ (x - y).msb = true MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 9.174667 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 12.733125 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 72.391834 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 43.341458 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.532500 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 22.534250 ms, MSGSTART 
    Unsupported syntax 0 < w === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app (Lean.Expr.const `LT.lt [Lean.Level.zero]) (Lean.Expr.const `Nat []))
          (Lean.Expr.const `instLTNat []))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
            (Lean.Expr.lit (Lean.Literal.natVal 0)))
          (Lean.Expr.app
            (Lean.Expr.app (Lean.Expr.const `Zero.toOfNat0 [Lean.Level.zero]) (Lean.Expr.const `Nat []))
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `MulZeroClass.toZero [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `NonUnitalNonAssocSemiring.toMulZeroClass [Lean.Level.zero])
                  (Lean.Expr.const `Nat []))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `NonAssocSemiring.toNonUnitalNonAssocSemiring [Lean.Level.zero])
                    (Lean.Expr.const `Nat []))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `Semiring.toNonAssocSemiring [Lean.Level.zero])
                      (Lean.Expr.const `Nat []))
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `CommSemiring.toSemiring [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.const `Nat.instCommSemiring [])))))))))
      (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 368019)) MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 11.275250 ms, MSGSTART 
    None of the hypotheses are in the supported BitVec fragment.
    There are two potential fixes for this:
    1. If you are using custom BitVec constructs simplify them to built-in ones.
    2. If your problem is using only built-in ones it might currently be out of reach.
       Consider expressing it in terms of different operations that are better supported. MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 249.771666 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:75:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.701000 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      (y ≥ᵤ x) = true ↔ (0 < w ∧ x.msb = false ∨ y.msb = true) ∧ (¬x.msb = y.msb ∨ 0 < w ∧ (y - x).msb = false) MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 10.592625 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 13.717125 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 72.727000 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 45.517917 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.068458 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 22.541459 ms, MSGSTART 
    Unsupported syntax 0 < w === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app (Lean.Expr.const `LT.lt [Lean.Level.zero]) (Lean.Expr.const `Nat []))
          (Lean.Expr.const `instLTNat []))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
            (Lean.Expr.lit (Lean.Literal.natVal 0)))
          (Lean.Expr.app
            (Lean.Expr.app (Lean.Expr.const `Zero.toOfNat0 [Lean.Level.zero]) (Lean.Expr.const `Nat []))
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `MulZeroClass.toZero [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `NonUnitalNonAssocSemiring.toMulZeroClass [Lean.Level.zero])
                  (Lean.Expr.const `Nat []))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `NonAssocSemiring.toNonUnitalNonAssocSemiring [Lean.Level.zero])
                    (Lean.Expr.const `Nat []))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `Semiring.toNonAssocSemiring [Lean.Level.zero])
                      (Lean.Expr.const `Nat []))
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `CommSemiring.toSemiring [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.const `Nat.instCommSemiring [])))))))))
      (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 409685)) MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 12.699834 ms, MSGSTART 
    None of the hypotheses are in the supported BitVec fragment.
    There are two potential fixes for this:
    1. If you are using custom BitVec constructs simplify them to built-in ones.
    2. If your problem is using only built-in ones it might currently be out of reach.
       Consider expressing it in terms of different operations that are better supported. MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 248.906459 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:80:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.683167 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      x = 0#w ↔ (x.abs - 1#w).msb = true MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 7.995125 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 5.688458 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 74.382625 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 21.292958 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.128625 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      a ≥ 0
      a - b ≤ -1
    where
     a := ↑0 % ↑(2 ^ w)
     b := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 48.312125 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.binop AutoStructs.Binop.equiv
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) AutoStructs.Term.zero)
            (AutoStructs.Formula.msbSet ((AutoStructs.Term.var 1).sub AutoStructs.Term.one))) =
        true
    is false MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 75.755416 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (((if x.getLsbD (w - 1) = true then -x else x) + -1#w).getLsbD (w - 1)),
     BitVec.ofBool (x == 0#w)]
    Consider the following assignment:
    BitVec.ofBool (x == 0#w) = 0x1#1
    BitVec.ofBool (((if x.getLsbD (w - 1) = true then -x else x) + -1#w).getLsbD (w - 1)) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 297.861333 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:85:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.512875 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      x = 0#w ↔ 0 < w ∧ x.msb = false ∧ (-x).msb = false MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 8.076875 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 10.613042 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 68.035625 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 33.234583 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.724125 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      a ≥ 0
      a - b ≤ -1
    where
     a := ↑0 % ↑(2 ^ w)
     b := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 22.367334 ms, MSGSTART 
    Unsupported syntax 0 < w === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app (Lean.Expr.const `LT.lt [Lean.Level.zero]) (Lean.Expr.const `Nat []))
          (Lean.Expr.const `instLTNat []))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
            (Lean.Expr.lit (Lean.Literal.natVal 0)))
          (Lean.Expr.app
            (Lean.Expr.app (Lean.Expr.const `Zero.toOfNat0 [Lean.Level.zero]) (Lean.Expr.const `Nat []))
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `MulZeroClass.toZero [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `NonUnitalNonAssocSemiring.toMulZeroClass [Lean.Level.zero])
                  (Lean.Expr.const `Nat []))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `NonAssocSemiring.toNonUnitalNonAssocSemiring [Lean.Level.zero])
                    (Lean.Expr.const `Nat []))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `Semiring.toNonAssocSemiring [Lean.Level.zero])
                      (Lean.Expr.const `Nat []))
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `CommSemiring.toSemiring [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.const `Nat.instCommSemiring [])))))))))
      (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 488142)) MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 7.632209 ms, MSGSTART 
    None of the hypotheses are in the supported BitVec fragment.
    There are two potential fixes for this:
    1. If you are using custom BitVec constructs simplify them to built-in ones.
    2. If your problem is using only built-in ones it might currently be out of reach.
       Consider expressing it in terms of different operations that are better supported. MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 221.909750 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:90:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.575000 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      x = 0#w ↔ (0 < w ∧ x.msb = false) ∧ (x - 1#w).msb = true MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 7.618875 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 11.056125 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 71.398167 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 33.306500 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.492375 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      a ≥ 0
      a - b ≤ -1
    where
     a := ↑0 % ↑(2 ^ w)
     b := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 22.116292 ms, MSGSTART 
    Unsupported syntax 0 < w === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app (Lean.Expr.const `LT.lt [Lean.Level.zero]) (Lean.Expr.const `Nat []))
          (Lean.Expr.const `instLTNat []))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
            (Lean.Expr.lit (Lean.Literal.natVal 0)))
          (Lean.Expr.app
            (Lean.Expr.app (Lean.Expr.const `Zero.toOfNat0 [Lean.Level.zero]) (Lean.Expr.const `Nat []))
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `MulZeroClass.toZero [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `NonUnitalNonAssocSemiring.toMulZeroClass [Lean.Level.zero])
                  (Lean.Expr.const `Nat []))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `NonAssocSemiring.toNonUnitalNonAssocSemiring [Lean.Level.zero])
                    (Lean.Expr.const `Nat []))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `Semiring.toNonAssocSemiring [Lean.Level.zero])
                      (Lean.Expr.const `Nat []))
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `CommSemiring.toSemiring [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.const `Nat.instCommSemiring [])))))))))
      (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 523149)) MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 8.711208 ms, MSGSTART 
    None of the hypotheses are in the supported BitVec fragment.
    There are two potential fixes for this:
    1. If you are using custom BitVec constructs simplify them to built-in ones.
    2. If your problem is using only built-in ones it might currently be out of reach.
       Consider expressing it in terms of different operations that are better supported. MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 229.733834 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:95:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.559834 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      ¬x = 0#w ↔ (-x.abs).msb = true MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 7.334583 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 5.725291 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 68.055250 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 27.571250 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.077333 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑0 % ↑(2 ^ w)
     b := ↑x.toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 49.382417 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.binop AutoStructs.Binop.equiv
            (AutoStructs.Formula.unop AutoStructs.Unop.neg
              (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) AutoStructs.Term.zero))
            (AutoStructs.Formula.msbSet (AutoStructs.Term.var 1).neg)) =
        true
    is false MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 77.846292 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (x == 0#w),
     BitVec.ofBool ((-if x.getLsbD (w - 1) = true then -x else x).getLsbD (w - 1))]
    Consider the following assignment:
    BitVec.ofBool (x == 0#w) = 0x1#1
    BitVec.ofBool ((-if x.getLsbD (w - 1) = true then -x else x).getLsbD (w - 1)) = 0x1#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 304.934542 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:105:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.528125 ms, MSGSTART 
    no applicable extensionality theorem found for
      Bool MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 10.243291 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 5.464291 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 52.361084 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 20.793958 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.046667 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 14.719750 ms, MSGSTART 
    Equality (0#w >ₛ x) = x.msb has a strange type MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 68.847333 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (x.getLsbD (w - 1)),
     BitVec.ofBool (0#w >ᵤ x)]
    Consider the following assignment:
    BitVec.ofBool (x.getLsbD (w - 1)) = 0x1#1
    BitVec.ofBool (0#w >ᵤ x) = 0x1#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 224.636583 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:110:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.706708 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      (0#w ≥ₛ x) = true ↔ x.msb = true ∨ 0 < w ∧ (-x).msb = false MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 8.184708 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 10.758542 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 66.876209 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 43.078292 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.403750 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 21.789375 ms, MSGSTART 
    Unsupported syntax 0 < w === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app (Lean.Expr.const `LT.lt [Lean.Level.zero]) (Lean.Expr.const `Nat []))
          (Lean.Expr.const `instLTNat []))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
            (Lean.Expr.lit (Lean.Literal.natVal 0)))
          (Lean.Expr.app
            (Lean.Expr.app (Lean.Expr.const `Zero.toOfNat0 [Lean.Level.zero]) (Lean.Expr.const `Nat []))
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `MulZeroClass.toZero [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `NonUnitalNonAssocSemiring.toMulZeroClass [Lean.Level.zero])
                  (Lean.Expr.const `Nat []))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `NonAssocSemiring.toNonUnitalNonAssocSemiring [Lean.Level.zero])
                    (Lean.Expr.const `Nat []))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `Semiring.toNonAssocSemiring [Lean.Level.zero])
                      (Lean.Expr.const `Nat []))
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `CommSemiring.toSemiring [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.const `Nat.instCommSemiring [])))))))))
      (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 634993)) MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 10.541959 ms, MSGSTART 
    None of the hypotheses are in the supported BitVec fragment.
    There are two potential fixes for this:
    1. If you are using custom BitVec constructs simplify them to built-in ones.
    2. If your problem is using only built-in ones it might currently be out of reach.
       Consider expressing it in terms of different operations that are better supported. MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 229.770667 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:120:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.646041 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      (x >ₛ 0#w) = true ↔ (-x).msb = true ∧ 0 < w ∧ x.msb = false MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 7.205166 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 11.098666 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 69.630917 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 48.824791 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.599209 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 21.176458 ms, MSGSTART 
    Unsupported syntax 0 < w === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app (Lean.Expr.const `LT.lt [Lean.Level.zero]) (Lean.Expr.const `Nat []))
          (Lean.Expr.const `instLTNat []))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
            (Lean.Expr.lit (Lean.Literal.natVal 0)))
          (Lean.Expr.app
            (Lean.Expr.app (Lean.Expr.const `Zero.toOfNat0 [Lean.Level.zero]) (Lean.Expr.const `Nat []))
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `MulZeroClass.toZero [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `NonUnitalNonAssocSemiring.toMulZeroClass [Lean.Level.zero])
                  (Lean.Expr.const `Nat []))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `NonAssocSemiring.toNonUnitalNonAssocSemiring [Lean.Level.zero])
                    (Lean.Expr.const `Nat []))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `Semiring.toNonAssocSemiring [Lean.Level.zero])
                      (Lean.Expr.const `Nat []))
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `CommSemiring.toSemiring [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.const `Nat.instCommSemiring [])))))))))
      (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 673796)) MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 10.414125 ms, MSGSTART 
    None of the hypotheses are in the supported BitVec fragment.
    There are two potential fixes for this:
    1. If you are using custom BitVec constructs simplify them to built-in ones.
    2. If your problem is using only built-in ones it might currently be out of reach.
       Consider expressing it in terms of different operations that are better supported. MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 242.039084 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:125:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.557583 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      (x ≥ₛ 0#w) = true ↔ 0 < w ∧ x.msb = false MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 6.409125 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 9.237000 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 50.896291 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 35.436292 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.041042 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 19.109542 ms, MSGSTART 
    Unsupported syntax 0 < w === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app (Lean.Expr.const `LT.lt [Lean.Level.zero]) (Lean.Expr.const `Nat []))
          (Lean.Expr.const `instLTNat []))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
            (Lean.Expr.lit (Lean.Literal.natVal 0)))
          (Lean.Expr.app
            (Lean.Expr.app (Lean.Expr.const `Zero.toOfNat0 [Lean.Level.zero]) (Lean.Expr.const `Nat []))
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `MulZeroClass.toZero [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `NonUnitalNonAssocSemiring.toMulZeroClass [Lean.Level.zero])
                  (Lean.Expr.const `Nat []))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `NonAssocSemiring.toNonUnitalNonAssocSemiring [Lean.Level.zero])
                    (Lean.Expr.const `Nat []))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `Semiring.toNonAssocSemiring [Lean.Level.zero])
                      (Lean.Expr.const `Nat []))
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `CommSemiring.toSemiring [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.const `Nat.instCommSemiring [])))))))))
      (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 711745)) MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 7.729417 ms, MSGSTART 
    None of the hypotheses are in the supported BitVec fragment.
    There are two potential fixes for this:
    1. If you are using custom BitVec constructs simplify them to built-in ones.
    2. If your problem is using only built-in ones it might currently be out of reach.
       Consider expressing it in terms of different operations that are better supported. MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 190.348750 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:130:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.701458 ms, MSGSTART 
    no applicable extensionality theorem found for
      Bool MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 91.158208 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 67.932458 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 83.861542 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 96.914000 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.426042 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 29.205417 ms, MSGSTART 
    Equality (y >ₛ x) = (2#w ^ (w - 1) + y >ₛ x + 2#w ^ (w - 1)) has a strange type MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 79.582583 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (y >ᵤ x),
     BitVec.ofBool (y.getLsbD (w - 1)),
     BitVec.ofBool (x.getLsbD (w - 1)),
     BitVec.ofBool ((2#w ^ (w - 1) + y).getLsbD (w - 1)),
     BitVec.ofBool ((x + 2#w ^ (w - 1)).getLsbD (w - 1)),
     BitVec.ofBool (2#w ^ (w - 1) + y >ᵤ x + 2#w ^ (w - 1))]
    Consider the following assignment:
    BitVec.ofBool (x.getLsbD (w - 1)) = 0x1#1
    BitVec.ofBool (y.getLsbD (w - 1)) = 0x1#1
    BitVec.ofBool (y >ᵤ x) = 0x1#1
    BitVec.ofBool ((x + 2#w ^ (w - 1)).getLsbD (w - 1)) = 0x1#1
    BitVec.ofBool ((2#w ^ (w - 1) + y).getLsbD (w - 1)) = 0x1#1
    BitVec.ofBool (2#w ^ (w - 1) + y >ᵤ x + 2#w ^ (w - 1)) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 522.211708 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:135:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.845166 ms, MSGSTART 
    no applicable extensionality theorem found for
      Bool MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 26.091458 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 38.809166 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 93.911250 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 58.010542 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.920167 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 42.071666 ms, MSGSTART 
    Equality (y >ᵤ x) = (-2#w ^ (w - 1) + y >ₛ x - 2#w ^ (w - 1)) has a strange type MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 87.381708 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (-2#w ^ (w - 1) + y >ᵤ x + -2#w ^ (w - 1)),
     BitVec.ofBool ((-2#w ^ (w - 1) + y).getLsbD (w - 1)),
     BitVec.ofBool ((x + -2#w ^ (w - 1)).getLsbD (w - 1)),
     BitVec.ofBool (y >ᵤ x)]
    Consider the following assignment:
    BitVec.ofBool (y >ᵤ x) = 0x1#1
    BitVec.ofBool ((x + -2#w ^ (w - 1)).getLsbD (w - 1)) = 0x1#1
    BitVec.ofBool ((-2#w ^ (w - 1) + y).getLsbD (w - 1)) = 0x1#1
    BitVec.ofBool (-2#w ^ (w - 1) + y >ᵤ x + -2#w ^ (w - 1)) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 431.062208 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:140:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.631708 ms, MSGSTART 
    no applicable extensionality theorem found for
      Bool MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 29.625417 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 33.820292 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 83.192125 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 49.189583 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.529167 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 31.155208 ms, MSGSTART 
    Equality (y >ₛ x) = !2#w ^ (w - 1) + x ≥ᵤ y + 2#w ^ (w - 1) has a strange type MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 74.816458 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (y.getLsbD (w - 1)),
     BitVec.ofBool (y + 2#w ^ (w - 1) >ᵤ 2#w ^ (w - 1) + x),
     BitVec.ofBool (y >ᵤ x),
     BitVec.ofBool (x.getLsbD (w - 1))]
    Consider the following assignment:
    BitVec.ofBool (x.getLsbD (w - 1)) = 0x1#1
    BitVec.ofBool (y.getLsbD (w - 1)) = 0x1#1
    BitVec.ofBool (y >ᵤ x) = 0x1#1
    BitVec.ofBool (y + 2#w ^ (w - 1) >ᵤ 2#w ^ (w - 1) + x) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 387.154667 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:145:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.592666 ms, MSGSTART 
    no applicable extensionality theorem found for
      Bool MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 52.710959 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 43.915792 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 85.063792 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 43.613083 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.066666 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 28.359250 ms, MSGSTART 
    Equality (y ≥ₛ x) = (2#w ^ (w - 1) + y ≥ᵤ x + 2#w ^ (w - 1)) has a strange type MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 76.859917 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (y.getLsbD (w - 1)),
     BitVec.ofBool (x + 2#w ^ (w - 1) >ᵤ 2#w ^ (w - 1) + y),
     BitVec.ofBool (x.getLsbD (w - 1)),
     BitVec.ofBool (x >ᵤ y)]
    Consider the following assignment:
    BitVec.ofBool (y.getLsbD (w - 1)) = 0x1#1
    BitVec.ofBool (x.getLsbD (w - 1)) = 0x1#1
    BitVec.ofBool (x >ᵤ y) = 0x1#1
    BitVec.ofBool (x + 2#w ^ (w - 1) >ᵤ 2#w ^ (w - 1) + y) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 408.860833 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:150:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.827334 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      x = y ↔ BitVec.carry w x (~~~y + 1#w) false = true MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 17.740625 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 11.548875 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 69.331333 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 19.732667 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.355500 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      a ≥ 0
      a - b ≤ -1
    where
     a := ↑y.toNat
     b := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 15.551459 ms, MSGSTART 
    Unsupported syntax BitVec.carry w x (~~~y + 1#w) false === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.app (Lean.Expr.const `BitVec.carry []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 995940)))
            (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 995940)))
          (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 995942)))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `HAdd.hAdd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                    (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 995940))))
                  (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 995940))))
                (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 995940))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `instHAdd [Lean.Level.zero])
                  (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 995940))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `Distrib.toAdd [Lean.Level.zero])
                    (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 995940))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `NonUnitalNonAssocSemiring.toDistrib [Lean.Level.zero])
                      (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 995940))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `NonAssocSemiring.toNonUnitalNonAssocSemiring [Lean.Level.zero])
                        (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 995940))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `Semiring.toNonAssocSemiring [Lean.Level.zero])
                          (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 995940))))
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `CommSemiring.toSemiring [Lean.Level.zero])
                            (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 995940))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec.instCommSemiring [])
                            (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 995940))))))))))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `Complement.complement [Lean.Level.zero])
                  (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 995940))))
                (Lean.Expr.app
                  (Lean.Expr.const `BitVec.instComplement [])
                  (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 995940))))
              (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 995944))))
          (Lean.Expr.app
            (Lean.Expr.app (Lean.Expr.const `BitVec.ofNat []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 995940)))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `One.toOfNat1 [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `AddMonoidWithOne.toOne [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `AddCommMonoidWithOne.toAddMonoidWithOne [Lean.Level.zero])
                      (Lean.Expr.const `Nat []))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `NonAssocSemiring.toAddCommMonoidWithOne [Lean.Level.zero])
                        (Lean.Expr.const `Nat []))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `Semiring.toNonAssocSemiring [Lean.Level.zero])
                          (Lean.Expr.const `Nat []))
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `CommSemiring.toSemiring [Lean.Level.zero])
                            (Lean.Expr.const `Nat []))
                          (Lean.Expr.const `Nat.instCommSemiring [])))))))))))
      (Lean.Expr.const `Bool.false []) MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 72.717875 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (x == y),
     BitVec.ofBool (BitVec.carry w x (~~~y + 1#w) false)]
    Consider the following assignment:
    BitVec.ofBool (x == y) = 0x1#1
    BitVec.ofBool (BitVec.carry w x (~~~y + 1#w) false) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 264.071459 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:160:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.844458 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      ¬x = y ↔ BitVec.carry w x (~~~y) false = true MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 6.135291 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 3.526791 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 50.396292 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 23.509458 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.062875 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑y.toNat
     b := ↑x.toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 15.489125 ms, MSGSTART 
    Unsupported syntax BitVec.carry w x (~~~y) false === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.app (Lean.Expr.const `BitVec.carry []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1024323)))
            (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1024323)))
          (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1024325)))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.const `Complement.complement [Lean.Level.zero])
              (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1024323))))
            (Lean.Expr.app (Lean.Expr.const `BitVec.instComplement []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1024323))))
          (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1024327))))
      (Lean.Expr.const `Bool.false []) MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 70.417208 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (BitVec.carry w x (~~~y) false),
     BitVec.ofBool (x == y)]
    Consider the following assignment:
    BitVec.ofBool (x == y) = 0x1#1
    BitVec.ofBool (BitVec.carry w x (~~~y) false) = 0x1#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 217.639250 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:165:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.551750 ms, MSGSTART 
    no applicable extensionality theorem found for
      Bool MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 25.529416 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 34.307458 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 95.298291 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 24.323000 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.375750 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 33.601416 ms, MSGSTART 
    Equality (y >ₛ x) =
      !BitVec.carry w (x + 2#w ^ (w - 1)) (~~~(2#w ^ (w - 1) + y) + 1#w) false has a strange type MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 80.250083 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (BitVec.carry w (x + 2#w ^ (w - 1)) (~~~(2#w ^ (w - 1) + y) + 1#w) false),
     BitVec.ofBool (x.getLsbD (w - 1)),
     BitVec.ofBool (y.getLsbD (w - 1)),
     BitVec.ofBool (y >ᵤ x)]
    Consider the following assignment:
    BitVec.ofBool (x.getLsbD (w - 1)) = 0x1#1
    BitVec.ofBool (y.getLsbD (w - 1)) = 0x1#1
    BitVec.ofBool (y >ᵤ x) = 0x1#1
    BitVec.ofBool (BitVec.carry w (x + 2#w ^ (w - 1)) (~~~(2#w ^ (w - 1) + y) + 1#w) false) = 0x1#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 374.318583 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:170:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.754417 ms, MSGSTART 
    no applicable extensionality theorem found for
      Bool MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 18.140959 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 54.428750 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 73.956125 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 23.707500 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.068792 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 60.594416 ms, MSGSTART 
    Equality (y >ₛ x) =
      !BitVec.carry w x (~~~y + 1#w) false ^^^ x.getMsbD (w - 1) ^^^ y.getMsbD (w - 1) has a strange type MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 76.707958 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (BitVec.carry w x (~~~y + 1#w) false ^^^ (Decidable.decide (w - 1 < w) && x.getLsbD (w - 1 - (w - 1))) ^^^
         (Decidable.decide (w - 1 < w) && y.getLsbD (w - 1 - (w - 1)))),
     BitVec.ofBool (y.getLsbD (w - 1)),
     BitVec.ofBool (y >ᵤ x),
     BitVec.ofBool (x.getLsbD (w - 1))]
    Consider the following assignment:
    BitVec.ofBool (x.getLsbD (w - 1)) = 0x1#1
    BitVec.ofBool (y.getLsbD (w - 1)) = 0x1#1
    BitVec.ofBool (y >ᵤ x) = 0x1#1
    BitVec.ofBool
      (BitVec.carry w x (~~~y + 1#w) false ^^^ (Decidable.decide (w - 1 < w) && x.getLsbD (w - 1 - (w - 1))) ^^^
        (Decidable.decide (w - 1 < w) && y.getLsbD (w - 1 - (w - 1)))) = 0x1#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 411.184542 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:178:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.505084 ms, MSGSTART 
    no applicable extensionality theorem found for
      Bool MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 24.056125 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 32.575250 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 97.421916 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 23.670708 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.365459 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 31.714792 ms, MSGSTART 
    Equality (y ≥ₛ x) =
      BitVec.carry w (y + 2#w ^ (w - 1)) (~~~(2#w ^ (w - 1) + x) + 1#w) false has a strange type MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 76.173292 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (y.getLsbD (w - 1)),
     BitVec.ofBool (x >ᵤ y),
     BitVec.ofBool (x.getLsbD (w - 1)),
     BitVec.ofBool (BitVec.carry w (y + 2#w ^ (w - 1)) (~~~(2#w ^ (w - 1) + x) + 1#w) false)]
    Consider the following assignment:
    BitVec.ofBool (y.getLsbD (w - 1)) = 0x1#1
    BitVec.ofBool (x.getLsbD (w - 1)) = 0x1#1
    BitVec.ofBool (x >ᵤ y) = 0x1#1
    BitVec.ofBool (BitVec.carry w (y + 2#w ^ (w - 1)) (~~~(2#w ^ (w - 1) + x) + 1#w) false) = 0x1#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 367.267583 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:183:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.617000 ms, MSGSTART 
    no applicable extensionality theorem found for
      Bool MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 21.566666 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 57.967292 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 70.095042 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 23.236000 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.908750 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 61.200083 ms, MSGSTART 
    Equality (y ≥ₛ x) =
      BitVec.carry w y (~~~x + 1#w) false ^^^ x.getMsbD (w - 1) ^^^ y.getMsbD (w - 1) has a strange type MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 77.154041 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (x.getLsbD (w - 1)),
     BitVec.ofBool (y.getLsbD (w - 1)),
     BitVec.ofBool
       (BitVec.carry w y (~~~x + 1#w) false ^^^ (Decidable.decide (w - 1 < w) && x.getLsbD (w - 1 - (w - 1))) ^^^
         (Decidable.decide (w - 1 < w) && y.getLsbD (w - 1 - (w - 1)))),
     BitVec.ofBool (x >ᵤ y)]
    Consider the following assignment:
    BitVec.ofBool (y.getLsbD (w - 1)) = 0x1#1
    BitVec.ofBool (x.getLsbD (w - 1)) = 0x1#1
    BitVec.ofBool (x >ᵤ y) = 0x1#1
    BitVec.ofBool
      (BitVec.carry w y (~~~x + 1#w) false ^^^ (Decidable.decide (w - 1 < w) && x.getLsbD (w - 1 - (w - 1))) ^^^
        (Decidable.decide (w - 1 < w) && y.getLsbD (w - 1 - (w - 1)))) = 0x1#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 419.327750 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:188:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.571667 ms, MSGSTART 
    no applicable extensionality theorem found for
      Bool MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 14.844000 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 12.508875 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 67.310083 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 11.385166 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.445375 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 16.334959 ms, MSGSTART 
    Equality (y >ᵤ x) = !BitVec.carry w x (~~~y + 1#w) false has a strange type MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 68.569042 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (y >ᵤ x),
     BitVec.ofBool (BitVec.carry w x (~~~y + 1#w) false)]
    Consider the following assignment:
    BitVec.ofBool (y >ᵤ x) = 0x1#1
    BitVec.ofBool (BitVec.carry w x (~~~y + 1#w) false) = 0x1#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 244.338084 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:193:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.572208 ms, MSGSTART 
    no applicable extensionality theorem found for
      Bool MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 15.267792 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 12.135917 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 68.975500 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 11.649916 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.462000 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 15.110083 ms, MSGSTART 
    Equality (y ≥ᵤ x) = BitVec.carry w y (~~~x + 1#w) false has a strange type MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 68.288083 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (x >ᵤ y),
     BitVec.ofBool (BitVec.carry w y (~~~x + 1#w) false)]
    Consider the following assignment:
    BitVec.ofBool (x >ᵤ y) = 0x1#1
    BitVec.ofBool (BitVec.carry w y (~~~x + 1#w) false) = 0x1#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 248.884208 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:198:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.717375 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      x = 0#w ↔ BitVec.carry w (~~~x) (1#w) false = true MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 7.885041 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 3.920291 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 57.123292 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 18.906583 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.908708 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      a ≥ 0
      a - b ≤ -1
    where
     a := ↑0 % ↑(2 ^ w)
     b := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 16.511083 ms, MSGSTART 
    Unsupported syntax BitVec.carry w (~~~x) (1#w) false === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.app (Lean.Expr.const `BitVec.carry []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1324929)))
            (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1324929)))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.const `Complement.complement [Lean.Level.zero])
                (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1324929))))
              (Lean.Expr.app (Lean.Expr.const `BitVec.instComplement []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1324929))))
            (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1324931))))
        (Lean.Expr.app
          (Lean.Expr.app (Lean.Expr.const `BitVec.ofNat []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1324929)))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `One.toOfNat1 [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `AddMonoidWithOne.toOne [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `AddCommMonoidWithOne.toAddMonoidWithOne [Lean.Level.zero])
                    (Lean.Expr.const `Nat []))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `NonAssocSemiring.toAddCommMonoidWithOne [Lean.Level.zero])
                      (Lean.Expr.const `Nat []))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `Semiring.toNonAssocSemiring [Lean.Level.zero])
                        (Lean.Expr.const `Nat []))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `CommSemiring.toSemiring [Lean.Level.zero])
                          (Lean.Expr.const `Nat []))
                        (Lean.Expr.const `Nat.instCommSemiring []))))))))))
      (Lean.Expr.const `Bool.false []) MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 70.892417 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (BitVec.carry w (~~~x) (1#w) false),
     BitVec.ofBool (x == 0#w)]
    Consider the following assignment:
    BitVec.ofBool (x == 0#w) = 0x1#1
    BitVec.ofBool (BitVec.carry w (~~~x) (1#w) false) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 230.786458 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:203:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.544292 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      ¬x = 0#w ↔ BitVec.carry w x (BitVec.allOnes w) false = true MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 6.753709 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 3.609166 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 84.870834 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 23.490958 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.960417 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑0 % ↑(2 ^ w)
     b := ↑x.toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 16.493417 ms, MSGSTART 
    Unsupported syntax BitVec.carry w x (-1#w) false === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.app (Lean.Expr.const `BitVec.carry []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1346689)))
            (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1346689)))
          (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1346691)))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.const `Neg.neg [Lean.Level.zero])
              (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1346689))))
            (Lean.Expr.app (Lean.Expr.const `BitVec.instNeg []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1346689))))
          (Lean.Expr.app
            (Lean.Expr.app (Lean.Expr.const `BitVec.ofNat []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1346689)))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))))
      (Lean.Expr.const `Bool.false []) MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 70.289125 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (BitVec.carry w x (BitVec.allOnes w) false),
     BitVec.ofBool (x == 0#w)]
    Consider the following assignment:
    BitVec.ofBool (x == 0#w) = 0x1#1
    BitVec.ofBool (BitVec.carry w x (BitVec.allOnes w) false) = 0x1#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 254.262959 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:208:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.646208 ms, MSGSTART 
    no applicable extensionality theorem found for
      Bool MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 9.660333 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 5.354042 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 54.066041 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 20.201208 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 0.822625 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 13.180959 ms, MSGSTART 
    Equality (0#w >ₛ x) = BitVec.carry w x x false has a strange type MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 66.349291 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (BitVec.carry w x x false),
     BitVec.ofBool (x.getLsbD (w - 1)),
     BitVec.ofBool (0#w >ᵤ x)]
    Consider the following assignment:
    BitVec.ofBool (x.getLsbD (w - 1)) = 0x1#1
    BitVec.ofBool (0#w >ᵤ x) = 0x1#1
    BitVec.ofBool (BitVec.carry w x x false) = 0x1#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 220.090875 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:213:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.904875 ms, MSGSTART 
    no applicable extensionality theorem found for
      Bool MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 12.088709 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 22.152958 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 88.852917 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 25.926416 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.543834 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 31.550916 ms, MSGSTART 
    Equality (0#w ≥ₛ x) = BitVec.carry w (2#w ^ (w - 1)) (-2#w ^ (w - 1) - x) false has a strange type MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 78.361250 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (x.getLsbD (w - 1)),
     BitVec.ofBool (x == 0#w),
     BitVec.ofBool (BitVec.carry w (2#w ^ (w - 1)) (-2#w ^ (w - 1) + -x) false)]
    Consider the following assignment:
    BitVec.ofBool (x.getLsbD (w - 1)) = 0x1#1
    BitVec.ofBool (x == 0#w) = 0x1#1
    BitVec.ofBool (BitVec.carry w (2#w ^ (w - 1)) (-2#w ^ (w - 1) + -x) false) = 0x1#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 351.474708 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:218:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.442667 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      AdditionNoOverflows? x y ↔ (y >ᵤ ~~~x) = true MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 8.757959 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 3.401375 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 49.760458 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 14.832458 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.036917 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 12.947125 ms, MSGSTART 
    Unsupported syntax AdditionNoOverflows? x y === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `HackersDelight.Ch2Basics.AdditionNoOverflows? [])
          (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1440318)))
        (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1440320)))
      (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1440322)) MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 1.536167 ms, MSGSTART 
    None of the hypotheses are in the supported BitVec fragment.
    There are two potential fixes for this:
    1. If you are using custom BitVec constructs simplify them to built-in ones.
    2. If your problem is using only built-in ones it might currently be out of reach.
       Consider expressing it in terms of different operations that are better supported. MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 138.358916 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:223:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.596125 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      AdditionNoOverflows? x y ↔ (x >ᵤ x + y) = true MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 14.351209 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 9.082958 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 59.460917 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 16.668625 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.398666 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 16.643000 ms, MSGSTART 
    Unsupported syntax AdditionNoOverflows? x y === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `HackersDelight.Ch2Basics.AdditionNoOverflows? [])
          (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1455178)))
        (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1455180)))
      (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1455182)) MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 2.809875 ms, MSGSTART 
    None of the hypotheses are in the supported BitVec fragment.
    There are two potential fixes for this:
    1. If you are using custom BitVec constructs simplify them to built-in ones.
    2. If your problem is using only built-in ones it might currently be out of reach.
       Consider expressing it in terms of different operations that are better supported. MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 172.285250 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:228:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.458000 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      AdditionNoOverflows? x (y + 1#w) ↔ (y ≥ᵤ ~~~x) = true MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 17.972541 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 11.325500 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 65.164833 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 16.621792 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.582041 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 15.651333 ms, MSGSTART 
    Unsupported syntax AdditionNoOverflows? x (y + 1#w) === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `HackersDelight.Ch2Basics.AdditionNoOverflows? [])
          (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1475704)))
        (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1475706)))
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `HAdd.hAdd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                  (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1475704))))
                (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1475704))))
              (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1475704))))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.const `instHAdd [Lean.Level.zero])
                (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1475704))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `Distrib.toAdd [Lean.Level.zero])
                  (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1475704))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `NonUnitalNonAssocSemiring.toDistrib [Lean.Level.zero])
                    (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1475704))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `NonAssocSemiring.toNonUnitalNonAssocSemiring [Lean.Level.zero])
                      (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1475704))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `Semiring.toNonAssocSemiring [Lean.Level.zero])
                        (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1475704))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `CommSemiring.toSemiring [Lean.Level.zero])
                          (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1475704))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec.instCommSemiring [])
                          (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1475704))))))))))
          (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1475708)))
        (Lean.Expr.app
          (Lean.Expr.app (Lean.Expr.const `BitVec.ofNat []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1475704)))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `One.toOfNat1 [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `AddMonoidWithOne.toOne [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `AddCommMonoidWithOne.toAddMonoidWithOne [Lean.Level.zero])
                    (Lean.Expr.const `Nat []))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `NonAssocSemiring.toAddCommMonoidWithOne [Lean.Level.zero])
                      (Lean.Expr.const `Nat []))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `Semiring.toNonAssocSemiring [Lean.Level.zero])
                        (Lean.Expr.const `Nat []))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `CommSemiring.toSemiring [Lean.Level.zero])
                          (Lean.Expr.const `Nat []))
                        (Lean.Expr.const `Nat.instCommSemiring [])))))))))) MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 3.783792 ms, MSGSTART 
    None of the hypotheses are in the supported BitVec fragment.
    There are two potential fixes for this:
    1. If you are using custom BitVec constructs simplify them to built-in ones.
    2. If your problem is using only built-in ones it might currently be out of reach.
       Consider expressing it in terms of different operations that are better supported. MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 189.322458 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:233:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.655792 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      AdditionNoOverflows? x (y + 1#w) ↔ (x ≥ᵤ y + 1#w + x) = true MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 107.685709 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 13.285291 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 74.726709 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 18.286666 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.628208 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 15.783416 ms, MSGSTART 
    Unsupported syntax AdditionNoOverflows? x (y + 1#w) === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `HackersDelight.Ch2Basics.AdditionNoOverflows? [])
          (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1500154)))
        (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1500156)))
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `HAdd.hAdd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                  (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1500154))))
                (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1500154))))
              (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1500154))))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.const `instHAdd [Lean.Level.zero])
                (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1500154))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `Distrib.toAdd [Lean.Level.zero])
                  (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1500154))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `NonUnitalNonAssocSemiring.toDistrib [Lean.Level.zero])
                    (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1500154))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `NonAssocSemiring.toNonUnitalNonAssocSemiring [Lean.Level.zero])
                      (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1500154))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `Semiring.toNonAssocSemiring [Lean.Level.zero])
                        (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1500154))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `CommSemiring.toSemiring [Lean.Level.zero])
                          (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1500154))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec.instCommSemiring [])
                          (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1500154))))))))))
          (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1500158)))
        (Lean.Expr.app
          (Lean.Expr.app (Lean.Expr.const `BitVec.ofNat []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1500154)))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `One.toOfNat1 [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `AddMonoidWithOne.toOne [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `AddCommMonoidWithOne.toAddMonoidWithOne [Lean.Level.zero])
                    (Lean.Expr.const `Nat []))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `NonAssocSemiring.toAddCommMonoidWithOne [Lean.Level.zero])
                      (Lean.Expr.const `Nat []))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `Semiring.toNonAssocSemiring [Lean.Level.zero])
                        (Lean.Expr.const `Nat []))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `CommSemiring.toSemiring [Lean.Level.zero])
                          (Lean.Expr.const `Nat []))
                        (Lean.Expr.const `Nat.instCommSemiring [])))))))))) MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 4.452959 ms, MSGSTART 
    None of the hypotheses are in the supported BitVec fragment.
    There are two potential fixes for this:
    1. If you are using custom BitVec constructs simplify them to built-in ones.
    2. If your problem is using only built-in ones it might currently be out of reach.
       Consider expressing it in terms of different operations that are better supported. MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 297.527875 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:238:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.582875 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      AdditionNoOverflows? x (~~~y + 1#w) ↔ (y >ᵤ x) = true MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 15.361667 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 11.858792 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 67.671625 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 17.610792 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.530333 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 16.178416 ms, MSGSTART 
    Unsupported syntax AdditionNoOverflows? x (~~~y + 1#w) === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `HackersDelight.Ch2Basics.AdditionNoOverflows? [])
          (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1551914)))
        (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1551916)))
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `HAdd.hAdd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                  (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1551914))))
                (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1551914))))
              (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1551914))))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.const `instHAdd [Lean.Level.zero])
                (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1551914))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `Distrib.toAdd [Lean.Level.zero])
                  (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1551914))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `NonUnitalNonAssocSemiring.toDistrib [Lean.Level.zero])
                    (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1551914))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `NonAssocSemiring.toNonUnitalNonAssocSemiring [Lean.Level.zero])
                      (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1551914))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `Semiring.toNonAssocSemiring [Lean.Level.zero])
                        (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1551914))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `CommSemiring.toSemiring [Lean.Level.zero])
                          (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1551914))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec.instCommSemiring [])
                          (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1551914))))))))))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.const `Complement.complement [Lean.Level.zero])
                (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1551914))))
              (Lean.Expr.app (Lean.Expr.const `BitVec.instComplement []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1551914))))
            (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1551918))))
        (Lean.Expr.app
          (Lean.Expr.app (Lean.Expr.const `BitVec.ofNat []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1551914)))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `One.toOfNat1 [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `AddMonoidWithOne.toOne [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `AddCommMonoidWithOne.toAddMonoidWithOne [Lean.Level.zero])
                    (Lean.Expr.const `Nat []))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `NonAssocSemiring.toAddCommMonoidWithOne [Lean.Level.zero])
                      (Lean.Expr.const `Nat []))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `Semiring.toNonAssocSemiring [Lean.Level.zero])
                        (Lean.Expr.const `Nat []))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `CommSemiring.toSemiring [Lean.Level.zero])
                          (Lean.Expr.const `Nat []))
                        (Lean.Expr.const `Nat.instCommSemiring [])))))))))) MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 3.201084 ms, MSGSTART 
    None of the hypotheses are in the supported BitVec fragment.
    There are two potential fixes for this:
    1. If you are using custom BitVec constructs simplify them to built-in ones.
    2. If your problem is using only built-in ones it might currently be out of reach.
       Consider expressing it in terms of different operations that are better supported. MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 191.227041 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:243:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.550792 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      AdditionNoOverflows? x (~~~y + 1#w) ↔ (x - y >ᵤ x) = true MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 28.115333 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 13.465125 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 78.976208 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 18.444875 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.932667 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 18.312709 ms, MSGSTART 
    Unsupported syntax AdditionNoOverflows? x (~~~y + 1#w) === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `HackersDelight.Ch2Basics.AdditionNoOverflows? [])
          (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1576249)))
        (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1576251)))
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `HAdd.hAdd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                  (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1576249))))
                (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1576249))))
              (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1576249))))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.const `instHAdd [Lean.Level.zero])
                (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1576249))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `Distrib.toAdd [Lean.Level.zero])
                  (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1576249))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `NonUnitalNonAssocSemiring.toDistrib [Lean.Level.zero])
                    (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1576249))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `NonAssocSemiring.toNonUnitalNonAssocSemiring [Lean.Level.zero])
                      (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1576249))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `Semiring.toNonAssocSemiring [Lean.Level.zero])
                        (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1576249))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `CommSemiring.toSemiring [Lean.Level.zero])
                          (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1576249))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec.instCommSemiring [])
                          (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1576249))))))))))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.const `Complement.complement [Lean.Level.zero])
                (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1576249))))
              (Lean.Expr.app (Lean.Expr.const `BitVec.instComplement []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1576249))))
            (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1576253))))
        (Lean.Expr.app
          (Lean.Expr.app (Lean.Expr.const `BitVec.ofNat []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1576249)))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `One.toOfNat1 [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `AddMonoidWithOne.toOne [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `AddCommMonoidWithOne.toAddMonoidWithOne [Lean.Level.zero])
                    (Lean.Expr.const `Nat []))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `NonAssocSemiring.toAddCommMonoidWithOne [Lean.Level.zero])
                      (Lean.Expr.const `Nat []))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `Semiring.toNonAssocSemiring [Lean.Level.zero])
                        (Lean.Expr.const `Nat []))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `CommSemiring.toSemiring [Lean.Level.zero])
                          (Lean.Expr.const `Nat []))
                        (Lean.Expr.const `Nat.instCommSemiring [])))))))))) MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 6.596666 ms, MSGSTART 
    None of the hypotheses are in the supported BitVec fragment.
    There are two potential fixes for this:
    1. If you are using custom BitVec constructs simplify them to built-in ones.
    2. If your problem is using only built-in ones it might currently be out of reach.
       Consider expressing it in terms of different operations that are better supported. MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 247.541000 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:248:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.445500 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      AdditionNoOverflows? x (~~~y) ↔ (y ≥ᵤ x) = true MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 7.585500 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 3.136584 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 52.452291 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 15.711875 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.196625 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 13.097833 ms, MSGSTART 
    Unsupported syntax AdditionNoOverflows? x (~~~y) === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `HackersDelight.Ch2Basics.AdditionNoOverflows? [])
          (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1607119)))
        (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1607121)))
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Complement.complement [Lean.Level.zero])
            (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1607119))))
          (Lean.Expr.app (Lean.Expr.const `BitVec.instComplement []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1607119))))
        (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1607123))) MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 2.077291 ms, MSGSTART 
    None of the hypotheses are in the supported BitVec fragment.
    There are two potential fixes for this:
    1. If you are using custom BitVec constructs simplify them to built-in ones.
    2. If your problem is using only built-in ones it might currently be out of reach.
       Consider expressing it in terms of different operations that are better supported. MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 138.590125 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:253:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.630208 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      AdditionNoOverflows? x (~~~y) ↔ (x + (-y - 1#w) ≥ᵤ x) = true MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 20.472084 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 18.114708 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 75.550709 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 21.914875 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.599791 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 19.300208 ms, MSGSTART 
    Unsupported syntax AdditionNoOverflows? x (~~~y) === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `HackersDelight.Ch2Basics.AdditionNoOverflows? [])
          (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1622131)))
        (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1622133)))
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Complement.complement [Lean.Level.zero])
            (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1622131))))
          (Lean.Expr.app (Lean.Expr.const `BitVec.instComplement []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1622131))))
        (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1622135))) MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 9.428542 ms, MSGSTART 
    None of the hypotheses are in the supported BitVec fragment.
    There are two potential fixes for this:
    1. If you are using custom BitVec constructs simplify them to built-in ones.
    2. If your problem is using only built-in ones it might currently be out of reach.
       Consider expressing it in terms of different operations that are better supported. MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 222.808584 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:258:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.524167 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      UnsignedMultiplicationOverflows? x y ↔ ¬first32Bits (x * y) = 0#32 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 24.890208 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 9.588208 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 99.494167 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 28.857166 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.703917 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 15.725875 ms, MSGSTART 
    Unsupported syntax UnsignedMultiplicationOverflows? x y === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `HackersDelight.Ch2Basics.UnsignedMultiplicationOverflows? [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 64)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 64)))))
        (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1654852)))
      (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1654853)) MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 6.050791 ms, MSGSTART 
    None of the hypotheses are in the supported BitVec fragment.
    There are two potential fixes for this:
    1. If you are using custom BitVec constructs simplify them to built-in ones.
    2. If your problem is using only built-in ones it might currently be out of reach.
       Consider expressing it in terms of different operations that are better supported. MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 253.469916 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:269:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.808667 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      SignedMultiplicationOverflows? x y ↔ ¬first32Bits (x * y) = last32Bits (x * y) >>> 31 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 12.510833 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 10.747875 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 101.283625 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 27.823583 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.392834 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 4294967295
      0 ≤ a ≤ 4294967295
      -2147483647 ≤ 2147483648*a - b ≤ 0
    where
     a := ↑(last32Bits (x * y)).toNat / 2147483648
     b := ↑(last32Bits (x * y)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 15.670750 ms, MSGSTART 
    Unsupported syntax SignedMultiplicationOverflows? x y === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `HackersDelight.Ch2Basics.SignedMultiplicationOverflows? [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 64)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 64)))))
        (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1680831)))
      (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1680832)) MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 5.553500 ms, MSGSTART 
    None of the hypotheses are in the supported BitVec fragment.
    There are two potential fixes for this:
    1. If you are using custom BitVec constructs simplify them to built-in ones.
    2. If your problem is using only built-in ones it might currently be out of reach.
       Consider expressing it in terms of different operations that are better supported. MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 267.373917 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:274:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.733084 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      (2 ^ w).succ.le (x.toNat * y.toNat) MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 5.770583 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 1.591791 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 8.712750 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 6.378209 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.589334 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      d ≥ 1
      c - d ≥ 1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑x.toNat
     b := ↑(x.toNat * y.toNat % 2 ^ w) / ↑z.toNat
     c := ↑2 ^ w
     d := ↑y.toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 9.803708 ms, MSGSTART 
    Unsupported syntax UnsignedMultiplicationOverflows? x y === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `HackersDelight.Ch2Basics.UnsignedMultiplicationOverflows? [])
          (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1708552)))
        (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1708554)))
      (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1708556)) MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 61.082834 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (x * y / z == x)]
    Consider the following assignment:
    BitVec.ofBool (x * y / z == x) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 106.468917 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:279:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.702958 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      (x.toInt * y.toInt - (2 ^ (w - 1) + 1)).NonNeg MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 5.893916 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 1.725292 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 7.441375 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 6.000709 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.610416 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 1
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑0 % ↑(2 ^ w)
     b := ↑y.toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 11.145750 ms, MSGSTART 
    Unsupported syntax SignedMultiplicationOverflows? x y === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `HackersDelight.Ch2Basics.SignedMultiplicationOverflows? [])
          (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1716058)))
        (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1716060)))
      (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1716062)) MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 8.633375 ms, MSGSTART 
    None of the hypotheses are in the supported BitVec fragment.
    There are two potential fixes for this:
    1. If you are using custom BitVec constructs simplify them to built-in ones.
    2. If your problem is using only built-in ones it might currently be out of reach.
       Consider expressing it in terms of different operations that are better supported. MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 50.264209 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:284:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.555333 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      32 ≤ numberOfLeadingZeros x + numberOfLeadingZeros y ↔ ¬UnsignedMultiplicationOverflows? x y MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 10.957750 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 14.510750 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 25.701250 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 16.245709 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.690333 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      a ≥ 0
      a + b ≥ 32
    where
     a := ↑(numberOfLeadingZeros x)
     b := ↑(numberOfLeadingZeros y) MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 19.201084 ms, MSGSTART 
    Unsupported syntax 32 ≤ numberOfLeadingZeros x + numberOfLeadingZeros y === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app (Lean.Expr.const `LE.le [Lean.Level.zero]) (Lean.Expr.const `Nat []))
          (Lean.Expr.const `instLENat []))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
            (Lean.Expr.lit (Lean.Literal.natVal 32)))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `instOfNatAtLeastTwo [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 32)))
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `AddMonoidWithOne.toNatCast [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `AddCommMonoidWithOne.toAddMonoidWithOne [Lean.Level.zero])
                    (Lean.Expr.const `Nat []))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `NonAssocSemiring.toAddCommMonoidWithOne [Lean.Level.zero])
                      (Lean.Expr.const `Nat []))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `Semiring.toNonAssocSemiring [Lean.Level.zero])
                        (Lean.Expr.const `Nat []))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `CommSemiring.toSemiring [Lean.Level.zero])
                          (Lean.Expr.const `Nat []))
                        (Lean.Expr.const `Nat.instCommSemiring [])))))))
            (Lean.Expr.app
              (Lean.Expr.const `instNatAtLeastTwo [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 30)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 30))))))))
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `HAdd.hAdd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                  (Lean.Expr.const `Nat []))
                (Lean.Expr.const `Nat []))
              (Lean.Expr.const `Nat []))
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `instHAdd [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `Distrib.toAdd [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `NonUnitalNonAssocSemiring.toDistrib [Lean.Level.zero])
                    (Lean.Expr.const `Nat []))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `NonAssocSemiring.toNonUnitalNonAssocSemiring [Lean.Level.zero])
                      (Lean.Expr.const `Nat []))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `Semiring.toNonAssocSemiring [Lean.Level.zero])
                        (Lean.Expr.const `Nat []))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `CommSemiring.toSemiring [Lean.Level.zero])
                          (Lean.Expr.const `Nat []))
                        (Lean.Expr.const `Nat.instCommSemiring []))))))))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.const `HackersDelight.Ch2Basics.numberOfLeadingZeros [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 64)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 64)))))
            (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1725920))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `HackersDelight.Ch2Basics.numberOfLeadingZeros [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 64)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 64)))))
          (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1725921)))) MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 2.988125 ms, MSGSTART 
    None of the hypotheses are in the supported BitVec fragment.
    There are two potential fixes for this:
    1. If you are using custom BitVec constructs simplify them to built-in ones.
    2. If your problem is using only built-in ones it might currently be out of reach.
       Consider expressing it in terms of different operations that are better supported. MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 102.001000 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:296:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.437542 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      numberOfLeadingZeros x + numberOfLeadingZeros y ≤ 30 ↔ UnsignedMultiplicationOverflows? x y MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 14.383833 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 13.058500 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 21.106125 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 14.696458 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.626375 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      a ≥ 0
      a + b ≤ 30
    where
     a := ↑(numberOfLeadingZeros x)
     b := ↑(numberOfLeadingZeros y) MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 17.510750 ms, MSGSTART 
    Unsupported syntax numberOfLeadingZeros x + numberOfLeadingZeros y ≤ 30 === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app (Lean.Expr.const `LE.le [Lean.Level.zero]) (Lean.Expr.const `Nat []))
          (Lean.Expr.const `instLENat []))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `HAdd.hAdd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                    (Lean.Expr.const `Nat []))
                  (Lean.Expr.const `Nat []))
                (Lean.Expr.const `Nat []))
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `instHAdd [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `Distrib.toAdd [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `NonUnitalNonAssocSemiring.toDistrib [Lean.Level.zero])
                      (Lean.Expr.const `Nat []))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `NonAssocSemiring.toNonUnitalNonAssocSemiring [Lean.Level.zero])
                        (Lean.Expr.const `Nat []))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `Semiring.toNonAssocSemiring [Lean.Level.zero])
                          (Lean.Expr.const `Nat []))
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `CommSemiring.toSemiring [Lean.Level.zero])
                            (Lean.Expr.const `Nat []))
                          (Lean.Expr.const `Nat.instCommSemiring []))))))))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.const `HackersDelight.Ch2Basics.numberOfLeadingZeros [])
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                    (Lean.Expr.lit (Lean.Literal.natVal 64)))
                  (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 64)))))
              (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1748429))))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.const `HackersDelight.Ch2Basics.numberOfLeadingZeros [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 64)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 64)))))
            (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1748430)))))
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
          (Lean.Expr.lit (Lean.Literal.natVal 30)))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `instOfNatAtLeastTwo [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 30)))
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `AddMonoidWithOne.toNatCast [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `AddCommMonoidWithOne.toAddMonoidWithOne [Lean.Level.zero])
                  (Lean.Expr.const `Nat []))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `NonAssocSemiring.toAddCommMonoidWithOne [Lean.Level.zero])
                    (Lean.Expr.const `Nat []))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `Semiring.toNonAssocSemiring [Lean.Level.zero])
                      (Lean.Expr.const `Nat []))
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `CommSemiring.toSemiring [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.const `Nat.instCommSemiring [])))))))
          (Lean.Expr.app
            (Lean.Expr.const `instNatAtLeastTwo [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 28)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 28))))))) MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 2.838542 ms, MSGSTART 
    None of the hypotheses are in the supported BitVec fragment.
    There are two potential fixes for this:
    1. If you are using custom BitVec constructs simplify them to built-in ones.
    2. If your problem is using only built-in ones it might currently be out of reach.
       Consider expressing it in terms of different operations that are better supported. MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 98.877875 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:301:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 2.547625 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      SignedDivisionOverflows?? x y ↔ y = 0#w ∨ x.toInt = -2147483648 ∧ y = BitVec.allOnes w MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 9.194000 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 32.217375 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 87.715167 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 60.689667 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.331333 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      c ≥ 0
      c - d ≤ -1
      b ≥ 0
      b - c ≥ 1
      b - d ≤ -1
      a ≤ -2147483649
    where
     a := x.toInt
     b := ↑0 % ↑(2 ^ w)
     c := ↑y.toNat
     d := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 41.272708 ms, MSGSTART 
    Unsupported syntax SignedDivisionOverflows?? x y === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `HackersDelight.Ch2Basics.SignedDivisionOverflows?? [])
          (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1769982)))
        (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1769984)))
      (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1769986)) MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 5.832459 ms, MSGSTART 
    None of the hypotheses are in the supported BitVec fragment.
    There are two potential fixes for this:
    1. If you are using custom BitVec constructs simplify them to built-in ones.
    2. If your problem is using only built-in ones it might currently be out of reach.
       Consider expressing it in terms of different operations that are better supported. MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 311.614959 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:308:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.734208 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      SignedDivisionOverflows?? x (BitVec.setWidth 64 y) ↔ ¬y = 0#32 ∧ x < BitVec.setWidth 64 y <<< 32 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 7.282834 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 5.902625 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 89.932833 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 33.633375 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.750709 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 15.760541 ms, MSGSTART 
    Unsupported syntax SignedDivisionOverflows?? x (BitVec.setWidth 64 y) === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `HackersDelight.Ch2Basics.SignedDivisionOverflows?? [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 64)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 64)))))
        (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1825930)))
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `BitVec.setWidth [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 32)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 64)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 64)))))
        (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1825931))) MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 7.250959 ms, MSGSTART 
    None of the hypotheses are in the supported BitVec fragment.
    There are two potential fixes for this:
    1. If you are using custom BitVec constructs simplify them to built-in ones.
    2. If your problem is using only built-in ones it might currently be out of reach.
       Consider expressing it in terms of different operations that are better supported. MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 247.336125 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:313:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.666625 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      SignedDivisionOverflows?? x (BitVec.setWidth 64 y) ↔ ¬y = 0#32 ∧ x >>> 32 < BitVec.setWidth 64 y MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 7.207166 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 5.796000 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 91.750541 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 31.984042 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.131209 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 14.081375 ms, MSGSTART 
    Unsupported syntax SignedDivisionOverflows?? x (BitVec.setWidth 64 y) === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `HackersDelight.Ch2Basics.SignedDivisionOverflows?? [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 64)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 64)))))
        (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1853302)))
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `BitVec.setWidth [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 32)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 64)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 64)))))
        (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1853304))) MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 6.452209 ms, MSGSTART 
    None of the hypotheses are in the supported BitVec fragment.
    There are two potential fixes for this:
    1. If you are using custom BitVec constructs simplify them to built-in ones.
    2. If your problem is using only built-in ones it might currently be out of reach.
       Consider expressing it in terms of different operations that are better supported. MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 250.342459 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:318:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 81.295292 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 31.842375 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 21.342042 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 58.844750 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.740708 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.511875 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(y.toNat + (signedDifferenceOrZero x y).toNat) % ↑(2 ^ w)
     b := ↑(signedMaxBitVec x y).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 51.431084 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0)
            ((AutoStructs.Term.var 1).add (AutoStructs.Term.var 2))) =
        true
    is false MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 68.269959 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (signedMaxBitVec x y == y + signedDifferenceOrZero x y)]
    Consider the following assignment:
    BitVec.ofBool (signedMaxBitVec x y == y + signedDifferenceOrZero x y) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 365.595916 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:341:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 82.922833 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 18.772875 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 11.687042 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 69.747459 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.228750 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.785917 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x.toNat + (2 ^ w - (signedDifferenceOrZero x y).toNat)) % ↑(2 ^ w)
     b := ↑(signedMinBitVec x y).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 49.121917 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0)
            ((AutoStructs.Term.var 1).sub (AutoStructs.Term.var 2))) =
        true
    is false MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 70.066417 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (signedMinBitVec x y == x + -signedDifferenceOrZero x y)]
    Consider the following assignment:
    BitVec.ofBool (signedMinBitVec x y == x + -signedDifferenceOrZero x y) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 361.659208 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:346:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 81.876083 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 22.813542 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 15.491916 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 57.685333 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.294833 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.802125 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(y.toNat + (unsignedDifferenceOrZero x y).toNat) % ↑(2 ^ w)
     b := ↑(unsignedMaxBitVec x y).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 43.503083 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0)
            ((AutoStructs.Term.var 1).add (AutoStructs.Term.var 2))) =
        true
    is false MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 66.698208 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (unsignedMaxBitVec x y == y + unsignedDifferenceOrZero x y)]
    Consider the following assignment:
    BitVec.ofBool (unsignedMaxBitVec x y == y + unsignedDifferenceOrZero x y) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 340.675375 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:351:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 85.669125 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 13.438208 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 7.912708 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 67.416625 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.270917 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.620375 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x.toNat + (2 ^ w - (unsignedDifferenceOrZero x y).toNat)) % ↑(2 ^ w)
     b := ↑(unsignedMinBitVec x y).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 55.040209 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0)
            ((AutoStructs.Term.var 1).sub (AutoStructs.Term.var 2))) =
        true
    is false MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 68.227875 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (unsignedMinBitVec x y == x + -unsignedDifferenceOrZero x y)]
    Consider the following assignment:
    BitVec.ofBool (unsignedMinBitVec x y == x + -unsignedDifferenceOrZero x y) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 350.878542 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:356:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 89.723167 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 24.663750 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 15.630834 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 71.494958 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.731417 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.161917 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x - y &&& leBitmask x y).toNat
     b := ↑(signedDifferenceOrZero x y).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 54.577083 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0)
            (((AutoStructs.Term.var 1).sub (AutoStructs.Term.var 2)).and (AutoStructs.Term.var 3))) =
        true
    is false MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 71.358875 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (signedDifferenceOrZero x y == x + -y &&& leBitmask x y)]
    Consider the following assignment:
    BitVec.ofBool (signedDifferenceOrZero x y == x + -y &&& leBitmask x y) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 386.350459 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:364:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 98.126292 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 24.084250 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 15.604458 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 52.372208 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 10.025000 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.513959 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑((x ^^^ y) &&& leBitmask x y ^^^ y).toNat
     b := ↑(signedMaxBitVec x y).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 46.591167 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0)
            ((((AutoStructs.Term.var 1).xor (AutoStructs.Term.var 2)).and (AutoStructs.Term.var 3)).xor
              (AutoStructs.Term.var 2))) =
        true
    is false MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 67.386958 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (signedMaxBitVec x y == (x ^^^ y) &&& leBitmask x y ^^^ y)]
    Consider the following assignment:
    BitVec.ofBool (signedMaxBitVec x y == (x ^^^ y) &&& leBitmask x y ^^^ y) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 357.181875 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:369:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 96.193875 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 23.766125 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 15.760167 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 51.730958 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.061875 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.803458 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑((x ^^^ y) &&& leBitmask y x ^^^ y).toNat
     b := ↑(signedMinBitVec x y).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 50.259292 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0)
            ((((AutoStructs.Term.var 1).xor (AutoStructs.Term.var 2)).and (AutoStructs.Term.var 3)).xor
              (AutoStructs.Term.var 2))) =
        true
    is false MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 67.811084 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (signedMinBitVec x y == (x ^^^ y) &&& leBitmask y x ^^^ y)]
    Consider the following assignment:
    BitVec.ofBool (signedMinBitVec x y == (x ^^^ y) &&& leBitmask y x ^^^ y) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 374.718292 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:374:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 94.320334 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 18.081875 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 12.429042 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 73.114209 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.579000 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.262917 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x - y &&& ~~~carryBitmask x y).toNat
     b := ↑(unsignedDifferenceOrZero x y).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 52.870709 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0)
            (((AutoStructs.Term.var 1).sub (AutoStructs.Term.var 2)).and (AutoStructs.Term.var 3).not)) =
        true
    is false MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 71.011709 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (unsignedDifferenceOrZero x y == x + -y &&& ~~~carryBitmask x y)]
    Consider the following assignment:
    BitVec.ofBool (unsignedDifferenceOrZero x y == x + -y &&& ~~~carryBitmask x y) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 386.910667 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:382:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 85.934625 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 20.585584 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 14.722292 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 79.140125 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.138750 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.013750 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x.toNat + (2 ^ w - (x - y &&& carryBitmask x y).toNat)) % ↑(2 ^ w)
     b := ↑(unsignedMaxBitVec x y).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 62.426209 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0)
            ((AutoStructs.Term.var 1).sub
              (((AutoStructs.Term.var 1).sub (AutoStructs.Term.var 2)).and (AutoStructs.Term.var 3)))) =
        true
    is false MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 71.617542 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (unsignedMaxBitVec x y == x + -(x + -y &&& carryBitmask x y))]
    Consider the following assignment:
    BitVec.ofBool (unsignedMaxBitVec x y == x + -(x + -y &&& carryBitmask x y)) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 418.835792 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:387:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 90.282083 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 31.867708 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 31.758208 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 72.027209 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 10.507875 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.459333 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(y.toNat + (-y + x &&& carryBitmask x y).toNat) % ↑(2 ^ w)
     b := ↑(unsignedMinBitVec x y).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 80.239541 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0)
            ((AutoStructs.Term.var 1).add
              (((AutoStructs.Term.var 1).neg.add (AutoStructs.Term.var 2)).and (AutoStructs.Term.var 3)))) =
        true
    is false MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 70.016792 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (unsignedMinBitVec x y == y + (-y + x &&& carryBitmask x y))]
    Consider the following assignment:
    BitVec.ofBool (unsignedMinBitVec x y == y + (-y + x &&& carryBitmask x y)) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 442.519417 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:392:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 151.324583 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 29.715292 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 19.916541 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 59.036333 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.503875 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.936625 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ f ≤ 4294967295
      0 ≤ e ≤ 4294967295
      0 ≤ c ≤ 4294967295
      c - e ≥ 1
      0 ≤ a ≤ 4294967295
      -4294967296 ≤ a - 4294967296*b - f ≤ -1
    where
     a := ↑x.toNat
     b := ↑(x.toNat + (2 ^ 32 - y.toNat)) / 4294967296
     c := ↑(d &&& (~~~d ^^^ ((x ^^^ y) &&& (d ^^^ x)) >>> 31)).toNat
     e := ↑(signedDifferenceOrZero x y).toNat
     f := ↑y.toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 49.690292 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0)
            ((AutoStructs.Term.var 1).and ((AutoStructs.Term.var 1).not.xor (AutoStructs.Term.var 2)))) =
        true
    is false MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 74.809958 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [signedDifferenceOrZero x y]
    Consider the following assignment:
    d = 0xffffffff#32
    x = 0xffffffff#32
    y = 0x00000000#32
    signedDifferenceOrZero x y = 0xffffffff#32
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 447.322917 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:400:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 183.896583 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 21.284791 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 16.775500 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 62.144750 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 10.591583 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.385375 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ f ≤ 4294967295
      0 ≤ e ≤ 4294967295
      0 ≤ c ≤ 4294967295
      c - e ≥ 1
      0 ≤ a ≤ 4294967295
      -4294967296 ≤ a - 4294967296*b - f ≤ -1
    where
     a := ↑x.toNat
     b := ↑(x.toNat + (2 ^ 32 - y.toNat)) / 4294967296
     c := ↑(d &&& ~~~((~~~x &&& y ||| ~~~(x ^^^ y) &&& d) >>> 31)).toNat
     e := ↑(unsignedDifferenceOrZero x y).toNat
     f := ↑y.toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 40.674750 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0)
            ((AutoStructs.Term.var 1).and (AutoStructs.Term.var 2).not)) =
        true
    is false MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 78.290125 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [unsignedDifferenceOrZero x y]
    Consider the following assignment:
    d = 0xffffffff#32
    x = 0xffffffff#32
    y = 0x00000000#32
    unsignedDifferenceOrZero x y = 0x7fffffff#32
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 462.642416 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:405:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 107.146041 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 25.071375 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 16.534541 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 71.481417 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.763458 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.340917 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 4294967295
      0 ≤ a ≤ 4294967295
      a - b ≥ 1
    where
     a := ↑(x - y &&& ~~~((x - y) >>> 31)).toNat
     b := ↑(signedDifferenceOrZero x y).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 58.457583 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0)
            (((AutoStructs.Term.var 1).sub (AutoStructs.Term.var 2)).and (AutoStructs.Term.var 3).not)) =
        true
    is false MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 75.471834 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [signedDifferenceOrZero x y]
    Consider the following assignment:
    signedDifferenceOrZero x y = 0xffffffff#32
    x = 0xffffffff#32
    y = 0xffffffff#32
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 430.902209 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:410:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 93.081958 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 26.152292 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 17.211334 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 79.289666 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.984208 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.897333 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ d ≤ 4294967295
      0 ≤ c ≤ 4294967295
      0 ≤ a ≤ 4294967295
      a - 4294967296*b - c - d ≥ -4294967295
      -4294967296 ≤ a - 4294967296*b - d ≤ -1
    where
     a := ↑x.toNat
     b := ↑(x.toNat + (2 ^ 32 - (x - y &&& (x - y) >>> 31).toNat)) / 4294967296
     c := ↑(signedMaxBitVec x y).toNat
     d := ↑(x - y &&& (x - y) >>> 31).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 66.470792 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0)
            ((AutoStructs.Term.var 1).sub
              (((AutoStructs.Term.var 1).sub (AutoStructs.Term.var 2)).and (AutoStructs.Term.var 3)))) =
        true
    is false MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 78.967291 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [signedMaxBitVec x y]
    Consider the following assignment:
    signedMaxBitVec x y = 0x00000001#32
    x = 0x00000000#32
    y = 0x00000000#32
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 437.155125 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:415:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 93.096916 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 35.915875 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 32.931834 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 76.012459 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 10.929417 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.078917 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ d ≤ 4294967295
      0 ≤ b ≤ 4294967295
      0 ≤ a ≤ 4294967295
      0 ≤ a + b - 4294967296*c ≤ 4294967295
      a + b - 4294967296*c - d ≥ 1
    where
     a := ↑y.toNat
     b := ↑(-y + x &&& (-y + x) >>> 31).toNat
     c := ↑(y.toNat + (-y + x &&& (-y + x) >>> 31).toNat) / 4294967296
     d := ↑(signedMinBitVec x y).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 85.833583 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0)
            ((AutoStructs.Term.var 1).add
              (((AutoStructs.Term.var 1).neg.add (AutoStructs.Term.var 2)).and (AutoStructs.Term.var 3)))) =
        true
    is false MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 76.989375 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [signedMinBitVec x y]
    Consider the following assignment:
    signedMinBitVec x y = 0x00000000#32
    y = 0x00000000#32
    x = 0x80000001#32
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 482.268291 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:420:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.586708 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      (x >ₛ y) = true ↔ (signedDifferenceOrZero x y).msb = true ∨ (-signedDifferenceOrZero x y).msb = true MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 7.132875 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 6.865916 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 63.295917 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 32.342417 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.908958 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 93.158750 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.binop AutoStructs.Binop.equiv
            (AutoStructs.Formula.atom (AutoStructs.Relation.signed AutoStructs.RelationOrdering.lt)
              (AutoStructs.Term.var 0) (AutoStructs.Term.var 1))
            (AutoStructs.Formula.binop AutoStructs.Binop.or (AutoStructs.Formula.msbSet (AutoStructs.Term.var 2))
              (AutoStructs.Formula.msbSet (AutoStructs.Term.var 2).neg))) =
        true
    is false MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 79.401833 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [signedDifferenceOrZero x y]
    Consider the following assignment:
    y = 0xffffffff#32
    x = 0xffffffff#32
    signedDifferenceOrZero x y = 0xffffffff#32
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 338.074417 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:425:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.566584 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      (x >ᵤ y) = true ↔ (unsignedDifferenceOrZero x y).msb = true ∨ (-unsignedDifferenceOrZero x y).msb = true MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 7.687041 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 6.665292 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 61.962250 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 20.689416 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.061709 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 61.470208 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.binop AutoStructs.Binop.equiv
            (AutoStructs.Formula.atom (AutoStructs.Relation.unsigned AutoStructs.RelationOrdering.lt)
              (AutoStructs.Term.var 0) (AutoStructs.Term.var 1))
            (AutoStructs.Formula.binop AutoStructs.Binop.or (AutoStructs.Formula.msbSet (AutoStructs.Term.var 2))
              (AutoStructs.Formula.msbSet (AutoStructs.Term.var 2).neg))) =
        true
    is false MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 75.340292 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [unsignedDifferenceOrZero x y]
    Consider the following assignment:
    y = 0xffffffff#32
    x = 0xffffffff#32
    unsignedDifferenceOrZero x y = 0xffffffff#32
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 288.607958 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:430:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.654792 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      BitVec.carry w x y false = true ↔
        (unsignedDifferenceOrZero x (~~~y)).msb = true ∨ (-unsignedDifferenceOrZero x (~~~y)).msb = true MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 8.289542 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 7.253334 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 62.490667 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 18.431417 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.680625 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 18.123041 ms, MSGSTART 
    Unsupported syntax BitVec.carry w x y false === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.const `BitVec.carry [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
            (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 2727187)))
          (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 2727205)))
        (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 2727210)))
      (Lean.Expr.const `Bool.false []) MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 75.413917 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (BitVec.carry w x y false),
     unsignedDifferenceOrZero x (~~~y)]
    Consider the following assignment:
    BitVec.ofBool (BitVec.carry w x y false) = 0x1#1
    unsignedDifferenceOrZero x (~~~y) = 0x00000000#32
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 255.738875 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:435:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 91.389250 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 29.448542 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 24.788083 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 69.018667 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.818000 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.385166 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑((signedDifferenceOrZero x y).toNat + (signedDifferenceOrZero y x).toNat) % ↑(2 ^ w)
     b := ↑(if Decidable.decide (2 ^ (w - 1) ≤ (x.toNat + (2 ^ w - y.toNat)) % 2 ^ w) = true then
        2 ^ w - (x.toNat + (2 ^ w - y.toNat)) % 2 ^ w
      else (x.toNat + (2 ^ w - y.toNat)) % 2 ^ w)
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 72.181750 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0)
            ((AutoStructs.Term.var 1).add (AutoStructs.Term.var 2))) =
        true
    is false MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 73.280625 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       ((if (x + -y).getLsbD (w - 1) = true then -(x + -y) else x + -y) ==
         signedDifferenceOrZero x y + signedDifferenceOrZero y x)]
    Consider the following assignment:
    BitVec.ofBool
      ((if (x + -y).getLsbD (w - 1) = true then -(x + -y) else x + -y) ==
        signedDifferenceOrZero x y + signedDifferenceOrZero y x) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 417.971334 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:442:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 90.058208 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 24.550084 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 19.581292 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 69.315291 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.951584 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 8.001833 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑((unsignedDifferenceOrZero x y).toNat + (unsignedDifferenceOrZero y x).toNat) % ↑(2 ^ w)
     b := ↑(if Decidable.decide (2 ^ (w - 1) ≤ (x.toNat + (2 ^ w - y.toNat)) % 2 ^ w) = true then
        2 ^ w - (x.toNat + (2 ^ w - y.toNat)) % 2 ^ w
      else (x.toNat + (2 ^ w - y.toNat)) % 2 ^ w)
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 52.803500 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0)
            ((AutoStructs.Term.var 1).add (AutoStructs.Term.var 2))) =
        true
    is false MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 70.920291 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       ((if (x + -y).getLsbD (w - 1) = true then -(x + -y) else x + -y) ==
         unsignedDifferenceOrZero x y + unsignedDifferenceOrZero y x)]
    Consider the following assignment:
    BitVec.ofBool
      ((if (x + -y).getLsbD (w - 1) = true then -(x + -y) else x + -y) ==
        unsignedDifferenceOrZero x y + unsignedDifferenceOrZero y x) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 398.824709 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:447:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.603208 ms, MSGSTART 
    no applicable extensionality theorem found for
      Bool MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 8.456833 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 4.481208 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 48.287375 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.354041 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 0.749000 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 13.315542 ms, MSGSTART 
    Equality BitVec.carry w x y false = (x >ᵤ ~~~y) has a strange type MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 66.608208 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (BitVec.carry w x y false),
     BitVec.ofBool (x >ᵤ ~~~y)]
    Consider the following assignment:
    BitVec.ofBool (BitVec.carry w x y false) = 0x1#1
    BitVec.ofBool (x >ᵤ ~~~y) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 203.415625 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:452:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 88.128250 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 29.041583 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 14.737417 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 49.669125 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 7.228750 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.696292 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(signedDifferenceOrZero x y).toNat
     b := ↑(signedDifferenceOrZero (~~~x) (~~~y)).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 62.271541 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) (AutoStructs.Term.var 1)) =
        true
    is false MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 61.578916 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (signedDifferenceOrZero (~~~x) (~~~y) == signedDifferenceOrZero x y)]
    Consider the following assignment:
    BitVec.ofBool (signedDifferenceOrZero (~~~x) (~~~y) == signedDifferenceOrZero x y) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 345.916208 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:457:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 79.537875 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 13.903500 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 6.783750 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 50.590583 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 7.126000 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.417709 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(unsignedDifferenceOrZero x y).toNat
     b := ↑(unsignedDifferenceOrZero (~~~x) (~~~y)).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 43.077333 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) (AutoStructs.Term.var 1)) =
        true
    is false MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 65.908667 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (unsignedDifferenceOrZero (~~~x) (~~~y) == unsignedDifferenceOrZero x y)]
    Consider the following assignment:
    BitVec.ofBool (unsignedDifferenceOrZero (~~~x) (~~~y) == unsignedDifferenceOrZero x y) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 307.676709 ms, 
TACEND
SSA/Projects/InstCombine/HackersDelight/ch2_3LogicalArithmeticIneq.lean:462:8: warning: declaration uses 'sorry'
