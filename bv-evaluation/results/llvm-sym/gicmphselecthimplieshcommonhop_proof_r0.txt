⚠ [830/898] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:26:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:33:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:40:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:43:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:54:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:58:8: declaration uses 'sorry'
⚠ [881/898] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [884/898] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:349:4: declaration uses 'sorry'
⚠ [890/898] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:56:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:129:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:164:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:198:6: declaration uses 'sorry'
⚠ [891/898] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.035870 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some (ofBool (2#8 == x✝)) ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 14.304530 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 9.765470 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 223.091989 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 38.256470 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 9.617820 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 19.900080 ms, MSGSTART 
    Unsupported syntax some (ofBool (2#8 == x✝)) ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.const `BitVec.ofBool [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `BEq.beq [Lean.Level.zero])
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 8)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `instBEqOfDecidableEq [Lean.Level.zero])
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                    (Lean.Expr.app
                      (Lean.Expr.const `instDecidableEqBitVec [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 8)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `BitVec.ofNat [])
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 8)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 2)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 2))))))
              (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 8635))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 134.913979 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 719.167727 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 223.741759 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 45.568040 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 13.305639 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 222.801090 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 40.348650 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 13.327709 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 63.411761 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.unop AutoStructs.Unop.neg
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) (AutoStructs.Term.var 1))) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 165.622940 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 422.858130 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 214.351779 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 36.778720 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 13.536490 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 179.182959 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 47.149410 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.899880 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝¹ == x✝)).toNat
     b := ↑(ofBool (2#8 == x✝)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 56.887300 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.binop AutoStructs.Binop.equiv
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) (AutoStructs.Term.var 1))
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 2) (AutoStructs.Term.var 1))) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 152.645279 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 607.552589 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 203.625149 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 31.190070 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 8.345950 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 141.697740 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 30.321849 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 10.309610 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 41.966081 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.unop AutoStructs.Unop.neg
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) (AutoStructs.Term.var 1))) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 122.305049 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 345.090589 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 216.898089 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 45.922870 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 12.755040 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 111.935800 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 35.493559 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 15.855330 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 62.372000 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.unop AutoStructs.Unop.neg
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) (AutoStructs.Term.var 1))) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 165.531529 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 257.769199 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.623600 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some (ofBool (2#8 >ₛ x✝)) ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 8.259620 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 3.852390 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 131.712119 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 38.746270 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.584890 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 12.391700 ms, MSGSTART 
    Unsupported syntax some (ofBool (2#8 >ₛ x✝)) ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.const `BitVec.ofBool [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `BitVec.slt [])
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 8)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 157851)))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `BitVec.ofNat [])
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 8)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                    (Lean.Expr.lit (Lean.Literal.natVal 2)))
                  (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 2)))))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 114.815930 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 444.349147 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 204.035999 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 98.165970 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 13.393710 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 209.233519 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 69.283230 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 16.917819 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 45.672050 ms, MSGSTART 
    tactic 'rfl' failed, the left-hand side
      ¬(((AutoStructs.Term.var 1).evalNat fun n => if n = 1 then 2#8 else if n = 0 then x✝ else BitVec.zero 8) >ₛ
            (AutoStructs.Term.var 0).evalNat fun n => if n = 1 then 2#8 else if n = 0 then x✝ else BitVec.zero 8) =
          true
    is not definitionally equal to the right-hand side
      (2#8 >ₛ x✝) = false
    x✝ : BitVec 8
    c✝¹ : BitVec 1
    heq✝¹ : ofBool (x✝ >ₛ 3#8) = 1#1
    c✝ : BitVec 1
    heq✝ : ofBool (4#8 >ₛ x✝) = 0#1
    ⊢ ¬(((AutoStructs.Term.var 1).evalNat fun n => if n = 1 then 2#8 else if n = 0 then x✝ else BitVec.zero 8) >ₛ
              (AutoStructs.Term.var 0).evalNat fun n => if n = 1 then 2#8 else if n = 0 then x✝ else BitVec.zero 8) =
            true ↔
        (2#8 >ₛ x✝) = false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 172.845019 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 405.890298 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 222.377809 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 120.463559 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 19.637080 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 186.119430 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 142.014489 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.695000 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝¹ >ₛ x✝)).toNat
     b := ↑(ofBool (2#8 >ₛ x✝)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 12.951380 ms, MSGSTART 
    Equality (2#8 >ₛ x✝) = (x✝¹ >ₛ x✝) has a strange type MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 175.268269 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 488.529098 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 150.879930 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 61.346020 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 8.274970 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 128.189059 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 37.108610 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 9.213970 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 25.538000 ms, MSGSTART 
    tactic 'rfl' failed, the left-hand side
      ¬(((AutoStructs.Term.var 1).evalNat fun n => if n = 1 then 2#8 else if n = 0 then x✝ else BitVec.zero 8) >ₛ
            (AutoStructs.Term.var 0).evalNat fun n => if n = 1 then 2#8 else if n = 0 then x✝ else BitVec.zero 8) =
          true
    is not definitionally equal to the right-hand side
      (2#8 >ₛ x✝) = false
    x✝¹ x✝ : BitVec 8
    c✝¹ : BitVec 1
    heq✝¹ : ofBool (x✝ >ₛ 3#8) = 1#1
    c✝ : BitVec 1
    heq✝ : ofBool (4#8 >ₛ x✝) = 0#1
    ⊢ ¬(((AutoStructs.Term.var 1).evalNat fun n => if n = 1 then 2#8 else if n = 0 then x✝ else BitVec.zero 8) >ₛ
              (AutoStructs.Term.var 0).evalNat fun n => if n = 1 then 2#8 else if n = 0 then x✝ else BitVec.zero 8) =
            true ↔
        (2#8 >ₛ x✝) = false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 124.710889 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 360.634639 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 154.628850 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 76.534579 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 7.263900 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 68.242740 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 36.066060 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 8.731450 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 24.558460 ms, MSGSTART 
    tactic 'rfl' failed, the left-hand side
      ¬(((AutoStructs.Term.var 1).evalNat fun n => if n = 1 then x✝¹ else if n = 0 then x✝ else BitVec.zero 8) >ₛ
            (AutoStructs.Term.var 0).evalNat fun n => if n = 1 then x✝¹ else if n = 0 then x✝ else BitVec.zero 8) =
          true
    is not definitionally equal to the right-hand side
      (x✝¹ >ₛ x✝) = false
    x✝¹ x✝ : BitVec 8
    c✝¹ : BitVec 1
    heq✝¹ : ofBool (x✝ >ₛ 3#8) = 0#1
    c✝ : BitVec 1
    heq✝ : ofBool (4#8 >ₛ x✝) = 0#1
    ⊢ ¬(((AutoStructs.Term.var 1).evalNat fun n => if n = 1 then x✝¹ else if n = 0 then x✝ else BitVec.zero 8) >ₛ
              (AutoStructs.Term.var 0).evalNat fun n => if n = 1 then x✝¹ else if n = 0 then x✝ else BitVec.zero 8) =
            true ↔
        (x✝¹ >ₛ x✝) = false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 123.519839 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 214.040129 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.608650 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some (ofBool (128#8 == x✝)) ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 8.254260 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 5.425390 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 124.269499 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 26.586960 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.414260 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 13.410970 ms, MSGSTART 
    Unsupported syntax some (ofBool (128#8 == x✝)) ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.const `BitVec.ofBool [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `BEq.beq [Lean.Level.zero])
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 8)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `instBEqOfDecidableEq [Lean.Level.zero])
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                    (Lean.Expr.app
                      (Lean.Expr.const `instDecidableEqBitVec [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 8)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `BitVec.ofNat [])
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 8)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 128)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 128))))))
              (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 341144))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 112.551020 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 456.758908 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 151.473490 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 24.348849 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 7.762430 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 128.826330 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 32.219000 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 10.241930 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 45.922530 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.unop AutoStructs.Unop.neg
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) (AutoStructs.Term.var 1))) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 125.325339 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 326.785879 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 168.977530 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 24.913110 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 9.614380 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 128.429279 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 41.300820 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.123700 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝² == x✝)).toNat
     b := ↑(ofBool (128#8 == x✝)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 47.453190 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.binop AutoStructs.Binop.equiv
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) (AutoStructs.Term.var 1))
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 2) (AutoStructs.Term.var 1))) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 132.320539 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 363.760519 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 150.140390 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 23.785929 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 7.847340 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 128.334650 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 27.778590 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 9.674760 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 39.548540 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.unop AutoStructs.Unop.neg
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) (AutoStructs.Term.var 1))) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 122.433279 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 323.244119 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 150.587099 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 23.715570 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 7.534800 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 73.188169 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 27.560230 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 8.742430 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 37.400490 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.unop AutoStructs.Unop.neg
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) (AutoStructs.Term.var 1))) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 121.147720 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 200.578299 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 160.651409 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 19.754150 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 7.081620 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 133.845370 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 33.047280 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.707350 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 37.595089 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.unop AutoStructs.Unop.neg
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) (AutoStructs.Term.var 1))) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 101.491080 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 303.316139 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 161.807699 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 19.773860 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 6.967530 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 132.455719 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 33.301230 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.817920 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 37.166480 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.unop AutoStructs.Unop.neg
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) (AutoStructs.Term.var 1))) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 149.635409 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 344.407779 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 183.160199 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 19.839260 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 8.544490 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 66.577839 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 54.145660 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.024220 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝² != x✝)).toNat
     b := ↑(ofBool (x✝ != x✝²)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 13.547900 ms, MSGSTART 
    Equality (x✝ != x✝²) = (x✝² != x✝) has a strange type MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 158.870459 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 113.584960 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 202.014509 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 17.249600 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 7.891100 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 158.658089 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 32.111100 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.790230 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 37.548620 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.unop AutoStructs.Unop.neg
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) (AutoStructs.Term.var 1))) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 93.004139 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 338.763498 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 154.210609 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 18.055710 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 7.957900 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 165.053679 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 32.341020 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.951480 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 38.357220 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.unop AutoStructs.Unop.neg
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) (AutoStructs.Term.var 1))) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 193.253009 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 341.762899 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.650870 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some (ofBool (x✝ == 1#8)) ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 8.039990 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 5.478960 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 127.558629 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 25.912220 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.660690 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 13.669560 ms, MSGSTART 
    Unsupported syntax some (ofBool (x✝ == 1#8)) ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.const `BitVec.ofBool [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `BEq.beq [Lean.Level.zero])
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 8)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `instBEqOfDecidableEq [Lean.Level.zero])
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                    (Lean.Expr.app
                      (Lean.Expr.const `instDecidableEqBitVec [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 8)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))))
                (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 654344)))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `BitVec.ofNat [])
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 8)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                    (Lean.Expr.lit (Lean.Literal.natVal 1)))
                  (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 100.315449 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 406.194479 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 138.170499 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 22.548040 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 7.750990 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 129.431740 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 27.278320 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 9.548330 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 36.491720 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.unop AutoStructs.Unop.neg
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) AutoStructs.Term.one)) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 208.390829 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 303.184188 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 160.413680 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 34.702839 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 10.844060 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 128.336940 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 39.600430 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.943060 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝¹ == x✝)).toNat
     b := ↑(ofBool (x✝ == 1#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 41.202049 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.binop AutoStructs.Binop.equiv
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) AutoStructs.Term.one)
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 1) (AutoStructs.Term.var 0))) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 116.753380 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 342.474299 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 136.616900 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 21.513390 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 7.840070 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 131.263319 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 27.569900 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 9.669050 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 36.581940 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.unop AutoStructs.Unop.neg
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) AutoStructs.Term.one)) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 108.204379 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 305.137149 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 150.539619 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 20.654660 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 8.321280 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 72.407820 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 43.783860 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.561409 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝¹ == x✝)).toNat
     b := ↑(ofBool (x✝ == x✝¹)).toNat MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 39.603370 ms, 
  TACBENCH bv_decide PASS, TIME_ELAPSED 117.410260 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 78.066210 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 158.518110 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 23.790740 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 7.680359 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 74.391080 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 26.995090 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 8.989040 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 37.565670 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.unop AutoStructs.Unop.neg
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) (AutoStructs.Term.var 1))) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 108.408209 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 183.867290 ms, 
TACEND
