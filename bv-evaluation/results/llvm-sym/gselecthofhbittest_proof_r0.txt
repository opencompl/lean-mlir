⚠ [673/898] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:26:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:33:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:40:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:43:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:54:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:58:8: declaration uses 'sorry'
⚠ [884/898] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [887/898] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:349:4: declaration uses 'sorry'
⚠ [893/898] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:56:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:129:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:164:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:198:6: declaration uses 'sorry'
⚠ [894/898] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 232.670490 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 34.495530 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 30.873980 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 250.112088 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 53.003640 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 13.790730 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ d ≤ 4294967295
      0 ≤ b ≤ 1
      0 ≤ b - 4294967296*c ≤ 4294967295
      b - 4294967296*c - d ≥ 1
      2 ≤ a ≤ 4294967295
    where
     a := ↑(↑32).toNat
     b := ↑(ofBool (x✝ &&& 3#32 != 0#32)).toNat
     c := ↑(ofBool (x✝ &&& 3#32 != 0#32)).toNat / 4294967296
     d := ↑(x✝ >>> 1#32 &&& 1#32).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 70.305570 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq ((AutoStructs.Term.var 0).and AutoStructs.Term.one)
            (AutoStructs.Term.var 1)) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 150.241039 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 1107.130837 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 187.233469 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 36.605871 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 19.990430 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 255.627289 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 68.438800 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 45.612960 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 61.710711 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq AutoStructs.Term.one (AutoStructs.Term.var 0)) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 138.119900 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 451.005349 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 205.898850 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 39.067710 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 29.795410 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 222.262779 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 51.440030 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 17.324590 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ c ≤ 4294967295
      0 ≤ a ≤ 1
      0 ≤ a - 4294967296*b ≤ 4294967295
      a - 4294967296*b - c ≥ 1
    where
     a := ↑(ofBool (x✝ &&& 3#32 != 0#32)).toNat
     b := ↑(ofBool (x✝ &&& 3#32 != 0#32)).toNat / 4294967296
     c := ↑(x✝ &&& 1#32).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 68.466229 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq ((AutoStructs.Term.var 0).and AutoStructs.Term.one)
            (AutoStructs.Term.var 1)) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 136.241490 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 1054.603016 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 207.279589 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 31.998970 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 25.935020 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 257.763749 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 44.976450 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 26.727890 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 37.654600 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq AutoStructs.Term.one (AutoStructs.Term.var 0)) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 105.500029 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 399.833259 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 168.519069 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 31.154800 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 28.556380 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 154.791579 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 41.733820 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 13.453100 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ d ≤ 4294967295
      0 ≤ b ≤ 1
      0 ≤ b - 4294967296*c ≤ 4294967295
      b - 4294967296*c - d ≥ 1
      2 ≤ a ≤ 4294967295
    where
     a := ↑(↑32).toNat
     b := ↑(ofBool (x✝ &&& (x✝¹ ||| 2#32) != 0#32)).toNat
     c := ↑(ofBool (x✝ &&& (x✝¹ ||| 2#32) != 0#32)).toNat / 4294967296
     d := ↑(x✝ >>> 1#32 &&& 1#32).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 46.973440 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq ((AutoStructs.Term.var 0).and AutoStructs.Term.one)
            (AutoStructs.Term.var 1)) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 122.076640 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 849.873937 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 209.770499 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 23.235390 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 19.978010 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 149.685639 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 38.307160 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 25.773910 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 34.039590 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq AutoStructs.Term.one (AutoStructs.Term.var 0)) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 102.302360 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 312.985928 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 164.890560 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 50.290439 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 46.670150 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 201.145249 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 40.402310 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 13.321850 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ d ≤ 4294967295
      0 ≤ b ≤ 1
      0 ≤ b - 4294967296*c ≤ 4294967295
      b - 4294967296*c - d ≥ 1
      2 ≤ a ≤ 4294967295
    where
     a := ↑(↑32).toNat
     b := ↑(ofBool (x✝¹ &&& (x✝ ||| 2#32) != 0#32)).toNat
     c := ↑(ofBool (x✝¹ &&& (x✝ ||| 2#32) != 0#32)).toNat / 4294967296
     d := ↑(x✝¹ >>> 1#32 &&& 1#32).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 46.115330 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq ((AutoStructs.Term.var 0).and AutoStructs.Term.one)
            (AutoStructs.Term.var 1)) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 109.365140 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 708.573677 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 153.800549 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 23.191260 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 19.520990 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 146.058070 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 37.838479 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 25.434800 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 37.222290 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq AutoStructs.Term.one (AutoStructs.Term.var 0)) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 101.334640 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 401.116718 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 142.498970 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 25.947100 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 20.054079 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 138.144529 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 37.581890 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 10.135900 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ c ≤ 4294967295
      0 ≤ a ≤ 1
      0 ≤ a - 4294967296*b ≤ 4294967295
      a - 4294967296*b - c ≥ 1
    where
     a := ↑(ofBool (x✝ &&& (x✝¹ ||| 1#32) != 0#32)).toNat
     b := ↑(ofBool (x✝ &&& (x✝¹ ||| 1#32) != 0#32)).toNat / 4294967296
     c := ↑(x✝ &&& 1#32).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 38.277300 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq ((AutoStructs.Term.var 0).and AutoStructs.Term.one)
            (AutoStructs.Term.var 1)) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 109.785709 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 646.102697 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 143.521689 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 21.509850 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 18.384390 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 139.918870 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 37.050510 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 24.378539 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 32.942520 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq AutoStructs.Term.one (AutoStructs.Term.var 0)) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 100.358160 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 293.683539 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 139.649820 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 24.533020 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 19.914610 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 134.389019 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 36.701760 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 9.849860 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ c ≤ 4294967295
      0 ≤ a ≤ 1
      0 ≤ a - 4294967296*b ≤ 4294967295
      a - 4294967296*b - c ≥ 1
    where
     a := ↑(ofBool (x✝¹ &&& (x✝ ||| 1#32) != 0#32)).toNat
     b := ↑(ofBool (x✝¹ &&& (x✝ ||| 1#32) != 0#32)).toNat / 4294967296
     c := ↑(x✝¹ &&& 1#32).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 39.015780 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq ((AutoStructs.Term.var 0).and AutoStructs.Term.one)
            (AutoStructs.Term.var 1)) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 101.523369 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 624.993068 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 142.787090 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 20.802000 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 17.983080 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 135.728959 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 36.529880 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 24.326680 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 33.764770 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq AutoStructs.Term.one (AutoStructs.Term.var 0)) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 99.983979 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 289.272309 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.593280 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some (x✝ &&& 2#32) ⊑ none MSGEND
  TACBENCH bv_ac PASS, TIME_ELAPSED 10.455210 ms, 
  TACBENCH bv_distrib PASS, TIME_ELAPSED 7.319030 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 73.187840 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 10.544799 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.449470 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ a ≤ 1
    where
     a := ↑(↑32).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 12.865580 ms, MSGSTART 
    Unsupported syntax some (x✝ &&& 2#32) ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 32)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `HAnd.hAnd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 32)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                  (Lean.Expr.app
                    (Lean.Expr.const `BitVec [])
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 32)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `instHAndOfAndOp [Lean.Level.zero])
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 32)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                  (Lean.Expr.app
                    (Lean.Expr.const `BitVec.instAndOp [])
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 32)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
              (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 480363)))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.const `BitVec.ofNat [])
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                    (Lean.Expr.lit (Lean.Literal.natVal 32)))
                  (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 2)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 2))))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 32)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))) MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 9.519970 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 88.518240 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 146.935609 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 19.970370 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 16.672910 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 81.520580 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 12.666440 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 8.596139 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ c ≤ 4294967295
      0 ≤ b ≤ 4294967295
      b - c ≥ 1
      2 ≤ a ≤ 4294967295
    where
     a := ↑(↑32).toNat
     b := ↑(x✝ >>> 1#32 &&& 1#32).toNat
     c := ↑(x✝ &&& 2#32).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 45.677670 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq ((AutoStructs.Term.var 0).and (AutoStructs.Term.var 1))
            ((AutoStructs.Term.var 2).and AutoStructs.Term.one)) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 91.245670 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 490.804848 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.784020 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some 1#32 ⊑ none MSGEND
  TACBENCH bv_ac PASS, TIME_ELAPSED 8.481680 ms, 
  TACBENCH bv_distrib PASS, TIME_ELAPSED 3.079920 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 72.065669 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.378490 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.423580 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ a ≤ 1
    where
     a := ↑(↑32).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 11.327050 ms, MSGSTART 
    Unsupported syntax some 1#32 ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 32)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.const `BitVec.ofNat [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 32)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))) MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 9.543150 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 81.303690 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 241.311169 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 14.582920 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 13.915760 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 76.637500 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 11.878150 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 8.806730 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      2 ≤ b ≤ 4294967295
      2 ≤ a ≤ 4294967295
    where
     a := ↑(↑32).toNat
     b := ↑(x✝ >>> 1#32 &&& 1#32).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 34.832230 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq AutoStructs.Term.one
            ((AutoStructs.Term.var 0).and AutoStructs.Term.one)) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 140.112539 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 547.144728 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 163.920169 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 20.626070 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 13.648450 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 85.714940 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 13.027650 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 11.845740 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      3 ≤ a ≤ 4294967295
    where
     a := ↑(↑32).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 37.912779 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq ((AutoStructs.Term.var 0).and AutoStructs.Term.one)
            AutoStructs.Term.one) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 109.086390 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 350.738979 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.673580 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some 1#32 ⊑ none MSGEND
  TACBENCH bv_ac PASS, TIME_ELAPSED 8.605420 ms, 
  TACBENCH bv_distrib PASS, TIME_ELAPSED 3.062860 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 71.912920 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.819950 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 9.380290 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ a ≤ 2
    where
     a := ↑(↑32).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 11.521650 ms, MSGSTART 
    Unsupported syntax some 1#32 ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 32)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.const `BitVec.ofNat [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 32)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))) MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 14.727230 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 83.416959 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 211.796149 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 16.828320 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 13.696470 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 80.006160 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 12.033740 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 11.247620 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      2 ≤ b ≤ 4294967295
      3 ≤ a ≤ 4294967295
    where
     a := ↑(↑32).toNat
     b := ↑(x✝ >>> 2#32 &&& 1#32).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 33.408049 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq AutoStructs.Term.one
            ((AutoStructs.Term.var 0).and AutoStructs.Term.one)) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 157.174210 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 297.113539 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 141.574780 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 17.918520 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 8.081080 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 74.461360 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 11.342109 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 8.864080 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 28.922980 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq ((AutoStructs.Term.var 0).and AutoStructs.Term.one)
            AutoStructs.Term.one) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 103.216550 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 221.104289 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 142.614920 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 12.600999 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 7.817599 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 71.829790 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 10.766450 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 8.518010 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      2 ≤ a ≤ 4294967295
    where
     a := ↑(x✝ &&& 1#32).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 26.561430 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq AutoStructs.Term.one
            ((AutoStructs.Term.var 0).and AutoStructs.Term.one)) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 102.063250 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 268.802439 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 162.550970 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 20.647060 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 14.078179 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 80.667970 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 12.145570 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 11.297230 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      3 ≤ a ≤ 4294967295
    where
     a := ↑(↑32).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 33.308030 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq ((AutoStructs.Term.var 0).and AutoStructs.Term.one)
            AutoStructs.Term.one) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 107.424669 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 248.092299 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.746040 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some 1#32 ⊑ none MSGEND
  TACBENCH bv_ac PASS, TIME_ELAPSED 8.506210 ms, 
  TACBENCH bv_distrib PASS, TIME_ELAPSED 2.981480 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 69.888490 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.077600 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 9.030730 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ a ≤ 2
    where
     a := ↑(↑32).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 10.889980 ms, MSGSTART 
    Unsupported syntax some 1#32 ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 32)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.const `BitVec.ofNat [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 32)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))) MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 13.756140 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 80.063360 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 159.583200 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 15.594160 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 13.454509 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 79.029250 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 11.974630 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 11.198960 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      2 ≤ b ≤ 4294967295
      3 ≤ a ≤ 4294967295
    where
     a := ↑(↑32).toNat
     b := ↑(x✝ >>> 2#32 &&& 1#32).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 33.293310 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq AutoStructs.Term.one
            ((AutoStructs.Term.var 0).and AutoStructs.Term.one)) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 107.094239 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 249.384749 ms, 
TACEND
