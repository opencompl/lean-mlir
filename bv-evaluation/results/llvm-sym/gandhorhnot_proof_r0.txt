⚠ [673/898] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:26:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:33:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:40:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:43:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:54:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:58:8: declaration uses 'sorry'
⚠ [884/898] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [887/898] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:349:4: declaration uses 'sorry'
⚠ [893/898] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:56:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:129:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:164:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:198:6: declaration uses 'sorry'
⚠ [894/898] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 165.303229 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 44.723550 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 45.573650 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 227.114579 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 23.012630 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.004720 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 4294967295
      0 ≤ a ≤ 4294967295
      a - b ≥ 1
    where
     a := ↑(x✝ ^^^ x✝¹).toNat
     b := ↑((x✝ ||| x✝¹) &&& (x✝ &&& x✝¹ ^^^ -1#32)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 75.984959 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq
            (((AutoStructs.Term.var 0).or (AutoStructs.Term.var 1)).and
              (((AutoStructs.Term.var 0).and (AutoStructs.Term.var 1)).xor (AutoStructs.Term.var 2)))
            ((AutoStructs.Term.var 0).xor (AutoStructs.Term.var 1))) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 92.864739 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 768.439716 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 168.444290 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 48.191410 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 47.008370 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 218.943109 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 28.014571 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.530660 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 4294967295
      0 ≤ a ≤ 4294967295
      a - b ≥ 1
    where
     a := ↑(x✝ ^^^ x✝¹).toNat
     b := ↑((x✝ &&& x✝¹ ^^^ -1#32) &&& (x✝ ||| x✝¹)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 86.157869 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq
            ((((AutoStructs.Term.var 0).and (AutoStructs.Term.var 1)).xor (AutoStructs.Term.var 2)).and
              ((AutoStructs.Term.var 0).or (AutoStructs.Term.var 1)))
            ((AutoStructs.Term.var 0).xor (AutoStructs.Term.var 1))) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 94.162591 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 741.045410 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 186.258530 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 47.255590 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 46.855380 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 210.232299 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 17.040050 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.484180 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 4294967295
      0 ≤ a ≤ 4294967295
      a - b ≥ 1
    where
     a := ↑(x✝ ^^^ x✝¹).toNat
     b := ↑((x✝ ||| x✝¹) &&& (x✝¹ &&& x✝ ^^^ -1#32)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 73.435389 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq
            (((AutoStructs.Term.var 0).or (AutoStructs.Term.var 1)).and
              (((AutoStructs.Term.var 1).and (AutoStructs.Term.var 0)).xor (AutoStructs.Term.var 2)))
            ((AutoStructs.Term.var 0).xor (AutoStructs.Term.var 1))) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 91.873430 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 749.331357 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 130.201260 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 27.283710 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 31.466970 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 134.008590 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 17.209390 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.514340 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 4294967295
      0 ≤ a ≤ 4294967295
      a - b ≥ 1
    where
     a := ↑(x✝¹ ^^^ x✝).toNat
     b := ↑((x✝ &&& x✝¹ ^^^ -1#32) &&& (x✝¹ ||| x✝)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 52.169949 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq
            ((((AutoStructs.Term.var 0).and (AutoStructs.Term.var 1)).xor (AutoStructs.Term.var 2)).and
              ((AutoStructs.Term.var 1).or (AutoStructs.Term.var 0)))
            ((AutoStructs.Term.var 1).xor (AutoStructs.Term.var 0))) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 77.984750 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 555.381968 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 147.821980 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 28.469740 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 27.032049 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 127.666600 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 16.581150 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.314080 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 4294967295
      0 ≤ a ≤ 4294967295
      a - b ≥ 1
    where
     a := ↑(x✝ ^^^ x✝¹ ^^^ -1#32).toNat
     b := ↑(x✝ &&& x✝¹ ||| (x✝ ||| x✝¹) ^^^ -1#32).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 52.501000 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq
            (((AutoStructs.Term.var 0).and (AutoStructs.Term.var 1)).or
              (((AutoStructs.Term.var 0).or (AutoStructs.Term.var 1)).xor (AutoStructs.Term.var 2)))
            (((AutoStructs.Term.var 0).xor (AutoStructs.Term.var 1)).xor (AutoStructs.Term.var 2))) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 79.547720 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 681.702267 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 176.642750 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 43.792250 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 44.727219 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 208.194980 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 16.165820 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.245270 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 4294967295
      0 ≤ a ≤ 4294967295
      a - b ≥ 1
    where
     a := ↑(x✝ ^^^ x✝¹ ^^^ -1#32).toNat
     b := ↑(x✝ &&& x✝¹ ||| (x✝¹ ||| x✝) ^^^ -1#32).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 57.294669 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq
            (((AutoStructs.Term.var 0).and (AutoStructs.Term.var 1)).or
              (((AutoStructs.Term.var 1).or (AutoStructs.Term.var 0)).xor (AutoStructs.Term.var 2)))
            (((AutoStructs.Term.var 0).xor (AutoStructs.Term.var 1)).xor (AutoStructs.Term.var 2))) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 81.289140 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 693.803677 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 192.701069 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 43.918800 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 41.438830 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 207.715949 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 27.006870 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.173700 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 4294967295
      0 ≤ a ≤ 4294967295
      a - b ≥ 1
    where
     a := ↑(x✝ ^^^ x✝¹ ^^^ -1#32).toNat
     b := ↑((x✝ ||| x✝¹) ^^^ -1#32 ||| x✝ &&& x✝¹).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 81.633550 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq
            ((((AutoStructs.Term.var 0).or (AutoStructs.Term.var 1)).xor (AutoStructs.Term.var 2)).or
              ((AutoStructs.Term.var 0).and (AutoStructs.Term.var 1)))
            (((AutoStructs.Term.var 0).xor (AutoStructs.Term.var 1)).xor (AutoStructs.Term.var 2))) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 91.425699 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 613.240478 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 136.673310 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 25.224080 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 25.281039 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 120.694330 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 15.491100 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.163420 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 4294967295
      0 ≤ a ≤ 4294967295
      a - b ≥ 1
    where
     a := ↑(x✝¹ ^^^ x✝ ^^^ -1#32).toNat
     b := ↑((x✝ ||| x✝¹) ^^^ -1#32 ||| x✝¹ &&& x✝).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 47.443590 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq
            ((((AutoStructs.Term.var 0).or (AutoStructs.Term.var 1)).xor (AutoStructs.Term.var 2)).or
              ((AutoStructs.Term.var 1).and (AutoStructs.Term.var 0)))
            (((AutoStructs.Term.var 1).xor (AutoStructs.Term.var 0)).xor (AutoStructs.Term.var 2))) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 76.093919 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 481.399218 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 115.827100 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 24.620470 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 19.054759 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 71.355850 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 13.159160 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.291740 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 4294967295
      0 ≤ a ≤ 4294967295
      a - b ≥ 1
    where
     a := ↑(x✝ ^^^ x✝¹).toNat
     b := ↑(x✝ &&& x✝¹ ^^^ (x✝ ||| x✝¹)).toNat MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 34.510870 ms, 
  TACBENCH bv_decide PASS, TIME_ELAPSED 73.307290 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 361.737808 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 156.116419 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 34.330950 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 30.824740 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 126.276830 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 21.322370 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.672920 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 4294967295
      0 ≤ a ≤ 4294967295
      a - b ≥ 1
    where
     a := ↑(x✝ ^^^ x✝¹).toNat
     b := ↑(x✝ &&& x✝¹ ^^^ (x✝¹ ||| x✝)).toNat MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 57.341709 ms, 
  TACBENCH bv_decide PASS, TIME_ELAPSED 83.729470 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 293.128729 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 113.037099 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 20.892440 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 18.473300 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 71.545030 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 13.460590 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.383090 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 4294967295
      0 ≤ a ≤ 4294967295
      a - b ≥ 1
    where
     a := ↑(x✝ ^^^ x✝¹).toNat
     b := ↑((x✝ ||| x✝¹) ^^^ x✝ &&& x✝¹).toNat MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 39.621300 ms, 
  TACBENCH bv_decide PASS, TIME_ELAPSED 74.027330 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 202.629869 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 114.123400 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 21.250600 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 18.764460 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 73.087659 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 13.859650 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.596380 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 4294967295
      0 ≤ a ≤ 4294967295
      a - b ≥ 1
    where
     a := ↑(x✝¹ ^^^ x✝).toNat
     b := ↑((x✝ ||| x✝¹) ^^^ x✝¹ &&& x✝).toNat MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 37.985390 ms, 
  TACBENCH bv_decide PASS, TIME_ELAPSED 72.349400 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 193.215659 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 157.679300 ms, 
  TACBENCH bv_ac PASS, TIME_ELAPSED 23.746329 ms, 
  TACBENCH bv_distrib PASS, TIME_ELAPSED 27.313290 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 118.150910 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 15.638250 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.256960 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 18446744073709551615
      0 ≤ a ≤ 18446744073709551615
      a - b ≥ 1
    where
     a := ↑((x✝¹ ||| x✝ ^^^ -1#64) &&& (x✝² ||| x✝¹ ^^^ -1#64)).toNat
     b := ↑((x✝ ^^^ -1#64 ||| x✝¹) &&& (x✝¹ ^^^ -1#64 ||| x✝²)).toNat MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 59.787640 ms, 
  TACBENCH bv_decide PASS, TIME_ELAPSED 77.846799 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 250.226599 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.608080 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some ((x✝ &&& x✝¹) * ((x✝ ||| x✝¹) ^^^ -1#32) * (x✝ &&& x✝¹ ||| (x✝ ||| x✝¹) ^^^ -1#32)) ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 24.783870 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 26.079780 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 179.087349 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 15.148680 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.778730 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 21.767460 ms, MSGSTART 
    Unsupported syntax some
        ((x✝ &&& x✝¹) * ((x✝ ||| x✝¹) ^^^ 4294967295#32) * (x✝ &&& x✝¹ ||| (x✝ ||| x✝¹) ^^^ 4294967295#32)) ⊑
      none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 32)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `HMul.hMul [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 32)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                  (Lean.Expr.app
                    (Lean.Expr.const `BitVec [])
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 32)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `instHMul [Lean.Level.zero])
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 32)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                  (Lean.Expr.app
                    (Lean.Expr.const `BitVec.instMul [])
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 32)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `HMul.hMul [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `instHMul [Lean.Level.zero])
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.instMul [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.const `HAnd.hAnd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                              (Lean.Expr.app
                                (Lean.Expr.const `BitVec [])
                                (Lean.Expr.app
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                      (Lean.Expr.const `Nat []))
                                    (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                  (Lean.Expr.app
                                    (Lean.Expr.const `instOfNatNat [])
                                    (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `instHAndOfAndOp [Lean.Level.zero])
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec.instAndOp [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app
                                (Lean.Expr.const `instOfNatNat [])
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
                      (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 452928)))
                    (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 452927))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `HXor.hXor [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `instHXorOfXor [Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec.instXor [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.const `HOr.hOr [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                                (Lean.Expr.app
                                  (Lean.Expr.const `BitVec [])
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.app
                                        (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                        (Lean.Expr.const `Nat []))
                                      (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                    (Lean.Expr.app
                                      (Lean.Expr.const `instOfNatNat [])
                                      (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                              (Lean.Expr.app
                                (Lean.Expr.const `BitVec [])
                                (Lean.Expr.app
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                      (Lean.Expr.const `Nat []))
                                    (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                  (Lean.Expr.app
                                    (Lean.Expr.const `instOfNatNat [])
                                    (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.const `instHOrOfOrOp [Lean.Level.zero])
                              (Lean.Expr.app
                                (Lean.Expr.const `BitVec [])
                                (Lean.Expr.app
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                      (Lean.Expr.const `Nat []))
                                    (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                  (Lean.Expr.app
                                    (Lean.Expr.const `instOfNatNat [])
                                    (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec.instOrOp [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
                        (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 452928)))
                      (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 452927))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec.ofNat [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 32)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 4294967295)))
                      (Lean.Expr.app
                        (Lean.Expr.const `instOfNatNat [])
                        (Lean.Expr.lit (Lean.Literal.natVal 4294967295))))))))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `HOr.hOr [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 32)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `instHOrOfOrOp [Lean.Level.zero])
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec.instOrOp [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 32)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `HAnd.hAnd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `instHAndOfAndOp [Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec.instAndOp [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
                    (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 452928)))
                  (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 452927))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `HXor.hXor [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `instHXorOfXor [Lean.Level.zero])
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.instXor [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.const `HOr.hOr [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                              (Lean.Expr.app
                                (Lean.Expr.const `BitVec [])
                                (Lean.Expr.app
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                      (Lean.Expr.const `Nat []))
                                    (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                  (Lean.Expr.app
                                    (Lean.Expr.const `instOfNatNat [])
                                    (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `instHOrOfOrOp [Lean.Level.zero])
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec.instOrOp [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app
                                (Lean.Expr.const `instOfNatNat [])
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
                      (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 452928)))
                    (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 452927))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `BitVec.ofNat [])
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 32)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 4294967295)))
                    (Lean.Expr.app
                      (Lean.Expr.const `instOfNatNat [])
                      (Lean.Expr.lit (Lean.Literal.natVal 4294967295))))))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 32)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))) MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 80.313080 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 392.307708 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 130.780559 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 19.582310 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 20.489080 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 113.851639 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 14.343340 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 8.576630 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ a ≤ 14
    where
     a := ↑(x✝ &&& x✝¹ &&& x✝² ^^^ -1#4 ||| x✝).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 50.488810 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq
            (((((AutoStructs.Term.var 0).and (AutoStructs.Term.var 1)).and (AutoStructs.Term.var 2)).xor
                  (AutoStructs.Term.var 3)).or
              (AutoStructs.Term.var 0))
            (AutoStructs.Term.var 3)) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 223.210879 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 655.582227 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 128.874980 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 19.990300 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 20.717719 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 112.338070 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 14.165370 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 8.363970 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ a ≤ 14
    where
     a := ↑(x✝ &&& x✝¹ &&& x✝² ^^^ -1#4 ||| x✝¹).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 49.845210 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq
            (((((AutoStructs.Term.var 0).and (AutoStructs.Term.var 1)).and (AutoStructs.Term.var 2)).xor
                  (AutoStructs.Term.var 3)).or
              (AutoStructs.Term.var 1))
            (AutoStructs.Term.var 3)) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 72.060629 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 602.785778 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 141.259030 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 24.404329 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 26.781010 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 122.268950 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 15.558130 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 9.036600 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ a ≤ 14
    where
     a := ↑(x✝ * x✝ &&& (x✝¹ &&& x✝²) &&& x✝³ ^^^ -1#4 ||| x✝¹).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 66.306729 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq
            (((((AutoStructs.Term.var 0).and ((AutoStructs.Term.var 1).and (AutoStructs.Term.var 2))).and
                      (AutoStructs.Term.var 3)).xor
                  (AutoStructs.Term.var 4)).or
              (AutoStructs.Term.var 1))
            (AutoStructs.Term.var 4)) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 75.759390 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 596.910738 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 142.792079 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 19.830300 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 20.841710 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 113.390549 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 14.494970 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.280590 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      1 ≤ a ≤ 15
    where
     a := ↑(((x✝ ||| x✝¹ ||| x✝²) ^^^ -1#4) &&& x✝¹).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 49.829130 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq
            (((((AutoStructs.Term.var 0).or (AutoStructs.Term.var 1)).or (AutoStructs.Term.var 2)).xor
                  (AutoStructs.Term.var 3)).and
              (AutoStructs.Term.var 1))
            AutoStructs.Term.zero) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 72.836660 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 476.218018 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 194.763339 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 24.191280 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 27.100000 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 124.383399 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 16.076350 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.837010 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      1 ≤ a ≤ 15
    where
     a := ↑(((x✝ * x✝ ||| (x✝¹ ||| x✝²) ||| x✝³) ^^^ -1#4) &&& x✝¹).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 64.657930 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq
            (((((AutoStructs.Term.var 0).or ((AutoStructs.Term.var 1).or (AutoStructs.Term.var 2))).or
                      (AutoStructs.Term.var 3)).xor
                  (AutoStructs.Term.var 4)).and
              (AutoStructs.Term.var 1))
            AutoStructs.Term.zero) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 75.797209 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 558.147768 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 155.951089 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 19.701750 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 18.886660 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 72.839670 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 13.511140 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.392800 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 15
      0 ≤ a ≤ 15
      a - b ≥ 1
    where
     a := ↑(x✝¹ ^^^ x✝² ||| x✝).toNat
     b := ↑(x✝ ^^^ x✝¹ ^^^ x✝² ||| x✝).toNat MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 40.612230 ms, 
  TACBENCH bv_decide PASS, TIME_ELAPSED 71.252599 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 202.888349 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 228.872209 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 18.938550 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 15.710170 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 66.723420 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 12.889770 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.203370 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 15
      0 ≤ a ≤ 15
      a - b ≥ 1
    where
     a := ↑(x✝ ^^^ x✝² ||| x✝¹).toNat
     b := ↑(x✝ ^^^ x✝¹ ^^^ x✝² ||| x✝¹).toNat MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 39.917179 ms, 
  TACBENCH bv_decide PASS, TIME_ELAPSED 70.333040 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 202.119969 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 148.106589 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 18.767970 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 16.416800 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 83.870340 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 13.527560 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.468290 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 15
      0 ≤ a ≤ 15
      a - b ≥ 1
    where
     a := ↑(x✝² ^^^ x✝ * x✝ ^^^ x✝³).toNat
     b := ↑(x✝ * x✝ ^^^ (x✝¹ ^^^ x✝²) ^^^ x✝³ ^^^ x✝¹).toNat MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 49.591240 ms, 
  TACBENCH bv_decide PASS, TIME_ELAPSED 73.022859 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 290.509789 ms, 
TACEND
