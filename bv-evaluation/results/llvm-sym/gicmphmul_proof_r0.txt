⚠ [673/898] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:26:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:33:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:40:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:43:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:54:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:58:8: declaration uses 'sorry'
⚠ [884/898] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [887/898] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:349:4: declaration uses 'sorry'
⚠ [893/898] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:56:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:129:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:164:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:198:6: declaration uses 'sorry'
⚠ [894/898] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 205.666970 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 25.809430 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 48.303249 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 182.890219 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 47.552640 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.068980 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ == 0#5)).toNat
     b := ↑(ofBool (x✝ * x✝ == 0#5)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 77.872580 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.binop AutoStructs.Binop.equiv
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) AutoStructs.Term.zero)
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 1) AutoStructs.Term.zero)) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 137.637369 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 584.008618 ms, 
TACEND
/home/luisacicolini/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:11:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 198.061380 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 51.175120 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 28.746520 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 209.480838 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 114.206079 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.790381 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ != 0#5)).toNat
     b := ↑(ofBool (x✝ * x✝ >ₛ 0#5)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 21.910050 ms, MSGSTART 
    Equality (x✝ * x✝ >ₛ 0#5) = (x✝ != 0#5) has a strange type MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 174.370359 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 654.432679 ms, 
TACEND
/home/luisacicolini/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:22:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 241.591999 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 85.797380 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 47.825290 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 177.618309 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 154.936861 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.750920 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (3#8 >ₛ x✝)).toNat
     b := ↑(ofBool (21#8 >ₛ x✝ * 7#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 23.120039 ms, MSGSTART 
    Equality (21#8 >ₛ x✝ * 7#8) = (3#8 >ₛ x✝) has a strange type MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 197.455340 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 785.084036 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 222.874430 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 300.084069 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 150.554109 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 275.911349 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 170.481820 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.577170 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ >ₛ 253#8)).toNat
     b := ↑(ofBool (21#8 >ₛ x✝ * 249#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 14.883700 ms, MSGSTART 
    Equality (21#8 >ₛ x✝ * 249#8) = (x✝ >ₛ 253#8) has a strange type MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 188.850720 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 967.264956 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 159.116160 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 81.290970 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 41.673450 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 161.556179 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 120.408300 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.348839 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (5#8 >ₛ x✝)).toNat
     b := ↑(ofBool (21#8 >ₛ x✝ * 5#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 15.920730 ms, MSGSTART 
    Equality (21#8 >ₛ x✝ * 5#8) = (5#8 >ₛ x✝) has a strange type MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 142.331630 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 588.172757 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 137.677030 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 33.180099 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 20.473680 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 178.365040 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 30.968169 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 11.530250 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (3#8 >ᵤ x✝)).toNat
     b := ↑(ofBool (21#8 >ᵤ x✝ * 7#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 13.976550 ms, MSGSTART 
    Equality (21#8 >ᵤ x✝ * 7#8) = (3#8 >ᵤ x✝) has a strange type MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 110.246370 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 382.044238 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 169.566449 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 40.768510 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 24.427740 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 153.843679 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 30.583670 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 17.564970 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (3#8 >ᵤ x✝)).toNat
     b := ↑(ofBool (21#8 >ᵤ x✝ * 7#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 24.321960 ms, MSGSTART 
    Equality (21#8 >ᵤ x✝ * 7#8) = (3#8 >ᵤ x✝) has a strange type MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 180.291909 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 426.677828 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 124.352790 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 23.182000 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 14.627450 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 151.965789 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 29.767420 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 11.004810 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (5#8 >ᵤ x✝)).toNat
     b := ↑(ofBool (21#8 >ᵤ x✝ * 5#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 13.770470 ms, MSGSTART 
    Equality (21#8 >ᵤ x✝ * 5#8) = (5#8 >ᵤ x✝) has a strange type MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 107.682189 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 363.348339 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 157.393250 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 28.795309 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 17.844090 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 159.491680 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 30.681620 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 13.866980 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (5#8 >ᵤ x✝)).toNat
     b := ↑(ofBool (21#8 >ᵤ x✝ * 5#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 13.715929 ms, MSGSTART 
    Equality (21#8 >ᵤ x✝ * 5#8) = (5#8 >ᵤ x✝) has a strange type MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 139.774170 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 413.554478 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 154.636279 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 72.510820 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 36.899000 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 169.515189 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 112.788480 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.992220 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ >ₛ 3#8)).toNat
     b := ↑(ofBool (x✝ * 7#8 >ₛ 21#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 13.465120 ms, MSGSTART 
    Equality (x✝ * 7#8 >ₛ 21#8) = (x✝ >ₛ 3#8) has a strange type MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 134.558319 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 545.941108 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 184.092939 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 141.140990 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 72.492729 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 147.898459 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 113.828289 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.048160 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (253#8 >ₛ x✝)).toNat
     b := ↑(ofBool (x✝ * 249#8 >ₛ 21#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 13.499910 ms, MSGSTART 
    Equality (x✝ * 249#8 >ₛ 21#8) = (253#8 >ₛ x✝) has a strange type MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 159.993520 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 685.423127 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 152.029149 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 68.419010 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 36.070450 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 145.009619 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 112.930900 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.982010 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ >ₛ 4#8)).toNat
     b := ↑(ofBool (x✝ * 5#8 >ₛ 21#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 13.441340 ms, MSGSTART 
    Equality (x✝ * 5#8 >ₛ 21#8) = (x✝ >ₛ 4#8) has a strange type MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 133.464009 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 547.886418 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 126.250630 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 20.560600 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 13.305039 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 148.540560 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 30.233300 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 11.259500 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ >ᵤ 3#8)).toNat
     b := ↑(ofBool (x✝ * 7#8 >ᵤ 21#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 14.004980 ms, MSGSTART 
    Equality (x✝ * 7#8 >ᵤ 21#8) = (x✝ >ᵤ 3#8) has a strange type MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 158.243519 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 462.233748 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 241.868639 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 21.420710 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 13.326000 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 147.349699 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 29.497670 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 13.057140 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ >ᵤ 3#8)).toNat
     b := ↑(ofBool (x✝ * 7#8 >ᵤ 21#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 13.581840 ms, MSGSTART 
    Equality (x✝ * 7#8 >ᵤ 21#8) = (x✝ >ᵤ 3#8) has a strange type MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 140.324109 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 392.696838 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 124.730630 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 20.344550 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 13.266050 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 146.909989 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 29.672120 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 11.024300 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ >ᵤ 4#8)).toNat
     b := ↑(ofBool (x✝ * 5#8 >ᵤ 21#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 13.558500 ms, MSGSTART 
    Equality (x✝ * 5#8 >ᵤ 21#8) = (x✝ >ᵤ 4#8) has a strange type MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 106.587879 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 513.344818 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 156.606459 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 20.512750 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 13.358790 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 147.168360 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 29.712599 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 13.067090 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ >ᵤ 4#8)).toNat
     b := ↑(ofBool (x✝ * 5#8 >ᵤ 21#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 13.451110 ms, MSGSTART 
    Equality (x✝ * 5#8 >ᵤ 21#8) = (x✝ >ᵤ 4#8) has a strange type MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 197.132530 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 396.759218 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 185.181739 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 22.687220 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 36.909270 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 150.429709 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 42.256760 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.311000 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ == 252#8)).toNat
     b := ↑(ofBool (x✝ * 251#8 == 20#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 86.503920 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.binop AutoStructs.Binop.equiv
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) (AutoStructs.Term.var 1))
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 2) (AutoStructs.Term.var 3))) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 131.512329 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 567.036698 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 162.798209 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 22.637380 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 35.349680 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 146.463670 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 28.960810 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 8.535979 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 85.196480 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.unop AutoStructs.Unop.neg
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) (AutoStructs.Term.var 1))) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 119.381490 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 451.268318 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 231.341719 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 24.132070 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 35.715229 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 152.853340 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 34.371620 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.740059 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 64.769450 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.unop AutoStructs.Unop.neg
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) (AutoStructs.Term.var 1))) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 118.857110 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 451.344608 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 130.914439 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 25.205060 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 16.631620 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 151.841749 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 53.870800 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 11.468940 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ != 26#8)).toNat
     b := ↑(ofBool (x✝ * 5#8 != 130#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 15.049660 ms, MSGSTART 
    Equality (x✝ * 5#8 != 130#8) = (x✝ != 26#8) has a strange type MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 111.784820 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 491.665147 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 149.765449 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 22.738170 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 35.203410 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 148.130139 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 29.473790 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 14.240540 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 85.177439 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.unop AutoStructs.Unop.neg
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) (AutoStructs.Term.var 1))) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 203.178520 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 482.706258 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 180.386910 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 23.829160 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 34.950189 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 152.399170 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 34.141730 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 12.245310 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 63.752939 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.unop AutoStructs.Unop.neg
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) (AutoStructs.Term.var 1))) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 101.939530 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 533.956638 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 226.974929 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 32.465020 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 12.404110 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 145.676549 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 36.059170 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.404110 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 33.128270 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom (AutoStructs.Relation.signed AutoStructs.RelationOrdering.lt)
            (AutoStructs.Term.var 0) (AutoStructs.Term.var 1)) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 272.775509 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 393.691848 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 115.527900 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 21.848390 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 15.813500 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 158.559309 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 35.528120 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.067370 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ == 0#8)).toNat
     b := ↑(ofBool (0#8 ≥ᵤ x✝ * -1#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 16.285950 ms, MSGSTART 
    Equality (0#8 ≥ᵤ x✝ * 255#8) = (x✝ == 0#8) has a strange type MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 95.440240 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 484.925258 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 33.987279 ms, 
  TACBENCH bv_ac PASS, TIME_ELAPSED 11.519090 ms, 
  TACBENCH bv_distrib PASS, TIME_ELAPSED 4.460600 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 136.221640 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 35.754440 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 8.114490 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 14.460920 ms, MSGSTART 
    no goals to be solved MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 18.675759 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 7.163641 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 143.166830 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 21.603469 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 36.482680 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 148.877660 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 41.372529 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.958111 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ == 4#8)).toNat
     b := ↑(ofBool (x✝ * 5#8 == 20#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 84.407449 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.binop AutoStructs.Binop.equiv
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) (AutoStructs.Term.var 1))
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 2) (AutoStructs.Term.var 3))) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 90.670550 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 473.564998 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 112.241960 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 25.170890 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 16.743770 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 151.624359 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 53.280420 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.986860 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ != 6#8)).toNat
     b := ↑(ofBool (x✝ * 5#8 != 30#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 14.911770 ms, MSGSTART 
    Equality (x✝ * 5#8 != 30#8) = (x✝ != 6#8) has a strange type MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 92.570409 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 474.707378 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 506.992168 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 32.535510 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 55.529560 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 159.068149 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 42.157760 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.022600 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ == x✝¹)).toNat
     b := ↑(ofBool (x✝ * 5#32 == x✝¹ * 5#32)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 107.322749 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.binop AutoStructs.Binop.equiv
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) (AutoStructs.Term.var 1))
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 2) (AutoStructs.Term.var 3))) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 359.264088 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 926.533676 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 985.466366 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 24.027130 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 56.796390 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 163.088169 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 42.631630 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.309500 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ == x✝¹)).toNat
     b := ↑(ofBool (x✝ * 6#32 == x✝¹ * 6#32)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 110.453309 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.binop AutoStructs.Binop.equiv
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) (AutoStructs.Term.var 1))
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 2) (AutoStructs.Term.var 3))) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 710.307057 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 1343.988295 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 1034.269936 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 24.391450 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 56.769379 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 162.729490 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 43.054890 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 18.170549 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ == x✝¹)).toNat
     b := ↑(ofBool (x✝ * 22#32 == x✝¹ * 22#32)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 114.278070 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.binop AutoStructs.Binop.equiv
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) (AutoStructs.Term.var 1))
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 2) (AutoStructs.Term.var 3))) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 832.944767 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 1412.643785 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 934.757096 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 31.465870 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 64.395910 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 171.634119 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 46.032660 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 12.245030 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool ((x✝ ^^^ x✝¹) &&& 1073741823#32 == 0#32)).toNat
     b := ↑(ofBool (x✝ * 44#32 == x✝¹ * 44#32)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 155.708149 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.binop AutoStructs.Binop.equiv
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) (AutoStructs.Term.var 1))
            (AutoStructs.Formula.atom AutoStructs.Relation.eq
              (((AutoStructs.Term.var 2).xor (AutoStructs.Term.var 3)).and (AutoStructs.Term.var 4))
              AutoStructs.Term.zero)) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 810.859687 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 1384.225674 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 1668.517253 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 33.832090 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 66.109950 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 174.289449 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 47.144330 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 14.770470 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool ((x✝ ^^^ x✝¹) &&& 2147483647#32 == 0#32)).toNat
     b := ↑(ofBool (x✝ * 54#32 == x✝¹ * 54#32)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 158.537669 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.binop AutoStructs.Binop.equiv
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) (AutoStructs.Term.var 1))
            (AutoStructs.Formula.atom AutoStructs.Relation.eq
              (((AutoStructs.Term.var 2).xor (AutoStructs.Term.var 3)).and (AutoStructs.Term.var 4))
              AutoStructs.Term.zero)) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 1716.554623 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 2102.306981 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 350.894039 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 34.676300 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 26.441550 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 172.409620 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 57.954299 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.031980 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool ((x✝ ^^^ x✝¹) &&& 1073741823#32 != 0#32)).toNat
     b := ↑(ofBool (x✝ * 12#32 != x✝¹ * 12#32)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 17.691470 ms, MSGSTART 
    Equality (x✝ * 12#32 != x✝¹ * 12#32) = ((x✝ ^^^ x✝¹) &&& 1073741823#32 != 0#32) has a strange type MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 427.188219 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 769.276486 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 118.639769 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 26.688540 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 18.143970 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 148.007110 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 19.246699 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.533350 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 28.712160 ms, MSGSTART 
    tactic 'rfl' failed, the left-hand side
      ¬(((AutoStructs.Term.var 1).evalNat fun n =>
              if n = 1 then (x✝ &&& 1#32) * setWidth 32 x✝¹ else if n = 0 then 255#32 else BitVec.zero 32) >ᵤ
            (AutoStructs.Term.var 0).evalNat fun n =>
              if n = 1 then (x✝ &&& 1#32) * setWidth 32 x✝¹ else if n = 0 then 255#32 else BitVec.zero 32) =
          true
    is not definitionally equal to the right-hand side
      ((x✝ &&& 1#32) * setWidth 32 x✝¹ >ᵤ 255#32) = false
    x✝¹ : BitVec 8
    x✝ : BitVec 32
    ⊢ ¬(((AutoStructs.Term.var 1).evalNat fun n =>
                if n = 1 then (x✝ &&& 1#32) * setWidth 32 x✝¹ else if n = 0 then 255#32 else BitVec.zero 32) >ᵤ
              (AutoStructs.Term.var 0).evalNat fun n =>
                if n = 1 then (x✝ &&& 1#32) * setWidth 32 x✝¹ else if n = 0 then 255#32 else BitVec.zero 32) =
            true ↔
        ((x✝ &&& 1#32) * setWidth 32 x✝¹ >ᵤ 255#32) = false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 96.033210 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 358.566428 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 117.072379 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 28.625150 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 18.792250 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 154.767529 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 19.135760 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.463500 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 27.458160 ms, MSGSTART 
    tactic 'rfl' failed, the left-hand side
      ¬(((AutoStructs.Term.var 1).evalNat fun n =>
              if n = 1 then (x✝ &&& 255#32) * (x✝¹ &&& 1#32) else if n = 0 then 255#32 else BitVec.zero 32) >ᵤ
            (AutoStructs.Term.var 0).evalNat fun n =>
              if n = 1 then (x✝ &&& 255#32) * (x✝¹ &&& 1#32) else if n = 0 then 255#32 else BitVec.zero 32) =
          true
    is not definitionally equal to the right-hand side
      ((x✝ &&& 255#32) * (x✝¹ &&& 1#32) >ᵤ 255#32) = false
    x✝¹ x✝ : BitVec 32
    ⊢ ¬(((AutoStructs.Term.var 1).evalNat fun n =>
                if n = 1 then (x✝ &&& 255#32) * (x✝¹ &&& 1#32) else if n = 0 then 255#32 else BitVec.zero 32) >ᵤ
              (AutoStructs.Term.var 0).evalNat fun n =>
                if n = 1 then (x✝ &&& 255#32) * (x✝¹ &&& 1#32) else if n = 0 then 255#32 else BitVec.zero 32) =
            true ↔
        ((x✝ &&& 255#32) * (x✝¹ &&& 1#32) >ᵤ 255#32) = false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 97.104150 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 366.537168 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 146.560080 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 28.420740 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 17.157430 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 160.492379 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 19.157760 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.657490 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 33.831500 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom (AutoStructs.Relation.unsigned AutoStructs.RelationOrdering.lt)
            (AutoStructs.Term.var 0) (AutoStructs.Term.var 1)) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 94.873899 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 372.655009 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.589100 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some (ofBool ((x✝ &&& 3#32) * zeroExtend 32 x✝¹ >ᵤ 255#32)) ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 14.046900 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 14.555840 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 149.201769 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 18.858060 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.383330 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 16.653130 ms, MSGSTART 
    Unsupported syntax some (ofBool ((x✝ &&& 3#32) * setWidth 32 x✝¹ >ᵤ 255#32)) ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.const `BitVec.ofBool [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `BitVec.ult [])
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 32)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `BitVec.ofNat [])
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 32)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 255)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 255))))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `HMul.hMul [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `instHMul [Lean.Level.zero])
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.instMul [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.const `HAnd.hAnd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                              (Lean.Expr.app
                                (Lean.Expr.const `BitVec [])
                                (Lean.Expr.app
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                      (Lean.Expr.const `Nat []))
                                    (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                  (Lean.Expr.app
                                    (Lean.Expr.const `instOfNatNat [])
                                    (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `instHAndOfAndOp [Lean.Level.zero])
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec.instAndOp [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app
                                (Lean.Expr.const `instOfNatNat [])
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
                      (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1458321)))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.ofNat [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 3)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 3)))))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec.setWidth [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 8)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 32)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                  (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1458320))))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 221.014389 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 571.568068 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.706010 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some (ofBool ((x✝ &&& 3#32) * zeroExtend 32 x✝¹ >ᵤ 255#32)) ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 14.805930 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 14.600070 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 147.715229 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 18.652710 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 22.503400 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      c ≥ 0
      0 ≤ c - 8589934592*d ≤ 8589934591
      a ≥ 0
      0 ≤ a - 18446744073709551616*b ≤ 18446744073709551615
      a - 18446744073709551616*b - 2147483648*c + 18446744073709551616*d ≥ 0
    where
     a := ↑((x✝ &&& 3#32).toNat % 2 ^ (2 * 32)) * ↑(x✝¹.toNat % 2 ^ 32 % 2 ^ (2 * 32))
     b := ↑((x✝ &&& 3#32).toNat % 2 ^ (2 * 32) * (x✝¹.toNat % 2 ^ 32 % 2 ^ (2 * 32))) / 18446744073709551616
     c := ↑2 ^ (1 % 2 ^ (2 * 32))
     d := ↑(2 ^ (32 - 1) % 2 ^ (2 * 32) * 2 ^ (1 % 2 ^ (2 * 32))) / 18446744073709551616 MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 16.576730 ms, MSGSTART 
    Unsupported syntax some (ofBool ((x✝ &&& 3#32) * setWidth 32 x✝¹ >ᵤ 255#32)) ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.const `BitVec.ofBool [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `BitVec.ult [])
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 32)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `BitVec.ofNat [])
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 32)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 255)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 255))))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `HMul.hMul [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `instHMul [Lean.Level.zero])
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.instMul [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.const `HAnd.hAnd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                              (Lean.Expr.app
                                (Lean.Expr.const `BitVec [])
                                (Lean.Expr.app
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                      (Lean.Expr.const `Nat []))
                                    (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                  (Lean.Expr.app
                                    (Lean.Expr.const `instOfNatNat [])
                                    (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `instHAndOfAndOp [Lean.Level.zero])
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec.instAndOp [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app
                                (Lean.Expr.const `instOfNatNat [])
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
                      (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1458321)))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.ofNat [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 3)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 3)))))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec.setWidth [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 8)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 32)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                  (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1458320))))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 253.244169 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 610.106277 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.604900 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some (ofBool ((x✝ &&& 255#32) * x✝¹ >>> 30#32 >ᵤ 255#32)) ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 16.212340 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 17.826109 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 157.643950 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 19.531180 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 8.421560 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      31 ≤ a ≤ 4294967295
    where
     a := ↑(↑32).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 19.669960 ms, MSGSTART 
    Unsupported syntax some (ofBool ((x✝ &&& 255#32) * x✝¹ >>> 30 >ᵤ 255#32)) ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.const `BitVec.ofBool [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `BitVec.ult [])
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 32)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `BitVec.ofNat [])
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 32)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 255)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 255))))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `HMul.hMul [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `instHMul [Lean.Level.zero])
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.instMul [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.const `HAnd.hAnd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                              (Lean.Expr.app
                                (Lean.Expr.const `BitVec [])
                                (Lean.Expr.app
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                      (Lean.Expr.const `Nat []))
                                    (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                  (Lean.Expr.app
                                    (Lean.Expr.const `instOfNatNat [])
                                    (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `instHAndOfAndOp [Lean.Level.zero])
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec.instAndOp [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app
                                (Lean.Expr.const `instOfNatNat [])
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
                      (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1523756)))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.ofNat [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 255)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 255)))))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `HShiftRight.hShiftRight [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                          (Lean.Expr.const `Nat []))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.instHShiftRightNat [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                    (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1523755)))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 30)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 30))))))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 225.587719 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 594.343837 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.924810 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some (ofBool ((x✝ &&& 255#32) * x✝¹ >>> 30#32 >ᵤ 255#32)) ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 17.931760 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 18.408720 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 158.108409 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 19.695600 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 23.198800 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      d ≥ 0
      0 ≤ d - 8589934592*e ≤ 8589934591
      b ≥ 0
      0 ≤ b - 18446744073709551616*c ≤ 18446744073709551615
      b - 18446744073709551616*c - 2147483648*d + 18446744073709551616*e ≥ 0
      31 ≤ a ≤ 4294967295
    where
     a := ↑(↑32).toNat
     b := ↑((x✝ &&& 255#32).toNat % 2 ^ (2 * 32)) * ↑((x✝¹ >>> 30#32).toNat % 2 ^ (2 * 32))
     c := ↑((x✝ &&& 255#32).toNat % 2 ^ (2 * 32) * ((x✝¹ >>> 30#32).toNat % 2 ^ (2 * 32))) / 18446744073709551616
     d := ↑2 ^ (1 % 2 ^ (2 * 32))
     e := ↑(2 ^ (32 - 1) % 2 ^ (2 * 32) * 2 ^ (1 % 2 ^ (2 * 32))) / 18446744073709551616 MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 20.680200 ms, MSGSTART 
    Unsupported syntax some (ofBool ((x✝ &&& 255#32) * x✝¹ >>> 30 >ᵤ 255#32)) ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.const `BitVec.ofBool [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `BitVec.ult [])
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 32)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `BitVec.ofNat [])
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 32)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 255)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 255))))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `HMul.hMul [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `instHMul [Lean.Level.zero])
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.instMul [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.const `HAnd.hAnd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                              (Lean.Expr.app
                                (Lean.Expr.const `BitVec [])
                                (Lean.Expr.app
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                      (Lean.Expr.const `Nat []))
                                    (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                  (Lean.Expr.app
                                    (Lean.Expr.const `instOfNatNat [])
                                    (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `instHAndOfAndOp [Lean.Level.zero])
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec.instAndOp [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app
                                (Lean.Expr.const `instOfNatNat [])
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
                      (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1523756)))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.ofNat [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 255)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 255)))))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `HShiftRight.hShiftRight [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                          (Lean.Expr.const `Nat []))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.instHShiftRightNat [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                    (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1523755)))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 30)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 30))))))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 261.888789 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 634.002897 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 258.876719 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 43.701040 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 22.853000 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 149.677319 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 38.759300 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 16.812990 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 27.946290 ms, MSGSTART 
    tactic 'rfl' failed, the left-hand side
      ¬(((AutoStructs.Term.var 1).evalNat fun n =>
              if n = 1 then (x✝ &&& 1#32) * signExtend 32 x✝¹ else if n = 0 then 127#32 else BitVec.zero 32) >ₛ
            (AutoStructs.Term.var 0).evalNat fun n =>
              if n = 1 then (x✝ &&& 1#32) * signExtend 32 x✝¹ else if n = 0 then 127#32 else BitVec.zero 32) =
          true
    is not definitionally equal to the right-hand side
      ((x✝ &&& 1#32) * signExtend 32 x✝¹ >ₛ 127#32) = false
    x✝¹ : BitVec 8
    x✝ : BitVec 32
    h✝¹ :
      ¬(True ∧
          ((signExtend (2 * 32) (twoPow 32 (32 - 1)) >ₛ
                signExtend (2 * 32) (x✝ &&& 1#32) * signExtend (2 * 32) (signExtend 32 x✝¹)) =
              true ∨
            (signExtend (2 * 32) (x✝ &&& 1#32) * signExtend (2 * 32) (signExtend 32 x✝¹) ≥ₛ twoPow (2 * 32) (32 - 1)) =
              true))
    h✝ :
      ¬(True ∧
          zeroExtend (2 * 32) (x✝ &&& 1#32) * zeroExtend (2 * 32) (signExtend 32 x✝¹) ≥ twoPow (2 * 32) (32 - 1) <<< 1)
    ⊢ ¬(((AutoStructs.Term.var 1).evalNat fun n =>
                if n = 1 then (x✝ &&& 1#32) * signExtend 32 x✝¹ else if n = 0 then 127#32 else BitVec.zero 32) >ₛ
              (AutoStructs.Term.var 0).evalNat fun n =>
                if n = 1 then (x✝ &&& 1#32) * signExtend 32 x✝¹ else if n = 0 then 127#32 else BitVec.zero 32) =
            true ↔
        ((x✝ &&& 1#32) * signExtend 32 x✝¹ >ₛ 127#32) = false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 243.586929 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 525.883178 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 130.218490 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 26.878110 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 18.303040 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 147.513819 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 19.421460 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.525710 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 28.818350 ms, MSGSTART 
    tactic 'rfl' failed, the left-hand side
      ¬(((AutoStructs.Term.var 1).evalNat fun n =>
              if n = 1 then (x✝ &&& 2#32) * setWidth 32 x✝¹ else if n = 0 then 510#32 else BitVec.zero 32) >ᵤ
            (AutoStructs.Term.var 0).evalNat fun n =>
              if n = 1 then (x✝ &&& 2#32) * setWidth 32 x✝¹ else if n = 0 then 510#32 else BitVec.zero 32) =
          true
    is not definitionally equal to the right-hand side
      ((x✝ &&& 2#32) * setWidth 32 x✝¹ >ᵤ 510#32) = false
    x✝¹ : BitVec 8
    x✝ : BitVec 32
    ⊢ ¬(((AutoStructs.Term.var 1).evalNat fun n =>
                if n = 1 then (x✝ &&& 2#32) * setWidth 32 x✝¹ else if n = 0 then 510#32 else BitVec.zero 32) >ᵤ
              (AutoStructs.Term.var 0).evalNat fun n =>
                if n = 1 then (x✝ &&& 2#32) * setWidth 32 x✝¹ else if n = 0 then 510#32 else BitVec.zero 32) =
            true ↔
        ((x✝ &&& 2#32) * setWidth 32 x✝¹ >ᵤ 510#32) = false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 108.295219 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 370.944499 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 130.155639 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 28.716810 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 19.410210 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 154.274640 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 19.615219 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.595240 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 28.053030 ms, MSGSTART 
    tactic 'rfl' failed, the left-hand side
      ¬(((AutoStructs.Term.var 1).evalNat fun n =>
              if n = 1 then (x✝ &&& 255#32) * (x✝¹ &&& 4#32) else if n = 0 then 1020#32 else BitVec.zero 32) >ᵤ
            (AutoStructs.Term.var 0).evalNat fun n =>
              if n = 1 then (x✝ &&& 255#32) * (x✝¹ &&& 4#32) else if n = 0 then 1020#32 else BitVec.zero 32) =
          true
    is not definitionally equal to the right-hand side
      ((x✝ &&& 255#32) * (x✝¹ &&& 4#32) >ᵤ 1020#32) = false
    x✝¹ x✝ : BitVec 32
    ⊢ ¬(((AutoStructs.Term.var 1).evalNat fun n =>
                if n = 1 then (x✝ &&& 255#32) * (x✝¹ &&& 4#32) else if n = 0 then 1020#32 else BitVec.zero 32) >ᵤ
              (AutoStructs.Term.var 0).evalNat fun n =>
                if n = 1 then (x✝ &&& 255#32) * (x✝¹ &&& 4#32) else if n = 0 then 1020#32 else BitVec.zero 32) =
            true ↔
        ((x✝ &&& 255#32) * (x✝¹ &&& 4#32) >ᵤ 1020#32) = false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 108.210930 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 381.408398 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 101.923610 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 21.493410 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 20.149110 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 110.953709 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 13.983770 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.034920 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ a ≤ 127
    where
     a := ↑((x✝ &&& 8#32) * (x✝¹ &&& 16#32) ||| 128#32).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 33.101290 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq ((AutoStructs.Term.var 0).or (AutoStructs.Term.var 1))
            (AutoStructs.Term.var 1)) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 94.665630 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 496.253868 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.598900 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some (ofBool ((x✝ &&& 6#32) * zeroExtend 32 x✝¹ >ᵤ 1530#32)) ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 14.065300 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 14.511220 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 148.525460 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 19.586190 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.482400 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 16.999130 ms, MSGSTART 
    Unsupported syntax some (ofBool ((x✝ &&& 6#32) * setWidth 32 x✝¹ >ᵤ 1530#32)) ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.const `BitVec.ofBool [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `BitVec.ult [])
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 32)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `BitVec.ofNat [])
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 32)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 1530)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1530))))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `HMul.hMul [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `instHMul [Lean.Level.zero])
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.instMul [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.const `HAnd.hAnd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                              (Lean.Expr.app
                                (Lean.Expr.const `BitVec [])
                                (Lean.Expr.app
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                      (Lean.Expr.const `Nat []))
                                    (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                  (Lean.Expr.app
                                    (Lean.Expr.const `instOfNatNat [])
                                    (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `instHAndOfAndOp [Lean.Level.zero])
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec.instAndOp [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app
                                (Lean.Expr.const `instOfNatNat [])
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
                      (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1718763)))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.ofNat [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 6)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 6)))))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec.setWidth [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 8)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 32)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                  (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1718762))))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 218.195349 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 573.725367 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.721790 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some (ofBool ((x✝ &&& 6#32) * zeroExtend 32 x✝¹ >ᵤ 1530#32)) ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 15.034520 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 14.648120 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 148.465429 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 18.877460 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 22.588640 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      c ≥ 0
      0 ≤ c - 8589934592*d ≤ 8589934591
      a ≥ 0
      0 ≤ a - 18446744073709551616*b ≤ 18446744073709551615
      a - 18446744073709551616*b - 2147483648*c + 18446744073709551616*d ≥ 0
    where
     a := ↑((x✝ &&& 6#32).toNat % 2 ^ (2 * 32)) * ↑(x✝¹.toNat % 2 ^ 32 % 2 ^ (2 * 32))
     b := ↑((x✝ &&& 6#32).toNat % 2 ^ (2 * 32) * (x✝¹.toNat % 2 ^ 32 % 2 ^ (2 * 32))) / 18446744073709551616
     c := ↑2 ^ (1 % 2 ^ (2 * 32))
     d := ↑(2 ^ (32 - 1) % 2 ^ (2 * 32) * 2 ^ (1 % 2 ^ (2 * 32))) / 18446744073709551616 MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 16.775590 ms, MSGSTART 
    Unsupported syntax some (ofBool ((x✝ &&& 6#32) * setWidth 32 x✝¹ >ᵤ 1530#32)) ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.const `BitVec.ofBool [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `BitVec.ult [])
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 32)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `BitVec.ofNat [])
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 32)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 1530)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1530))))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `HMul.hMul [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `instHMul [Lean.Level.zero])
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.instMul [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.const `HAnd.hAnd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                              (Lean.Expr.app
                                (Lean.Expr.const `BitVec [])
                                (Lean.Expr.app
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                      (Lean.Expr.const `Nat []))
                                    (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                  (Lean.Expr.app
                                    (Lean.Expr.const `instOfNatNat [])
                                    (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `instHAndOfAndOp [Lean.Level.zero])
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec.instAndOp [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app
                                (Lean.Expr.const `instOfNatNat [])
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
                      (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1718763)))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.ofNat [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 6)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 6)))))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec.setWidth [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 8)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 32)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                  (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1718762))))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 252.785979 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 611.806087 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.574870 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some (ofBool ((x✝ &&& 255#32) * (x✝¹ &&& 12#32) >ᵤ 3060#32)) ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 15.884340 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 15.108190 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 154.638329 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 19.079000 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.608230 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 15.628610 ms, MSGSTART 
    Unsupported syntax some (ofBool ((x✝ &&& 255#32) * (x✝¹ &&& 12#32) >ᵤ 3060#32)) ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.const `BitVec.ofBool [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `BitVec.ult [])
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 32)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `BitVec.ofNat [])
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 32)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 3060)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 3060))))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `HMul.hMul [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `instHMul [Lean.Level.zero])
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.instMul [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.const `HAnd.hAnd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                              (Lean.Expr.app
                                (Lean.Expr.const `BitVec [])
                                (Lean.Expr.app
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                      (Lean.Expr.const `Nat []))
                                    (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                  (Lean.Expr.app
                                    (Lean.Expr.const `instOfNatNat [])
                                    (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `instHAndOfAndOp [Lean.Level.zero])
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec.instAndOp [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app
                                (Lean.Expr.const `instOfNatNat [])
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
                      (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1775959)))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.ofNat [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 255)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 255)))))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `HAnd.hAnd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `instHAndOfAndOp [Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec.instAndOp [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
                    (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1775958)))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec.ofNat [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 32)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 12)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 12)))))))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 223.591249 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 592.225227 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.767050 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some (ofBool ((x✝ &&& 255#32) * (x✝¹ &&& 12#32) >ᵤ 3060#32)) ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 17.335380 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 15.594570 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 157.407039 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 19.046090 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 20.653780 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      c ≥ 0
      0 ≤ c - 8589934592*d ≤ 8589934591
      a ≥ 0
      0 ≤ a - 18446744073709551616*b ≤ 18446744073709551615
      a - 18446744073709551616*b - 2147483648*c + 18446744073709551616*d ≥ 0
    where
     a := ↑((x✝ &&& 255#32).toNat % 2 ^ (2 * 32)) * ↑((x✝¹ &&& 12#32).toNat % 2 ^ (2 * 32))
     b := ↑((x✝ &&& 255#32).toNat % 2 ^ (2 * 32) * ((x✝¹ &&& 12#32).toNat % 2 ^ (2 * 32))) / 18446744073709551616
     c := ↑2 ^ (1 % 2 ^ (2 * 32))
     d := ↑(2 ^ (32 - 1) % 2 ^ (2 * 32) * 2 ^ (1 % 2 ^ (2 * 32))) / 18446744073709551616 MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 15.812490 ms, MSGSTART 
    Unsupported syntax some (ofBool ((x✝ &&& 255#32) * (x✝¹ &&& 12#32) >ᵤ 3060#32)) ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.const `BitVec.ofBool [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `BitVec.ult [])
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 32)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `BitVec.ofNat [])
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 32)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 3060)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 3060))))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `HMul.hMul [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `instHMul [Lean.Level.zero])
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.instMul [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.const `HAnd.hAnd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                              (Lean.Expr.app
                                (Lean.Expr.const `BitVec [])
                                (Lean.Expr.app
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                      (Lean.Expr.const `Nat []))
                                    (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                  (Lean.Expr.app
                                    (Lean.Expr.const `instOfNatNat [])
                                    (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `instHAndOfAndOp [Lean.Level.zero])
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec.instAndOp [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app
                                (Lean.Expr.const `instOfNatNat [])
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
                      (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1775959)))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.ofNat [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 255)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 255)))))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `HAnd.hAnd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `instHAndOfAndOp [Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec.instAndOp [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
                    (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1775958)))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec.ofNat [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 32)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 12)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 12)))))))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 254.891729 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 628.888267 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 406.568579 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 22.602570 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 18.759520 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 154.353199 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 30.853810 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.070640 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      97 ≤ a ≤ 340282366920938463463374607431768211455
    where
     a := ↑(↑128).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 37.163430 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) AutoStructs.Term.zero) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 357.616748 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 657.420737 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 344.541369 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 24.820609 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 23.177480 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 231.387499 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 73.910550 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.334950 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ c ≤ 1
      0 ≤ b ≤ 1
      b - c ≥ 1
      96 ≤ a ≤ 340282366920938463463374607431768211455
    where
     a := ↑(↑128).toNat
     b := ↑(ofBool (x✝ >ₛ -1#32)).toNat
     c := ↑(ofBool ((zeroExtend 128 x✝ * 18446744078004518913#128) >>> 95#128 == 0#128)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 23.385210 ms, MSGSTART 
    Equality ((setWidth 128 x✝ * 18446744078004518913#128) >>> 95 == 0#128) =
      (x✝ >ₛ 4294967295#32) has a strange type MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 448.673248 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 793.900737 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.606020 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some 1#1 ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 7.733660 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 2.832490 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 69.236700 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.164269 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.311361 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 10.588929 ms, MSGSTART 
    Unsupported syntax some 1#1 ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.const `BitVec.ofNat [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 98.509810 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 267.608509 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.721020 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some 1#1 ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 8.385190 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 3.015330 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 70.928700 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.296160 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 20.869349 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      c ≥ 0
      0 ≤ c - 512*d ≤ 511
      a ≥ 0
      0 ≤ a - 65536*b ≤ 65535
      a - 65536*b - 128*c + 65536*d ≥ 0
    where
     a := ↑(x✝¹.toNat % 2 ^ (2 * 8)) * ↑(x✝.toNat % 2 ^ (2 * 8))
     b := ↑(x✝¹.toNat % 2 ^ (2 * 8) * (x✝.toNat % 2 ^ (2 * 8))) / 65536
     c := ↑2 ^ (1 % 2 ^ (2 * 8))
     d := ↑(2 ^ (8 - 1) % 2 ^ (2 * 8) * 2 ^ (1 % 2 ^ (2 * 8))) / 65536 MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 10.744790 ms, MSGSTART 
    Unsupported syntax some 1#1 ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.const `BitVec.ofNat [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 121.641520 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 292.448519 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.736550 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some 1#1 ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 8.742870 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 3.029330 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 70.501149 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.305790 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 14.124720 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 10.650610 ms, MSGSTART 
    Unsupported syntax some 1#1 ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.const `BitVec.ofNat [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 120.140780 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 293.514448 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.711160 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some 1#1 ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 8.429290 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 3.145390 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 72.075040 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.353450 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.344030 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 10.736080 ms, MSGSTART 
    Unsupported syntax some 1#1 ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.const `BitVec.ofNat [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 96.990699 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 266.896579 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 220.499209 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 32.058610 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 11.683310 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 145.936810 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 17.815329 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 21.762869 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 34.586320 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom (AutoStructs.Relation.unsigned AutoStructs.RelationOrdering.lt)
            (AutoStructs.Term.var 0) (AutoStructs.Term.var 1)) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 160.848670 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 412.896008 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.731710 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some 1#1 ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 8.443870 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 3.003250 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 69.894150 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.285280 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 20.826620 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      c ≥ 0
      0 ≤ c - 512*d ≤ 511
      a ≥ 0
      0 ≤ a - 65536*b ≤ 65535
      a - 65536*b - 128*c + 65536*d ≥ 0
    where
     a := ↑(x✝¹.toNat % 2 ^ (2 * 8)) * ↑(x✝.toNat % 2 ^ (2 * 8))
     b := ↑(x✝¹.toNat % 2 ^ (2 * 8) * (x✝.toNat % 2 ^ (2 * 8))) / 65536
     c := ↑2 ^ (1 % 2 ^ (2 * 8))
     d := ↑(2 ^ (8 - 1) % 2 ^ (2 * 8) * 2 ^ (1 % 2 ^ (2 * 8))) / 65536 MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 10.809880 ms, MSGSTART 
    Unsupported syntax some 1#1 ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.const `BitVec.ofNat [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 119.441109 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 290.537109 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.753930 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some 1#1 ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 12.237410 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 3.168190 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 73.698490 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.822460 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 28.536520 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      c ≥ 0
      0 ≤ c - 512*d ≤ 511
      a ≥ 0
      0 ≤ a - 65536*b ≤ 65535
      a - 65536*b - 128*c + 65536*d ≥ 0
    where
     a := ↑(x✝².toNat % 2 ^ (2 * 8)) * ↑(x✝.toNat % 2 ^ (2 * 8))
     b := ↑(x✝².toNat % 2 ^ (2 * 8) * (x✝.toNat % 2 ^ (2 * 8))) / 65536
     c := ↑2 ^ (1 % 2 ^ (2 * 8))
     d := ↑(2 ^ (8 - 1) % 2 ^ (2 * 8) * 2 ^ (1 % 2 ^ (2 * 8))) / 65536 MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 11.331489 ms, MSGSTART 
    Unsupported syntax some 1#1 ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.const `BitVec.ofNat [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 146.145850 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 328.694388 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 226.213309 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 30.099960 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 15.291620 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 156.220349 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 18.685320 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 25.739230 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 28.061120 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq AutoStructs.Term.one (AutoStructs.Term.var 0)) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 165.753539 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 394.218909 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 278.919159 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 29.464330 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 65.026330 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 168.236649 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 46.300700 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 8.387730 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝¹ == 0#8)).toNat
     b := ↑(ofBool (x✝ * x✝¹ == (x✝ + 1#8) * x✝¹)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 108.229229 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.binop AutoStructs.Binop.equiv
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) (AutoStructs.Term.var 1))
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 2) AutoStructs.Term.zero)) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 200.394519 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 214.753630 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 237.121790 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 29.154280 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 64.337930 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 166.394929 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 45.285390 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 19.336930 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝¹ == 0#8)).toNat
     b := ↑(ofBool (x✝ * x✝¹ == (x✝ + 1#8) * x✝¹)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 106.109510 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.binop AutoStructs.Binop.equiv
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) (AutoStructs.Term.var 1))
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 2) AutoStructs.Term.zero)) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 158.283849 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 218.000739 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 268.470619 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 29.336450 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 58.926480 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 167.551799 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 46.399650 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 8.448410 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝¹ == 0#8)).toNat
     b := ↑(ofBool (x✝ * x✝¹ == x✝¹ * (x✝ + 1#8))).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 97.823970 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.binop AutoStructs.Binop.equiv
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) (AutoStructs.Term.var 1))
            (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 2) AutoStructs.Term.zero)) =
        true
    is false MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 258.790428 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 207.761220 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 218.690749 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 31.717580 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 23.457760 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 165.785379 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 57.729600 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.917560 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝¹ != 0#8)).toNat
     b := ↑(ofBool (x✝ * x✝¹ != (x✝ + 1#8) * x✝¹)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 16.352200 ms, MSGSTART 
    Equality (x✝ * x✝¹ != (x✝ + 1#8) * x✝¹) = (x✝¹ != 0#8) has a strange type MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 200.779289 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 547.788148 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 218.243130 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 107.724590 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 56.470750 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 159.241819 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 125.176510 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.215550 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝¹ >ₛ x✝)).toNat
     b := ↑(ofBool (x✝¹ * 7#8 >ₛ x✝ * 7#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 14.190020 ms, MSGSTART 
    Equality (x✝¹ * 7#8 >ₛ x✝ * 7#8) = (x✝¹ >ₛ x✝) has a strange type MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 223.936709 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 704.071257 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 219.237999 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 86.834319 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 45.547470 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 162.880359 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 125.994890 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.257780 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝¹ ≥ₛ x✝)).toNat
     b := ↑(ofBool (x✝¹ * 7#8 ≥ₛ x✝ * 7#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 14.556820 ms, MSGSTART 
    Equality (x✝¹ * 7#8 ≥ₛ x✝ * 7#8) = (x✝¹ ≥ₛ x✝) has a strange type MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 203.906549 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 672.265257 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 217.101579 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 107.810910 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 56.657400 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 162.781319 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 124.757109 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.242000 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ >ₛ x✝¹)).toNat
     b := ↑(ofBool (x✝ * 7#8 >ₛ x✝¹ * 7#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 14.302710 ms, MSGSTART 
    Equality (x✝ * 7#8 >ₛ x✝¹ * 7#8) = (x✝ >ₛ x✝¹) has a strange type MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 223.722119 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 708.647737 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 218.367639 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 86.132560 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 45.831100 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 163.083219 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 128.557200 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.269860 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ ≥ₛ x✝¹)).toNat
     b := ↑(ofBool (x✝ * 7#8 ≥ₛ x✝¹ * 7#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 14.324499 ms, MSGSTART 
    Equality (x✝ * 7#8 ≥ₛ x✝¹ * 7#8) = (x✝ ≥ₛ x✝¹) has a strange type MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 204.499520 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 674.281677 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 546.498158 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 102.269769 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 53.694990 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 154.803729 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 119.844920 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.982440 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ >ₛ x✝¹)).toNat
     b := ↑(ofBool (x✝¹ * 249#8 >ₛ x✝ * 249#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 13.770190 ms, MSGSTART 
    Equality (x✝¹ * 249#8 >ₛ x✝ * 249#8) = (x✝ >ₛ x✝¹) has a strange type MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 459.707618 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 1009.399536 ms, 
TACEND
