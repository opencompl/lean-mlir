⚠ [202/2570] Replayed Mathlib.Logic.ExistsUnique
warning: ././.lake/packages/mathlib/././Mathlib/Logic/ExistsUnique.lean:109:16: `exists_unique_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [225/2570] Replayed Mathlib.Tactic.Lift
warning: ././.lake/packages/mathlib/././Mathlib/Tactic/Lift.lean:49:9: `PiSubtype.canLift'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [443/2570] Replayed Mathlib.Control.Combinators
warning: ././.lake/packages/mathlib/././Mathlib/Control/Combinators.lean:35:4: `Monad.mapM'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Control/Combinators.lean:57:4: `Monad.sequence'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [445/2570] Replayed Mathlib.Data.Prod.PProd
warning: ././.lake/packages/mathlib/././Mathlib/Data/Prod/PProd.lean:35:8: `PProd.forall'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Prod/PProd.lean:38:8: `PProd.exists'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [880/2570] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [883/2570] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:349:4: declaration uses 'sorry'
⚠ [899/2570] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:30:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:32:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:37:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:39:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:53:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:2: Apply builder was used for a theorem with conclusion A ↔ B.
You probably want to use the simp builder or create an alias that applies the theorem in one direction.
Use `set_option aesop.warn.applyIff false` to disable this warning.
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:57:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:60:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:71:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:70:2: Apply builder was used for a theorem with conclusion A ↔ B.
You probably want to use the simp builder or create an alias that applies the theorem in one direction.
Use `set_option aesop.warn.applyIff false` to disable this warning.
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:76:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:80:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:85:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:99:37: declaration uses 'sorry'
✔ [2561/2570] Built SSA.Experimental.Bits.AutoStructs.ForMathlib
✔ [2563/2570] Built SSA.Experimental.Bits.AutoStructs.Defs
✔ [2564/2570] Built SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
⚠ [2565/2570] Built SSA.Experimental.Bits.AutoStructs.Basic
warning: ././././SSA/Experimental/Bits/AutoStructs/Basic.lean:461:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Basic.lean:1070:4: declaration uses 'sorry'
⚠ [2566/2570] Built SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:28:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:30:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:41:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:53:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:79:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:166:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:183:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:210:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:262:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:274:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:302:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:305:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:318:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:321:4: declaration uses 'sorry'
⚠ [2567/2570] Built SSA.Experimental.Bits.AutoStructs.FormulaToAuto
warning: ././././SSA/Experimental/Bits/AutoStructs/FormulaToAuto.lean:381:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/FormulaToAuto.lean:409:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/FormulaToAuto.lean:446:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/FormulaToAuto.lean:551:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/FormulaToAuto.lean:659:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/FormulaToAuto.lean:702:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/FormulaToAuto.lean:750:6: declaration uses 'sorry'
✔ [2568/2570] Built SSA.Experimental.Bits.AutoStructs.Tactic
✔ [2569/2570] Built SSA.Projects.InstCombine.TacticAuto
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 299.543188 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 25.329050 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 166.212339 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 348.804299 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 40.426730 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.369030 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ d ≤ 1
      0 ≤ c ≤ 1
      c - d ≥ 1
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝¹.toNat
     c := ↑(ofBool (zeroExtend 16 ((-1#8) >>> x✝¹) ≥ᵤ x✝ ^^^ 123#16)).toNat
     d := ↑(ofBool ((x✝ ^^^ 123#16) &&& zeroExtend 16 ((-1#8) >>> x✝¹) == x✝ ^^^ 123#16)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 164.089719 ms, MSGSTART 
    Equality ((x✝ ^^^ 123#16) &&& setWidth 16 (255#8 >>> x✝¹.toNat) == x✝ ^^^ 123#16) =
      (setWidth 16 (255#8 >>> x✝¹.toNat) ≥ᵤ x✝ ^^^ 123#16) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 151.954679 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 32.227260 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 106.816670 ms, 
  TACBENCH bv_auto FAIL, TIME_ELAPSED 1012.867715 ms, MSGSTART 
    internal exception #4 MSGEND
TACEND
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphandhlowbithmask_proof.lean:11:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 353.115348 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 31.839320 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 209.167859 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 371.697688 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 50.607550 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.172140 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ d ≤ 1
      0 ≤ c ≤ 1
      c - d ≥ 1
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝¹.toNat
     c := ↑(ofBool (x✝ ^^^ 65412#16 ||| zeroExtend 16 (254#8 >>> x✝¹) == -1#16)).toNat
     d := ↑(ofBool ((x✝ ^^^ 123#16) &&& zeroExtend 16 (254#8 >>> x✝¹) == x✝ ^^^ 123#16)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 306.399209 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.binop AutoStructs.Binop.equiv
            (AutoStructs.Formula.atom AutoStructs.Relation.eq
              (((AutoStructs.Term.var 0).xor (AutoStructs.Term.var 1)).and (AutoStructs.Term.var 2))
              ((AutoStructs.Term.var 0).xor (AutoStructs.Term.var 1)))
            (AutoStructs.Formula.atom AutoStructs.Relation.eq
              (((AutoStructs.Term.var 0).xor (AutoStructs.Term.var 3)).or (AutoStructs.Term.var 2))
              (AutoStructs.Term.var 4))) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 193.685259 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 34.251070 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 109.403019 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 1125.762055 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.679870 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some (ofBool ((signExtend 16 (31#8 >>> x✝) ^^^ -1#16) &&& (x✝¹ ^^^ 123#16) == 0#16)) ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 27.573530 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 187.427969 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 359.117559 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 33.055659 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.411850 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝.toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 180.663050 ms, MSGSTART 
    Unsupported syntax some (ofBool ((signExtend 16 (31#8 >>> x✝.toNat) ^^^ 65535#16) &&& (x✝¹ ^^^ 123#16) == 0#16)) ⊑
      none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.const `BitVec.ofBool [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `BEq.beq [Lean.Level.zero])
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 16)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 16))))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `instBEqOfDecidableEq [Lean.Level.zero])
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 16)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 16))))))
                    (Lean.Expr.app
                      (Lean.Expr.const `instDecidableEqBitVec [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 16)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 16)))))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `HAnd.hAnd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 16)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 16))))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 16)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 16))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 16)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 16))))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `instHAndOfAndOp [Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 16)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 16))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec.instAndOp [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 16)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 16)))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.const `HXor.hXor [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                                (Lean.Expr.app
                                  (Lean.Expr.const `BitVec [])
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.app
                                        (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                        (Lean.Expr.const `Nat []))
                                      (Lean.Expr.lit (Lean.Literal.natVal 16)))
                                    (Lean.Expr.app
                                      (Lean.Expr.const `instOfNatNat [])
                                      (Lean.Expr.lit (Lean.Literal.natVal 16))))))
                              (Lean.Expr.app
                                (Lean.Expr.const `BitVec [])
                                (Lean.Expr.app
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                      (Lean.Expr.const `Nat []))
                                    (Lean.Expr.lit (Lean.Literal.natVal 16)))
                                  (Lean.Expr.app
                                    (Lean.Expr.const `instOfNatNat [])
                                    (Lean.Expr.lit (Lean.Literal.natVal 16))))))
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 16)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 16))))))
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.const `instHXorOfXor [Lean.Level.zero])
                              (Lean.Expr.app
                                (Lean.Expr.const `BitVec [])
                                (Lean.Expr.app
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                      (Lean.Expr.const `Nat []))
                                    (Lean.Expr.lit (Lean.Literal.natVal 16)))
                                  (Lean.Expr.app
                                    (Lean.Expr.const `instOfNatNat [])
                                    (Lean.Expr.lit (Lean.Literal.natVal 16))))))
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec.instXor [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 16)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 16)))))))
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec.signExtend [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 16)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 16)))))
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.const
                                        `HShiftRight.hShiftRight
                                        [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                                      (Lean.Expr.app
                                        (Lean.Expr.const `BitVec [])
                                        (Lean.Expr.app
                                          (Lean.Expr.app
                                            (Lean.Expr.app
                                              (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                              (Lean.Expr.const `Nat []))
                                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                          (Lean.Expr.app
                                            (Lean.Expr.const `instOfNatNat [])
                                            (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                                    (Lean.Expr.const `Nat []))
                                  (Lean.Expr.app
                                    (Lean.Expr.const `BitVec [])
                                    (Lean.Expr.app
                                      (Lean.Expr.app
                                        (Lean.Expr.app
                                          (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                          (Lean.Expr.const `Nat []))
                                        (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                      (Lean.Expr.app
                                        (Lean.Expr.const `instOfNatNat [])
                                        (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                                (Lean.Expr.app
                                  (Lean.Expr.const `BitVec.instHShiftRightNat [])
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.app
                                        (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                        (Lean.Expr.const `Nat []))
                                      (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                    (Lean.Expr.app
                                      (Lean.Expr.const `instOfNatNat [])
                                      (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.const `BitVec.ofNat [])
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.app
                                        (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                        (Lean.Expr.const `Nat []))
                                      (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                    (Lean.Expr.app
                                      (Lean.Expr.const `instOfNatNat [])
                                      (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                                (Lean.Expr.app
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                      (Lean.Expr.const `Nat []))
                                    (Lean.Expr.lit (Lean.Literal.natVal 31)))
                                  (Lean.Expr.app
                                    (Lean.Expr.const `instOfNatNat [])
                                    (Lean.Expr.lit (Lean.Literal.natVal 31))))))
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.const `BitVec.toNat [])
                                (Lean.Expr.app
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                      (Lean.Expr.const `Nat []))
                                    (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                  (Lean.Expr.app
                                    (Lean.Expr.const `instOfNatNat [])
                                    (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                              (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 329117))))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec.ofNat [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 16)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 16)))))
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 65535)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 65535)))))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.const `HXor.hXor [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                              (Lean.Expr.app
                                (Lean.Expr.const `BitVec [])
                                (Lean.Expr.app
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                      (Lean.Expr.const `Nat []))
                                    (Lean.Expr.lit (Lean.Literal.natVal 16)))
                                  (Lean.Expr.app
                                    (Lean.Expr.const `instOfNatNat [])
                                    (Lean.Expr.lit (Lean.Literal.natVal 16))))))
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 16)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 16))))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 16)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 16))))))
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `instHXorOfXor [Lean.Level.zero])
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 16)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 16))))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec.instXor [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 16)))
                              (Lean.Expr.app
                                (Lean.Expr.const `instOfNatNat [])
                                (Lean.Expr.lit (Lean.Literal.natVal 16)))))))
                      (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 329116)))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.ofNat [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 16)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 16)))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 123)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 123))))))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `BitVec.ofNat [])
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 16)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 16)))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                    (Lean.Expr.lit (Lean.Literal.natVal 0)))
                  (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 0)))))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 167.144859 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 28.493260 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 90.590219 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 1200.002565 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 355.717908 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 36.125910 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 223.962689 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 357.861439 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 41.824310 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 8.005170 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ d ≤ 1
      0 ≤ c ≤ 1
      c - d ≥ 1
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝.toNat
     c := ↑(ofBool (zeroExtend 16 (31#8 >>> x✝) ≥ᵤ x✝¹ ^^^ 123#16)).toNat
     d := ↑(ofBool ((signExtend 16 (31#8 >>> x✝) ^^^ -1#16) &&& (x✝¹ ^^^ 123#16) == 0#16)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 212.033189 ms, MSGSTART 
    Equality ((signExtend 16 (31#8 >>> x✝.toNat) ^^^ 65535#16) &&& (x✝¹ ^^^ 123#16) == 0#16) =
      (setWidth 16 (31#8 >>> x✝.toNat) ≥ᵤ x✝¹ ^^^ 123#16) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 199.989729 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 39.160150 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 115.322039 ms, 
  TACBENCH bv_auto FAIL, TIME_ELAPSED 1278.488115 ms, MSGSTART 
    internal exception #4 MSGEND
TACEND
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphandhlowbithmask_proof.lean:36:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 382.622118 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 31.886690 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 239.747169 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 282.940189 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 42.801919 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.847510 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ e ≤ 1
      0 ≤ d ≤ 1
      d - e ≥ 1
      0 ≤ c ≤ 255
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
      a - c ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝¹.toNat
     c := ↑x✝².toNat
     d := ↑(ofBool (7#8 >>> x✝¹ &&& (-1#8) >>> x✝² ≥ᵤ x✝ ^^^ 123#8)).toNat
     e := ↑(ofBool (x✝ ^^^ 123#8 == (x✝ ^^^ 123#8) &&& ((7#8).sshiftRight' x✝¹ &&& (-1#8) >>> x✝²))).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 234.055069 ms, MSGSTART 
    Equality (x✝ ^^^ 123#8 == (x✝ ^^^ 123#8) &&& ((7#8).sshiftRight x✝¹.toNat &&& 255#8 >>> x✝².toNat)) =
      (7#8 >>> x✝¹.toNat &&& 255#8 >>> x✝².toNat ≥ᵤ x✝ ^^^ 123#8) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 219.706139 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 41.360120 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 118.634150 ms, 
  TACBENCH bv_auto FAIL, TIME_ELAPSED 1155.374115 ms, MSGSTART 
    internal exception #4 MSGEND
TACEND
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphandhlowbithmask_proof.lean:49:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 389.110368 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 20.545810 ms, MSGSTART 
    tactic 'simp' failed, nested error:
    maximum recursion depth has been reached
    use `set_option maxRecDepth <num>` to increase limit
    use `set_option diagnostics true` to get diagnostic information MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 237.125849 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 290.484409 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 50.838300 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.200410 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ e ≤ 1
      0 ≤ d ≤ 1
      d - e ≥ 1
      0 ≤ c ≤ 255
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
      a - c ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝¹.toNat
     c := ↑x✝².toNat
     d := ↑(ofBool ((248#8).sshiftRight' x✝¹ &&& (-1#8) >>> x✝² ||| x✝ ^^^ 132#8 == -1#8)).toNat
     e := ↑(ofBool (x✝ ^^^ 123#8 == (x✝ ^^^ 123#8) &&& ((248#8).sshiftRight' x✝¹ &&& (-1#8) >>> x✝²))).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 402.659678 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.binop AutoStructs.Binop.equiv
            (AutoStructs.Formula.atom AutoStructs.Relation.eq ((AutoStructs.Term.var 0).xor (AutoStructs.Term.var 1))
              (((AutoStructs.Term.var 0).xor (AutoStructs.Term.var 1)).and
                ((AutoStructs.Term.var 2).and (AutoStructs.Term.var 3))))
            (AutoStructs.Formula.atom AutoStructs.Relation.eq
              (((AutoStructs.Term.var 2).and (AutoStructs.Term.var 3)).or
                ((AutoStructs.Term.var 0).xor (AutoStructs.Term.var 4)))
              (AutoStructs.Term.var 5))) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 222.861679 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 43.346720 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 119.915619 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 1116.948865 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 303.966729 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 25.974720 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 189.026039 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 278.362429 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 41.038250 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.430850 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ d ≤ 1
      0 ≤ c ≤ 1
      c - d ≥ 1
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝¹.toNat
     c := ↑(ofBool ((-1#8) >>> x✝¹ &&& 7#8 ≥ᵤ x✝ ^^^ 123#8)).toNat
     d := ↑(ofBool (x✝ ^^^ 123#8 == (-1#8) >>> x✝¹ &&& 7#8 &&& (x✝ ^^^ 123#8))).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 170.280319 ms, MSGSTART 
    Equality (x✝ ^^^ 123#8 == 255#8 >>> x✝¹.toNat &&& 7#8 &&& (x✝ ^^^ 123#8)) =
      (255#8 >>> x✝¹.toNat &&& 7#8 ≥ᵤ x✝ ^^^ 123#8) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 158.030439 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 32.848560 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 106.535720 ms, 
  TACBENCH bv_auto FAIL, TIME_ELAPSED 937.690635 ms, MSGSTART 
    internal exception #4 MSGEND
TACEND
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphandhlowbithmask_proof.lean:76:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 287.588649 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 161.677429 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 293.704709 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 276.904879 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 47.005230 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.212290 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ ^^^ 123#8 >ᵤ x✝¹ ^^^ x✝¹ + -1#8)).toNat
     b := ↑(ofBool ((x✝ ^^^ 123#8) &&& (x✝¹ ^^^ x✝¹ + -1#8) != x✝ ^^^ 123#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 155.777449 ms, MSGSTART 
    Equality ((x✝ ^^^ 123#8) &&& (x✝¹ ^^^ x✝¹ + 255#8) != x✝ ^^^ 123#8) =
      (x✝ ^^^ 123#8 >ᵤ x✝¹ ^^^ x✝¹ + 255#8) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 144.826429 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 26.633650 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 100.019440 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 1188.448585 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 391.760889 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 176.317330 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 398.608788 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 337.722599 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 64.314659 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.608930 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝¹ ^^^ 0#8 - x✝¹ ||| x✝ ^^^ 132#8 != -1#8)).toNat
     b := ↑(ofBool ((x✝ ^^^ 123#8) &&& (x✝¹ ^^^ x✝¹ + -1#8 ^^^ -1#8) != x✝ ^^^ 123#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 251.744409 ms, MSGSTART 
    Equality ((x✝ ^^^ 123#8) &&& (x✝¹ ^^^ x✝¹ + 255#8 ^^^ 255#8) != x✝ ^^^ 123#8) =
      (x✝¹ ^^^ -x✝¹ ||| x✝ ^^^ 132#8 != 255#8) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 239.197019 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 37.841770 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 113.833569 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 1617.956173 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 183.153289 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 22.149250 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 70.977560 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 236.676929 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 44.083540 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.439260 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ ^^^ 123#8 >ᵤ 15#8)).toNat
     b := ↑(ofBool (15#8 &&& (x✝ ^^^ 123#8) != x✝ ^^^ 123#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 69.993629 ms, MSGSTART 
    Equality (15#8 &&& (x✝ ^^^ 123#8) != x✝ ^^^ 123#8) = (x✝ ^^^ 123#8 >ᵤ 15#8) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 58.487570 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 21.617430 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 94.430220 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 684.307117 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 289.108439 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 162.510879 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 295.067799 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 278.781359 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 46.946610 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.195789 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝¹ ^^^ 123#8 >ᵤ x✝ ^^^ x✝ + -1#8)).toNat
     b := ↑(ofBool ((x✝ ^^^ x✝ + -1#8) &&& (x✝¹ ^^^ 123#8) != x✝¹ ^^^ 123#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 156.509940 ms, MSGSTART 
    Equality ((x✝ ^^^ x✝ + 255#8) &&& (x✝¹ ^^^ 123#8) != x✝¹ ^^^ 123#8) =
      (x✝¹ ^^^ 123#8 >ᵤ x✝ ^^^ x✝ + 255#8) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 144.484979 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 26.761460 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 99.585200 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 1187.682215 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 184.742169 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 22.124070 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 71.524160 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 237.260889 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 43.918670 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.471360 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝¹ ^^^ 123#8 >ᵤ 15#8)).toNat
     b := ↑(ofBool (15#8 &&& (x✝¹ ^^^ 123#8) != x✝¹ ^^^ 123#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 70.068089 ms, MSGSTART 
    Equality (15#8 &&& (x✝¹ ^^^ 123#8) != x✝¹ ^^^ 123#8) = (x✝¹ ^^^ 123#8 >ᵤ 15#8) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 59.055890 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 21.738770 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 93.572160 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 684.811177 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 358.791578 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 29.307380 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 227.947879 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 284.930709 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 48.993260 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.140920 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ d ≤ 1
      0 ≤ c ≤ 1
      c - d ≥ 1
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝¹.toNat
     c := ↑(ofBool (x✝ ^^^ 122#8 >ᵤ (-1#8) >>> x✝¹)).toNat
     d := ↑(ofBool (0#8 != (x✝ ^^^ 123#8) &&& ((-1#8) <<< x✝¹ >>> x✝¹ ^^^ -1#8))).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 223.927719 ms, MSGSTART 
    Equality (0#8 != (x✝ ^^^ 123#8) &&& (255#8 <<< x✝¹.toNat >>> x✝¹.toNat ^^^ 255#8)) =
      (x✝ ^^^ 122#8 >ᵤ 255#8 >>> x✝¹.toNat) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 211.705559 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 34.524610 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 112.343799 ms, 
  TACBENCH bv_auto FAIL, TIME_ELAPSED 1400.388924 ms, MSGSTART 
    internal exception #4 MSGEND
TACEND
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphandhlowbithmask_proof.lean:128:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 405.860358 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 39.099330 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 278.629548 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 296.124909 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 64.332910 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.798850 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ d ≤ 1
      0 ≤ c ≤ 1
      c - d ≥ 1
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝¹.toNat
     c := ↑(ofBool (x✝ ^^^ 132#8 ||| (-1#8) >>> x✝¹ &&& 254#8 != -1#8)).toNat
     d := ↑(ofBool (0#8 != (x✝ ^^^ 123#8) &&& (254#8 <<< x✝¹ >>> x✝¹ ^^^ -1#8))).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 267.595479 ms, MSGSTART 
    Equality (0#8 != (x✝ ^^^ 123#8) &&& (254#8 <<< x✝¹.toNat >>> x✝¹.toNat ^^^ 255#8)) =
      (x✝ ^^^ 132#8 ||| 255#8 >>> x✝¹.toNat &&& 254#8 != 255#8) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 252.976409 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 38.701989 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 117.192590 ms, 
  TACBENCH bv_auto FAIL, TIME_ELAPSED 1680.675363 ms, MSGSTART 
    internal exception #4 MSGEND
TACEND
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphandhlowbithmask_proof.lean:140:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 242.285899 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 24.153410 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 125.190449 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 241.257669 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 45.816480 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.136740 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ d ≤ 1
      0 ≤ c ≤ 1
      c - d ≥ 1
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝¹.toNat
     c := ↑(ofBool (x✝ ^^^ 123#8 >ᵤ 15#8 >>> x✝¹)).toNat
     d := ↑(ofBool (x✝ ^^^ 123#8 != 15#8 >>> x✝¹ &&& (x✝ ^^^ 123#8))).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 123.503200 ms, MSGSTART 
    Equality (x✝ ^^^ 123#8 != 15#8 >>> x✝¹.toNat &&& (x✝ ^^^ 123#8)) =
      (x✝ ^^^ 123#8 >ᵤ 15#8 >>> x✝¹.toNat) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 112.028929 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 29.547870 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 103.773250 ms, 
  TACBENCH bv_auto FAIL, TIME_ELAPSED 792.094386 ms, MSGSTART 
    internal exception #4 MSGEND
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 323.947679 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 164.268839 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 324.843249 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 289.887589 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 49.072439 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.988550 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ d ≤ 1
      0 ≤ c ≤ 1
      c - d ≥ 1
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝².toNat
     c := ↑(ofBool (x✝ ^^^ 123#8 >ᵤ (x✝¹ ^^^ x✝¹ + -1#8) >>> x✝²)).toNat
     d := ↑(ofBool (x✝ ^^^ 123#8 != (x✝¹ ^^^ x✝¹ + -1#8) >>> x✝² &&& (x✝ ^^^ 123#8))).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 187.896830 ms, MSGSTART 
    Equality (x✝ ^^^ 123#8 != (x✝¹ ^^^ x✝¹ + 255#8) >>> x✝².toNat &&& (x✝ ^^^ 123#8)) =
      (x✝ ^^^ 123#8 >ᵤ (x✝¹ ^^^ x✝¹ + 255#8) >>> x✝².toNat) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 173.743479 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 34.897430 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 111.965749 ms, 
  TACBENCH bv_auto FAIL, TIME_ELAPSED 1122.654415 ms, MSGSTART 
    internal exception #4 MSGEND
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 246.047939 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 24.447620 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 125.871950 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 242.257118 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 45.986720 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.164230 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ d ≤ 1
      0 ≤ c ≤ 1
      c - d ≥ 1
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝².toNat
     c := ↑(ofBool (x✝ ^^^ 123#8 >ᵤ 15#8 >>> x✝²)).toNat
     d := ↑(ofBool (x✝ ^^^ 123#8 != 15#8 >>> x✝² &&& (x✝ ^^^ 123#8))).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 123.745150 ms, MSGSTART 
    Equality (x✝ ^^^ 123#8 != 15#8 >>> x✝².toNat &&& (x✝ ^^^ 123#8)) =
      (x✝ ^^^ 123#8 >ᵤ 15#8 >>> x✝².toNat) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 112.137009 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 29.313750 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 104.248080 ms, 
  TACBENCH bv_auto FAIL, TIME_ELAPSED 793.369246 ms, MSGSTART 
    internal exception #4 MSGEND
TACEND
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphandhlowbithmask_proof.lean:153:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 236.217089 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 26.381660 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 122.953890 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 207.480399 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 32.206110 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.592600 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ d ≤ 1
      0 ≤ c ≤ 1
      c - d ≥ 1
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝¹.toNat
     c := ↑(ofBool (x✝ ^^^ 123#8 >ᵤ (15#8).sshiftRight' x✝¹)).toNat
     d := ↑(ofBool (x✝ ^^^ 123#8 >ᵤ (x✝ ^^^ 123#8) &&& (15#8).sshiftRight' x✝¹)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 118.558189 ms, MSGSTART 
    Equality (x✝ ^^^ 123#8 >ᵤ (x✝ ^^^ 123#8) &&& (15#8).sshiftRight x✝¹.toNat) =
      (x✝ ^^^ 123#8 >ᵤ (15#8).sshiftRight x✝¹.toNat) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 107.247290 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 26.711919 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 101.972170 ms, 
  TACBENCH bv_auto FAIL, TIME_ELAPSED 635.751627 ms, MSGSTART 
    internal exception #4 MSGEND
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 314.920719 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 179.377319 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 331.362138 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 247.767019 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 34.699150 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.401560 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ d ≤ 1
      0 ≤ c ≤ 1
      c - d ≥ 1
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝².toNat
     c := ↑(ofBool (x✝ ^^^ 123#8 >ᵤ (x✝¹ ^^^ x✝¹ + -1#8).sshiftRight' x✝²)).toNat
     d := ↑(ofBool (x✝ ^^^ 123#8 >ᵤ (x✝ ^^^ 123#8) &&& (x✝¹ ^^^ x✝¹ + -1#8).sshiftRight' x✝²)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 179.552419 ms, MSGSTART 
    Equality (x✝ ^^^ 123#8 >ᵤ (x✝ ^^^ 123#8) &&& (x✝¹ ^^^ x✝¹ + 255#8).sshiftRight x✝².toNat) =
      (x✝ ^^^ 123#8 >ᵤ (x✝¹ ^^^ x✝¹ + 255#8).sshiftRight x✝².toNat) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 168.158320 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 31.680769 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 109.203200 ms, 
  TACBENCH bv_auto FAIL, TIME_ELAPSED 981.553766 ms, MSGSTART 
    internal exception #4 MSGEND
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 236.959809 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 26.299110 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 121.793060 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 206.857989 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 31.974000 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.619240 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ d ≤ 1
      0 ≤ c ≤ 1
      c - d ≥ 1
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝².toNat
     c := ↑(ofBool (x✝ ^^^ 123#8 >ᵤ (15#8).sshiftRight' x✝²)).toNat
     d := ↑(ofBool (x✝ ^^^ 123#8 >ᵤ (x✝ ^^^ 123#8) &&& (15#8).sshiftRight' x✝²)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 117.882149 ms, MSGSTART 
    Equality (x✝ ^^^ 123#8 >ᵤ (x✝ ^^^ 123#8) &&& (15#8).sshiftRight x✝².toNat) =
      (x✝ ^^^ 123#8 >ᵤ (15#8).sshiftRight x✝².toNat) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 106.847970 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 26.641460 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 101.278009 ms, 
  TACBENCH bv_auto FAIL, TIME_ELAPSED 635.414707 ms, MSGSTART 
    internal exception #4 MSGEND
TACEND
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphandhlowbithmask_proof.lean:167:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 300.465598 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 32.697090 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 174.495470 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 260.697598 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 35.362130 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.578780 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ d ≤ 1
      0 ≤ c ≤ 1
      c - d ≥ 1
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝.toNat
     c := ↑(ofBool (x✝¹ ^^^ 123#8 >ᵤ 2#8 <<< x✝ + -1#8)).toNat
     d := ↑(ofBool (x✝¹ ^^^ 123#8 >ᵤ 2#8 <<< x✝ + -1#8 &&& (x✝¹ ^^^ 123#8))).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 166.135670 ms, MSGSTART 
    Equality (x✝¹ ^^^ 123#8 >ᵤ 2#8 <<< x✝.toNat + 255#8 &&& (x✝¹ ^^^ 123#8)) =
      (x✝¹ ^^^ 123#8 >ᵤ 2#8 <<< x✝.toNat + 255#8) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 154.136449 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 31.900660 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 108.528059 ms, 
  TACBENCH bv_auto FAIL, TIME_ELAPSED 819.856557 ms, MSGSTART 
    internal exception #4 MSGEND
TACEND
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphandhlowbithmask_proof.lean:182:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 333.363868 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 75.847420 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 228.901349 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 331.627598 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 35.200370 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.451750 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ d ≤ 1
      0 ≤ c ≤ 1
      c - d ≥ 1
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝¹.toNat
     c := ↑(ofBool (x✝ ^^^ 65408#16 ≥ᵤ signExtend 16 (248#8 <<< x✝¹))).toNat
     d := ↑(ofBool ((signExtend 16 (248#8 <<< x✝¹) ^^^ -1#16) &&& (x✝ ^^^ 123#16) ≥ᵤ x✝ ^^^ 123#16)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 197.905449 ms, MSGSTART 
    Equality ((signExtend 16 (248#8 <<< x✝¹.toNat) ^^^ 65535#16) &&& (x✝ ^^^ 123#16) ≥ᵤ x✝ ^^^ 123#16) =
      (x✝ ^^^ 65408#16 ≥ᵤ signExtend 16 (248#8 <<< x✝¹.toNat)) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 185.554930 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 31.535919 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 109.372620 ms, 
  TACBENCH bv_auto FAIL, TIME_ELAPSED 1058.261685 ms, MSGSTART 
    internal exception #4 MSGEND
TACEND
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphandhlowbithmask_proof.lean:194:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 201.931539 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 22.918060 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 88.000370 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 243.150839 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 38.826219 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.601750 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (7#8 ≥ᵤ x✝ ^^^ 123#8)).toNat
     b := ↑(ofBool ((x✝ ^^^ 123#8) &&& 248#8 == 0#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 86.822290 ms, MSGSTART 
    Equality ((x✝ ^^^ 123#8) &&& 248#8 == 0#8) = (7#8 ≥ᵤ x✝ ^^^ 123#8) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 75.095490 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 22.229220 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 95.519789 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 775.877197 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 345.379379 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 165.882169 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 346.759788 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 304.720209 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 42.478650 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.803960 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝¹ ^^^ x✝¹ + -1#8 ≥ᵤ x✝ ^^^ 123#8)).toNat
     b := ↑(ofBool ((x✝ ^^^ 123#8) &&& (x✝¹ ^^^ 0#8 - x✝¹) == 0#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 204.825409 ms, MSGSTART 
    Equality ((x✝ ^^^ 123#8) &&& (x✝¹ ^^^ -x✝¹) == 0#8) =
      (x✝¹ ^^^ x✝¹ + 255#8 ≥ᵤ x✝ ^^^ 123#8) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 192.817229 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 33.521230 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 110.265119 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 1397.010364 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 201.968969 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 22.961770 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 88.333610 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 243.147269 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 38.522550 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.585840 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (7#8 ≥ᵤ x✝ ^^^ 123#8)).toNat
     b := ↑(ofBool ((x✝ ^^^ 123#8) &&& 248#8 == 0#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 86.473389 ms, MSGSTART 
    Equality ((x✝ ^^^ 123#8) &&& 248#8 == 0#8) = (7#8 ≥ᵤ x✝ ^^^ 123#8) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 75.404350 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 21.993080 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 95.278969 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 777.535867 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 202.486769 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 23.000840 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 88.420589 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 243.792209 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 38.705020 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.587910 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (7#8 ≥ᵤ x✝ ^^^ 123#8)).toNat
     b := ↑(ofBool (248#8 &&& (x✝ ^^^ 123#8) == 0#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 86.923130 ms, MSGSTART 
    Equality (248#8 &&& (x✝ ^^^ 123#8) == 0#8) = (7#8 ≥ᵤ x✝ ^^^ 123#8) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 75.630149 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 21.995230 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 95.288880 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 780.582896 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 344.633568 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 165.465029 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 345.230869 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 305.107939 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 42.468339 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.787510 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ ^^^ x✝ + -1#8 ≥ᵤ x✝¹ ^^^ 123#8)).toNat
     b := ↑(ofBool ((x✝ ^^^ 0#8 - x✝) &&& (x✝¹ ^^^ 123#8) == 0#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 203.873820 ms, MSGSTART 
    Equality ((x✝ ^^^ -x✝) &&& (x✝¹ ^^^ 123#8) == 0#8) = (x✝ ^^^ x✝ + 255#8 ≥ᵤ x✝¹ ^^^ 123#8) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 191.554219 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 33.479730 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 109.049369 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 1399.989584 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 202.829499 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 23.175850 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 88.674929 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 244.788299 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 38.789880 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.650260 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (7#8 ≥ᵤ x✝¹ ^^^ 123#8)).toNat
     b := ↑(ofBool (248#8 &&& (x✝¹ ^^^ 123#8) == 0#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 86.995000 ms, MSGSTART 
    Equality (248#8 &&& (x✝¹ ^^^ 123#8) == 0#8) = (7#8 ≥ᵤ x✝¹ ^^^ 123#8) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 75.467499 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 21.948110 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 95.521470 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 781.195137 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.644270 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some (ofBool (((-1#8) >>> x✝ <<< x✝ ^^^ -1#8) &&& (x✝¹ ^^^ 123#8) == x✝¹ ^^^ 123#8)) ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 20.002500 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 249.331529 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 279.590898 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 33.493220 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 11.137160 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ c ≤ 254
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝.toNat
     c := ↑(((-1#8) <<< x✝).sshiftRight' x✝).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 248.727759 ms, MSGSTART 
    Unsupported syntax some (ofBool ((255#8 &&& 255#8 <<< x✝.toNat ^^^ 255#8) &&& (x✝¹ ^^^ 123#8) == x✝¹ ^^^ 123#8)) ⊑
      none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.const `BitVec.ofBool [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `BEq.beq [Lean.Level.zero])
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 8)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `instBEqOfDecidableEq [Lean.Level.zero])
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                    (Lean.Expr.app
                      (Lean.Expr.const `instDecidableEqBitVec [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 8)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `HAnd.hAnd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 8)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `instHAndOfAndOp [Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 8)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec.instAndOp [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.const `HXor.hXor [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                                (Lean.Expr.app
                                  (Lean.Expr.const `BitVec [])
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.app
                                        (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                        (Lean.Expr.const `Nat []))
                                      (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                    (Lean.Expr.app
                                      (Lean.Expr.const `instOfNatNat [])
                                      (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                              (Lean.Expr.app
                                (Lean.Expr.const `BitVec [])
                                (Lean.Expr.app
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                      (Lean.Expr.const `Nat []))
                                    (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                  (Lean.Expr.app
                                    (Lean.Expr.const `instOfNatNat [])
                                    (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.const `instHXorOfXor [Lean.Level.zero])
                              (Lean.Expr.app
                                (Lean.Expr.const `BitVec [])
                                (Lean.Expr.app
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                      (Lean.Expr.const `Nat []))
                                    (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                  (Lean.Expr.app
                                    (Lean.Expr.const `instOfNatNat [])
                                    (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec.instXor [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 8)))))))
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app
                                    (Lean.Expr.const `HAnd.hAnd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                                    (Lean.Expr.app
                                      (Lean.Expr.const `BitVec [])
                                      (Lean.Expr.app
                                        (Lean.Expr.app
                                          (Lean.Expr.app
                                            (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                            (Lean.Expr.const `Nat []))
                                          (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                        (Lean.Expr.app
                                          (Lean.Expr.const `instOfNatNat [])
                                          (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                                  (Lean.Expr.app
                                    (Lean.Expr.const `BitVec [])
                                    (Lean.Expr.app
                                      (Lean.Expr.app
                                        (Lean.Expr.app
                                          (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                          (Lean.Expr.const `Nat []))
                                        (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                      (Lean.Expr.app
                                        (Lean.Expr.const `instOfNatNat [])
                                        (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                                (Lean.Expr.app
                                  (Lean.Expr.const `BitVec [])
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.app
                                        (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                        (Lean.Expr.const `Nat []))
                                      (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                    (Lean.Expr.app
                                      (Lean.Expr.const `instOfNatNat [])
                                      (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.const `instHAndOfAndOp [Lean.Level.zero])
                                  (Lean.Expr.app
                                    (Lean.Expr.const `BitVec [])
                                    (Lean.Expr.app
                                      (Lean.Expr.app
                                        (Lean.Expr.app
                                          (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                          (Lean.Expr.const `Nat []))
                                        (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                      (Lean.Expr.app
                                        (Lean.Expr.const `instOfNatNat [])
                                        (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                                (Lean.Expr.app
                                  (Lean.Expr.const `BitVec.instAndOp [])
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.app
                                        (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                        (Lean.Expr.const `Nat []))
                                      (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                    (Lean.Expr.app
                                      (Lean.Expr.const `instOfNatNat [])
                                      (Lean.Expr.lit (Lean.Literal.natVal 8)))))))
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.const `BitVec.ofNat [])
                                (Lean.Expr.app
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                      (Lean.Expr.const `Nat []))
                                    (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                  (Lean.Expr.app
                                    (Lean.Expr.const `instOfNatNat [])
                                    (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 255)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 255))))))
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.const
                                        `HShiftLeft.hShiftLeft
                                        [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                                      (Lean.Expr.app
                                        (Lean.Expr.const `BitVec [])
                                        (Lean.Expr.app
                                          (Lean.Expr.app
                                            (Lean.Expr.app
                                              (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                              (Lean.Expr.const `Nat []))
                                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                          (Lean.Expr.app
                                            (Lean.Expr.const `instOfNatNat [])
                                            (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                                    (Lean.Expr.const `Nat []))
                                  (Lean.Expr.app
                                    (Lean.Expr.const `BitVec [])
                                    (Lean.Expr.app
                                      (Lean.Expr.app
                                        (Lean.Expr.app
                                          (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                          (Lean.Expr.const `Nat []))
                                        (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                      (Lean.Expr.app
                                        (Lean.Expr.const `instOfNatNat [])
                                        (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                                (Lean.Expr.app
                                  (Lean.Expr.const `BitVec.instHShiftLeftNat [])
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.app
                                        (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                        (Lean.Expr.const `Nat []))
                                      (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                    (Lean.Expr.app
                                      (Lean.Expr.const `instOfNatNat [])
                                      (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.const `BitVec.ofNat [])
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.app
                                        (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                        (Lean.Expr.const `Nat []))
                                      (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                    (Lean.Expr.app
                                      (Lean.Expr.const `instOfNatNat [])
                                      (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                                (Lean.Expr.app
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                      (Lean.Expr.const `Nat []))
                                    (Lean.Expr.lit (Lean.Literal.natVal 255)))
                                  (Lean.Expr.app
                                    (Lean.Expr.const `instOfNatNat [])
                                    (Lean.Expr.lit (Lean.Literal.natVal 255))))))
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.const `BitVec.toNat [])
                                (Lean.Expr.app
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                      (Lean.Expr.const `Nat []))
                                    (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                  (Lean.Expr.app
                                    (Lean.Expr.const `instOfNatNat [])
                                    (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                              (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 4396246))))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec.ofNat [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 255)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 255)))))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.const `HXor.hXor [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                              (Lean.Expr.app
                                (Lean.Expr.const `BitVec [])
                                (Lean.Expr.app
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                      (Lean.Expr.const `Nat []))
                                    (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                  (Lean.Expr.app
                                    (Lean.Expr.const `instOfNatNat [])
                                    (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 8)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `instHXorOfXor [Lean.Level.zero])
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec.instXor [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 8)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))))
                      (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 4396245)))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.ofNat [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 123)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 123))))))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `HXor.hXor [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 8)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `instHXorOfXor [Lean.Level.zero])
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.instXor [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))))
                  (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 4396245)))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `BitVec.ofNat [])
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 8)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 123)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 123))))))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 235.163299 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 31.571210 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 98.475880 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 1064.978315 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 429.697318 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 32.777790 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 301.969329 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 283.081499 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 42.800450 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 8.691100 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ d ≤ 1
      0 ≤ c ≤ 1
      c - d ≥ 1
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝.toNat
     c := ↑(ofBool (x✝¹ ^^^ 132#8 ≥ᵤ (-1#8) <<< x✝)).toNat
     d := ↑(ofBool (((-1#8) >>> x✝ <<< x✝ ^^^ -1#8) &&& (x✝¹ ^^^ 123#8) == x✝¹ ^^^ 123#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 294.971739 ms, MSGSTART 
    Equality ((255#8 &&& 255#8 <<< x✝.toNat ^^^ 255#8) &&& (x✝¹ ^^^ 123#8) == x✝¹ ^^^ 123#8) =
      (x✝¹ ^^^ 132#8 ≥ᵤ 255#8 <<< x✝.toNat) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 281.211619 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 42.866550 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 123.015599 ms, 
  TACBENCH bv_auto FAIL, TIME_ELAPSED 1175.400775 ms, MSGSTART 
    internal exception #4 MSGEND
TACEND
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphandhlowbithmask_proof.lean:234:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 375.616699 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 33.261380 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 224.082989 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 278.115248 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 50.005780 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.909280 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ e ≤ 1
      0 ≤ d ≤ 1
      d - e ≥ 1
      0 ≤ c ≤ 255
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
      a - c ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝.toNat
     c := ↑x✝¹.toNat
     d := ↑(ofBool ((x✝² ^^^ 123#8) &&& (-1#8) >>> x✝ <<< x✝¹ == 0#8)).toNat
     e := ↑(ofBool (((-1#8) >>> x✝ <<< x✝¹ ^^^ -1#8) &&& (x✝² ^^^ 123#8) == x✝² ^^^ 123#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 288.433539 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.binop AutoStructs.Binop.equiv
            (AutoStructs.Formula.atom AutoStructs.Relation.eq
              (((AutoStructs.Term.var 0).xor (AutoStructs.Term.var 1)).and
                ((AutoStructs.Term.var 2).xor (AutoStructs.Term.var 3)))
              ((AutoStructs.Term.var 2).xor (AutoStructs.Term.var 3)))
            (AutoStructs.Formula.atom AutoStructs.Relation.eq
              (((AutoStructs.Term.var 2).xor (AutoStructs.Term.var 3)).and (AutoStructs.Term.var 0))
              AutoStructs.Term.zero)) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 209.569099 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 43.180140 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 120.958619 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 953.552126 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 371.924449 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 183.260579 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 316.485748 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 363.951039 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 42.506640 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.846630 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ f ≤ 1
      0 ≤ e ≤ 1
      e - f ≥ 1
      0 ≤ d ≤ 65535
      0 ≤ c ≤ 65535
      c - d ≥ 1
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝¹.toNat
     c := ↑(↑16).toNat
     d := ↑x✝².toNat
     e := ↑(ofBool (x✝ ^^^ 65412#16 ≥ᵤ (signExtend 16 (224#8 <<< x✝¹)).sshiftRight' x✝²)).toNat
     f := ↑(ofBool
          (x✝ ^^^ 123#16 ==
            (x✝ ^^^ 123#16) &&& ((signExtend 16 (224#8 <<< x✝¹)).sshiftRight' x✝² ^^^ -1#16))).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 229.712829 ms, MSGSTART 
    Equality (x✝ ^^^ 123#16 ==
        (x✝ ^^^ 123#16) &&& ((signExtend 16 (224#8 <<< x✝¹.toNat)).sshiftRight x✝².toNat ^^^ 65535#16)) =
      (x✝ ^^^ 65412#16 ≥ᵤ (signExtend 16 (224#8 <<< x✝¹.toNat)).sshiftRight x✝².toNat) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 216.754609 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 39.619460 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 124.015999 ms, 
  TACBENCH bv_auto FAIL, TIME_ELAPSED 1489.068403 ms, MSGSTART 
    internal exception #4 MSGEND
TACEND
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphandhlowbithmask_proof.lean:262:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 323.908019 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 33.842090 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 204.349759 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 350.570118 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 41.953900 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.735650 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝¹ ^^^ 132#8 ≥ᵤ x✝ ||| 0#8 - x✝)).toNat
     b := ↑(ofBool (0#8 == 0#8 - (0#8 - x✝ &&& x✝) &&& (x✝¹ ^^^ 123#8))).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 194.440109 ms, MSGSTART 
    Equality (0#8 == -(-x✝ &&& x✝) &&& (x✝¹ ^^^ 123#8)) = (x✝¹ ^^^ 132#8 ≥ᵤ x✝ ||| -x✝) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 182.252549 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 37.547650 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 114.004820 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 1185.246315 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 201.137119 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 74.792270 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 103.129749 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 208.306069 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 114.831150 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.263000 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (0#8 >ₛ x✝)).toNat
     b := ↑(ofBool ((x✝ ^^^ 123#8) &&& 7#8 >ₛ x✝ ^^^ 123#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 75.342029 ms, MSGSTART 
    Equality ((x✝ ^^^ 123#8) &&& 7#8 >ₛ x✝ ^^^ 123#8) = (0#8 >ₛ x✝) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 64.244900 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 30.707170 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 105.653790 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 738.545546 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 191.965459 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 75.936800 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 95.815580 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 206.437099 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 89.909039 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.263630 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ ^^^ 123#8 >ₛ 7#8)).toNat
     b := ↑(ofBool (x✝ ^^^ 123#8 >ₛ (x✝ ^^^ 123#8) &&& 7#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 68.085000 ms, MSGSTART 
    Equality (x✝ ^^^ 123#8 >ₛ (x✝ ^^^ 123#8) &&& 7#8) = (x✝ ^^^ 123#8 >ₛ 7#8) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 57.058970 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 29.871930 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 104.653779 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 686.656147 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 240.061969 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 63.318830 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 123.094600 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 243.394689 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 114.558429 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.456070 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ >ₛ -1#8)).toNat
     b := ↑(ofBool (x✝ ^^^ 123#8 ≥ₛ (x✝ ^^^ 123#8) &&& 31#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 101.293090 ms, MSGSTART 
    Equality (x✝ ^^^ 123#8 ≥ₛ (x✝ ^^^ 123#8) &&& 31#8) = (x✝ >ₛ 255#8) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 89.984369 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 31.750490 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 106.142710 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 760.281206 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 201.229569 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 67.960830 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 100.031450 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 211.863469 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 90.723839 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.305650 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (32#8 >ₛ x✝ ^^^ 123#8)).toNat
     b := ↑(ofBool ((x✝ ^^^ 123#8) &&& 31#8 ≥ₛ x✝ ^^^ 123#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 75.795510 ms, MSGSTART 
    Equality ((x✝ ^^^ 123#8) &&& 31#8 ≥ₛ x✝ ^^^ 123#8) = (32#8 >ₛ x✝ ^^^ 123#8) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 64.406150 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 30.980260 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 105.968649 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 704.414727 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 178.529260 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 24.418170 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 84.655739 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 226.957409 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 29.159050 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.484440 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 50.056300 ms, MSGSTART 
    no goals to be solved MSGEND
  TACBENCH simp PASS, TIME_ELAPSED 83.494460 ms, 
  TACBENCH bv_normalize PASS, TIME_ELAPSED 5.328030 ms, 
  TACBENCH bv_decide PASS, TIME_ELAPSED 5.007039 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 87.878250 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.645380 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some (ofBool (0#8 == x✝ &&& 0#8)) ⊑ none MSGEND
  TACBENCH bv_ac PASS, TIME_ELAPSED 11.205430 ms, 
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 87.381419 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 223.218769 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 28.393450 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.577140 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 96.081340 ms, MSGSTART 
    Unsupported syntax some 1#1 ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.const `BitVec.ofNat [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 85.334389 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize PASS, TIME_ELAPSED 4.896750 ms, 
  TACBENCH bv_decide PASS, TIME_ELAPSED 4.396700 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 203.246830 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 230.704639 ms, 
  TACBENCH bv_ac PASS, TIME_ELAPSED 13.301790 ms, 
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 118.426089 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 266.297059 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 31.418160 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 8.229680 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝.toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 118.780169 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0)
            ((AutoStructs.Term.var 1).and (AutoStructs.Term.var 0))) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 111.242360 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize PASS, TIME_ELAPSED 9.965250 ms, 
  TACBENCH bv_decide PASS, TIME_ELAPSED 9.555340 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 412.006648 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.748560 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some (ofBool ((-1#8) <<< x✝ == x✝¹ &&& (-1#8) <<< x✝)) ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 14.362040 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 111.895659 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 264.294219 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 30.316240 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 12.756530 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ c ≤ 254
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝.toNat
     c := ↑(((-1#8) <<< x✝).sshiftRight' x✝).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 116.402609 ms, MSGSTART 
    Unsupported syntax some (ofBool (255#8 <<< x✝.toNat == x✝¹ &&& 255#8 <<< x✝.toNat)) ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.const `BitVec.ofBool [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `BEq.beq [Lean.Level.zero])
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 8)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `instBEqOfDecidableEq [Lean.Level.zero])
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                    (Lean.Expr.app
                      (Lean.Expr.const `instDecidableEqBitVec [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 8)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `HShiftLeft.hShiftLeft [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                          (Lean.Expr.const `Nat []))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.instHShiftLeftNat [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.ofNat [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 255)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 255))))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec.toNat [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 8)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                    (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 5745108)))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `HAnd.hAnd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 8)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `instHAndOfAndOp [Lean.Level.zero])
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.instAndOp [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))))
                  (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 5745107)))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `HShiftLeft.hShiftLeft [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                          (Lean.Expr.const `Nat []))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.instHShiftLeftNat [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.ofNat [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 255)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 255))))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec.toNat [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 8)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                    (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 5745108)))))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 104.440560 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 29.921950 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 97.271259 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 841.353597 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 276.720878 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 36.742840 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 131.164300 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 262.821869 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 38.314710 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 9.958889 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ d ≤ 1
      0 ≤ c ≤ 1
      c - d ≥ 1
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝.toNat
     c := ↑(ofBool (x✝¹ ≥ᵤ (-1#8) <<< x✝)).toNat
     d := ↑(ofBool ((-1#8) <<< x✝ == x✝¹ &&& (-1#8) <<< x✝)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 129.286150 ms, MSGSTART 
    Equality (255#8 <<< x✝.toNat == x✝¹ &&& 255#8 <<< x✝.toNat) = (x✝¹ ≥ᵤ 255#8 <<< x✝.toNat) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 118.005599 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 40.061410 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 118.922600 ms, 
  TACBENCH bv_auto FAIL, TIME_ELAPSED 740.469516 ms, MSGSTART 
    internal exception #4 MSGEND
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 181.291989 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 24.377800 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 84.663980 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 227.444299 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 29.298649 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.490950 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 49.868470 ms, MSGSTART 
    no goals to be solved MSGEND
  TACBENCH simp PASS, TIME_ELAPSED 83.117790 ms, 
  TACBENCH bv_normalize PASS, TIME_ELAPSED 5.316380 ms, 
  TACBENCH bv_decide PASS, TIME_ELAPSED 5.018930 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 87.896659 ms, 
TACEND
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphandhlowbithmask_proof.lean:335:95: error: (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.
Additional diagnostic information may be available using the `set_option diagnostics true` command.
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 126.614469 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 18.000330 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 82.049870 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 222.721609 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 34.509580 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.698459 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 50.650930 ms, MSGSTART 
    no goals to be solved MSGEND
  TACBENCH simp PASS, TIME_ELAPSED 80.930350 ms, 
  TACBENCH bv_normalize PASS, TIME_ELAPSED 4.111070 ms, 
  TACBENCH bv_decide PASS, TIME_ELAPSED 3.918710 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 85.920490 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.636950 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some (ofBool (x✝ &&& (-1#8) <<< x✝¹ != (-1#8) <<< x✝¹)) ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 13.587830 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 110.016390 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 263.839909 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 35.320049 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 10.195780 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ c ≤ 254
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝¹.toNat
     c := ↑(((-1#8) <<< x✝¹).sshiftRight' x✝¹).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 114.228690 ms, MSGSTART 
    Unsupported syntax some (ofBool (x✝ &&& 255#8 <<< x✝¹.toNat != 255#8 <<< x✝¹.toNat)) ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.const `BitVec.ofBool [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `bne [Lean.Level.zero])
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 8)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `instBEqOfDecidableEq [Lean.Level.zero])
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                    (Lean.Expr.app
                      (Lean.Expr.const `instDecidableEqBitVec [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 8)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `HAnd.hAnd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 8)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `instHAndOfAndOp [Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 8)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec.instAndOp [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))))
                    (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 6254588)))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.const `HShiftLeft.hShiftLeft [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                              (Lean.Expr.app
                                (Lean.Expr.const `BitVec [])
                                (Lean.Expr.app
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                      (Lean.Expr.const `Nat []))
                                    (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                  (Lean.Expr.app
                                    (Lean.Expr.const `instOfNatNat [])
                                    (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                            (Lean.Expr.const `Nat []))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 8)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec.instHShiftLeftNat [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec.ofNat [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 255)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 255))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.toNat [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                      (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 6254586))))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `HShiftLeft.hShiftLeft [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 8)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                        (Lean.Expr.const `Nat []))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec.instHShiftLeftNat [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 8)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec.ofNat [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 8)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 255)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 255))))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `BitVec.toNat [])
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 8)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                  (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 6254586))))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 102.062199 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 28.139900 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 95.082980 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 840.200116 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 272.418599 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 24.463750 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 128.850739 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 265.804059 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 44.854610 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.424450 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ d ≤ 1
      0 ≤ c ≤ 1
      c - d ≥ 1
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝¹.toNat
     c := ↑(ofBool ((-1#8) <<< x✝¹ >ᵤ x✝)).toNat
     d := ↑(ofBool (x✝ &&& (-1#8) <<< x✝¹ != (-1#8) <<< x✝¹)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 128.216869 ms, MSGSTART 
    Equality (x✝ &&& 255#8 <<< x✝¹.toNat != 255#8 <<< x✝¹.toNat) = (255#8 <<< x✝¹.toNat >ᵤ x✝) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 116.236500 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 37.609260 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 115.935399 ms, 
  TACBENCH bv_auto FAIL, TIME_ELAPSED 743.801577 ms, MSGSTART 
    internal exception #4 MSGEND
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 129.500750 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 18.120490 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 82.155349 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 222.770089 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 34.430540 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.431940 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 50.804650 ms, MSGSTART 
    no goals to be solved MSGEND
  TACBENCH simp PASS, TIME_ELAPSED 80.715040 ms, 
  TACBENCH bv_normalize PASS, TIME_ELAPSED 4.160370 ms, 
  TACBENCH bv_decide PASS, TIME_ELAPSED 3.928060 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 85.576029 ms, 
TACEND
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphandhlowbithmask_proof.lean:344:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 126.689260 ms, 
  TACBENCH bv_ac PASS, TIME_ELAPSED 10.605450 ms, 
  TACBENCH bv_distrib PASS, TIME_ELAPSED 81.431020 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 191.604489 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 17.783510 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.086310 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 48.426750 ms, MSGSTART 
    no goals to be solved MSGEND
  TACBENCH simp PASS, TIME_ELAPSED 80.277210 ms, 
  TACBENCH bv_normalize PASS, TIME_ELAPSED 4.390960 ms, 
  TACBENCH bv_decide PASS, TIME_ELAPSED 4.138850 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 84.879179 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.625530 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some (ofBool ((-1#8) <<< x✝¹ >ᵤ x✝ &&& (-1#8) <<< x✝¹)) ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 12.852920 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 107.201399 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 234.639229 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 18.928050 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 10.036710 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ c ≤ 254
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝¹.toNat
     c := ↑(((-1#8) <<< x✝¹).sshiftRight' x✝¹).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 112.108050 ms, MSGSTART 
    Unsupported syntax some (ofBool (255#8 <<< x✝¹.toNat >ᵤ x✝ &&& 255#8 <<< x✝¹.toNat)) ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.const `BitVec.ofBool [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `BitVec.ult [])
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 8)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `HAnd.hAnd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 8)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `instHAndOfAndOp [Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 8)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec.instAndOp [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))))
                    (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 6569105)))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.const `HShiftLeft.hShiftLeft [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                              (Lean.Expr.app
                                (Lean.Expr.const `BitVec [])
                                (Lean.Expr.app
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                      (Lean.Expr.const `Nat []))
                                    (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                  (Lean.Expr.app
                                    (Lean.Expr.const `instOfNatNat [])
                                    (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                            (Lean.Expr.const `Nat []))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 8)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec.instHShiftLeftNat [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec.ofNat [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 255)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 255))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.toNat [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                      (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 6569103))))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `HShiftLeft.hShiftLeft [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 8)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                        (Lean.Expr.const `Nat []))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec.instHShiftLeftNat [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 8)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec.ofNat [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 8)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 255)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 255))))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `BitVec.toNat [])
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 8)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                  (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 6569103))))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 99.937799 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 25.999500 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 93.334460 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 751.380027 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 268.279549 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 27.236580 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 126.575359 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 232.926679 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 31.437380 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.102010 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ d ≤ 1
      0 ≤ c ≤ 1
      c - d ≥ 1
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝¹.toNat
     c := ↑(ofBool ((-1#8) <<< x✝¹ >ᵤ x✝)).toNat
     d := ↑(ofBool ((-1#8) <<< x✝¹ >ᵤ x✝ &&& (-1#8) <<< x✝¹)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 124.473839 ms, MSGSTART 
    Equality (255#8 <<< x✝¹.toNat >ᵤ x✝ &&& 255#8 <<< x✝¹.toNat) = (255#8 <<< x✝¹.toNat >ᵤ x✝) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 113.229060 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 35.350200 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 114.481989 ms, 
  TACBENCH bv_auto FAIL, TIME_ELAPSED 620.998247 ms, MSGSTART 
    internal exception #4 MSGEND
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 128.430860 ms, 
  TACBENCH bv_ac PASS, TIME_ELAPSED 10.663840 ms, 
  TACBENCH bv_distrib PASS, TIME_ELAPSED 81.406679 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 191.716080 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 17.705509 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.246210 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 48.487480 ms, MSGSTART 
    no goals to be solved MSGEND
  TACBENCH simp PASS, TIME_ELAPSED 79.984550 ms, 
  TACBENCH bv_normalize PASS, TIME_ELAPSED 4.373700 ms, 
  TACBENCH bv_decide PASS, TIME_ELAPSED 4.101770 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 84.983349 ms, 
TACEND
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphandhlowbithmask_proof.lean:357:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 177.654269 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 22.059830 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 83.529679 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 197.087649 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 17.763700 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.289410 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 48.272520 ms, MSGSTART 
    no goals to be solved MSGEND
  TACBENCH simp PASS, TIME_ELAPSED 82.200070 ms, 
  TACBENCH bv_normalize PASS, TIME_ELAPSED 6.352550 ms, 
  TACBENCH bv_decide PASS, TIME_ELAPSED 5.976620 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 86.931879 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.642460 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some (ofBool (x✝ &&& 0#8 ≥ᵤ 0#8)) ⊑ none MSGEND
  TACBENCH bv_ac PASS, TIME_ELAPSED 10.699790 ms, 
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 85.658150 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 191.961529 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 17.055810 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.465420 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 94.344719 ms, MSGSTART 
    Unsupported syntax some 1#1 ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.const `BitVec.ofNat [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 84.497410 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize PASS, TIME_ELAPSED 4.921130 ms, 
  TACBENCH bv_decide PASS, TIME_ELAPSED 4.351640 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 202.829329 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 227.095029 ms, 
  TACBENCH bv_ac PASS, TIME_ELAPSED 12.975460 ms, 
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 116.493490 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 236.197369 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 19.285670 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.986780 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝¹.toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 117.467809 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom (AutoStructs.Relation.unsigned AutoStructs.RelationOrdering.le)
            (AutoStructs.Term.var 0) ((AutoStructs.Term.var 1).and (AutoStructs.Term.var 0))) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 107.388300 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize PASS, TIME_ELAPSED 10.192810 ms, 
  TACBENCH bv_decide PASS, TIME_ELAPSED 9.576170 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 255.824458 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.614620 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some (ofBool (x✝ &&& (-1#8) <<< x✝¹ ≥ᵤ (-1#8) <<< x✝¹)) ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 12.932419 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 108.495960 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 232.979349 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 18.773890 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 12.519930 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ c ≤ 254
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝¹.toNat
     c := ↑(((-1#8) <<< x✝¹).sshiftRight' x✝¹).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 113.286529 ms, MSGSTART 
    Unsupported syntax some (ofBool (x✝ &&& 255#8 <<< x✝¹.toNat ≥ᵤ 255#8 <<< x✝¹.toNat)) ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.const `BitVec.ofBool [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `BitVec.ule [])
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 8)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `HShiftLeft.hShiftLeft [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                          (Lean.Expr.const `Nat []))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.instHShiftLeftNat [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.ofNat [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 255)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 255))))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec.toNat [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 8)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                    (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 6853436)))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `HAnd.hAnd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 8)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `instHAndOfAndOp [Lean.Level.zero])
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.instAndOp [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))))
                  (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 6853438)))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `HShiftLeft.hShiftLeft [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                          (Lean.Expr.const `Nat []))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.instHShiftLeftNat [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.ofNat [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 255)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 255))))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec.toNat [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 8)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                    (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 6853436)))))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 101.219810 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 28.143650 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 95.682859 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 761.333847 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 272.912169 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 34.879230 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 127.470919 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 233.178419 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 31.600380 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 9.714550 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ d ≤ 1
      0 ≤ c ≤ 1
      c - d ≥ 1
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝¹.toNat
     c := ↑(ofBool (x✝ ≥ᵤ (-1#8) <<< x✝¹)).toNat
     d := ↑(ofBool (x✝ &&& (-1#8) <<< x✝¹ ≥ᵤ (-1#8) <<< x✝¹)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 125.866140 ms, MSGSTART 
    Equality (x✝ &&& 255#8 <<< x✝¹.toNat ≥ᵤ 255#8 <<< x✝¹.toNat) = (x✝ ≥ᵤ 255#8 <<< x✝¹.toNat) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 114.689089 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 38.053250 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 118.548890 ms, 
  TACBENCH bv_auto FAIL, TIME_ELAPSED 631.226457 ms, MSGSTART 
    internal exception #4 MSGEND
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 179.458459 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 22.080340 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 83.409279 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 198.053349 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 17.840440 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.284900 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 48.136060 ms, MSGSTART 
    no goals to be solved MSGEND
  TACBENCH simp PASS, TIME_ELAPSED 81.929550 ms, 
  TACBENCH bv_normalize PASS, TIME_ELAPSED 6.348950 ms, 
  TACBENCH bv_decide PASS, TIME_ELAPSED 5.947140 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 86.496829 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.626520 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some (ofBool (x✝ &&& 0#8 ≥ᵤ 0#8)) ⊑ none MSGEND
  TACBENCH bv_ac PASS, TIME_ELAPSED 10.606410 ms, 
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 86.105690 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 193.067989 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 17.207770 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 10.898630 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ a ≤ 254
    where
     a := ↑(((-1#8) <<< x✝¹).sshiftRight' x✝¹).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 94.974609 ms, MSGSTART 
    Unsupported syntax some 1#1 ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.const `BitVec.ofNat [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 84.250560 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize PASS, TIME_ELAPSED 4.954700 ms, 
  TACBENCH bv_decide PASS, TIME_ELAPSED 4.404550 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 202.361149 ms, 
TACEND
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphandhlowbithmask_proof.lean:374:95: error: (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.
Additional diagnostic information may be available using the `set_option diagnostics true` command.
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.636980 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some (ofBool ((-1#8) <<< x✝¹ >ₛ x✝ &&& (-1#8) <<< x✝¹)) ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 12.846680 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 108.651110 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 237.124849 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 39.134520 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 10.147569 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ c ≤ 254
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝¹.toNat
     c := ↑(((-1#8) <<< x✝¹).sshiftRight' x✝¹).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 113.510110 ms, MSGSTART 
    Unsupported syntax some (ofBool (255#8 <<< x✝¹.toNat >ₛ x✝ &&& 255#8 <<< x✝¹.toNat)) ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.const `BitVec.ofBool [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `BitVec.slt [])
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 8)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `HAnd.hAnd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 8)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `instHAndOfAndOp [Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 8)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec.instAndOp [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))))
                    (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 7300425)))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.const `HShiftLeft.hShiftLeft [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                              (Lean.Expr.app
                                (Lean.Expr.const `BitVec [])
                                (Lean.Expr.app
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                      (Lean.Expr.const `Nat []))
                                    (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                  (Lean.Expr.app
                                    (Lean.Expr.const `instOfNatNat [])
                                    (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                            (Lean.Expr.const `Nat []))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 8)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec.instHShiftLeftNat [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec.ofNat [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 255)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 255))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.toNat [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                      (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 7300424))))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `HShiftLeft.hShiftLeft [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 8)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                        (Lean.Expr.const `Nat []))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec.instHShiftLeftNat [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 8)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec.ofNat [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 8)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 255)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 255))))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `BitVec.toNat [])
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 8)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                  (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 7300424))))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 101.921140 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 33.425829 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 100.560390 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 784.194927 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 282.525409 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 79.030369 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 152.255920 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 234.337969 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 96.287069 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.202870 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ d ≤ 1
      0 ≤ c ≤ 1
      c - d ≥ 1
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝¹.toNat
     c := ↑(ofBool ((-1#8) <<< x✝¹ >ₛ x✝)).toNat
     d := ↑(ofBool ((-1#8) <<< x✝¹ >ₛ x✝ &&& (-1#8) <<< x✝¹)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 126.229240 ms, MSGSTART 
    Equality (255#8 <<< x✝¹.toNat >ₛ x✝ &&& 255#8 <<< x✝¹.toNat) = (255#8 <<< x✝¹.toNat >ₛ x✝) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 114.241359 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 47.866650 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 129.650419 ms, 
  TACBENCH bv_auto FAIL, TIME_ELAPSED 774.971797 ms, MSGSTART 
    internal exception #4 MSGEND
TACEND
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphandhlowbithmask_proof.lean:383:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.637550 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some (ofBool (x✝ &&& (-1#8) <<< x✝¹ ≥ₛ (-1#8) <<< x✝¹)) ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 12.493110 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 108.030180 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 236.673518 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 38.988100 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 9.994310 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ c ≤ 254
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝¹.toNat
     c := ↑(((-1#8) <<< x✝¹).sshiftRight' x✝¹).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 112.323080 ms, MSGSTART 
    Unsupported syntax some (ofBool (x✝ &&& 255#8 <<< x✝¹.toNat ≥ₛ 255#8 <<< x✝¹.toNat)) ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.const `BitVec.ofBool [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `BitVec.sle [])
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 8)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `HShiftLeft.hShiftLeft [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                          (Lean.Expr.const `Nat []))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.instHShiftLeftNat [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.ofNat [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 255)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 255))))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec.toNat [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 8)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                    (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 7513807)))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `HAnd.hAnd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 8)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `instHAndOfAndOp [Lean.Level.zero])
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.instAndOp [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))))
                  (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 7513808)))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `HShiftLeft.hShiftLeft [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                          (Lean.Expr.const `Nat []))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.instHShiftLeftNat [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.ofNat [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 255)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 255))))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec.toNat [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 8)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                    (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 7513807)))))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 101.166139 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 33.792290 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 101.916370 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 786.420876 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 282.797958 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 48.160210 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 137.991330 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 233.312459 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 97.017189 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.124390 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ d ≤ 1
      0 ≤ c ≤ 1
      c - d ≥ 1
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝¹.toNat
     c := ↑(ofBool (x✝ ≥ₛ (-1#8) <<< x✝¹)).toNat
     d := ↑(ofBool (x✝ &&& (-1#8) <<< x✝¹ ≥ₛ (-1#8) <<< x✝¹)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 126.020570 ms, MSGSTART 
    Equality (x✝ &&& 255#8 <<< x✝¹.toNat ≥ₛ 255#8 <<< x✝¹.toNat) = (x✝ ≥ₛ 255#8 <<< x✝¹.toNat) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 114.582209 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 49.560830 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 131.617029 ms, 
  TACBENCH bv_auto FAIL, TIME_ELAPSED 734.272327 ms, MSGSTART 
    internal exception #4 MSGEND
TACEND
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphandhlowbithmask_proof.lean:394:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.667530 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some (ofBool ((-1#8) <<< x✝¹ >ₛ x✝ &&& (-1#8) <<< x✝¹)) ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 12.813490 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 107.957569 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 234.417109 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 38.838350 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 10.027780 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ c ≤ 254
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝¹.toNat
     c := ↑(((-1#8) <<< x✝¹).sshiftRight' x✝¹).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 112.952480 ms, MSGSTART 
    Unsupported syntax some (ofBool (255#8 <<< x✝¹.toNat >ₛ x✝ &&& 255#8 <<< x✝¹.toNat)) ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.const `BitVec.ofBool [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `BitVec.slt [])
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 8)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `HAnd.hAnd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 8)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `instHAndOfAndOp [Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 8)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec.instAndOp [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))))
                    (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 7741273)))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.const `HShiftLeft.hShiftLeft [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                              (Lean.Expr.app
                                (Lean.Expr.const `BitVec [])
                                (Lean.Expr.app
                                  (Lean.Expr.app
                                    (Lean.Expr.app
                                      (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero])
                                      (Lean.Expr.const `Nat []))
                                    (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                  (Lean.Expr.app
                                    (Lean.Expr.const `instOfNatNat [])
                                    (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                            (Lean.Expr.const `Nat []))
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 8)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec.instHShiftLeftNat [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec.ofNat [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 255)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 255))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.toNat [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                      (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 7741271))))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `HShiftLeft.hShiftLeft [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 8)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                        (Lean.Expr.const `Nat []))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec.instHShiftLeftNat [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 8)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec.ofNat [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 8)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 255)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 255))))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `BitVec.toNat [])
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 8)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                  (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 7741271))))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 101.105079 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 32.854400 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 100.486470 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 790.049576 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.714680 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some (ofBool (x✝ &&& (-1#8) <<< x✝¹ ≥ₛ (-1#8) <<< x✝¹)) ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 12.887550 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 108.953279 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 235.833839 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 39.011150 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 10.138590 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ c ≤ 254
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝¹.toNat
     c := ↑(((-1#8) <<< x✝¹).sshiftRight' x✝¹).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 113.255010 ms, MSGSTART 
    Unsupported syntax some (ofBool (x✝ &&& 255#8 <<< x✝¹.toNat ≥ₛ 255#8 <<< x✝¹.toNat)) ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.const `BitVec.ofBool [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `BitVec.sle [])
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 8)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `HShiftLeft.hShiftLeft [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                          (Lean.Expr.const `Nat []))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.instHShiftLeftNat [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.ofNat [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 255)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 255))))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec.toNat [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 8)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                    (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 7856898)))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `HAnd.hAnd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 8)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `instHAndOfAndOp [Lean.Level.zero])
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.instAndOp [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))))
                  (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 7856900)))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.const `HShiftLeft.hShiftLeft [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                            (Lean.Expr.app
                              (Lean.Expr.const `BitVec [])
                              (Lean.Expr.app
                                (Lean.Expr.app
                                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                  (Lean.Expr.lit (Lean.Literal.natVal 8)))
                                (Lean.Expr.app
                                  (Lean.Expr.const `instOfNatNat [])
                                  (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                          (Lean.Expr.const `Nat []))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 8)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.instHShiftLeftNat [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.ofNat [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 8)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 255)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 255))))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec.toNat [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 8)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 8)))))
                    (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 7856898)))))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 101.353649 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 33.826730 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 101.647890 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 785.380316 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 252.727169 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 20.596680 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 116.412670 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 267.597809 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 44.515129 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.630020 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ >ᵤ 0#8)).toNat
     b := ↑(ofBool (0#8 ||| x✝ ^^^ -1#8 != -1#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 119.416470 ms, MSGSTART 
    Equality (x✝ ^^^ 255#8 != 255#8) = (x✝ >ᵤ 0#8) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 107.962449 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 24.957790 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 99.557760 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 593.652267 ms, 
TACEND
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphandhlowbithmask_proof.lean:441:4: warning: Unknown integer 255
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphandhlowbithmask_proof.lean:441:4: warning: Unknown integer 255
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 279.569819 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 22.515160 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 144.974759 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 270.104319 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 46.177510 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.231770 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ d ≤ 1
      0 ≤ c ≤ 1
      c - d ≥ 1
      0 ≤ b ≤ 255
      0 ≤ a ≤ 255
      a - b ≥ 1
    where
     a := ↑(↑8).toNat
     b := ↑x✝.toNat
     c := ↑(ofBool (x✝¹ >ᵤ (-1#8) >>> x✝)).toNat
     d := ↑(ofBool ((-1#8) >>> x✝ ||| x✝¹ ^^^ -1#8 != -1#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 144.820929 ms, MSGSTART 
    Equality (255#8 >>> x✝.toNat ||| x✝¹ ^^^ 255#8 != 255#8) = (x✝¹ >ᵤ 255#8 >>> x✝.toNat) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 133.176830 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 30.554429 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 108.069790 ms, 
  TACBENCH bv_auto FAIL, TIME_ELAPSED 804.380006 ms, MSGSTART 
    internal exception #4 MSGEND
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 253.673829 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 20.556959 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 116.943430 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 268.229429 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 44.748080 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.660230 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝¹ >ᵤ 0#8)).toNat
     b := ↑(ofBool (0#8 ||| x✝¹ ^^^ -1#8 != -1#8)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 119.210159 ms, MSGSTART 
    Equality (x✝¹ ^^^ 255#8 != 255#8) = (x✝¹ >ᵤ 0#8) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 108.194760 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 25.152789 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 99.845830 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 575.470138 ms, 
TACEND
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphandhlowbithmask_proof.lean:441:4: warning: Unknown integer 255
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphandhlowbithmask_proof.lean:441:4: warning: Unknown integer 255
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphandhlowbithmask_proof.lean:433:8: warning: declaration uses 'sorry'
