⚠ [202/2570] Replayed Mathlib.Logic.ExistsUnique
warning: ././.lake/packages/mathlib/././Mathlib/Logic/ExistsUnique.lean:109:16: `exists_unique_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [225/2570] Replayed Mathlib.Tactic.Lift
warning: ././.lake/packages/mathlib/././Mathlib/Tactic/Lift.lean:49:9: `PiSubtype.canLift'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [443/2570] Replayed Mathlib.Control.Combinators
warning: ././.lake/packages/mathlib/././Mathlib/Control/Combinators.lean:35:4: `Monad.mapM'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Control/Combinators.lean:57:4: `Monad.sequence'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [445/2570] Replayed Mathlib.Data.Prod.PProd
warning: ././.lake/packages/mathlib/././Mathlib/Data/Prod/PProd.lean:35:8: `PProd.forall'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Prod/PProd.lean:38:8: `PProd.exists'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [880/2570] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [883/2570] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:349:4: declaration uses 'sorry'
⚠ [899/2570] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:30:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:32:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:37:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:39:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:53:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:2: Apply builder was used for a theorem with conclusion A ↔ B.
You probably want to use the simp builder or create an alias that applies the theorem in one direction.
Use `set_option aesop.warn.applyIff false` to disable this warning.
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:57:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:60:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:71:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:70:2: Apply builder was used for a theorem with conclusion A ↔ B.
You probably want to use the simp builder or create an alias that applies the theorem in one direction.
Use `set_option aesop.warn.applyIff false` to disable this warning.
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:76:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:80:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:85:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:99:37: declaration uses 'sorry'
✔ [2561/2570] Built SSA.Experimental.Bits.AutoStructs.ForMathlib
✔ [2564/2570] Built SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
⚠ [2565/2570] Built SSA.Experimental.Bits.AutoStructs.Basic
warning: ././././SSA/Experimental/Bits/AutoStructs/Basic.lean:461:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Basic.lean:1070:4: declaration uses 'sorry'
⚠ [2566/2570] Built SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:28:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:30:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:41:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:53:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:79:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:166:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:183:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:210:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:262:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:274:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:302:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:305:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:318:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:321:4: declaration uses 'sorry'
⚠ [2567/2570] Built SSA.Experimental.Bits.AutoStructs.FormulaToAuto
warning: ././././SSA/Experimental/Bits/AutoStructs/FormulaToAuto.lean:381:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/FormulaToAuto.lean:409:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/FormulaToAuto.lean:446:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/FormulaToAuto.lean:551:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/FormulaToAuto.lean:659:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/FormulaToAuto.lean:702:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/FormulaToAuto.lean:750:6: declaration uses 'sorry'
✔ [2568/2570] Built SSA.Experimental.Bits.AutoStructs.Tactic
✔ [2569/2570] Built SSA.Projects.InstCombine.TacticAuto
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 251.480219 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 418.719658 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 280.690109 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 250.673389 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 76.473230 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.411639 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (128#32 >ᵤ x✝)).toNat
     b := ↑(ofBool (x✝ >ₛ -1#32) &&& ofBool (256#32 >ᵤ x✝ + 128#32)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 117.781690 ms, MSGSTART 
    Equality ((x✝ >ₛ 4294967295#32) && 256#32 >ᵤ x✝ + 128#32) = (128#32 >ᵤ x✝) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 106.707250 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 28.265789 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 104.896100 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 8836.842382 ms, 
TACEND
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsignedhtruncationhcheck_proof.lean:13:47: error: (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.
Additional diagnostic information may be available using the `set_option diagnostics true` command.
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 191.444239 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 2223.356600 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 443.034038 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 219.041670 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 30.337469 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.645450 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (128#32 >ᵤ x✝)).toNat
     b := ↑(ofBool (256#32 >ᵤ x✝ + 128#32)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 58.270280 ms, MSGSTART 
    Equality (256#32 >ᵤ x✝ + 128#32) = (128#32 >ᵤ x✝) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 46.874300 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 33.480360 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 110.729809 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 2004.077142 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 166.900469 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 17.474700 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 36.560780 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 188.351899 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 16.215750 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.642320 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 53.351930 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq AutoStructs.Term.zero (AutoStructs.Term.var 0)) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 30.440940 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 27.608629 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 96.878710 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 380.010068 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 225.548388 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 421.543499 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 340.388868 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 265.026989 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 48.844500 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.742530 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (128#32 >ᵤ x✝)).toNat
     b := ↑(ofBool (x✝ &&& 1107296256#32 == 0#32) &&& ofBool (256#32 >ᵤ x✝ + 128#32)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 110.411209 ms, MSGSTART 
    Equality (x✝ &&& 1107296256#32 == 0#32 && 256#32 >ᵤ x✝ + 128#32) = (128#32 >ᵤ x✝) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 99.257930 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 25.692590 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 102.835839 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 1587.606833 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 187.140989 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 2243.414900 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 446.257348 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 219.582819 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 30.236610 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.156490 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (128#32 >ᵤ x✝)).toNat
     b := ↑(ofBool (256#32 >ᵤ x✝ + 128#32)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 57.459310 ms, MSGSTART 
    Equality (256#32 >ᵤ x✝ + 128#32) = (128#32 >ᵤ x✝) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 47.171440 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 31.067470 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 108.326259 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 2019.576011 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 161.400949 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 15.703860 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 35.536460 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 187.389079 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 15.803810 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.055680 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 52.425020 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq AutoStructs.Term.zero (AutoStructs.Term.var 0)) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 30.489910 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 24.832019 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 95.329680 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 380.042418 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 206.108720 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 418.788448 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 255.430269 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 229.560679 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 40.148209 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.141840 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (128#32 >ᵤ x✝)).toNat
     b := ↑(ofBool (512#32 >ᵤ x✝) &&& ofBool (256#32 >ᵤ x✝ + 128#32)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 91.840150 ms, MSGSTART 
    Equality ((512#32 >ᵤ x✝) && 256#32 >ᵤ x✝ + 128#32) = (128#32 >ᵤ x✝) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 81.363670 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 22.721910 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 101.336409 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 3264.374336 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 183.250459 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 2552.243999 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 447.509088 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 219.062399 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 30.208750 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.431200 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (128#32 >ᵤ x✝)).toNat
     b := ↑(ofBool (256#32 >ᵤ x✝ + 128#32)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 57.348750 ms, MSGSTART 
    Equality (256#32 >ᵤ x✝ + 128#32) = (128#32 >ᵤ x✝) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 47.275190 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 27.825100 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 105.823299 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 2006.189651 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 158.660569 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 14.578000 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 35.598840 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 187.118959 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 15.874540 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.323350 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 52.180690 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq AutoStructs.Term.zero (AutoStructs.Term.var 0)) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 30.669570 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 21.664969 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 93.415310 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 377.257308 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 200.355279 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 808.776886 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 87.208430 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 225.698369 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 38.117950 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.091190 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (128#32 >ᵤ x✝)).toNat
     b := ↑(ofBool (128#32 >ᵤ x✝) &&& ofBool (512#32 >ᵤ x✝ + 256#32)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 92.935729 ms, MSGSTART 
    Unsupported syntax (128#32 >ᵤ x✝) = true → (512#32 >ᵤ x✝ + 256#32) = true === Lean.Expr.forallE
      (Lean.Name.mkNum `a._@.Init.Data.Bool._hyg 1363)
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app (Lean.Expr.const `Eq [Lean.Level.succ (Lean.Level.zero)]) (Lean.Expr.const `Bool []))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.const `BitVec.ult [])
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                    (Lean.Expr.lit (Lean.Literal.natVal 32)))
                  (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
              (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 2544947)))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.const `BitVec.ofNat [])
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                    (Lean.Expr.lit (Lean.Literal.natVal 32)))
                  (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 128)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 128)))))))
        (Lean.Expr.const `Bool.true []))
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app (Lean.Expr.const `Eq [Lean.Level.succ (Lean.Level.zero)]) (Lean.Expr.const `Bool []))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.const `BitVec.ult [])
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                    (Lean.Expr.lit (Lean.Literal.natVal 32)))
                  (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `HAdd.hAdd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `instHAdd [Lean.Level.zero])
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.instAdd [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
                  (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 2544947)))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `BitVec.ofNat [])
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 32)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 256)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 256)))))))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.const `BitVec.ofNat [])
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                    (Lean.Expr.lit (Lean.Literal.natVal 32)))
                  (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 512)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 512)))))))
        (Lean.Expr.const `Bool.true []))
      (Lean.BinderInfo.default) MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 81.951690 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 19.863740 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 93.921409 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 919.896566 ms, 
TACEND
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsignedhtruncationhcheck_proof.lean:95:47: error: (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.
Additional diagnostic information may be available using the `set_option diagnostics true` command.
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 331.027318 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 432.825088 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 556.392158 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 253.913069 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 49.628190 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.073100 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (128#32 >ᵤ x✝) &&& x✝¹).toNat
     b := ↑(ofBool (256#32 >ᵤ x✝ + 128#32) &&& (ofBool (x✝ >ₛ -1#32) &&& x✝¹)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 2937.414527 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq
            ((AutoStructs.Term.var 0).and ((AutoStructs.Term.var 1).and (AutoStructs.Term.var 2)))
            ((AutoStructs.Term.var 3).and (AutoStructs.Term.var 2))) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 136.204119 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 32.067750 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 109.726520 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 664.200607 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.583770 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some 0#1 ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 43.762769 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 11.102360 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 103.233370 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.184710 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 8.609570 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 18.469040 ms, MSGSTART 
    Unsupported syntax some 0#1 ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.const `BitVec.ofNat [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 0)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 0)))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 9.148570 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 38.888810 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 115.760839 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 414.114378 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.681280 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some 0#1 ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 43.317200 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 11.275860 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 102.980449 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.231010 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.861930 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 18.521310 ms, MSGSTART 
    Unsupported syntax some 0#1 ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.const `BitVec.ofNat [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 0)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 0)))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 9.178660 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 23.399840 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 96.456189 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 393.666509 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 190.672749 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 109.913100 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 18.834270 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 100.013379 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.617680 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 10.710430 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 37.039420 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) AutoStructs.Term.zero) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 16.020470 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 43.158980 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 120.152339 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 307.773579 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 189.545699 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 444.279758 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 18.931530 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 99.753970 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.691680 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 9.474949 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 37.351960 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq AutoStructs.Term.zero (AutoStructs.Term.var 0)) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 16.153940 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 43.480550 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 119.481320 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 305.608728 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 171.004419 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 437.261639 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 18.860549 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 99.898590 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.665480 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.703830 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 37.211050 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq AutoStructs.Term.zero (AutoStructs.Term.var 0)) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 16.143760 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 28.003600 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 101.649609 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 288.637879 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 273.719889 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 437.217498 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 308.264789 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 343.656608 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 78.807400 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.569760 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (128#32 >ᵤ x✝)).toNat
     b := ↑(ofBool (truncate 8 x✝ >ₛ -1#8) &&& ofBool (256#32 >ᵤ x✝ + 128#32)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 139.854839 ms, MSGSTART 
    Equality ((setWidth 8 x✝ >ₛ 255#8) && 256#32 >ᵤ x✝ + 128#32) = (128#32 >ᵤ x✝) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 127.345790 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 29.990700 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 107.633419 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 1057.532216 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 192.169139 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 2268.004400 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 451.018848 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 223.343820 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 30.847019 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.828050 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (128#32 >ᵤ x✝)).toNat
     b := ↑(ofBool (256#32 >ᵤ x✝ + 128#32)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 58.082610 ms, MSGSTART 
    Equality (256#32 >ᵤ x✝ + 128#32) = (128#32 >ᵤ x✝) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 47.503340 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 35.061030 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 112.528089 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 2021.000931 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 167.191939 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 20.724490 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 35.711420 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 189.270689 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 15.934190 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.713840 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 53.428160 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq AutoStructs.Term.zero (AutoStructs.Term.var 0)) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 30.646290 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 28.433479 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 99.493600 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 386.323658 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 314.678719 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 45.168840 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 191.066019 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 371.669898 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 87.082900 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.204120 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ &&& 65408#32 == 0#32)).toNat
     b := ↑(ofBool (truncate 16 x✝ >ₛ -1#16) &&& ofBool (256#16 >ᵤ truncate 16 x✝ + 128#16)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 178.907729 ms, MSGSTART 
    Equality ((setWidth 16 x✝ >ₛ 65535#16) && 256#16 >ᵤ setWidth 16 x✝ + 128#16) =
      (x✝ &&& 65408#32 == 0#32) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 166.474419 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 33.564960 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 110.661800 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 1094.794295 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 255.533129 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 41.032310 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 123.106730 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 338.291988 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 38.020030 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.490460 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ &&& 65408#32 == 0#32)).toNat
     b := ↑(ofBool (256#16 >ᵤ truncate 16 x✝ + 128#16)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 118.337919 ms, MSGSTART 
    Equality (256#16 >ᵤ setWidth 16 x✝ + 128#16) = (x✝ &&& 65408#32 == 0#32) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 107.394600 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 39.425390 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 116.298299 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 960.562686 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 187.900649 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 26.568470 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 59.084219 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 226.044519 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 28.906660 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.406830 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 73.029670 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq AutoStructs.Term.zero (AutoStructs.Term.var 0)) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 49.220480 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 31.842110 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 103.018129 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 464.579368 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 356.008718 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 79.927550 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 234.921329 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 460.834528 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 95.153050 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.533530 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ &&& 16384#32 == 0#32) &&& ofBool (256#16 >ᵤ truncate 16 x✝ + 128#16)).toNat
     b := ↑(ofBool (truncate 15 x✝ >ₛ -1#15) &&& ofBool (256#16 >ᵤ truncate 16 x✝ + 128#16)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 219.075179 ms, MSGSTART 
    Equality ((setWidth 15 x✝ >ₛ 32767#15) && 256#16 >ᵤ setWidth 16 x✝ + 128#16) =
      (x✝ &&& 16384#32 == 0#32 && 256#16 >ᵤ setWidth 16 x✝ + 128#16) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 206.656479 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 36.483149 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 113.813080 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 1338.316924 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 240.374929 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 46.038770 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 92.507220 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 219.050129 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 18.243440 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 10.497890 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 86.890769 ms, MSGSTART 
    tactic 'rfl' failed, the left-hand side
      ¬(((AutoStructs.Term.var 2).evalNat fun n =>
              if n = 2 then 256#16 else if n = 1 then 128#16 else if n = 0 then setWidth 16 x✝ else BitVec.zero 16) >ᵤ
            ((AutoStructs.Term.var 0).evalNat fun n =>
                if n = 2 then 256#16 else if n = 1 then 128#16 else if n = 0 then setWidth 16 x✝ else BitVec.zero 16) +
              (AutoStructs.Term.var 1).evalNat fun n =>
                if n = 2 then 256#16 else if n = 1 then 128#16 else if n = 0 then setWidth 16 x✝ else BitVec.zero 16) =
          true
    is not definitionally equal to the right-hand side
      (256#16 >ᵤ setWidth 16 x✝ + 128#16) = false
    x✝ : BitVec 32
    c✝¹ : BitVec 1
    heq✝¹ : ofBool (truncate 15 x✝ >ₛ -1#15) = 1#1
    c✝ : BitVec 1
    heq✝ : ofBool (x✝ &&& 16384#32 == 0#32) = 0#1
    ⊢ ¬(((AutoStructs.Term.var 2).evalNat fun n =>
                if n = 2 then 256#16 else if n = 1 then 128#16 else if n = 0 then setWidth 16 x✝ else BitVec.zero 16) >ᵤ
              ((AutoStructs.Term.var 0).evalNat fun n =>
                  if n = 2 then 256#16
                  else if n = 1 then 128#16 else if n = 0 then setWidth 16 x✝ else BitVec.zero 16) +
                (AutoStructs.Term.var 1).evalNat fun n =>
                  if n = 2 then 256#16
                  else if n = 1 then 128#16 else if n = 0 then setWidth 16 x✝ else BitVec.zero 16) =
            true ↔
        (256#16 >ᵤ setWidth 16 x✝ + 128#16) = false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 83.314260 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 45.805700 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 122.988739 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 630.569718 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 236.776839 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 39.615840 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 96.843540 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 219.262439 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 18.177560 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 9.173580 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 106.460279 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq AutoStructs.Term.zero (AutoStructs.Term.var 0)) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 82.260850 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 45.627090 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 121.635629 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 516.798668 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 322.418119 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 3489.703035 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 885.960546 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 378.216428 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 94.567150 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.479640 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ &&& 128#32 == 0#32) &&& ofBool (256#32 >ᵤ x✝¹ + 128#32)).toNat
     b := ↑(ofBool (truncate 8 x✝ >ₛ -1#8) &&& ofBool (256#32 >ᵤ x✝¹ + 128#32)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 184.663389 ms, MSGSTART 
    Equality ((setWidth 8 x✝ >ₛ 255#8) && 256#32 >ᵤ x✝¹ + 128#32) =
      (x✝ &&& 128#32 == 0#32 && 256#32 >ᵤ x✝¹ + 128#32) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 172.384159 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 34.493050 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 113.270209 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 2834.670408 ms, 
TACEND
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsignedhtruncationhcheck_proof.lean:206:73: error: (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.
Additional diagnostic information may be available using the `set_option diagnostics true` command.
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 0.566010 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some 0#1 ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 8.667940 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 10.870000 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 101.886339 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.213020 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.413010 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 18.365110 ms, MSGSTART 
    Unsupported syntax some 0#1 ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.const `BitVec.ofNat [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 0)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 0)))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 9.066170 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 31.190700 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 102.482980 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 365.006698 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 204.244839 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 1860.059222 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 218.803719 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 215.005649 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 17.590870 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 10.366730 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 57.772940 ms, MSGSTART 
    tactic 'rfl' failed, the left-hand side
      ¬(((AutoStructs.Term.var 2).evalNat fun n =>
              if n = 2 then 256#32 else if n = 1 then 128#32 else if n = 0 then x✝¹ else BitVec.zero 32) >ᵤ
            ((AutoStructs.Term.var 0).evalNat fun n =>
                if n = 2 then 256#32 else if n = 1 then 128#32 else if n = 0 then x✝¹ else BitVec.zero 32) +
              (AutoStructs.Term.var 1).evalNat fun n =>
                if n = 2 then 256#32 else if n = 1 then 128#32 else if n = 0 then x✝¹ else BitVec.zero 32) =
          true
    is not definitionally equal to the right-hand side
      (256#32 >ᵤ x✝¹ + 128#32) = false
    x✝¹ x✝ : BitVec 32
    c✝¹ : BitVec 1
    heq✝¹ : ofBool (truncate 8 x✝ >ₛ -1#8) = 1#1
    c✝ : BitVec 1
    heq✝ : ofBool (x✝ &&& 128#32 == 0#32) = 0#1
    ⊢ ¬(((AutoStructs.Term.var 2).evalNat fun n =>
                if n = 2 then 256#32 else if n = 1 then 128#32 else if n = 0 then x✝¹ else BitVec.zero 32) >ᵤ
              ((AutoStructs.Term.var 0).evalNat fun n =>
                  if n = 2 then 256#32 else if n = 1 then 128#32 else if n = 0 then x✝¹ else BitVec.zero 32) +
                (AutoStructs.Term.var 1).evalNat fun n =>
                  if n = 2 then 256#32 else if n = 1 then 128#32 else if n = 0 then x✝¹ else BitVec.zero 32) =
            true ↔
        (256#32 >ᵤ x✝¹ + 128#32) = false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 48.622319 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 43.858540 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 120.974230 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 1621.574823 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 201.883990 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 815.330696 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 447.350828 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 215.551989 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 17.541840 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 9.115370 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 69.791920 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq AutoStructs.Term.zero (AutoStructs.Term.var 0)) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 46.950310 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 43.767419 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 120.755260 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 469.523088 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 250.959209 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 2323.653930 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 116.925609 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 264.336159 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 44.380990 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.715110 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ &&& 1711276033#32 == 0#32) &&& ofBool (256#32 >ᵤ x✝ + 128#32)).toNat
     b := ↑(ofBool (256#32 >ᵤ x✝ + 128#32)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 119.786229 ms, MSGSTART 
    Unsupported syntax (256#32 >ᵤ x✝ + 128#32) = true → x✝ &&& 1711276033#32 = 0#32 === Lean.Expr.forallE
      (Lean.Name.mkNum `a._@.Init.Data.Bool._hyg 1447)
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app (Lean.Expr.const `Eq [Lean.Level.succ (Lean.Level.zero)]) (Lean.Expr.const `Bool []))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.const `BitVec.ult [])
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                    (Lean.Expr.lit (Lean.Literal.natVal 32)))
                  (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `HAdd.hAdd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `instHAdd [Lean.Level.zero])
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.instAdd [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
                  (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 7513083)))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `BitVec.ofNat [])
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 32)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 128)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 128)))))))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.const `BitVec.ofNat [])
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                    (Lean.Expr.lit (Lean.Literal.natVal 32)))
                  (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 256)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 256)))))))
        (Lean.Expr.const `Bool.true []))
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Eq [Lean.Level.succ (Lean.Level.zero)])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `HAnd.hAnd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 32)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                  (Lean.Expr.app
                    (Lean.Expr.const `BitVec [])
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 32)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `instHAndOfAndOp [Lean.Level.zero])
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 32)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                  (Lean.Expr.app
                    (Lean.Expr.const `BitVec.instAndOp [])
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 32)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
              (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 7513083)))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.const `BitVec.ofNat [])
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                    (Lean.Expr.lit (Lean.Literal.natVal 32)))
                  (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1711276033)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1711276033)))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `BitVec.ofNat [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 32)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 0)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 0))))))
      (Lean.BinderInfo.default) MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 107.801580 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 35.482610 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 111.002129 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 706.498547 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 178.211739 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 417.804798 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 668.297887 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 264.130699 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 42.257340 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.398860 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 126.050579 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq AutoStructs.Term.zero (AutoStructs.Term.var 0)) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 101.442620 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 35.530060 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 109.881289 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 519.859418 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 248.648079 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 2316.509960 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 117.327800 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 263.685299 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 44.275029 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.698970 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ &&& 4278190144#32 == 0#32) &&& ofBool (256#32 >ᵤ x✝ + 128#32)).toNat
     b := ↑(ofBool (256#32 >ᵤ x✝ + 128#32)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 119.783780 ms, MSGSTART 
    Unsupported syntax (256#32 >ᵤ x✝ + 128#32) = true → x✝ &&& 4278190144#32 = 0#32 === Lean.Expr.forallE
      (Lean.Name.mkNum `a._@.Init.Data.Bool._hyg 1447)
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app (Lean.Expr.const `Eq [Lean.Level.succ (Lean.Level.zero)]) (Lean.Expr.const `Bool []))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.const `BitVec.ult [])
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                    (Lean.Expr.lit (Lean.Literal.natVal 32)))
                  (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `HAdd.hAdd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `instHAdd [Lean.Level.zero])
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.instAdd [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
                  (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 8025773)))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `BitVec.ofNat [])
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 32)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 128)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 128)))))))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.const `BitVec.ofNat [])
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                    (Lean.Expr.lit (Lean.Literal.natVal 32)))
                  (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 256)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 256)))))))
        (Lean.Expr.const `Bool.true []))
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Eq [Lean.Level.succ (Lean.Level.zero)])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `HAnd.hAnd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 32)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                  (Lean.Expr.app
                    (Lean.Expr.const `BitVec [])
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 32)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `instHAndOfAndOp [Lean.Level.zero])
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 32)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                  (Lean.Expr.app
                    (Lean.Expr.const `BitVec.instAndOp [])
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 32)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
              (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 8025773)))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.const `BitVec.ofNat [])
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                    (Lean.Expr.lit (Lean.Literal.natVal 32)))
                  (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 4278190144)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 4278190144)))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `BitVec.ofNat [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 32)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 0)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 0))))))
      (Lean.BinderInfo.default) MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 107.731779 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 35.348190 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 110.881190 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 708.273627 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 177.818999 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 418.633469 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 666.889187 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 263.019289 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 42.264549 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.421270 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 125.723460 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq AutoStructs.Term.zero (AutoStructs.Term.var 0)) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 100.585039 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 35.323380 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 110.020000 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 518.581078 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 250.037659 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 2325.544640 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 117.417989 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 265.380499 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 44.486730 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.665970 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ &&& 1#32 == 0#32) &&& ofBool (256#32 >ᵤ x✝ + 128#32)).toNat
     b := ↑(ofBool (256#32 >ᵤ x✝ + 128#32)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 120.274119 ms, MSGSTART 
    Unsupported syntax (256#32 >ᵤ x✝ + 128#32) = true → x✝ &&& 1#32 = 0#32 === Lean.Expr.forallE
      (Lean.Name.mkNum `a._@.Init.Data.Bool._hyg 1447)
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app (Lean.Expr.const `Eq [Lean.Level.succ (Lean.Level.zero)]) (Lean.Expr.const `Bool []))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.const `BitVec.ult [])
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                    (Lean.Expr.lit (Lean.Literal.natVal 32)))
                  (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `HAdd.hAdd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `instHAdd [Lean.Level.zero])
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.instAdd [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
                  (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 8538365)))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `BitVec.ofNat [])
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 32)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 128)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 128)))))))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.const `BitVec.ofNat [])
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                    (Lean.Expr.lit (Lean.Literal.natVal 32)))
                  (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 256)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 256)))))))
        (Lean.Expr.const `Bool.true []))
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Eq [Lean.Level.succ (Lean.Level.zero)])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 32)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `HAnd.hAnd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 32)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                  (Lean.Expr.app
                    (Lean.Expr.const `BitVec [])
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 32)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `instHAndOfAndOp [Lean.Level.zero])
                    (Lean.Expr.app
                      (Lean.Expr.const `BitVec [])
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                          (Lean.Expr.lit (Lean.Literal.natVal 32)))
                        (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                  (Lean.Expr.app
                    (Lean.Expr.const `BitVec.instAndOp [])
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 32)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
              (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 8538365)))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.const `BitVec.ofNat [])
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                    (Lean.Expr.lit (Lean.Literal.natVal 32)))
                  (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `BitVec.ofNat [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 32)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 0)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 0))))))
      (Lean.BinderInfo.default) MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 108.458510 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 35.300050 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 111.060969 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 710.227107 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 177.341569 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 419.082098 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 667.366577 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 263.948569 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 42.046650 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 7.383640 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 125.264819 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq AutoStructs.Term.zero (AutoStructs.Term.var 0)) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 100.780710 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 35.177830 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 109.804359 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 518.586008 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 246.246239 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 798.835336 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 120.757210 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 248.844888 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 75.297280 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 6.727000 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 126.530280 ms, MSGSTART 
    Unsupported syntax (x✝ >ₛ 4294967295#32) = true → (256#32 >ᵤ x✝ + 256#32) = false === Lean.Expr.forallE
      (Lean.Name.mkNum `a._@.Init.SimpLemmas._hyg 1811)
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app (Lean.Expr.const `Eq [Lean.Level.succ (Lean.Level.zero)]) (Lean.Expr.const `Bool []))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.const `BitVec.slt [])
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                    (Lean.Expr.lit (Lean.Literal.natVal 32)))
                  (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.const `BitVec.ofNat [])
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 32)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                    (Lean.Expr.lit (Lean.Literal.natVal 4294967295)))
                  (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 4294967295))))))
            (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 9049627))))
        (Lean.Expr.const `Bool.true []))
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app (Lean.Expr.const `Eq [Lean.Level.succ (Lean.Level.zero)]) (Lean.Expr.const `Bool []))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.const `BitVec.ult [])
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                    (Lean.Expr.lit (Lean.Literal.natVal 32)))
                  (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `HAdd.hAdd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `instHAdd [Lean.Level.zero])
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.instAdd [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
                  (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 9049627)))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `BitVec.ofNat [])
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 32)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 256)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 256)))))))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.const `BitVec.ofNat [])
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                    (Lean.Expr.lit (Lean.Literal.natVal 32)))
                  (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 256)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 256)))))))
        (Lean.Expr.const `Bool.false []))
      (Lean.BinderInfo.default) MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 115.441959 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 25.353720 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 98.876420 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 652.602117 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 177.825649 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 2617.723569 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 374.125768 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 217.296359 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 17.441980 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 8.333660 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 48.980950 ms, MSGSTART 
    tactic 'rfl' failed, the left-hand side
      ¬(((AutoStructs.Term.var 1).evalNat fun n => if n = 1 then 256#32 else if n = 0 then x✝ else BitVec.zero 32) >ᵤ
            ((AutoStructs.Term.var 0).evalNat fun n => if n = 1 then 256#32 else if n = 0 then x✝ else BitVec.zero 32) +
              (AutoStructs.Term.var 1).evalNat fun n =>
                if n = 1 then 256#32 else if n = 0 then x✝ else BitVec.zero 32) =
          true
    is not definitionally equal to the right-hand side
      (256#32 >ᵤ x✝ + 256#32) = false
    x✝ : BitVec 32
    c✝ : BitVec 1
    heq✝ : ofBool (x✝ >ₛ -1#32) = 1#1
    ⊢ ¬(((AutoStructs.Term.var 1).evalNat fun n => if n = 1 then 256#32 else if n = 0 then x✝ else BitVec.zero 32) >ᵤ
              ((AutoStructs.Term.var 0).evalNat fun n =>
                  if n = 1 then 256#32 else if n = 0 then x✝ else BitVec.zero 32) +
                (AutoStructs.Term.var 1).evalNat fun n =>
                  if n = 1 then 256#32 else if n = 0 then x✝ else BitVec.zero 32) =
            true ↔
        (256#32 >ᵤ x✝ + 256#32) = false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 41.391769 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 29.582100 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 103.371920 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 2046.066791 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 262.482039 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 805.656836 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 456.957058 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 278.645799 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 83.172310 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.765090 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ == 0#32)).toNat
     b := ↑(ofBool (x✝ >ₛ -1#32) &&& ofBool (256#32 >ᵤ x✝ + 255#32)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 127.778039 ms, MSGSTART 
    Equality ((x✝ >ₛ 4294967295#32) && 256#32 >ᵤ x✝ + 255#32) = (x✝ == 0#32) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 116.681349 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 30.049550 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 108.113770 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 2240.966410 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 201.834609 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 3119.609586 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 520.107508 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 246.822839 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 35.406590 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.744470 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (x✝ == 0#32)).toNat
     b := ↑(ofBool (256#32 >ᵤ x✝ + 255#32)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 66.619139 ms, MSGSTART 
    Equality (256#32 >ᵤ x✝ + 255#32) = (x✝ == 0#32) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 56.102030 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 34.391710 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 112.969300 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 2649.031798 ms, 
TACEND
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsignedhtruncationhcheck_proof.lean:304:44: error: (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.
Additional diagnostic information may be available using the `set_option diagnostics true` command.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsignedhtruncationhcheck_proof.lean:315:47: error: (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.
Additional diagnostic information may be available using the `set_option diagnostics true` command.
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 204.303929 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 1160.520395 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 264.059589 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 223.766329 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 31.376350 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.879610 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (192#32 >ᵤ x✝)).toNat
     b := ↑(ofBool (256#32 >ᵤ x✝ + 64#32)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 66.849179 ms, MSGSTART 
    Equality (256#32 >ᵤ x✝ + 64#32) = (192#32 >ᵤ x✝) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 54.739180 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 34.437050 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 113.211670 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 1331.085345 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 167.060449 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 16.908960 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 36.162370 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 187.678759 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 16.066320 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.596560 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 53.869350 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq AutoStructs.Term.zero (AutoStructs.Term.var 0)) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 30.826610 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 27.560999 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 99.440121 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 385.609658 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 223.028969 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 444.296608 ms, MSGSTART 
    tactic 'simp' failed, nested error:
    maximum recursion depth has been reached
    use `set_option maxRecDepth <num>` to increase limit
    use `set_option diagnostics true` to get diagnostic information MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 105.085480 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 242.977159 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 37.935069 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.357580 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(ofBool (256#32 >ᵤ x✝ + 128#32)).toNat
     b := ↑(ofBool (1024#32 >ᵤ x✝ + 512#32) &&& ofBool (256#32 >ᵤ x✝ + 128#32)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 110.112510 ms, MSGSTART 
    Unsupported syntax (256#32 >ᵤ x✝ + 128#32) = true → (1024#32 >ᵤ x✝ + 512#32) = true === Lean.Expr.forallE
      (Lean.Name.mkNum `a._@.Init.Data.Bool._hyg 1391)
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app (Lean.Expr.const `Eq [Lean.Level.succ (Lean.Level.zero)]) (Lean.Expr.const `Bool []))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.const `BitVec.ult [])
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                    (Lean.Expr.lit (Lean.Literal.natVal 32)))
                  (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `HAdd.hAdd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `instHAdd [Lean.Level.zero])
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.instAdd [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
                  (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 11464427)))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `BitVec.ofNat [])
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 32)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 128)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 128)))))))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.const `BitVec.ofNat [])
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                    (Lean.Expr.lit (Lean.Literal.natVal 32)))
                  (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 256)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 256)))))))
        (Lean.Expr.const `Bool.true []))
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app (Lean.Expr.const `Eq [Lean.Level.succ (Lean.Level.zero)]) (Lean.Expr.const `Bool []))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.const `BitVec.ult [])
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                    (Lean.Expr.lit (Lean.Literal.natVal 32)))
                  (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app
                          (Lean.Expr.const `HAdd.hAdd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                          (Lean.Expr.app
                            (Lean.Expr.const `BitVec [])
                            (Lean.Expr.app
                              (Lean.Expr.app
                                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                                (Lean.Expr.lit (Lean.Literal.natVal 32)))
                              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.const `instHAdd [Lean.Level.zero])
                        (Lean.Expr.app
                          (Lean.Expr.const `BitVec [])
                          (Lean.Expr.app
                            (Lean.Expr.app
                              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                              (Lean.Expr.lit (Lean.Literal.natVal 32)))
                            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32))))))
                      (Lean.Expr.app
                        (Lean.Expr.const `BitVec.instAdd [])
                        (Lean.Expr.app
                          (Lean.Expr.app
                            (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                            (Lean.Expr.lit (Lean.Literal.natVal 32)))
                          (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))))
                  (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 11464427)))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `BitVec.ofNat [])
                    (Lean.Expr.app
                      (Lean.Expr.app
                        (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                        (Lean.Expr.lit (Lean.Literal.natVal 32)))
                      (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                      (Lean.Expr.lit (Lean.Literal.natVal 512)))
                    (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 512)))))))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.const `BitVec.ofNat [])
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                    (Lean.Expr.lit (Lean.Literal.natVal 32)))
                  (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 32)))))
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1024)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1024)))))))
        (Lean.Expr.const `Bool.true []))
      (Lean.BinderInfo.default) MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 98.872900 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 21.512740 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 97.871419 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 682.091577 ms, 
TACEND
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsignedhtruncationhcheck_proof.lean:356:4: error: maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
