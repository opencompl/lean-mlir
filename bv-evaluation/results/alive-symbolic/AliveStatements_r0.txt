⚠ [55/2570] Replayed Mathlib.Algebra.Group.Defs
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Defs.lean:814:33: `pow_succ'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Defs.lean:819:6: `pow_mul_comm'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Defs.lean:828:6: `pow_three'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Defs.lean:851:6: `pow_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [201/2570] Replayed Mathlib.Logic.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Basic.lean:155:8: `dec_em'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Basic.lean:159:8: `em'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Basic.lean:304:8: `or_congr_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Basic.lean:307:8: `or_congr_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Basic.lean:320:8: `imp_or'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Basic.lean:359:8: `xor_iff_not_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Basic.lean:418:8: `eqRec_heq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Basic.lean:515:8: `forall_true_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Basic.lean:536:8: `exists_apply_eq_apply'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Basic.lean:543:6: `exists_apply_eq_apply2'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Basic.lean:552:6: `exists_apply_eq_apply3'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Basic.lean:579:8: `forall_apply_eq_imp_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Basic.lean:582:8: `forall_eq_apply_imp_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Basic.lean:642:8: `forall_prop_congr'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Basic.lean:715:6: `Classical.choose_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Basic.lean:851:8: `dite_eq_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Basic.lean:855:8: `ite_eq_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [202/2570] Replayed Mathlib.Logic.ExistsUnique
warning: ././.lake/packages/mathlib/././Mathlib/Logic/ExistsUnique.lean:109:16: `exists_unique_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [205/2570] Replayed Mathlib.Logic.Function.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Function/Basic.lean:83:8: `Function.Injective.eq_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Function/Basic.lean:92:8: `Function.Injective.ne_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Function/Basic.lean:122:8: `Function.Injective.of_comp_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Function/Basic.lean:168:8: `Function.Surjective.of_comp_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Function/Basic.lean:242:8: `Function.Bijective.of_comp_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Function/Basic.lean:546:8: `Function.update_comp_eq_of_forall_ne'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Function/Basic.lean:557:8: `Function.update_comp_eq_of_injective'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Function/Basic.lean:654:8: `Function.extend_apply'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Function/Basic.lean:686:8: `Function.Injective.surjective_comp_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [220/2570] Replayed Mathlib.Data.Nat.Defs
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:89:6: `Nat.succ_pos'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:280:16: `Nat.sub_eq_of_eq_add'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:282:16: `Nat.eq_sub_of_add_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:285:16: `Nat.lt_sub_iff_add_lt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:287:16: `Nat.sub_lt_iff_lt_add'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:370:6: `Nat.mul_lt_mul''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:416:6: `Nat.le_div_iff_mul_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:419:6: `Nat.div_lt_iff_lt_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:452:16: `Nat.mul_div_cancel_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:504:16: `Nat.div_le_of_le_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:518:16: `Nat.div_le_self'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:629:6: `Nat.one_le_pow'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:635:6: `Nat.one_lt_pow'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:644:6: `Nat.one_lt_two_pow'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:727:6: `Nat.leRec_succ'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:771:6: `Nat.leRecOn_succ'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:878:6: `Nat.decreasingInduction_succ'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:1067:6: `Nat.mod_add_div'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:1069:6: `Nat.div_add_mod'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:1159:6: `Nat.mul_add_mod'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:1176:6: `Nat.dvd_sub'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [221/2570] Replayed Mathlib.Logic.IsEmpty
warning: ././.lake/packages/mathlib/././Mathlib/Logic/IsEmpty.lean:36:9: `Fin.isEmpty'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [225/2570] Replayed Mathlib.Tactic.Lift
warning: ././.lake/packages/mathlib/././Mathlib/Tactic/Lift.lean:49:9: `PiSubtype.canLift'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [226/2570] Replayed Mathlib.Data.Int.Defs
warning: ././.lake/packages/mathlib/././Mathlib/Data/Int/Defs.lean:191:16: `Int.add_le_zero_iff_le_neg'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Int/Defs.lean:193:16: `Int.add_nonnneg_iff_neg_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Int/Defs.lean:324:14: `Int.natAbs_ofNat'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Int/Defs.lean:577:6: `Int.toNat_lt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [229/2570] Replayed Mathlib.Algebra.Group.Units.Defs
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Units/Defs.lean:438:8: `isUnit_iff_exists_inv'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Units/Defs.lean:547:21: `IsUnit.val_inv_unit'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [231/2570] Replayed Mathlib.Logic.Unique
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Unique.lean:131:18: `Unique.subsingleton_unique'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Unique.lean:259:9: `Unique.subtypeEq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [240/2570] Replayed Mathlib.Logic.Function.Iterate
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Function/Iterate.lean:160:8: `Function.iterate_succ'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Function/Iterate.lean:163:8: `Function.iterate_succ_apply'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [241/2570] Replayed Mathlib.Data.Prod.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Data/Prod/Basic.lean:31:8: `Prod.forall'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Prod/Basic.lean:34:8: `Prod.exists'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Prod/Basic.lean:51:8: `Prod.map_apply'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Prod/Basic.lean:54:8: `Prod.map_fst'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Prod/Basic.lean:57:8: `Prod.map_snd'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [250/2570] Replayed Mathlib.Algebra.Group.Invertible.Defs
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Invertible/Defs.lean:97:8: `invOf_mul_self'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Invertible/Defs.lean:103:8: `mul_invOf_self'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Invertible/Defs.lean:109:8: `invOf_mul_cancel_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Invertible/Defs.lean:120:8: `mul_invOf_cancel_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Invertible/Defs.lean:131:8: `invOf_mul_cancel_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Invertible/Defs.lean:142:8: `mul_invOf_cancel_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Invertible/Defs.lean:198:8: `invOf_one'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [260/2570] Replayed Mathlib.Data.FunLike.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Data/FunLike/Basic.lean:187:8: `DFunLike.ext'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [261/2570] Replayed Mathlib.Algebra.Group.Hom.Defs
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Hom/Defs.lean:407:8: `map_div'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Hom/Defs.lean:412:6: `map_comp_div'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Hom/Defs.lean:460:8: `map_zpow'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Hom/Defs.lean:466:6: `map_comp_zpow'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Hom/Defs.lean:842:18: `MonoidHom.map_zpow'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [266/2570] Replayed Mathlib.Logic.Relation
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Relation.lean:351:8: `Relation.TransGen.head'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Relation.lean:354:8: `Relation.TransGen.tail'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Relation.lean:444:8: `Relation.TransGen.lift'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Relation.lean:453:6: `Relation.TransGen.closed'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Relation.lean:523:8: `Relation.ReflTransGen.lift'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [273/2570] Replayed Mathlib.Data.Quot
warning: ././.lake/packages/mathlib/././Mathlib/Data/Quot.lean:594:18: `Quotient.liftOn'_mk''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Quot.lean:598:14: `Quotient.surjective_liftOn'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Quot.lean:609:18: `Quotient.liftOn₂'_mk''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Quot.lean:675:8: `Quotient.hrecOn'_mk''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Quot.lean:688:8: `Quotient.hrecOn₂'_mk''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Quot.lean:700:8: `Quotient.map'_mk''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Quot.lean:710:8: `Quotient.map₂'_mk''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Quot.lean:715:8: `Quotient.exact'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Quot.lean:719:8: `Quotient.sound'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Quot.lean:723:18: `Quotient.eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Quot.lean:727:18: `Quotient.eq''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Quot.lean:736:8: `Quotient.out_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Quot.lean:739:8: `Quotient.mk_out'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [274/2570] Replayed Mathlib.Data.Bool.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Data/Bool/Basic.lean:156:8: `Bool.eq_true_of_not_eq_false'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Bool/Basic.lean:159:8: `Bool.eq_false_of_not_eq_true'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [276/2570] Replayed Mathlib.Logic.Equiv.Defs
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Equiv/Defs.lean:138:9: `Equiv.inhabited'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Equiv/Defs.lean:153:8: `Equiv.left_inv'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Equiv/Defs.lean:154:8: `Equiv.right_inv'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Equiv/Defs.lean:725:16: `Equiv.forall_congr'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Equiv/Defs.lean:737:16: `Equiv.exists_congr'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Equiv/Defs.lean:757:16: `Equiv.existsUnique_congr'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Equiv/Defs.lean:772:18: `Equiv.forall₂_congr'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Equiv/Defs.lean:782:18: `Equiv.forall₃_congr'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [278/2570] Replayed Mathlib.Algebra.GroupWithZero.Defs
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/GroupWithZero/Defs.lean:110:8: `mul_left_inj'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/GroupWithZero/Defs.lean:113:8: `mul_right_inj'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [279/2570] Replayed Mathlib.Algebra.NeZero
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/NeZero.lean:44:6: `zero_ne_one'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/NeZero.lean:46:6: `one_ne_zero'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/NeZero.lean:48:6: `two_ne_zero'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/NeZero.lean:50:6: `three_ne_zero'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/NeZero.lean:52:6: `four_ne_zero'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [291/2570] Replayed Mathlib.Data.Sigma.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Data/Sigma/Basic.lean:90:6: `Sigma.exists'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Sigma/Basic.lean:93:6: `Sigma.forall'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [304/2570] Replayed Mathlib.Logic.Equiv.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Equiv/Basic.lean:1706:8: `Equiv.coe_piCongr'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [311/2570] Replayed Mathlib.Algebra.Group.TypeTags
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/TypeTags.lean:494:6: `AddMonoidHom.coe_toMultiplicative'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/TypeTags.lean:504:6: `MonoidHom.coe_toAdditive'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/TypeTags.lean:525:6: `AddMonoidHom.coe_toMultiplicative''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/TypeTags.lean:535:6: `MonoidHom.coe_toAdditive''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [314/2570] Replayed Mathlib.Data.Nat.Sqrt
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Sqrt.lean:114:6: `Nat.sqrt_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Sqrt.lean:118:6: `Nat.lt_succ_sqrt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Sqrt.lean:127:6: `Nat.le_sqrt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Sqrt.lean:131:6: `Nat.sqrt_lt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Sqrt.lean:150:6: `Nat.eq_sqrt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Sqrt.lean:170:6: `Nat.sqrt_add_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Sqrt.lean:175:6: `Nat.sqrt_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Sqrt.lean:185:6: `Nat.exists_mul_self'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Sqrt.lean:191:6: `Nat.sqrt_mul_sqrt_lt_succ'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Sqrt.lean:197:6: `Nat.succ_le_succ_sqrt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Sqrt.lean:207:6: `Nat.not_exists_sq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [414/2570] Replayed Mathlib.Algebra.Ring.Defs
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Ring/Defs.lean:234:6: `add_sq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [437/2570] Replayed Mathlib.Algebra.Field.Defs
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Field/Defs.lean:202:6: `Rat.cast_mk'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [443/2570] Replayed Mathlib.Control.Combinators
warning: ././.lake/packages/mathlib/././Mathlib/Control/Combinators.lean:35:4: `Monad.mapM'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Control/Combinators.lean:57:4: `Monad.sequence'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [445/2570] Replayed Mathlib.Data.Prod.PProd
warning: ././.lake/packages/mathlib/././Mathlib/Data/Prod/PProd.lean:35:8: `PProd.forall'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Prod/PProd.lean:38:8: `PProd.exists'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [456/2570] Replayed Mathlib.Order.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:70:8: `le_trans'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:73:8: `lt_trans'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:76:8: `lt_of_le_of_lt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:79:8: `lt_of_lt_of_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:91:8: `lt_of_le_of_ne'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:96:8: `Ne.lt_of_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:156:8: `le_of_le_of_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:159:8: `le_of_eq_of_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:162:8: `lt_of_lt_of_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:165:8: `lt_of_eq_of_lt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:265:8: `LT.lt.ne'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:350:8: `min_def'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:359:8: `max_def'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:402:8: `lt_iff_lt_of_le_iff_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:420:8: `le_of_forall_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:429:8: `le_of_forall_lt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:432:8: `forall_lt_iff_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:851:8: `update_le_update_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:910:8: `min_rec'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:913:8: `max_rec'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [461/2570] Replayed Mathlib.Order.Compare
warning: ././.lake/packages/mathlib/././Mathlib/Order/Compare.lean:220:8: `Eq.cmp_eq_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [464/2570] Replayed Mathlib.Order.RelClasses
warning: ././.lake/packages/mathlib/././Mathlib/Order/RelClasses.lean:34:8: `antisymm'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/RelClasses.lean:111:8: `ne_of_irrefl'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [465/2570] Replayed Mathlib.Order.Monotone.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Order/Monotone/Basic.lean:476:8: `Subsingleton.monotone'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Monotone/Basic.lean:479:8: `Subsingleton.antitone'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Monotone/Basic.lean:568:18: `StrictMono.ite'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Monotone/Basic.lean:586:18: `StrictAnti.ite'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [494/2570] Replayed Mathlib.Algebra.Order.Group.Synonym
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Synonym.lean:39:9: `OrderDual.instPow'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Synonym.lean:156:9: `Lex.instPow'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [496/2570] Replayed Mathlib.Algebra.Order.Monoid.Unbundled.Pow
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Pow.lean:68:8: `pow_le_pow_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Pow.lean:72:8: `pow_le_pow_right_of_le_one'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Pow.lean:76:8: `one_lt_pow'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Pow.lean:86:8: `pow_right_strictMono'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Pow.lean:90:8: `pow_lt_pow_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Pow.lean:140:6: `pow_lt_pow_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Pow.lean:150:8: `pow_le_pow_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Pow.lean:207:8: `pow_le_pow_iff_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Pow.lean:211:8: `pow_lt_pow_iff_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Pow.lean:221:8: `lt_of_pow_lt_pow_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Pow.lean:239:8: `le_of_pow_le_pow_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Pow.lean:253:8: `Left.pow_lt_one_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [559/2570] Replayed Mathlib.Data.PNat.Defs
warning: ././.lake/packages/mathlib/././Mathlib/Data/PNat/Defs.lean:131:8: `PNat.coe_toPNat'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [667/2570] Replayed Mathlib.Data.Nat.Find
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Find.lean:71:18: `Nat.find_min'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [691/2570] Replayed Mathlib.Control.Applicative
warning: ././.lake/packages/mathlib/././Mathlib/Control/Applicative.lean:34:8: `Applicative.pure_seq_eq_map'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [807/2570] Replayed Mathlib.Algebra.Order.Group.Abs
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Abs.lean:72:8: `le_abs'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Abs.lean:81:8: `apply_abs_le_mul_of_one_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Abs.lean:100:8: `abs_add'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [820/2570] Replayed Mathlib.Algebra.CharZero.Lemmas
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/CharZero/Lemmas.lean:100:8: `nat_mul_inj'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [880/2570] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [883/2570] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:349:4: declaration uses 'sorry'
⚠ [899/2570] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:30:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:32:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:37:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:39:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:53:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:2: Apply builder was used for a theorem with conclusion A ↔ B.
You probably want to use the simp builder or create an alias that applies the theorem in one direction.
Use `set_option aesop.warn.applyIff false` to disable this warning.
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:57:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:60:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:71:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:70:2: Apply builder was used for a theorem with conclusion A ↔ B.
You probably want to use the simp builder or create an alias that applies the theorem in one direction.
Use `set_option aesop.warn.applyIff false` to disable this warning.
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:76:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:80:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:85:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:99:37: declaration uses 'sorry'
⚠ [905/2570] Replayed SSA.Experimental.Bits.AutoStructs.Basic
warning: ././././SSA/Experimental/Bits/AutoStructs/Basic.lean:461:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Basic.lean:1070:4: declaration uses 'sorry'
⚠ [926/2570] Replayed Mathlib.Algebra.Module.Equiv.Defs
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Module/Equiv/Defs.lean:462:8: `LinearEquiv.mk_coe'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [974/2570] Replayed Mathlib.Algebra.Module.ULift
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Module/ULift.lean:40:9: `ULift.isScalarTower'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Module/ULift.lean:44:9: `ULift.isScalarTower''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Module/ULift.lean:59:9: `ULift.mulAction'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Module/ULift.lean:67:9: `ULift.smulZeroClass'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Module/ULift.lean:73:9: `ULift.distribSMul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Module/ULift.lean:82:9: `ULift.distribMulAction'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Module/ULift.lean:91:9: `ULift.mulDistribMulAction'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Module/ULift.lean:106:9: `ULift.smulWithZero'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Module/ULift.lean:118:9: `ULift.mulActionWithZero'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Module/ULift.lean:131:9: `ULift.module'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [1027/2570] Replayed Mathlib.Order.Iterate
warning: ././.lake/packages/mathlib/././Mathlib/Order/Iterate.lean:170:8: `Function.Commute.iterate_pos_lt_of_map_lt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Iterate.lean:185:8: `Function.Commute.iterate_pos_lt_iff_map_lt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Iterate.lean:193:8: `Function.Commute.iterate_pos_le_iff_map_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [1035/2570] Replayed Mathlib.Data.Countable.Defs
warning: ././.lake/packages/mathlib/././Mathlib/Data/Countable/Defs.lean:104:9: `Prop.countable'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [1163/2570] Replayed Mathlib.Algebra.Order.BigOperators.Group.Multiset
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/BigOperators/Group/Multiset.lean:127:6: `Multiset.prod_lt_prod'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/BigOperators/Group/Multiset.lean:134:6: `Multiset.prod_lt_prod_of_nonempty'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [1266/2570] Replayed Mathlib.Algebra.Order.Group.MinMax
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/MinMax.lean:36:8: `min_inv_inv'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/MinMax.lean:41:8: `max_inv_inv'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/MinMax.lean:46:8: `min_div_div_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/MinMax.lean:50:8: `max_div_div_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/MinMax.lean:54:8: `min_div_div_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/MinMax.lean:58:8: `max_div_div_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [2562/2570] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:28:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:30:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:41:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:53:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:79:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:166:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:183:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:210:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:262:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:274:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:302:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:305:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:318:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:321:4: declaration uses 'sorry'
⚠ [2564/2570] Replayed SSA.Experimental.Bits.AutoStructs.FormulaToAuto
warning: ././././SSA/Experimental/Bits/AutoStructs/FormulaToAuto.lean:381:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/FormulaToAuto.lean:409:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/FormulaToAuto.lean:446:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/FormulaToAuto.lean:551:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/FormulaToAuto.lean:659:4: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/FormulaToAuto.lean:702:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/FormulaToAuto.lean:750:6: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 150.843958 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 18.931375 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 83.903000 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 140.670083 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 11.951667 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.922083 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝².toNat + (2 ^ w - (x✝ ||| ~~~x✝¹).toNat)) % ↑(2 ^ w)
     b := ↑(((x✝ &&& x✝¹ ^^^ x✝¹).toNat + 1 % 2 ^ w) % 2 ^ w + x✝².toNat) % ↑(2 ^ w)
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 114.723625 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 71.503625 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 9.632209 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 78.304417 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       ((x✝ &&& x✝¹ ^^^ x✝¹) + 1#w + x✝² == x✝² + -(x✝ ||| ~~~x✝¹))]
    Consider the following assignment:
    BitVec.ofBool ((x✝ &&& x✝¹ ^^^ x✝¹) + 1#w + x✝² == x✝² + -(x✝ ||| ~~~x✝¹)) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 704.868292 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 143.890584 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 9.703834 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 43.192084 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 85.861208 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.335834 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.804000 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ c ≤ 1
      0 ≤ b ≤ 1
      0 ≤ b + c - 2*d ≤ 1
      0 ≤ a ≤ 1
      a - b - c + 2*d ≥ 1
    where
     a := ↑(x✝ ^^^ x✝¹).toNat
     b := ↑x✝.toNat
     c := ↑x✝¹.toNat
     d := ↑(x✝.toNat + x✝¹.toNat) / 2 MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 62.479250 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq ((AutoStructs.Term.var 0).add (AutoStructs.Term.var 1))
            ((AutoStructs.Term.var 0).xor (AutoStructs.Term.var 1))) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 37.787084 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize PASS, TIME_ELAPSED 1.595625 ms, 
  TACBENCH bv_decide PASS, TIME_ELAPSED 1.625917 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 265.639625 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.501083 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some (x✝ + x✝) ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 9.229500 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 12.363666 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 85.110792 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 7.146709 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.631125 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 0
      a - c ≤ -1
    where
     a := ↑1 % ↑(2 ^ w)
     b := ↑(↑w).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 20.012666 ms, MSGSTART 
    Unsupported syntax some (x✝ + x✝) ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 195399))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 195399))))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.app
                      (Lean.Expr.const `HAdd.hAdd [Lean.Level.zero, Lean.Level.zero, Lean.Level.zero])
                      (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 195399))))
                    (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 195399))))
                  (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 195399))))
                (Lean.Expr.app
                  (Lean.Expr.app
                    (Lean.Expr.const `instHAdd [Lean.Level.zero])
                    (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 195399))))
                  (Lean.Expr.app (Lean.Expr.const `BitVec.instAdd []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 195399)))))
              (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 197305)))
            (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 197305)))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 195399)))) MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 9.709583 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 5.455416 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 77.284500 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (BitVec.ofNat w w >ᵤ 1#w)]
    Consider the following assignment:
    BitVec.ofBool (BitVec.ofNat w w >ᵤ 1#w) = 0x0#1
     MSGEND
  TACBENCH bv_auto FAIL, TIME_ELAPSED 356.757208 ms, MSGSTART 
    internal exception #4 MSGEND
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 174.839708 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 12.410834 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 82.572792 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 96.670042 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.287333 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.565458 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      e ≥ 0
      d ≥ 0
      d - e ≥ 1
      c - d ≥ 1
      c - e ≥ 1
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(↑w).toNat
     b := ↑1 % ↑(2 ^ w)
     c := ↑2 ^ w
     d := ↑(x✝.toNat * 2 ^ (1 % 2 ^ w)) % ↑(2 ^ w)
     e := ↑(x✝.toNat + x✝.toNat) % ↑(2 ^ w) MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 98.232625 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq ((AutoStructs.Term.var 0).add (AutoStructs.Term.var 0))
            (AutoStructs.Term.var 1)) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 74.196000 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 8.660834 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 78.467625 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (BitVec.ofNat w w >ᵤ 1#w),
     BitVec.ofBool (x✝ * 2#w == x✝ <<< 1#w)]
    Consider the following assignment:
    BitVec.ofBool (BitVec.ofNat w w >ᵤ 1#w) = 0x1#1
    BitVec.ofBool (x✝ * 2#w == x✝ <<< 1#w) = 0x0#1
     MSGEND
  TACBENCH bv_auto FAIL, TIME_ELAPSED 927.458500 ms, MSGSTART 
    internal exception #4 MSGEND
TACEND
/Users/tobiasgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/AliveStatements.lean:27:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 159.190417 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 12.898083 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 89.485917 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 129.805083 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.031000 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.797583 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝¹.toNat + (2 ^ w - x✝.toNat)) % ↑(2 ^ w)
     b := ↑((0 % 2 ^ w + (2 ^ w - x✝.toNat)) % 2 ^ w + x✝¹.toNat) % ↑(2 ^ w)
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 110.830084 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 82.712000 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 7.340542 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 78.668875 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (-x✝ + x✝¹ == x✝¹ + -x✝)]
    Consider the following assignment:
    BitVec.ofBool (-x✝ + x✝¹ == x✝¹ + -x✝) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 178.650375 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 252.975250 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 20.926542 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 185.086416 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 138.572958 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.111167 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.595959 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(0 % 2 ^ w + (2 ^ w - (x✝.toNat + x✝¹.toNat) % 2 ^ w)) % ↑(2 ^ w)
     b := ↑((0 % 2 ^ w + (2 ^ w - x✝.toNat)) % 2 ^ w + (0 % 2 ^ w + (2 ^ w - x✝¹.toNat)) % 2 ^ w) % ↑(2 ^ w)
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 206.064333 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 172.435750 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 8.183541 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 79.435459 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (-x✝ + -x✝¹ == -(x✝ + x✝¹))]
    Consider the following assignment:
    BitVec.ofBool (-x✝ + -x✝¹ == -(x✝ + x✝¹)) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 274.169500 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 79.873042 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 12.448541 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 85.097625 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 129.266542 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.998958 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.987292 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝.toNat + (2 ^ w - x✝¹.toNat)) % ↑(2 ^ w)
     b := ↑(x✝.toNat + (0 % 2 ^ w + (2 ^ w - x✝¹.toNat)) % 2 ^ w) % ↑(2 ^ w)
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 114.793417 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 85.351875 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize PASS, TIME_ELAPSED 2.682792 ms, 
  TACBENCH bv_decide PASS, TIME_ELAPSED 2.738625 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 185.666459 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 170.820542 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 16.629042 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 80.051000 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 153.304125 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.740584 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.245084 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑((x✝¹.toNat + (2 ^ w - 1 % 2 ^ w)) % 2 ^ w + (2 ^ w - x✝.toNat)) % ↑(2 ^ w)
     b := ↑((x✝ ^^^ -1#w).toNat + x✝¹.toNat) % ↑(2 ^ w)
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 100.472500 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 69.722583 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 8.080750 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 79.516334 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       ((x✝ ^^^ -1#w) + x✝¹ == x✝¹ + -1#w + -x✝)]
    Consider the following assignment:
    BitVec.ofBool ((x✝ ^^^ -1#w) + x✝¹ == x✝¹ + -1#w + -x✝) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 729.300917 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 55.639750 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 13.709000 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 32.745500 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 99.517041 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.618000 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.233000 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝ ||| x✝¹).toNat
     b := ↑((x✝ &&& x✝¹).toNat + (x✝ ^^^ x✝¹).toNat) % ↑(2 ^ w)
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 41.878375 ms, MSGSTART 
    no goals to be solved MSGEND
  TACBENCH simp PASS, TIME_ELAPSED 31.503458 ms, 
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 6.897208 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 78.572458 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       ((x✝ &&& x✝¹) + (x✝ ^^^ x✝¹) == x✝ ||| x✝¹)]
    Consider the following assignment:
    BitVec.ofBool ((x✝ &&& x✝¹) + (x✝ ^^^ x✝¹) == x✝ ||| x✝¹) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 37.552791 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 48.337791 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 14.911292 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 32.092000 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 105.115750 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.252625 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.785667 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝.toNat + x✝¹.toNat) % ↑(2 ^ w)
     b := ↑((x✝ &&& x✝¹).toNat + (x✝ ||| x✝¹).toNat) % ↑(2 ^ w)
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 40.478792 ms, MSGSTART 
    no goals to be solved MSGEND
  TACBENCH simp PASS, TIME_ELAPSED 30.334458 ms, 
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 7.004500 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 79.135917 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       ((x✝ &&& x✝¹) + (x✝ ||| x✝¹) == x✝ + x✝¹)]
    Consider the following assignment:
    BitVec.ofBool ((x✝ &&& x✝¹) + (x✝ ||| x✝¹) == x✝ + x✝¹) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 36.129292 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 85.864125 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 9.433958 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 67.027167 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 120.658375 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.394125 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.759083 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝.toNat + x✝¹.toNat) % ↑(2 ^ w)
     b := ↑(x✝.toNat + (2 ^ w - (0 % 2 ^ w + (2 ^ w - x✝¹.toNat)) % 2 ^ w)) % ↑(2 ^ w)
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 75.571792 ms, MSGSTART 
    no goals to be solved MSGEND
  TACBENCH simp PASS, TIME_ELAPSED 65.288167 ms, 
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 7.115000 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 78.611250 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (x✝ + - -x✝¹ == x✝ + x✝¹)]
    Consider the following assignment:
    BitVec.ofBool (x✝ + - -x✝¹ == x✝ + x✝¹) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 72.363041 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 57.984625 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 9.931750 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 45.640958 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring PASS, TIME_ELAPSED 97.895042 ms, 
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.321791 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.358250 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝.toNat + (2 ^ w - x✝¹.toNat) % 2 ^ w) % ↑(2 ^ w)
     b := ↑(x✝.toNat + (2 ^ w - x✝¹.toNat)) % ↑(2 ^ w)
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 67.458459 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 40.631875 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize PASS, TIME_ELAPSED 1.575458 ms, 
  TACBENCH bv_decide PASS, TIME_ELAPSED 1.615625 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 134.643958 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 149.643250 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 8.469333 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 27.954541 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 97.802083 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.261541 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.074875 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ d ≤ 1
      0 ≤ b ≤ 1
      -2 ≤ b - 2*c - d ≤ -1
      0 ≤ a ≤ 1
      a - b + 2*c + d ≥ 3
    where
     a := ↑(x✝ ^^^ x✝¹).toNat
     b := ↑x✝.toNat
     c := ↑(x✝.toNat + (2 ^ 1 - x✝¹.toNat)) / 2
     d := ↑x✝¹.toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 48.275417 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq ((AutoStructs.Term.var 0).sub (AutoStructs.Term.var 1))
            ((AutoStructs.Term.var 0).xor (AutoStructs.Term.var 1))) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 23.582333 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 7.540958 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 81.200750 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 269.935667 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 75.709625 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 15.928875 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 37.927209 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 132.801417 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.637000 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.469875 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝ ^^^ -1#w).toNat
     b := ↑((2 ^ w - 1 % 2 ^ w) % 2 ^ w + (2 ^ w - x✝.toNat)) % ↑(2 ^ w)
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 52.513709 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 28.077125 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 6.433417 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 78.057750 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (-1#w + -x✝ == x✝ ^^^ -1#w)]
    Consider the following assignment:
    BitVec.ofBool (-1#w + -x✝ == x✝ ^^^ -1#w) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 201.494083 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 163.072792 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 21.957167 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 59.524541 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 160.133875 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.534667 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.148709 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝¹.toNat + (x✝.toNat + 1 % 2 ^ w) % 2 ^ w) % ↑(2 ^ w)
     b := ↑(x✝.toNat + (2 ^ w - (x✝¹ ^^^ -1#w).toNat)) % ↑(2 ^ w)
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 73.524833 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 41.955667 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 7.563916 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 79.382125 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (x✝ + -(x✝¹ ^^^ -1#w) == x✝¹ + (x✝ + 1#w))]
    Consider the following assignment:
    BitVec.ofBool (x✝ + -(x✝¹ ^^^ -1#w) == x✝¹ + (x✝ + 1#w)) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 578.996708 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 146.349000 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 12.440500 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 58.306417 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring PASS, TIME_ELAPSED 101.841000 ms, 
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.445666 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.862542 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑((x✝.toNat + (2 ^ w - x✝².toNat)) % 2 ^ w + (2 ^ w - x✝¹.toNat)) % ↑(2 ^ w)
     b := ↑(x✝.toNat + (2 ^ w - (x✝¹.toNat + x✝².toNat) % 2 ^ w)) % ↑(2 ^ w)
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 89.380250 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 51.670666 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 8.222209 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 80.110375 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (x✝ + -(x✝¹ + x✝²) == x✝ + -x✝² + -x✝¹)]
    Consider the following assignment:
    BitVec.ofBool (x✝ + -(x✝¹ + x✝²) == x✝ + -x✝² + -x✝¹) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 151.958416 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 89.564083 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 11.764667 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 65.966583 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 117.951500 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.493375 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.694959 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(0 % 2 ^ w + (2 ^ w - x✝¹.toNat)) % ↑(2 ^ w)
     b := ↑(x✝.toNat + (2 ^ w - (x✝.toNat + x✝¹.toNat) % 2 ^ w)) % ↑(2 ^ w)
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 75.428083 ms, MSGSTART 
    no goals to be solved MSGEND
  TACBENCH simp PASS, TIME_ELAPSED 64.927375 ms, 
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 6.936708 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 79.427166 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (x✝ + -(x✝ + x✝¹) == -x✝¹)]
    Consider the following assignment:
    BitVec.ofBool (x✝ + -(x✝ + x✝¹) == -x✝¹) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 72.163875 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 81.824917 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 11.730583 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 59.791625 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 118.078375 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.029708 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.643250 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(0 % 2 ^ w + (2 ^ w - x✝¹.toNat)) % ↑(2 ^ w)
     b := ↑((x✝.toNat + (2 ^ w - x✝¹.toNat)) % 2 ^ w + (2 ^ w - x✝.toNat)) % ↑(2 ^ w)
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 68.440542 ms, MSGSTART 
    no goals to be solved MSGEND
  TACBENCH simp PASS, TIME_ELAPSED 58.030875 ms, 
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 7.218250 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 79.474375 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (x✝ + -x✝¹ + -x✝ == -x✝¹)]
    Consider the following assignment:
    BitVec.ofBool (x✝ + -x✝¹ + -x✝ == -x✝¹) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 65.679916 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 135.020833 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 12.590166 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 41.703666 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 112.058250 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.611667 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.373875 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝ &&& x✝¹).toNat
     b := ↑((x✝ ||| x✝¹).toNat + (2 ^ w - (x✝ ^^^ x✝¹).toNat)) % ↑(2 ^ w)
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 59.061042 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 33.457208 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 7.491667 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 79.740875 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       ((x✝ ||| x✝¹) + -(x✝ ^^^ x✝¹) == x✝ &&& x✝¹)]
    Consider the following assignment:
    BitVec.ofBool ((x✝ ||| x✝¹) + -(x✝ ^^^ x✝¹) == x✝ &&& x✝¹) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 497.722959 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 156.761041 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 13.983500 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 46.505958 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 78.531500 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.852709 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.790375 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝ &&& x✝² ^^^ x✝¹ &&& x✝²).toNat
     b := ↑((x✝ ^^^ x✝¹) &&& x✝²).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 65.850791 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 36.372667 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 6.210625 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 78.752917 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       ((x✝ ^^^ x✝¹) &&& x✝² == x✝ &&& x✝² ^^^ x✝¹ &&& x✝²)]
    Consider the following assignment:
    BitVec.ofBool ((x✝ ^^^ x✝¹) &&& x✝² == x✝ &&& x✝² ^^^ x✝¹ &&& x✝²) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 279.977500 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 160.445292 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 14.079042 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 46.070625 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 78.379750 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.749625 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.836875 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑((x✝ ||| x✝¹ &&& x✝²) &&& x✝²).toNat
     b := ↑((x✝ ||| x✝¹) &&& x✝²).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 63.874000 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 36.497208 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 6.334542 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 77.492250 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       ((x✝ ||| x✝¹) &&& x✝² == (x✝ ||| x✝¹ &&& x✝²) &&& x✝²)]
    Consider the following assignment:
    BitVec.ofBool ((x✝ ||| x✝¹) &&& x✝² == (x✝ ||| x✝¹ &&& x✝²) &&& x✝²) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 275.521625 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 177.204041 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 27.299958 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 76.321208 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 165.998042 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 35.310083 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.222625 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(BitVec.ofBool (x✝ &&& (x✝¹ ||| x✝²) == 0#w)).toNat
     b := ↑(BitVec.ofBool (x✝ &&& x✝¹ == 0#w) &&& BitVec.ofBool (x✝ &&& x✝² == 0#w)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 75.696291 ms, MSGSTART 
    Equality (x✝ &&& x✝¹ == 0#w && x✝ &&& x✝² == 0#w) = (x✝ &&& (x✝¹ ||| x✝²) == 0#w) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 63.121375 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 16.128625 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 94.706250 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (x✝ &&& x✝¹ == 0#w),
     BitVec.ofBool (x✝ &&& x✝² == 0#w),
     BitVec.ofBool (x✝ &&& (x✝¹ ||| x✝²) == 0#w)]
    Consider the following assignment:
    BitVec.ofBool (x✝ &&& x✝¹ == 0#w) = 0x1#1
    BitVec.ofBool (x✝ &&& x✝² == 0#w) = 0x1#1
    BitVec.ofBool (x✝ &&& (x✝¹ ||| x✝²) == 0#w) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 422.076166 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 172.239500 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 27.973875 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 71.746375 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 162.749459 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 36.453291 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.332583 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(BitVec.ofBool (x✝ &&& (x✝¹ ||| x✝²) == x✝¹ ||| x✝²)).toNat
     b := ↑(BitVec.ofBool (x✝ &&& x✝¹ == x✝¹) &&& BitVec.ofBool (x✝ &&& x✝² == x✝²)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 72.924583 ms, MSGSTART 
    Equality (x✝ &&& x✝¹ == x✝¹ && x✝ &&& x✝² == x✝²) = (x✝ &&& (x✝¹ ||| x✝²) == x✝¹ ||| x✝²) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 61.017958 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 16.224333 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 96.330208 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (x✝ &&& x✝¹ == x✝¹),
     BitVec.ofBool (x✝ &&& x✝² == x✝²),
     BitVec.ofBool (x✝ &&& (x✝¹ ||| x✝²) == x✝¹ ||| x✝²)]
    Consider the following assignment:
    BitVec.ofBool (x✝ &&& x✝¹ == x✝¹) = 0x1#1
    BitVec.ofBool (x✝ &&& x✝² == x✝²) = 0x1#1
    BitVec.ofBool (x✝ &&& (x✝¹ ||| x✝²) == x✝¹ ||| x✝²) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 395.283166 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 172.176916 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 25.119167 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 72.389208 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 166.632166 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 34.981291 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.360583 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(BitVec.ofBool (x✝ &&& (x✝¹ &&& x✝²) == x✝)).toNat
     b := ↑(BitVec.ofBool (x✝ &&& x✝¹ == x✝) &&& BitVec.ofBool (x✝ &&& x✝² == x✝)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 74.923791 ms, MSGSTART 
    Equality (x✝ &&& x✝¹ == x✝ && x✝ &&& x✝² == x✝) = (x✝ &&& (x✝¹ &&& x✝²) == x✝) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 62.124208 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 17.426125 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 96.439709 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (x✝ &&& x✝¹ == x✝),
     BitVec.ofBool (x✝ &&& (x✝¹ &&& x✝²) == x✝),
     BitVec.ofBool (x✝ &&& x✝² == x✝)]
    Consider the following assignment:
    BitVec.ofBool (x✝ &&& x✝¹ == x✝) = 0x1#1
    BitVec.ofBool (x✝ &&& x✝² == x✝) = 0x1#1
    BitVec.ofBool (x✝ &&& (x✝¹ &&& x✝²) == x✝) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 389.864250 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 150.008458 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 20.795625 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 41.941000 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 91.366167 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 86.145958 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.287708 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(BitVec.ofBool (x✝ >ₛ x✝¹)).toNat
     b := ↑(BitVec.ofBool (x✝ >ₛ x✝¹) &&& BitVec.ofBool (x✝ != x✝¹)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 55.275000 ms, MSGSTART 
    Unsupported syntax (x✝ >ₛ x✝¹) = true → ¬x✝ = x✝¹ === Lean.Expr.forallE
      (Lean.Name.mkNum `a._@.Init.Data.Bool._hyg 1363)
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.app (Lean.Expr.const `Eq [Lean.Level.succ (Lean.Level.zero)]) (Lean.Expr.const `Bool []))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `BitVec.slt []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1934184)))
              (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1937393)))
            (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1937394))))
        (Lean.Expr.const `Bool.true []))
      (Lean.Expr.app
        (Lean.Expr.const `Not [])
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.const `Eq [Lean.Level.succ (Lean.Level.zero)])
              (Lean.Expr.app (Lean.Expr.const `BitVec []) (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1934184))))
            (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1937394)))
          (Lean.Expr.fvar (Lean.Name.mkNum `_uniq 1937393))))
      (Lean.BinderInfo.default) MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 42.339958 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 15.520792 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 93.678125 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (x✝ == x✝¹),
     BitVec.ofBool (x✝.getLsbD (w - 1)),
     BitVec.ofBool (x✝¹.getLsbD (w - 1)),
     BitVec.ofBool (x✝ >ᵤ x✝¹)]
    Consider the following assignment:
    BitVec.ofBool (x✝¹.getLsbD (w - 1)) = 0x1#1
    BitVec.ofBool (x✝.getLsbD (w - 1)) = 0x1#1
    BitVec.ofBool (x✝ >ᵤ x✝¹) = 0x1#1
    BitVec.ofBool (x✝ == x✝¹) = 0x1#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 199.820750 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 157.027625 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 22.922583 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 53.679542 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 162.751792 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 32.770959 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.979333 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(BitVec.ofBool (x✝ ||| x✝¹ == 0#w)).toNat
     b := ↑(BitVec.ofBool (x✝ == 0#w) &&& BitVec.ofBool (x✝¹ == 0#w)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 56.386791 ms, MSGSTART 
    Equality (x✝ == 0#w && x✝¹ == 0#w) = (x✝ ||| x✝¹ == 0#w) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 46.262750 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 14.877208 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 92.255666 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (x✝ ||| x✝¹ == 0#w),
     BitVec.ofBool (x✝¹ == 0#w),
     BitVec.ofBool (x✝ == 0#w)]
    Consider the following assignment:
    BitVec.ofBool (x✝ == 0#w) = 0x1#1
    BitVec.ofBool (x✝¹ == 0#w) = 0x1#1
    BitVec.ofBool (x✝ ||| x✝¹ == 0#w) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 340.603542 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 68.596208 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 12.518917 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 39.417708 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 99.056334 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 21.031625 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.686083 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 47.479458 ms, MSGSTART 
    no goals to be solved MSGEND
  TACBENCH simp PASS, TIME_ELAPSED 37.965583 ms, 
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 11.355542 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 90.659583 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 43.058875 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 110.977083 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 18.550084 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 56.255042 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 119.027708 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.083250 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.169167 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑((x✝ ||| x✝¹) ^^^ -1#w).toNat
     b := ↑((x✝ ^^^ -1#w) &&& (x✝¹ ^^^ -1#w)).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 69.895250 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 41.578416 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 7.029667 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 79.078958 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       ((x✝ ^^^ -1#w) &&& (x✝¹ ^^^ -1#w) == (x✝ ||| x✝¹) ^^^ -1#w)]
    Consider the following assignment:
    BitVec.ofBool ((x✝ ^^^ -1#w) &&& (x✝¹ ^^^ -1#w) == (x✝ ||| x✝¹) ^^^ -1#w) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 223.143583 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 180.524209 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 19.695125 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 57.050500 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 123.242083 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.878958 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.442875 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝ ^^^ x✝¹).toNat
     b := ↑((x✝ ||| x✝¹) &&& (x✝ &&& x✝¹ ^^^ -1#w)).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 74.367875 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 43.263750 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 7.102375 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 79.538792 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       ((x✝ ||| x✝¹) &&& (x✝ &&& x✝¹ ^^^ -1#w) == x✝ ^^^ x✝¹)]
    Consider the following assignment:
    BitVec.ofBool ((x✝ ||| x✝¹) &&& (x✝ &&& x✝¹ ^^^ -1#w) == x✝ ^^^ x✝¹) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 297.968042 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 180.267000 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 19.418292 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 56.973750 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 117.208500 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.085375 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.188666 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝ ^^^ x✝¹).toNat
     b := ↑((x✝ &&& x✝¹ ^^^ -1#w) &&& (x✝ ||| x✝¹)).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 70.323167 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 41.998459 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 6.876667 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 79.761959 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       ((x✝ &&& x✝¹ ^^^ -1#w) &&& (x✝ ||| x✝¹) == x✝ ^^^ x✝¹)]
    Consider the following assignment:
    BitVec.ofBool ((x✝ &&& x✝¹ ^^^ -1#w) &&& (x✝ ||| x✝¹) == x✝ ^^^ x✝¹) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 298.560083 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 170.102167 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 21.291250 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 51.139583 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 116.536917 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.044666 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.986250 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝ &&& (x✝¹ ^^^ -1#w)).toNat
     b := ↑((x✝ ^^^ x✝¹) &&& x✝).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 63.569750 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 36.641542 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 6.273667 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 78.840416 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       ((x✝ ^^^ x✝¹) &&& x✝ == x✝ &&& (x✝¹ ^^^ -1#w))]
    Consider the following assignment:
    BitVec.ofBool ((x✝ ^^^ x✝¹) &&& x✝ == x✝ &&& (x✝¹ ^^^ -1#w)) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 279.079625 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 175.575000 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 16.821625 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 50.228375 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 117.001666 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.933500 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.104125 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝ &&& x✝¹).toNat
     b := ↑((x✝ ^^^ -1#w ||| x✝¹) &&& x✝).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 64.559250 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 37.478750 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 6.626666 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 79.417334 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       ((x✝ ^^^ -1#w ||| x✝¹) &&& x✝ == x✝ &&& x✝¹)]
    Consider the following assignment:
    BitVec.ofBool ((x✝ ^^^ -1#w ||| x✝¹) &&& x✝ == x✝ &&& x✝¹) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 282.903875 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 197.954291 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 20.556292 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 64.188458 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 112.976625 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.939625 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.061667 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑((x✝ ^^^ x✝¹) &&& (x✝² ^^^ -1#w)).toNat
     b := ↑((x✝ ^^^ x✝¹) &&& (x✝¹ ^^^ x✝² ^^^ x✝)).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 81.116375 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 49.846916 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 7.007333 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 78.712209 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       ((x✝ ^^^ x✝¹) &&& (x✝¹ ^^^ x✝² ^^^ x✝) == (x✝ ^^^ x✝¹) &&& (x✝² ^^^ -1#w))]
    Consider the following assignment:
    BitVec.ofBool ((x✝ ^^^ x✝¹) &&& (x✝¹ ^^^ x✝² ^^^ x✝) == (x✝ ^^^ x✝¹) &&& (x✝² ^^^ -1#w)) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 323.104000 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 185.197500 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 19.013500 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 55.682334 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 118.591250 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.115625 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.162125 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝ &&& x✝¹).toNat
     b := ↑((x✝ ||| x✝¹) &&& (x✝ ^^^ -1#w ^^^ x✝¹)).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 70.181750 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 41.672583 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 6.832166 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 79.968083 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       ((x✝ ||| x✝¹) &&& (x✝ ^^^ -1#w ^^^ x✝¹) == x✝ &&& x✝¹)]
    Consider the following assignment:
    BitVec.ofBool ((x✝ ||| x✝¹) &&& (x✝ ^^^ -1#w ^^^ x✝¹) == x✝ &&& x✝¹) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 301.798208 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 143.342000 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 16.184083 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 39.382708 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 91.141792 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 27.932167 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.789291 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(BitVec.ofBool (x✝ ≥ᵤ x✝¹)).toNat
     b := ↑(BitVec.ofBool (x✝ >ᵤ x✝¹) ||| BitVec.ofBool (x✝ == x✝¹)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 45.014917 ms, MSGSTART 
    Equality ((x✝ >ᵤ x✝¹) || x✝ == x✝¹) = (x✝ ≥ᵤ x✝¹) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 34.289166 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 11.935792 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 89.954291 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (x✝ >ᵤ x✝¹),
     BitVec.ofBool (x✝¹ >ᵤ x✝),
     BitVec.ofBool (x✝ == x✝¹)]
    Consider the following assignment:
    BitVec.ofBool (x✝ >ᵤ x✝¹) = 0x1#1
    BitVec.ofBool (x✝ == x✝¹) = 0x1#1
    BitVec.ofBool (x✝¹ >ᵤ x✝) = 0x1#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 141.967458 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 176.664250 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 12.632042 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 39.212208 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 101.555875 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 23.598250 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.530458 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 62.622458 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 37.457250 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 10.778708 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 87.427333 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (x✝¹ >ᵤ x✝),
     BitVec.ofBool (x✝ == x✝¹)]
    Consider the following assignment:
    BitVec.ofBool (x✝¹ >ᵤ x✝) = 0x1#1
    BitVec.ofBool (x✝ == x✝¹) = 0x1#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 133.540083 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 180.358458 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 21.928959 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 78.740417 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 193.652375 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 26.802709 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.129875 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(BitVec.ofBool (x✝ + -1#w ≥ᵤ x✝¹)).toNat
     b := ↑(BitVec.ofBool (x✝ == 0#w) ||| BitVec.ofBool (x✝ >ᵤ x✝¹)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 78.786042 ms, MSGSTART 
    Equality (x✝ == 0#w || x✝ >ᵤ x✝¹) = (x✝ + -1#w ≥ᵤ x✝¹) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 68.115708 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 13.440541 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 89.075625 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (x✝¹ >ᵤ x✝ + -1#w),
     BitVec.ofBool (x✝ == 0#w),
     BitVec.ofBool (x✝ >ᵤ x✝¹)]
    Consider the following assignment:
    BitVec.ofBool (x✝ == 0#w) = 0x1#1
    BitVec.ofBool (x✝ >ᵤ x✝¹) = 0x1#1
    BitVec.ofBool (x✝¹ >ᵤ x✝ + -1#w) = 0x1#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 537.482625 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 182.317375 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 21.721708 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 81.278583 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 196.425833 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 27.204041 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.119375 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(BitVec.ofBool (x✝ + -1#w ≥ᵤ x✝¹)).toNat
     b := ↑(BitVec.ofBool (x✝ == 0#w) ||| BitVec.ofBool (x✝ >ᵤ x✝¹)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 80.438541 ms, MSGSTART 
    Equality (x✝ == 0#w || x✝ >ᵤ x✝¹) = (x✝ + -1#w ≥ᵤ x✝¹) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 67.917000 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 13.446625 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 91.494916 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (x✝ == 0#w),
     BitVec.ofBool (x✝ >ᵤ x✝¹),
     BitVec.ofBool (x✝¹ >ᵤ x✝ + -1#w)]
    Consider the following assignment:
    BitVec.ofBool (x✝ == 0#w) = 0x1#1
    BitVec.ofBool (x✝ >ᵤ x✝¹) = 0x1#1
    BitVec.ofBool (x✝¹ >ᵤ x✝ + -1#w) = 0x1#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 465.819875 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 160.518709 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 23.149125 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 53.028250 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 164.411167 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 40.967541 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.821375 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(BitVec.ofBool (x✝ ||| x✝¹ != 0#w)).toNat
     b := ↑(BitVec.ofBool (x✝ != 0#w) ||| BitVec.ofBool (x✝¹ != 0#w)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 54.627958 ms, MSGSTART 
    Equality (x✝ != 0#w || x✝¹ != 0#w) = (x✝ ||| x✝¹ != 0#w) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 44.041708 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 14.639500 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 93.368083 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (x✝ ||| x✝¹ == 0#w),
     BitVec.ofBool (x✝¹ == 0#w),
     BitVec.ofBool (x✝ == 0#w)]
    Consider the following assignment:
    BitVec.ofBool (x✝ == 0#w) = 0x1#1
    BitVec.ofBool (x✝¹ == 0#w) = 0x1#1
    BitVec.ofBool (x✝ ||| x✝¹ == 0#w) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 417.031708 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 173.561750 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 15.466208 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 53.073708 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 84.946500 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.945417 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.087958 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑((x✝ ||| x✝²) ^^^ x✝¹ &&& ~~~x✝²).toNat
     b := ↑(x✝ ^^^ x✝¹ ||| x✝²).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 69.525791 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 41.390167 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 6.651708 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 80.200958 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (x✝ ^^^ x✝¹ ||| x✝² == (x✝ ||| x✝²) ^^^ x✝¹ &&& ~~~x✝²)]
    Consider the following assignment:
    BitVec.ofBool (x✝ ^^^ x✝¹ ||| x✝² == (x✝ ||| x✝²) ^^^ x✝¹ &&& ~~~x✝²) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 297.024291 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 175.442250 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 17.009541 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 49.553042 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 116.802750 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.928708 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.093375 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝ ||| x✝¹).toNat
     b := ↑((x✝ ^^^ -1#w) &&& x✝¹ ||| x✝).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 64.333166 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 37.375667 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 6.458667 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 79.053791 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       ((x✝ ^^^ -1#w) &&& x✝¹ ||| x✝ == x✝ ||| x✝¹)]
    Consider the following assignment:
    BitVec.ofBool ((x✝ ^^^ -1#w) &&& x✝¹ ||| x✝ == x✝ ||| x✝¹) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 283.812417 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 175.732500 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 17.445667 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 49.740625 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 120.008500 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.135250 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.213500 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝ ^^^ -1#w ||| x✝¹).toNat
     b := ↑(x✝ &&& x✝¹ ||| x✝ ^^^ -1#w).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 67.135750 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 38.823458 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 6.790208 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 79.650417 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (x✝ &&& x✝¹ ||| x✝ ^^^ -1#w == x✝ ^^^ -1#w ||| x✝¹)]
    Consider the following assignment:
    BitVec.ofBool (x✝ &&& x✝¹ ||| x✝ ^^^ -1#w == x✝ ^^^ -1#w ||| x✝¹) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 291.374083 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 120.076625 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 17.170042 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 49.696333 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 116.230667 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.021166 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.051875 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝ ^^^ x✝¹).toNat
     b := ↑(x✝ &&& (x✝¹ ^^^ -1#w) ||| x✝ ^^^ x✝¹).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 64.415834 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 37.362750 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 6.365875 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 80.055750 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (x✝ &&& (x✝¹ ^^^ -1#w) ||| x✝ ^^^ x✝¹ == x✝ ^^^ x✝¹)]
    Consider the following assignment:
    BitVec.ofBool (x✝ &&& (x✝¹ ^^^ -1#w) ||| x✝ ^^^ x✝¹ == x✝ ^^^ x✝¹) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 233.878500 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 204.418583 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 19.461375 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 60.944917 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 117.331042 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.184500 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.205458 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝ ^^^ x✝¹).toNat
     b := ↑(x✝ &&& (x✝¹ ^^^ -1#w) ||| (x✝ ^^^ -1#w) &&& x✝¹).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 74.783459 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 46.426042 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 7.013125 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 80.456583 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (x✝ &&& (x✝¹ ^^^ -1#w) ||| (x✝ ^^^ -1#w) &&& x✝¹ == x✝ ^^^ x✝¹)]
    Consider the following assignment:
    BitVec.ofBool (x✝ &&& (x✝¹ ^^^ -1#w) ||| (x✝ ^^^ -1#w) &&& x✝¹ == x✝ ^^^ x✝¹) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 324.584334 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 164.084292 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 12.663250 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 44.841708 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 79.496000 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.404458 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.842542 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝ ^^^ x✝¹ ||| x✝²).toNat
     b := ↑(x✝ ^^^ x✝¹ ||| x✝¹ ^^^ x✝² ^^^ x✝).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 64.553417 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 37.954125 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 5.938875 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 78.937042 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (x✝ ^^^ x✝¹ ||| x✝¹ ^^^ x✝² ^^^ x✝ == x✝ ^^^ x✝¹ ||| x✝²)]
    Consider the following assignment:
    BitVec.ofBool (x✝ ^^^ x✝¹ ||| x✝¹ ^^^ x✝² ^^^ x✝ == x✝ ^^^ x✝¹ ||| x✝²) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 280.282583 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 160.392500 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 14.396417 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 46.054875 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 78.617458 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.182958 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.793583 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝ ||| x✝² &&& x✝¹).toNat
     b := ↑((x✝ ||| x✝¹) &&& x✝² ||| x✝).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 64.738792 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 36.867791 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 6.124875 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 79.455791 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       ((x✝ ||| x✝¹) &&& x✝² ||| x✝ == x✝ ||| x✝² &&& x✝¹)]
    Consider the following assignment:
    BitVec.ofBool ((x✝ ||| x✝¹) &&& x✝² ||| x✝ == x✝ ||| x✝² &&& x✝¹) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 277.451084 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 113.632500 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 18.579125 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 57.635500 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 117.026125 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.001000 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.119042 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝ &&& x✝¹ ^^^ -1#w).toNat
     b := ↑(x✝ ^^^ -1#w ||| x✝¹ ^^^ -1#w).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 69.694500 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 41.498917 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 6.584292 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 79.705834 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (x✝ ^^^ -1#w ||| x✝¹ ^^^ -1#w == x✝ &&& x✝¹ ^^^ -1#w)]
    Consider the following assignment:
    BitVec.ofBool (x✝ ^^^ -1#w ||| x✝¹ ^^^ -1#w == x✝ &&& x✝¹ ^^^ -1#w) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 221.491458 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 135.203625 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 10.688583 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 29.487334 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 78.399250 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 7.906000 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.643375 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝ ||| x✝¹).toNat
     b := ↑(x✝ ||| x✝ ^^^ x✝¹).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 46.969541 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 23.470459 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 5.194958 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 78.342000 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (x✝ ||| x✝ ^^^ x✝¹ == x✝ ||| x✝¹)]
    Consider the following assignment:
    BitVec.ofBool (x✝ ||| x✝ ^^^ x✝¹ == x✝ ||| x✝¹) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 238.473375 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 195.128666 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 19.136625 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 54.125875 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 112.695542 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.976583 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.113500 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝ ||| x✝¹ ^^^ -1#w).toNat
     b := ↑(x✝ ||| x✝ ^^^ -1#w ^^^ x✝¹).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 69.299500 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 41.238792 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 6.374041 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 77.475833 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (x✝ ||| x✝ ^^^ -1#w ^^^ x✝¹ == x✝ ||| x✝¹ ^^^ -1#w)]
    Consider the following assignment:
    BitVec.ofBool (x✝ ||| x✝ ^^^ -1#w ^^^ x✝¹ == x✝ ||| x✝¹ ^^^ -1#w) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 306.552667 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 144.181208 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 14.706667 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 37.894209 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 82.583208 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.497583 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.952667 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝ ||| x✝¹).toNat
     b := ↑(x✝ &&& x✝¹ ||| x✝ ^^^ x✝¹).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 53.536375 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 28.443417 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 6.031291 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 79.251209 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (x✝ &&& x✝¹ ||| x✝ ^^^ x✝¹ == x✝ ||| x✝¹)]
    Consider the following assignment:
    BitVec.ofBool (x✝ &&& x✝¹ ||| x✝ ^^^ x✝¹ == x✝ ||| x✝¹) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 258.024167 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 189.698333 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 21.432250 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 58.635166 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 113.804208 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.751125 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.001375 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝ ||| x✝¹ ^^^ -1#w).toNat
     b := ↑(x✝ ||| (x✝ ||| x✝¹) ^^^ -1#w).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 70.719459 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 41.685500 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 6.735833 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 78.232042 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (x✝ ||| (x✝ ||| x✝¹) ^^^ -1#w == x✝ ||| x✝¹ ^^^ -1#w)]
    Consider the following assignment:
    BitVec.ofBool (x✝ ||| (x✝ ||| x✝¹) ^^^ -1#w == x✝ ||| x✝¹ ^^^ -1#w) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 304.300917 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 193.703666 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 19.730375 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 56.353042 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 118.410541 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.965458 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.122458 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝ ||| x✝¹ ^^^ -1#w).toNat
     b := ↑(x✝ ||| x✝ ^^^ x✝¹ ^^^ -1#w).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 69.673792 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 41.543041 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 6.345750 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 79.701708 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (x✝ ||| x✝ ^^^ x✝¹ ^^^ -1#w == x✝ ||| x✝¹ ^^^ -1#w)]
    Consider the following assignment:
    BitVec.ofBool (x✝ ||| x✝ ^^^ x✝¹ ^^^ -1#w == x✝ ||| x✝¹ ^^^ -1#w) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 303.571958 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 122.333459 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 17.195084 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 50.041291 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 117.085708 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.955208 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.084375 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝ ^^^ -1#w ^^^ x✝¹).toNat
     b := ↑(x✝ &&& x✝¹ ||| x✝ ^^^ -1#w ^^^ x✝¹).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 65.648625 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 37.088750 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 6.390958 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 80.139000 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (x✝ &&& x✝¹ ||| x✝ ^^^ -1#w ^^^ x✝¹ == x✝ ^^^ -1#w ^^^ x✝¹)]
    Consider the following assignment:
    BitVec.ofBool (x✝ &&& x✝¹ ||| x✝ ^^^ -1#w ^^^ x✝¹ == x✝ ^^^ -1#w ^^^ x✝¹) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 231.201000 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 151.959125 ms, 
  TACBENCH bv_ac PASS, TIME_ELAPSED 8.027208 ms, 
  TACBENCH bv_distrib PASS, TIME_ELAPSED 63.329125 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 74.617500 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 7.752584 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.594084 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝ ||| x✝² ||| x✝¹).toNat
     b := ↑(x✝ ||| x✝¹ ||| x✝²).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 57.706584 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 31.387708 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 5.296458 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 76.808958 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (x✝ ||| x✝¹ ||| x✝² == x✝ ||| x✝² ||| x✝¹)]
    Consider the following assignment:
    BitVec.ofBool (x✝ ||| x✝¹ ||| x✝² == x✝ ||| x✝² ||| x✝¹) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 259.740250 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 126.234708 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 19.921625 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 59.094000 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 128.470291 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.422000 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.113250 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝ ||| x✝¹ ^^^ -1#w).toNat
     b := ↑((x✝ ^^^ -1#w) &&& x✝¹ ^^^ -1#w).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 74.736541 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 45.259333 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 6.813208 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 80.314542 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       ((x✝ ^^^ -1#w) &&& x✝¹ ^^^ -1#w == x✝ ||| x✝¹ ^^^ -1#w)]
    Consider the following assignment:
    BitVec.ofBool ((x✝ ^^^ -1#w) &&& x✝¹ ^^^ -1#w == x✝ ||| x✝¹ ^^^ -1#w) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 228.444459 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 120.901000 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 18.193917 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 57.850333 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 116.769125 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.000541 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.118917 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝ &&& (x✝¹ ^^^ -1#w)).toNat
     b := ↑((x✝ ^^^ -1#w ||| x✝¹) ^^^ -1#w).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 70.321667 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 43.402500 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 7.001750 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 81.152709 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       ((x✝ ^^^ -1#w ||| x✝¹) ^^^ -1#w == x✝ &&& (x✝¹ ^^^ -1#w))]
    Consider the following assignment:
    BitVec.ofBool ((x✝ ^^^ -1#w ||| x✝¹) ^^^ -1#w == x✝ &&& (x✝¹ ^^^ -1#w)) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 241.630625 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 115.935833 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 20.696750 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 58.694250 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 117.963750 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.981375 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.134042 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝ ^^^ -1#w ||| x✝¹ ^^^ -1#w).toNat
     b := ↑(x✝ &&& x✝¹ ^^^ -1#w).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 70.186875 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 42.125959 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 6.731166 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 80.361375 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (x✝ &&& x✝¹ ^^^ -1#w == x✝ ^^^ -1#w ||| x✝¹ ^^^ -1#w)]
    Consider the following assignment:
    BitVec.ofBool (x✝ &&& x✝¹ ^^^ -1#w == x✝ ^^^ -1#w ||| x✝¹ ^^^ -1#w) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 222.117708 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 109.122625 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 18.090042 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 55.050584 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 117.502750 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.192084 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.174375 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑((x✝ ^^^ -1#w) &&& (x✝¹ ^^^ -1#w)).toNat
     b := ↑((x✝ ||| x✝¹) ^^^ -1#w).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 69.908833 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 42.253958 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 6.733833 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 79.628167 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       ((x✝ ||| x✝¹) ^^^ -1#w == (x✝ ^^^ -1#w) &&& (x✝¹ ^^^ -1#w))]
    Consider the following assignment:
    BitVec.ofBool ((x✝ ||| x✝¹) ^^^ -1#w == (x✝ ^^^ -1#w) &&& (x✝¹ ^^^ -1#w)) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 222.098583 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 98.270542 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 18.738167 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 65.816375 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 109.351792 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 7.903500 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.337000 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      e ≥ 0
      d ≥ 0
      d - e ≥ 1
      c - d ≥ 1
      c - e ≥ 1
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(↑w).toNat
     b := ↑x✝¹.toNat
     c := ↑2 ^ w
     d := ↑(x✝.sshiftRight' x✝¹).toNat
     e := ↑((x✝ ^^^ -1#w).sshiftRight' x✝¹ ^^^ -1#w).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 87.184917 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq ((AutoStructs.Term.var 0).xor AutoStructs.Term.one.neg)
            (AutoStructs.Term.var 1)) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 53.193125 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 8.504041 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 81.667209 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       ((x✝ ^^^ -1#w).sshiftRight' x✝¹ ^^^ -1#w == x✝.sshiftRight' x✝¹),
     BitVec.ofBool (BitVec.ofNat w w >ᵤ x✝¹)]
    Consider the following assignment:
    BitVec.ofBool (BitVec.ofNat w w >ᵤ x✝¹) = 0x1#1
    BitVec.ofBool ((x✝ ^^^ -1#w).sshiftRight' x✝¹ ^^^ -1#w == x✝.sshiftRight' x✝¹) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 80.483958 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 118.021458 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 18.467542 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 52.629875 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 105.435417 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 24.194500 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.680334 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(BitVec.ofBool (x✝ ≥ₛ x✝¹)).toNat
     b := ↑(BitVec.ofBool (x✝¹ >ₛ x✝) ^^^ -1#1).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 84.606125 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq ((AutoStructs.Term.var 0).xor AutoStructs.Term.one)
            (AutoStructs.Term.var 1)) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 42.315375 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 14.042875 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 96.060375 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 230.278542 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 179.232958 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 30.578167 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 62.415000 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 156.306416 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.910125 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.982250 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝¹.toNat + ((2 ^ w - 1 % 2 ^ w) % 2 ^ w + (2 ^ w - x✝.toNat)) % 2 ^ w) % ↑(2 ^ w)
     b := ↑(x✝ - x✝¹ ^^^ -1#w).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 71.325334 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 40.430166 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 7.869542 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 81.420917 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (x✝ + -x✝¹ ^^^ -1#w == x✝¹ + (-1#w + -x✝))]
    Consider the following assignment:
    BitVec.ofBool (x✝ + -x✝¹ ^^^ -1#w == x✝¹ + (-1#w + -x✝)) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 748.359583 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 179.379292 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 23.444584 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 66.263334 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 148.594833 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.997917 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.022208 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(((2 ^ w - 1 % 2 ^ w) % 2 ^ w + (2 ^ w - x✝¹.toNat)) % 2 ^ w + (2 ^ w - x✝.toNat)) % ↑(2 ^ w)
     b := ↑(x✝ + x✝¹ ^^^ -1#w).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 82.651959 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 52.231375 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 7.774000 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 81.434959 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (x✝ + x✝¹ ^^^ -1#w == -1#w + -x✝¹ + -x✝)]
    Consider the following assignment:
    BitVec.ofBool (x✝ + x✝¹ ^^^ -1#w == -1#w + -x✝¹ + -x✝) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 681.695792 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 171.168500 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 17.238708 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 49.598750 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 119.279500 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.824500 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.056583 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝ &&& (x✝¹ ^^^ -1#w)).toNat
     b := ↑((x✝ ||| x✝¹) ^^^ x✝¹).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 66.603542 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 37.621042 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 6.434959 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 79.353042 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       ((x✝ ||| x✝¹) ^^^ x✝¹ == x✝ &&& (x✝¹ ^^^ -1#w))]
    Consider the following assignment:
    BitVec.ofBool ((x✝ ||| x✝¹) ^^^ x✝¹ == x✝ &&& (x✝¹ ^^^ -1#w)) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 284.837500 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 171.701166 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 16.935500 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 50.402083 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 116.947417 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.649500 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.973084 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑((x✝ ^^^ -1#w) &&& x✝¹).toNat
     b := ↑(x✝ &&& x✝¹ ^^^ x✝¹).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 66.391666 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 37.041916 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 6.230583 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 79.736792 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (x✝ &&& x✝¹ ^^^ x✝¹ == (x✝ ^^^ -1#w) &&& x✝¹)]
    Consider the following assignment:
    BitVec.ofBool (x✝ &&& x✝¹ ^^^ x✝¹ == (x✝ ^^^ -1#w) &&& x✝¹) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 279.419625 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 146.514500 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 14.180250 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 37.686166 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 82.031583 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.527833 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.885417 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝ ^^^ x✝¹).toNat
     b := ↑(x✝ &&& x✝¹ ^^^ (x✝ ||| x✝¹)).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 52.647500 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 28.409917 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 5.916167 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 79.124000 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (x✝ &&& x✝¹ ^^^ (x✝ ||| x✝¹) == x✝ ^^^ x✝¹)]
    Consider the following assignment:
    BitVec.ofBool (x✝ &&& x✝¹ ^^^ (x✝ ||| x✝¹) == x✝ ^^^ x✝¹) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 255.202083 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 207.265375 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 18.067750 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 59.349292 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 115.862292 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.286750 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.061542 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝ ^^^ x✝¹).toNat
     b := ↑((x✝ ||| x✝¹ ^^^ -1#w) ^^^ (x✝ ^^^ -1#w ||| x✝¹)).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 75.983625 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 46.234167 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 6.448625 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 79.784208 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       ((x✝ ||| x✝¹ ^^^ -1#w) ^^^ (x✝ ^^^ -1#w ||| x✝¹) == x✝ ^^^ x✝¹)]
    Consider the following assignment:
    BitVec.ofBool ((x✝ ||| x✝¹ ^^^ -1#w) ^^^ (x✝ ^^^ -1#w ||| x✝¹) == x✝ ^^^ x✝¹) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 327.525416 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 203.658875 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 19.062125 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 60.193916 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 113.320000 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.867250 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.026250 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝ ^^^ x✝¹).toNat
     b := ↑(x✝ &&& (x✝¹ ^^^ -1#w) ^^^ (x✝ ^^^ -1#w) &&& x✝¹).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 74.587917 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 45.878250 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 6.760125 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 76.293334 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (x✝ &&& (x✝¹ ^^^ -1#w) ^^^ (x✝ ^^^ -1#w) &&& x✝¹ == x✝ ^^^ x✝¹)]
    Consider the following assignment:
    BitVec.ofBool (x✝ &&& (x✝¹ ^^^ -1#w) ^^^ (x✝ ^^^ -1#w) &&& x✝¹ == x✝ ^^^ x✝¹) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 323.763292 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 201.517166 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 19.714000 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 64.730250 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 117.970250 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.356041 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.230083 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑((x✝ ^^^ -1#w) &&& x✝² ^^^ x✝¹).toNat
     b := ↑(x✝ ^^^ x✝¹ ^^^ (x✝ ||| x✝²)).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 82.398334 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 51.046834 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 7.175000 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 80.577042 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (x✝ ^^^ x✝¹ ^^^ (x✝ ||| x✝²) == (x✝ ^^^ -1#w) &&& x✝² ^^^ x✝¹)]
    Consider the following assignment:
    BitVec.ofBool (x✝ ^^^ x✝¹ ^^^ (x✝ ||| x✝²) == (x✝ ^^^ -1#w) &&& x✝² ^^^ x✝¹) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 331.231458 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 147.369250 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 13.136459 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 36.615625 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 83.377125 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.690375 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.048167 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝ ||| x✝¹).toNat
     b := ↑(x✝ &&& x✝¹ ^^^ (x✝ ^^^ x✝¹)).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 55.248333 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 28.803875 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 5.975166 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 77.465291 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (x✝ &&& x✝¹ ^^^ (x✝ ^^^ x✝¹) == x✝ ||| x✝¹)]
    Consider the following assignment:
    BitVec.ofBool (x✝ &&& x✝¹ ^^^ (x✝ ^^^ x✝¹) == x✝ ||| x✝¹) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 263.989542 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 205.945541 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 21.921958 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 60.841583 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 113.482000 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.904250 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.056500 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝ &&& x✝¹ ^^^ -1#w).toNat
     b := ↑(x✝ &&& (x✝¹ ^^^ -1#w) ^^^ (x✝ ^^^ -1#w)).toNat
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic PASS, TIME_ELAPSED 74.381208 ms, 
  TACBENCH simp FAIL, TIME_ELAPSED 46.376750 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 6.964958 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 80.637916 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (x✝ &&& (x✝¹ ^^^ -1#w) ^^^ (x✝ ^^^ -1#w) == x✝ &&& x✝¹ ^^^ -1#w)]
    Consider the following assignment:
    BitVec.ofBool (x✝ &&& (x✝¹ ^^^ -1#w) ^^^ (x✝ ^^^ -1#w) == x✝ &&& x✝¹ ^^^ -1#w) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 322.408000 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 149.327167 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 15.784750 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 40.605875 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 94.206166 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool PASS, TIME_ELAPSED 37.879542 ms, 
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.648625 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(BitVec.ofBool (x✝ ≥ᵤ x✝¹)).toNat
     b := ↑(BitVec.ofBool (x✝¹ ≥ᵤ x✝) ^^^ BitVec.ofBool (x✝ != x✝¹)).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 45.295916 ms, MSGSTART 
    Equality ((x✝¹ ≥ᵤ x✝) ^^ x✝ != x✝¹) = (x✝ ≥ᵤ x✝¹) has a strange type MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 34.625333 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 12.394292 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 91.499625 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (x✝¹ >ᵤ x✝),
     BitVec.ofBool (x✝ == x✝¹),
     BitVec.ofBool (x✝ >ᵤ x✝¹)]
    Consider the following assignment:
    BitVec.ofBool (x✝ >ᵤ x✝¹) = 0x1#1
    BitVec.ofBool (x✝ == x✝¹) = 0x1#1
    BitVec.ofBool (x✝¹ >ᵤ x✝) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 164.914459 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 69.752166 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 28.201458 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 76.615125 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 125.556917 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.069833 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.887791 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(0 % 2 ^ w + (2 ^ w - x✝.toNat)) % ↑(2 ^ w)
     b := ↑(x✝.toNat * ((2 ^ w - 1 % 2 ^ w) % 2 ^ w)) % ↑(2 ^ w)
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 85.760375 ms, MSGSTART 
    no goals to be solved MSGEND
  TACBENCH simp PASS, TIME_ELAPSED 74.614375 ms, 
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 5.838458 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 79.216458 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (x✝ * -1#w == -x✝)]
    Consider the following assignment:
    BitVec.ofBool (x✝ * -1#w == -x✝) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 52.699042 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 130.087708 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 19.146000 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 142.267041 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring PASS, TIME_ELAPSED 87.183958 ms, 
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.169042 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.074542 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝.toNat * x✝².toNat % 2 ^ w + x✝¹.toNat * x✝².toNat % 2 ^ w) % ↑(2 ^ w)
     b := ↑((x✝.toNat + x✝¹.toNat) % 2 ^ w * x✝².toNat) % ↑(2 ^ w)
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 164.548542 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0)
            ((AutoStructs.Term.var 1).add (AutoStructs.Term.var 2))) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 129.448541 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 6.579083 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 79.666875 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       ((x✝ + x✝¹) * x✝² == x✝ * x✝² + x✝¹ * x✝²)]
    Consider the following assignment:
    BitVec.ofBool ((x✝ + x✝¹) * x✝² == x✝ * x✝² + x✝¹ * x✝²) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 213.688208 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 133.390583 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 19.690125 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 117.161333 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 139.940000 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.379167 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.310333 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(x✝.toNat * x✝¹.toNat) % ↑(2 ^ w)
     b := ↑((0 % 2 ^ w + (2 ^ w - x✝.toNat)) % 2 ^ w * ((0 % 2 ^ w + (2 ^ w - x✝¹.toNat)) % 2 ^ w)) % ↑(2 ^ w)
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 126.315541 ms, MSGSTART 
    no goals to be solved MSGEND
  TACBENCH simp PASS, TIME_ELAPSED 112.668459 ms, 
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 6.745916 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 79.963250 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (-x✝ * -x✝¹ == x✝ * x✝¹)]
    Consider the following assignment:
    BitVec.ofBool (-x✝ * -x✝¹ == x✝ * x✝¹) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 124.481167 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 168.856375 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 10.690375 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 161.751333 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 108.600625 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.747625 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 8.400292 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      1 ≤ f ≤ 31
      0 ≤ e ≤ 32
      c ≥ 0
      0 ≤ c - 32*d ≤ 31
      0 ≤ a ≤ 31
      a - 32*b - c + 32*d - e ≥ -31
      -32 ≤ a - 32*b - e ≤ -1
    where
     a := ↑x✝.toNat
     b := ↑(x✝.toNat + (2 ^ 5 - x✝.toNat % x✝¹.toNat)) / 32
     c := ↑(x✝.toNat / x✝¹.toNat) * ↑x✝¹.toNat
     d := ↑(x✝.toNat / x✝¹.toNat * x✝¹.toNat) / 32
     e := ↑x✝.toNat % ↑x✝¹.toNat
     f := ↑x✝¹.toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 182.801333 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0)
            ((AutoStructs.Term.var 1).sub (AutoStructs.Term.var 2))) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 155.542541 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 13.183625 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 132.331458 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 1027.587375 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 180.356625 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 15.900166 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 126.123833 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 98.703708 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 7.806000 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 13.421500 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ e ≤ 31
      c ≥ 0
      0 ≤ c - 32*d ≤ 31
      0 ≤ a ≤ 31
      a - 32*b - c + 32*d - e ≥ -31
      -32 ≤ a - 32*b - e ≤ -1
    where
     a := ↑x✝.toNat
     b := ↑(x✝.toNat + (2 ^ 5 - (x✝.srem x✝¹).toNat)) / 32
     c := ↑(match Decidable.decide (2 ^ (5 - 1) ≤ x✝.toNat), Decidable.decide (2 ^ (5 - 1) ≤ x✝¹.toNat) with
        | false, false => (x✝.udiv x✝¹).toNat
        | false, true => (2 ^ 5 - (x✝.udiv (-x✝¹)).toNat) % 2 ^ 5
        | true, false => (2 ^ 5 - ((-x✝).udiv x✝¹).toNat) % 2 ^ 5
        | true, true => ((-x✝).udiv (-x✝¹)).toNat) *
      ↑x✝¹.toNat
     d := ↑((match Decidable.decide (2 ^ (5 - 1) ≤ x✝.toNat), Decidable.decide (2 ^ (5 - 1) ≤ x✝¹.toNat) with
          | false, false => (x✝.udiv x✝¹).toNat
          | false, true => (2 ^ 5 - (x✝.udiv (-x✝¹)).toNat) % 2 ^ 5
          | true, false => (2 ^ 5 - ((-x✝).udiv x✝¹).toNat) % 2 ^ 5
          | true, true => ((-x✝).udiv (-x✝¹)).toNat) *
          x✝¹.toNat) /
      32
     e := ↑(x✝.srem x✝¹).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 145.250125 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0)
            ((AutoStructs.Term.var 1).sub (AutoStructs.Term.var 2))) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 117.267750 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 44.761709 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 381.522875 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 1175.633291 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 234.179875 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 18.192375 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 89.774041 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 122.388500 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.042667 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 15.755375 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ e ≤ 31
      c ≥ 0
      0 ≤ c - 32*d ≤ 31
      0 ≤ a ≤ 31
      a - 32*b - c + 32*d - e ≥ -31
      -32 ≤ a - 32*b - e ≤ -1
    where
     a := ↑(x✝.srem x✝¹).toNat
     b := ↑((x✝.srem x✝¹).toNat + (2 ^ 5 - x✝.toNat)) / 32
     c := ↑(match Decidable.decide (2 ^ (5 - 1) ≤ x✝.toNat), Decidable.decide (2 ^ (5 - 1) ≤ x✝¹.toNat) with
        | false, false => (x✝.udiv x✝¹).toNat
        | false, true => (2 ^ 5 - (x✝.udiv (-x✝¹)).toNat) % 2 ^ 5
        | true, false => (2 ^ 5 - ((-x✝).udiv x✝¹).toNat) % 2 ^ 5
        | true, true => ((-x✝).udiv (-x✝¹)).toNat) *
      ↑((0 % 2 ^ 5 + (2 ^ 5 - x✝¹.toNat)) % 2 ^ 5)
     d := ↑((match Decidable.decide (2 ^ (5 - 1) ≤ x✝.toNat), Decidable.decide (2 ^ (5 - 1) ≤ x✝¹.toNat) with
          | false, false => (x✝.udiv x✝¹).toNat
          | false, true => (2 ^ 5 - (x✝.udiv (-x✝¹)).toNat) % 2 ^ 5
          | true, false => (2 ^ 5 - ((-x✝).udiv x✝¹).toNat) % 2 ^ 5
          | true, true => ((-x✝).udiv (-x✝¹)).toNat) *
          ((0 % 2 ^ 5 + (2 ^ 5 - x✝¹.toNat)) % 2 ^ 5)) /
      32
     e := ↑x✝.toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 110.413042 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0).neg
            ((AutoStructs.Term.var 1).sub (AutoStructs.Term.var 2))) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 73.877584 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 44.682458 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 442.623250 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 1078.787334 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 254.644917 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 14.247875 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 154.839875 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 136.149916 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.482834 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 10.219125 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      1 ≤ f ≤ 31
      0 ≤ e ≤ 31
      c ≥ 0
      0 ≤ c - 32*d ≤ 31
      a ≥ 0
      a - 32*b - c + 32*d - e ≥ -31
      -32 ≤ a - 32*b - e ≤ -1
    where
     a := ↑x✝.toNat % ↑x✝¹.toNat
     b := ↑(x✝.toNat % x✝¹.toNat + (2 ^ 5 - x✝.toNat)) / 32
     c := ↑(x✝.toNat / x✝¹.toNat) * ↑((0 % 2 ^ 5 + (2 ^ 5 - x✝¹.toNat)) % 2 ^ 5)
     d := ↑(x✝.toNat / x✝¹.toNat * ((0 % 2 ^ 5 + (2 ^ 5 - x✝¹.toNat)) % 2 ^ 5)) / 32
     e := ↑x✝.toNat
     f := ↑x✝¹.toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 167.537209 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0).neg
            ((AutoStructs.Term.var 1).sub (AutoStructs.Term.var 2))) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 136.011583 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 16.198375 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 130.984375 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 890.178542 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 152.351833 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 10.164000 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 114.626250 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 85.566500 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 7.660167 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.651042 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      0 ≤ b - 2*c ≤ 1
      0 ≤ a ≤ 1
      a - b + 2*c ≥ 1
    where
     a := ↑(x✝ &&& x✝¹).toNat
     b := ↑x✝.toNat * ↑x✝¹.toNat
     c := ↑(x✝.toNat * x✝¹.toNat) / 2 MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 132.279875 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0)
            ((AutoStructs.Term.var 1).and (AutoStructs.Term.var 2))) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 107.376583 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize PASS, TIME_ELAPSED 1.507834 ms, 
  TACBENCH bv_decide PASS, TIME_ELAPSED 1.523000 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 341.450500 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 80.040667 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 12.213167 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 47.816792 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 100.175125 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 7.815958 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.314125 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      e ≥ 0
      d ≥ 0
      d - e ≥ 1
      c - d ≥ 1
      c - e ≥ 1
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(↑w).toNat
     b := ↑x✝.toNat
     c := ↑2 ^ w
     d := ↑(x✝¹.toNat * 2 ^ x✝.toNat) % ↑(2 ^ w)
     e := ↑(1 % 2 ^ w * 2 ^ x✝.toNat % 2 ^ w * x✝¹.toNat) % ↑(2 ^ w) MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 56.838875 ms, MSGSTART 
    no goals to be solved MSGEND
  TACBENCH simp PASS, TIME_ELAPSED 46.725667 ms, 
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 8.480542 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 83.614750 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (1#w <<< x✝ * x✝¹ == x✝¹ <<< x✝),
     BitVec.ofBool (BitVec.ofNat w w >ᵤ x✝)]
    Consider the following assignment:
    BitVec.ofBool (BitVec.ofNat w w >ᵤ x✝) = 0x1#1
    BitVec.ofBool (1#w <<< x✝ * x✝¹ == x✝¹ <<< x✝) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 54.563875 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 260.712125 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 13.956459 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 34.260584 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 93.664833 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 7.376916 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 15.032125 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      a ≥ 0
      a - b ≥ 1
    where
     a := ↑(match Decidable.decide (2 ^ (9 - 1) ≤ x✝.toNat), Decidable.decide (2 ^ (9 - 1) ≤ x✝¹.toNat) with
      | false, false => (x✝.udiv x✝¹).toNat
      | false, true => (2 ^ 9 - (x✝.udiv (-x✝¹)).toNat) % 2 ^ 9
      | true, false => (2 ^ 9 - ((-x✝).udiv x✝¹).toNat) % 2 ^ 9
      | true, true => ((-x✝).udiv (-x✝¹)).toNat)
     b := ↑(match Decidable.decide (2 ^ (9 - 1) ≤ (x✝.toNat + (2 ^ 9 - (x✝.srem x✝¹).toNat)) % 2 ^ 9),
        Decidable.decide (2 ^ (9 - 1) ≤ x✝¹.toNat) with
      | false, false => ((x✝ - x✝.srem x✝¹).udiv x✝¹).toNat
      | false, true => (2 ^ 9 - ((x✝ - x✝.srem x✝¹).udiv (-x✝¹)).toNat) % 2 ^ 9
      | true, false => (2 ^ 9 - ((-(x✝ - x✝.srem x✝¹)).udiv x✝¹).toNat) % 2 ^ 9
      | true, true => ((-(x✝ - x✝.srem x✝¹)).udiv (-x✝¹)).toNat) MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 59.796291 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) (AutoStructs.Term.var 1)) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 28.060750 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 86.761542 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 5981.657958 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 6626.624333 ms, 
TACEND
/Users/tobiasgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/AliveStatements.lean:700:95: error: (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.
Additional diagnostic information may be available using the `set_option diagnostics true` command.
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 143.106042 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 8.523125 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 43.388708 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 102.963417 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.505708 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.840917 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      1 ≤ c ≤ 511
      a - b ≥ 1
    where
     a := ↑x✝.toNat / ↑x✝¹.toNat
     b := ↑((x✝.toNat + (2 ^ 9 - x✝.toNat % x✝¹.toNat)) % 2 ^ 9) / ↑x✝¹.toNat
     c := ↑x✝¹.toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 63.682166 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) (AutoStructs.Term.var 1)) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 40.040917 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 13.432875 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 1344.889166 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 1860.427291 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 69.468542 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 13.841833 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 38.590208 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 125.514500 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 7.644084 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 12.075125 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      b ≥ 0
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(0 % 2 ^ w + (2 ^ w - x✝.toNat)) % ↑(2 ^ w)
     b := ↑(match Decidable.decide (2 ^ (w - 1) ≤ x✝.toNat),
        Decidable.decide (2 ^ (w - 1) ≤ (2 ^ w - 1 % 2 ^ w) % 2 ^ w) with
      | false, false => (x✝.udiv (-1#w)).toNat
      | false, true => (2 ^ w - (x✝.udiv (- -1#w)).toNat) % 2 ^ w
      | true, false => (2 ^ w - ((-x✝).udiv (-1#w)).toNat) % 2 ^ w
      | true, true => ((-x✝).udiv (- -1#w)).toNat)
     c := ↑2 ^ w MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 61.014792 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0) (AutoStructs.Term.var 1).neg) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 34.354834 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 22.933958 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 98.886708 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       ((if x✝.getLsbD (w - 1) = true then if (-1#w).getLsbD (w - 1) = true then -x✝ / - -1#w else -(-x✝ / -1#w)
         else if (-1#w).getLsbD (w - 1) = true then -(x✝ / - -1#w) else x✝ / -1#w) ==
         -x✝),
     BitVec.ofBool (w != 1),
     BitVec.ofBool (-1#w == 0#w),
     BitVec.ofBool (x✝ == BitVec.intMin w)]
    Consider the following assignment:
    BitVec.ofBool
      ((if x✝.getLsbD (w - 1) = true then if (-1#w).getLsbD (w - 1) = true then -x✝ / - -1#w else -(-x✝ / -1#w)
        else if (-1#w).getLsbD (w - 1) = true then -(x✝ / - -1#w) else x✝ / -1#w) ==
        -x✝) = 0x0#1
    BitVec.ofBool (-1#w == 0#w) = 0x0#1
    BitVec.ofBool (w != 1) = 0x0#1
    BitVec.ofBool (x✝ == BitVec.intMin w) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 52.183084 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.504583 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some (1#1 ^^^ -1#1) ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 8.743000 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 30.428625 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 111.302542 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 7.067708 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.255625 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 37.726584 ms, MSGSTART 
    Unsupported syntax some 0#1 ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.const `BitVec.ofNat [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 0)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 0)))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 26.961250 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 1.949708 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 2.033500 ms, MSGSTART 
    None of the hypotheses are in the supported BitVec fragment.
    There are two potential fixes for this:
    1. If you are using custom BitVec constructs simplify them to built-in ones.
    2. If your problem is using only built-in ones it might currently be out of reach.
       Consider expressing it in terms of different operations that are better supported. MSGEND
  TACBENCH bv_auto FAIL, TIME_ELAPSED 212.385208 ms, MSGSTART 
    internal exception #4 MSGEND
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 69.736500 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 10.477291 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 42.648459 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 111.305584 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.021625 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.732500 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑((1#1 ^^^ -1#1) &&& x✝).toNat
     b := ↑(1#1 ^^^ -1#1).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 51.149417 ms, MSGSTART 
    no goals to be solved MSGEND
  TACBENCH simp PASS, TIME_ELAPSED 40.994208 ms, 
  TACBENCH bv_normalize PASS, TIME_ELAPSED 2.317833 ms, 
  TACBENCH bv_decide PASS, TIME_ELAPSED 2.298583 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 46.871500 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 124.127375 ms, 
  TACBENCH bv_ac PASS, TIME_ELAPSED 9.881125 ms, 
  TACBENCH bv_distrib PASS, TIME_ELAPSED 51.337708 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 118.319000 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.377667 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.764042 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑((0#1 ^^^ -1#1) &&& x✝).toNat
     b := ↑x✝.toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 68.110625 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0)
            (AutoStructs.Term.one.and (AutoStructs.Term.var 0))) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 45.203584 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize PASS, TIME_ELAPSED 2.303291 ms, 
  TACBENCH bv_decide PASS, TIME_ELAPSED 2.300292 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 217.533500 ms, 
TACEND
/Users/tobiasgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/AliveStatements.lean:723:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 1.480542 ms, MSGSTART 
    applyExtTheorem only applies to equations, not
      some (0#1 ^^^ -1#1) ⊑ none MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 7.959334 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 34.301459 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 111.674292 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 7.517708 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.299250 ms, MSGSTART 
    omega could not prove the goal:
    No usable constraints found. You may need to unfold definitions so `omega` can see linear arithmetic facts about `Nat` and `Int`, which may also involve multiplication, division, and modular remainder by constants. MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 43.558625 ms, MSGSTART 
    Unsupported syntax some 1#1 ⊑ none === Lean.Expr.app
      (Lean.Expr.app
        (Lean.Expr.app
          (Lean.Expr.const `BitVec.Refinement [Lean.Level.zero])
          (Lean.Expr.app
            (Lean.Expr.const `BitVec [])
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
        (Lean.Expr.app
          (Lean.Expr.app
            (Lean.Expr.const `Option.some [Lean.Level.zero])
            (Lean.Expr.app
              (Lean.Expr.const `BitVec [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1))))))
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.const `BitVec.ofNat [])
              (Lean.Expr.app
                (Lean.Expr.app
                  (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                  (Lean.Expr.lit (Lean.Literal.natVal 1)))
                (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))
            (Lean.Expr.app
              (Lean.Expr.app
                (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
                (Lean.Expr.lit (Lean.Literal.natVal 1)))
              (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))))
      (Lean.Expr.app
        (Lean.Expr.const `Option.none [Lean.Level.zero])
        (Lean.Expr.app
          (Lean.Expr.const `BitVec [])
          (Lean.Expr.app
            (Lean.Expr.app
              (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.const `Nat []))
              (Lean.Expr.lit (Lean.Literal.natVal 1)))
            (Lean.Expr.app (Lean.Expr.const `instOfNatNat []) (Lean.Expr.lit (Lean.Literal.natVal 1)))))) MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 32.321500 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 2.009375 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 2.028625 ms, MSGSTART 
    None of the hypotheses are in the supported BitVec fragment.
    There are two potential fixes for this:
    1. If you are using custom BitVec constructs simplify them to built-in ones.
    2. If your problem is using only built-in ones it might currently be out of reach.
       Consider expressing it in terms of different operations that are better supported. MSGEND
  TACBENCH bv_auto FAIL, TIME_ELAPSED 230.474416 ms, MSGSTART 
    internal exception #4 MSGEND
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 81.213917 ms, 
  TACBENCH bv_ac PASS, TIME_ELAPSED 9.396500 ms, 
  TACBENCH bv_distrib PASS, TIME_ELAPSED 42.631667 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 111.490917 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 7.941042 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.707708 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(1#1 ^^^ -1#1 ||| x✝).toNat
     b := ↑x✝.toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 52.326083 ms, MSGSTART 
    no goals to be solved MSGEND
  TACBENCH simp PASS, TIME_ELAPSED 41.325708 ms, 
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 5.837417 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 83.742125 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 49.237167 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 124.179333 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 10.483792 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 51.312292 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 119.916458 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.724750 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 1.683708 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      0 ≤ b ≤ 1
      0 ≤ a ≤ 1
      a - b ≥ 1
    where
     a := ↑(0#1 ^^^ -1#1 ||| x✝).toNat
     b := ↑(0#1 ^^^ -1#1).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 73.625458 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq AutoStructs.Term.one
            (AutoStructs.Term.one.or (AutoStructs.Term.var 0))) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 46.096500 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 6.065250 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide PASS, TIME_ELAPSED 85.310958 ms, 
  TACBENCH bv_auto PASS, TIME_ELAPSED 220.803417 ms, 
TACEND
/Users/tobiasgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/AliveStatements.lean:732:8: warning: declaration uses 'sorry'
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 294.690625 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 10.191667 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 66.668875 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 113.792042 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.367041 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.760833 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      e ≥ 0
      d ≥ 0
      d - e ≥ 1
      c - d ≥ 1
      c - e ≥ 1
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(↑w).toNat
     b := ↑x✝¹.toNat
     c := ↑2 ^ w
     d := ↑(x✝ &&& (-1#w) >>> x✝¹).toNat
     e := ↑(x✝ <<< x✝¹ >>> x✝¹).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 93.487875 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0)
            ((AutoStructs.Term.var 1).and (AutoStructs.Term.var 2))) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 61.468083 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 9.380792 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 87.191292 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (x✝ <<< x✝¹ >>> x✝¹ == x✝ &&& (-1#w) >>> x✝¹),
     BitVec.ofBool (BitVec.ofNat w w >ᵤ x✝¹)]
    Consider the following assignment:
    BitVec.ofBool (BitVec.ofNat w w >ᵤ x✝¹) = 0x1#1
    BitVec.ofBool (x✝ <<< x✝¹ >>> x✝¹ == x✝ &&& (-1#w) >>> x✝¹) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 396.278750 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 154.348291 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 11.190125 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 108.085417 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 125.191959 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.659458 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.508584 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      e ≥ 0
      d ≥ 0
      d - e ≥ 1
      c - d ≥ 1
      c - e ≥ 1
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(↑w).toNat
     b := ↑x✝¹.toNat
     c := ↑2 ^ w
     d := ↑(x✝ &&& (-1#w) <<< x✝¹).toNat
     e := ↑((x✝ >>> x✝¹).toNat * 2 ^ x✝¹.toNat) % ↑(2 ^ w) MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 133.177250 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq ((AutoStructs.Term.var 0).and (AutoStructs.Term.var 1))
            ((AutoStructs.Term.var 0).and (AutoStructs.Term.var 2))) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 94.882583 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 10.100916 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 88.782250 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (x✝ >>> x✝¹ <<< x✝¹ == x✝ &&& (-1#w) <<< x✝¹),
     BitVec.ofBool (BitVec.ofNat w w >ᵤ x✝¹)]
    Consider the following assignment:
    BitVec.ofBool (BitVec.ofNat w w >ᵤ x✝¹) = 0x1#1
    BitVec.ofBool (x✝ >>> x✝¹ <<< x✝¹ == x✝ &&& (-1#w) <<< x✝¹) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 102.600375 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 325.803209 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 16.051500 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 277.748833 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 84.527334 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 10.008500 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 4.576333 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      e ≥ 0
      d ≥ 0
      d - e ≥ 1
      c - d ≥ 1
      c - e ≥ 1
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(↑w).toNat
     b := ↑x✝².toNat
     c := ↑2 ^ w
     d := ↑(x✝¹ &&& x✝³ <<< x✝² ^^^ x✝ <<< x✝²).toNat
     e := ↑((x✝ ^^^ x✝¹ >>> x✝² &&& x✝³).toNat * 2 ^ x✝².toNat) % ↑(2 ^ w) MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 142.624834 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0)
            (((AutoStructs.Term.var 1).and (AutoStructs.Term.var 2)).xor (AutoStructs.Term.var 3))) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 106.024625 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 11.473291 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 89.954917 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (BitVec.ofNat w w >ᵤ x✝²),
     BitVec.ofBool ((x✝ ^^^ x✝¹ >>> x✝² &&& x✝³) <<< x✝² == x✝¹ &&& x✝³ <<< x✝² ^^^ x✝ <<< x✝²)]
    Consider the following assignment:
    BitVec.ofBool (BitVec.ofNat w w >ᵤ x✝²) = 0x1#1
    BitVec.ofBool ((x✝ ^^^ x✝¹ >>> x✝² &&& x✝³) <<< x✝² == x✝¹ &&& x✝³ <<< x✝² ^^^ x✝ <<< x✝²) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 675.510708 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise FAIL, TIME_ELAPSED 335.088750 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ac FAIL, TIME_ELAPSED 16.265125 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 269.498584 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 88.668792 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 10.119875 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.293917 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      e ≥ 0
      d ≥ 0
      d - e ≥ 1
      c - d ≥ 1
      c - e ≥ 1
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(↑w).toNat
     b := ↑x✝¹.toNat
     c := ↑2 ^ w
     d := ↑(x✝ &&& x✝² <<< x✝¹ ||| x✝³ <<< x✝¹).toNat
     e := ↑((x✝ >>> x✝¹ &&& x✝² ||| x✝³).toNat * 2 ^ x✝¹.toNat) % ↑(2 ^ w) MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 152.120625 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0)
            (((AutoStructs.Term.var 1).and (AutoStructs.Term.var 2)).or (AutoStructs.Term.var 3))) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 100.869958 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 10.723166 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 89.212792 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (BitVec.ofNat w w >ᵤ x✝¹),
     BitVec.ofBool ((x✝ >>> x✝¹ &&& x✝² ||| x✝³) <<< x✝¹ == x✝ &&& x✝² <<< x✝¹ ||| x✝³ <<< x✝¹)]
    Consider the following assignment:
    BitVec.ofBool (BitVec.ofNat w w >ᵤ x✝¹) = 0x1#1
    BitVec.ofBool ((x✝ >>> x✝¹ &&& x✝² ||| x✝³) <<< x✝¹ == x✝ &&& x✝² <<< x✝¹ ||| x✝³ <<< x✝¹) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 651.586375 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 125.375417 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 10.535125 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 66.297625 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 77.011458 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 7.979875 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 2.470834 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      e ≥ 0
      d ≥ 0
      d - e ≥ 1
      c - d ≥ 1
      c - e ≥ 1
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(↑w).toNat
     b := ↑x✝².toNat
     c := ↑2 ^ w
     d := ↑(x✝ >>> x✝² ^^^ x✝¹ >>> x✝²).toNat
     e := ↑((x✝ ^^^ x✝¹) >>> x✝²).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 88.655792 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0)
            ((AutoStructs.Term.var 1).xor (AutoStructs.Term.var 2))) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 60.487708 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 8.811334 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 86.268583 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       ((x✝ ^^^ x✝¹) >>> x✝² == x✝ >>> x✝² ^^^ x✝¹ >>> x✝²),
     BitVec.ofBool (BitVec.ofNat w w >ᵤ x✝²)]
    Consider the following assignment:
    BitVec.ofBool (BitVec.ofNat w w >ᵤ x✝²) = 0x1#1
    BitVec.ofBool ((x✝ ^^^ x✝¹) >>> x✝² == x✝ >>> x✝² ^^^ x✝¹ >>> x✝²) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 245.456917 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 111.489584 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 12.533542 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib PASS, TIME_ELAPSED 90.343917 ms, 
  TACBENCH bv_ring FAIL, TIME_ELAPSED 106.399833 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 8.160542 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 5.285958 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      e ≥ 0
      d ≥ 0
      d - e ≥ 1
      c - d ≥ 1
      c - e ≥ 1
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(↑w).toNat
     b := ↑x✝².toNat
     c := ↑2 ^ w
     d := ↑(x✝.toNat * 2 ^ x✝².toNat % 2 ^ w + x✝¹.toNat * 2 ^ x✝².toNat % 2 ^ w) % ↑(2 ^ w)
     e := ↑((x✝.toNat + x✝¹.toNat) % 2 ^ w * 2 ^ x✝².toNat) % ↑(2 ^ w) MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 99.380042 ms, MSGSTART 
    no goals to be solved MSGEND
  TACBENCH simp PASS, TIME_ELAPSED 94.216750 ms, 
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 9.732833 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 89.438958 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (BitVec.ofNat w w >ᵤ x✝²),
     BitVec.ofBool ((x✝ + x✝¹) <<< x✝² == x✝ <<< x✝² + x✝¹ <<< x✝²)]
    Consider the following assignment:
    BitVec.ofBool (BitVec.ofNat w w >ᵤ x✝²) = 0x1#1
    BitVec.ofBool ((x✝ + x✝¹) <<< x✝² == x✝ <<< x✝² + x✝¹ <<< x✝²) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 94.272167 ms, 
TACEND
TACSTART
  TACBENCH bv_bitwise PASS, TIME_ELAPSED 278.158875 ms, 
  TACBENCH bv_ac FAIL, TIME_ELAPSED 10.005500 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_distrib FAIL, TIME_ELAPSED 66.099959 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_ring FAIL, TIME_ELAPSED 115.500209 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_of_bool FAIL, TIME_ELAPSED 9.686667 ms, MSGSTART 
    simp made no progress MSGEND
  TACBENCH bv_omega FAIL, TIME_ELAPSED 3.039792 ms, MSGSTART 
    omega could not prove the goal:
    a possible counterexample may satisfy the constraints
      e ≥ 0
      d ≥ 0
      d - e ≥ 1
      c - d ≥ 1
      c - e ≥ 1
      b ≥ 0
      b - c ≤ -1
      a ≥ 0
      a - b ≥ 1
      a - c ≤ -1
    where
     a := ↑(↑w).toNat
     b := ↑x✝¹.toNat
     c := ↑2 ^ w
     d := ↑(x✝ &&& (-1#w) >>> x✝¹).toNat
     e := ↑(x✝ <<< x✝¹ >>> x✝¹).toNat MSGEND
  TACBENCH bv_automata_classic FAIL, TIME_ELAPSED 96.440417 ms, MSGSTART 
    tactic 'native_decide' evaluated that the proposition
      formulaIsUniversal
          (AutoStructs.Formula.atom AutoStructs.Relation.eq (AutoStructs.Term.var 0)
            ((AutoStructs.Term.var 1).and (AutoStructs.Term.var 2))) =
        true
    is false MSGEND
  TACBENCH simp FAIL, TIME_ELAPSED 65.221625 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_normalize FAIL, TIME_ELAPSED 9.637958 ms, MSGSTART 
    internal exception #4 MSGEND
  TACBENCH bv_decide FAIL, TIME_ELAPSED 84.596792 ms, MSGSTART 
    The prover found a potentially spurious counterexample:
    - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool
       (x✝ <<< x✝¹ >>> x✝¹ == x✝ &&& (-1#w) >>> x✝¹),
     BitVec.ofBool (BitVec.ofNat w w >ᵤ x✝¹)]
    Consider the following assignment:
    BitVec.ofBool (BitVec.ofNat w w >ᵤ x✝¹) = 0x1#1
    BitVec.ofBool (x✝ <<< x✝¹ >>> x✝¹ == x✝ &&& (-1#w) >>> x✝¹) = 0x0#1
     MSGEND
  TACBENCH bv_auto PASS, TIME_ELAPSED 410.843084 ms, 
TACEND
