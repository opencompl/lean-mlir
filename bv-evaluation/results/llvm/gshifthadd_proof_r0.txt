‚ö† [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
‚ö† [878/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
‚ö† [881/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
‚ö† [887/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
‚ö† [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:17:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:11:8: error: (kernel) declaration has metavariables 'shl_C1_add_A_C2_i32_thm'
[bv] [0.071311] Normalizing goal
  [Meta.synthInstance] [0.001888] ‚úÖÔ∏è Decidable
        ((if BitVec.zeroExtend 32 x‚úù + 5#32 ‚â• ‚Üë32 then none else some (6#32 <<< (BitVec.zeroExtend 32 x‚úù + 5#32))) ‚äë
          if BitVec.zeroExtend 32 x‚úù ‚â• ‚Üë32 then none else some (192#32 <<< BitVec.zeroExtend 32 x‚úù))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 16
      x‚úù : BitVec 16
      a‚úù :
        ¬¨(if BitVec.zeroExtend 32 x‚úù + 5#32 ‚â• ‚Üë32 then none else some (6#32 <<< (BitVec.zeroExtend 32 x‚úù + 5#32))) ‚äë
            if BitVec.zeroExtend 32 x‚úù ‚â• ‚Üë32 then none else some (192#32 <<< BitVec.zeroExtend 32 x‚úù)
      ‚ä¢ False
  [Meta.isDefEq] [0.002102] ‚ùåÔ∏è ?a == ?a =?= (32#32 >·µ§ BitVec.zeroExtend 32 x‚úù + 5#32) == true
    [Meta.isDefEq.onFailure] [0.001684] ‚ùåÔ∏è ?a == ?a =?= (32#32 >·µ§ BitVec.zeroExtend 32 x‚úù + 5#32) == true
      [Meta.synthInstance] [0.001654] üí•Ô∏è BEq ?Œ±
        [Meta.synthInstance] [0.001539] new goal BEq ?Œ±
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 16
      x‚úù : BitVec 16
      a‚úù :
        ¬¨(if (!32#32 >·µ§ BitVec.zeroExtend 32 x‚úù + 5#32) = true then none
            else some (6#32 <<< (BitVec.zeroExtend 32 x‚úù + 5#32))) ‚äë
            if (!32#32 >·µ§ BitVec.zeroExtend 32 x‚úù) = true then none else some (192#32 <<< BitVec.zeroExtend 32 x‚úù)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:27:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:21:8: error: (kernel) declaration has metavariables 'ashr_C1_add_A_C2_i32_thm'
[bv] [0.027953] Normalizing goal
  [Meta.synthInstance] [0.001780] ‚úÖÔ∏è Decidable
        ((if (x‚úù &&& 65535#32) + 5#32 ‚â• ‚Üë32 then none else some ((6#32).sshiftRight ((x‚úù &&& 65535#32) + 5#32).toNat)) ‚äë
          some 0#32)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if (x‚úù &&& 65535#32) + 5#32 ‚â• ‚Üë32 then none else some ((6#32).sshiftRight ((x‚úù &&& 65535#32) + 5#32).toNat)) ‚äë
            some 0#32
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if (!32#32 >·µ§ (x‚úù &&& 65535#32) + 5#32) = true then none
            else some ((6#32).sshiftRight ((x‚úù &&& 65535#32) + 5#32).toNat)) ‚äë
            some 0#32
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:38:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:31:8: error: (kernel) declaration has metavariables 'lshr_C1_add_A_C2_i32_thm'
[bv] [0.039708] Normalizing goal
  [Meta.synthInstance] [0.001934] ‚úÖÔ∏è Decidable
        ((if (x‚úù &&& 65535#32) + 5#32 ‚â• ‚Üë32 then none else some (6#32 <<< ((x‚úù &&& 65535#32) + 5#32))) ‚äë
          if x‚úù &&& 65535#32 ‚â• ‚Üë32 then none else some (192#32 <<< (x‚úù &&& 65535#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if (x‚úù &&& 65535#32) + 5#32 ‚â• ‚Üë32 then none else some (6#32 <<< ((x‚úù &&& 65535#32) + 5#32))) ‚äë
            if x‚úù &&& 65535#32 ‚â• ‚Üë32 then none else some (192#32 <<< (x‚úù &&& 65535#32))
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if (!32#32 >·µ§ (x‚úù &&& 65535#32) + 5#32) = true then none else some (6#32 <<< ((x‚úù &&& 65535#32) + 5#32))) ‚äë
            if (!32#32 >·µ§ x‚úù &&& 65535#32) = true then none else some (192#32 <<< (x‚úù &&& 65535#32))
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:48:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:42:8: error: (kernel) declaration has metavariables 'shl_add_nuw_thm'
[bv] [0.050691] Normalizing goal
  [Meta.synthInstance] [0.002098] ‚úÖÔ∏è Decidable
        ((if True ‚àß (x‚úù + 5#32 < x‚úù ‚à® x‚úù + 5#32 < 5#32) then none
          else if x‚úù + 5#32 ‚â• ‚Üë32 then none else some (6#32 <<< (x‚úù + 5#32))) ‚äë
          if x‚úù ‚â• ‚Üë32 then none else some (192#32 <<< x‚úù))
    [Meta.check] [0.001105] ‚úÖÔ∏è BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if True ‚àß (x‚úù + 5#32 < x‚úù ‚à® x‚úù + 5#32 < 5#32) then none
          else if x‚úù + 5#32 ‚â• ‚Üë32 then none else some (6#32 <<< (x‚úù + 5#32)))
          (if x‚úù ‚â• ‚Üë32 then none else some (192#32 <<< x‚úù))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if True ‚àß (x‚úù + 5#32 < x‚úù ‚à® x‚úù + 5#32 < 5#32) then none
            else if x‚úù + 5#32 ‚â• ‚Üë32 then none else some (6#32 <<< (x‚úù + 5#32))) ‚äë
            if x‚úù ‚â• ‚Üë32 then none else some (192#32 <<< x‚úù)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if (!((!x‚úù >·µ§ x‚úù + 5#32) && !5#32 >·µ§ x‚úù + 5#32)) = true then none
            else if (!32#32 >·µ§ x‚úù + 5#32) = true then none else some (6#32 <<< (x‚úù + 5#32))) ‚äë
            if (!32#32 >·µ§ x‚úù) = true then none else some (192#32 <<< x‚úù)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:59:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:52:8: error: (kernel) declaration has metavariables 'shl_nuw_add_nuw_thm'
[bv] [0.073101] Normalizing goal
  [Meta.synthInstance] [0.002354] ‚úÖÔ∏è Decidable
        ((if True ‚àß (x‚úù + 1#32 < x‚úù ‚à® x‚úù + 1#32 < 1#32) then none
          else
            if True ‚àß 1#32 <<< (x‚úù + 1#32) >>> (x‚úù + 1#32) = 1#32 then none
            else if x‚úù + 1#32 ‚â• ‚Üë32 then none else some (1#32 <<< (x‚úù + 1#32))) ‚äë
          if True ‚àß 2#32 <<< x‚úù >>> x‚úù = 2#32 then none else if x‚úù ‚â• ‚Üë32 then none else some (2#32 <<< x‚úù))
    [Meta.check] [0.001365] ‚úÖÔ∏è BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if True ‚àß (x‚úù + 1#32 < x‚úù ‚à® x‚úù + 1#32 < 1#32) then none
          else
            if True ‚àß 1#32 <<< (x‚úù + 1#32) >>> (x‚úù + 1#32) = 1#32 then none
            else if x‚úù + 1#32 ‚â• ‚Üë32 then none else some (1#32 <<< (x‚úù + 1#32)))
          (if True ‚àß 2#32 <<< x‚úù >>> x‚úù = 2#32 then none else if x‚úù ‚â• ‚Üë32 then none else some (2#32 <<< x‚úù))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if True ‚àß (x‚úù + 1#32 < x‚úù ‚à® x‚úù + 1#32 < 1#32) then none
            else
              if True ‚àß 1#32 <<< (x‚úù + 1#32) >>> (x‚úù + 1#32) = 1#32 then none
              else if x‚úù + 1#32 ‚â• ‚Üë32 then none else some (1#32 <<< (x‚úù + 1#32))) ‚äë
            if True ‚àß 2#32 <<< x‚úù >>> x‚úù = 2#32 then none else if x‚úù ‚â• ‚Üë32 then none else some (2#32 <<< x‚úù)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if (!((!x‚úù >·µ§ x‚úù + 1#32) && !1#32 >·µ§ x‚úù + 1#32)) = true then none
            else
              if (1#32 <<< (x‚úù + 1#32) >>> (x‚úù + 1#32) == 1#32) = true then none
              else if (!32#32 >·µ§ x‚úù + 1#32) = true then none else some (1#32 <<< (x‚úù + 1#32))) ‚äë
            if (2#32 <<< x‚úù >>> x‚úù == 2#32) = true then none
            else if (!32#32 >·µ§ x‚úù) = true then none else some (2#32 <<< x‚úù)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:70:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:63:8: error: (kernel) declaration has metavariables 'shl_nsw_add_nuw_thm'
[bv] [0.073123] Normalizing goal
  [Meta.synthInstance] [0.002314] ‚úÖÔ∏è Decidable
        ((if True ‚àß (x‚úù + 1#32 < x‚úù ‚à® x‚úù + 1#32 < 1#32) then none
          else
            if True ‚àß ((-1#32) <<< (x‚úù + 1#32)).sshiftRight (x‚úù + 1#32).toNat = -1#32 then none
            else if x‚úù + 1#32 ‚â• ‚Üë32 then none else some ((-1#32) <<< (x‚úù + 1#32))) ‚äë
          if True ‚àß (4294967294#32 <<< x‚úù).sshiftRight x‚úù.toNat = 4294967294#32 then none
          else if x‚úù ‚â• ‚Üë32 then none else some (4294967294#32 <<< x‚úù))
    [Meta.check] [0.001327] ‚úÖÔ∏è BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if True ‚àß (x‚úù + 1#32 < x‚úù ‚à® x‚úù + 1#32 < 1#32) then none
          else
            if True ‚àß ((-1#32) <<< (x‚úù + 1#32)).sshiftRight (x‚úù + 1#32).toNat = -1#32 then none
            else if x‚úù + 1#32 ‚â• ‚Üë32 then none else some ((-1#32) <<< (x‚úù + 1#32)))
          (if True ‚àß (4294967294#32 <<< x‚úù).sshiftRight x‚úù.toNat = 4294967294#32 then none
          else if x‚úù ‚â• ‚Üë32 then none else some (4294967294#32 <<< x‚úù))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if True ‚àß (x‚úù + 1#32 < x‚úù ‚à® x‚úù + 1#32 < 1#32) then none
            else
              if True ‚àß ((-1#32) <<< (x‚úù + 1#32)).sshiftRight (x‚úù + 1#32).toNat = -1#32 then none
              else if x‚úù + 1#32 ‚â• ‚Üë32 then none else some ((-1#32) <<< (x‚úù + 1#32))) ‚äë
            if True ‚àß (4294967294#32 <<< x‚úù).sshiftRight x‚úù.toNat = 4294967294#32 then none
            else if x‚úù ‚â• ‚Üë32 then none else some (4294967294#32 <<< x‚úù)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if (!((!x‚úù >·µ§ x‚úù + 1#32) && !1#32 >·µ§ x‚úù + 1#32)) = true then none
            else
              if ((4294967295#32 <<< (x‚úù + 1#32)).sshiftRight (x‚úù + 1#32).toNat == 4294967295#32) = true then none
              else if (!32#32 >·µ§ x‚úù + 1#32) = true then none else some (4294967295#32 <<< (x‚úù + 1#32))) ‚äë
            if ((4294967294#32 <<< x‚úù).sshiftRight x‚úù.toNat == 4294967294#32) = true then none
            else if (!32#32 >·µ§ x‚úù) = true then none else some (4294967294#32 <<< x‚úù)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:80:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:74:8: error: (kernel) declaration has metavariables 'lshr_exact_add_nuw_thm'
[bv] [0.051162] Normalizing goal
  [Meta.synthInstance] [0.002078] ‚úÖÔ∏è Decidable
        ((if True ‚àß (x‚úù + 1#32 < x‚úù ‚à® x‚úù + 1#32 < 1#32) then none
          else if x‚úù + 1#32 ‚â• ‚Üë32 then none else some (4#32 >>> (x‚úù + 1#32))) ‚äë
          if x‚úù ‚â• ‚Üë32 then none else some (2#32 >>> x‚úù))
    [Meta.check] [0.001079] ‚úÖÔ∏è BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if True ‚àß (x‚úù + 1#32 < x‚úù ‚à® x‚úù + 1#32 < 1#32) then none
          else if x‚úù + 1#32 ‚â• ‚Üë32 then none else some (4#32 >>> (x‚úù + 1#32)))
          (if x‚úù ‚â• ‚Üë32 then none else some (2#32 >>> x‚úù))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if True ‚àß (x‚úù + 1#32 < x‚úù ‚à® x‚úù + 1#32 < 1#32) then none
            else if x‚úù + 1#32 ‚â• ‚Üë32 then none else some (4#32 >>> (x‚úù + 1#32))) ‚äë
            if x‚úù ‚â• ‚Üë32 then none else some (2#32 >>> x‚úù)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if (!((!x‚úù >·µ§ x‚úù + 1#32) && !1#32 >·µ§ x‚úù + 1#32)) = true then none
            else if (!32#32 >·µ§ x‚úù + 1#32) = true then none else some (4#32 >>> (x‚úù + 1#32))) ‚äë
            if (!32#32 >·µ§ x‚úù) = true then none else some (2#32 >>> x‚úù)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:90:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:84:8: error: (kernel) declaration has metavariables 'ashr_exact_add_nuw_thm'
[bv] [0.047095] Normalizing goal
  [Meta.synthInstance] [0.002011] ‚úÖÔ∏è Decidable
        ((if True ‚àß (x‚úù + 1#32 < x‚úù ‚à® x‚úù + 1#32 < 1#32) then none
          else if x‚úù + 1#32 ‚â• ‚Üë32 then none else some ((4294967292#32).sshiftRight (x‚úù + 1#32).toNat)) ‚äë
          if x‚úù ‚â• ‚Üë32 then none else some ((4294967294#32).sshiftRight x‚úù.toNat))
    [Meta.check] [0.001028] ‚úÖÔ∏è BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if True ‚àß (x‚úù + 1#32 < x‚úù ‚à® x‚úù + 1#32 < 1#32) then none
          else if x‚úù + 1#32 ‚â• ‚Üë32 then none else some ((4294967292#32).sshiftRight (x‚úù + 1#32).toNat))
          (if x‚úù ‚â• ‚Üë32 then none else some ((4294967294#32).sshiftRight x‚úù.toNat))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if True ‚àß (x‚úù + 1#32 < x‚úù ‚à® x‚úù + 1#32 < 1#32) then none
            else if x‚úù + 1#32 ‚â• ‚Üë32 then none else some ((4294967292#32).sshiftRight (x‚úù + 1#32).toNat)) ‚äë
            if x‚úù ‚â• ‚Üë32 then none else some ((4294967294#32).sshiftRight x‚úù.toNat)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if (!((!x‚úù >·µ§ x‚úù + 1#32) && !1#32 >·µ§ x‚úù + 1#32)) = true then none
            else if (!32#32 >·µ§ x‚úù + 1#32) = true then none else some ((4294967292#32).sshiftRight (x‚úù + 1#32).toNat)) ‚äë
            if (!32#32 >·µ§ x‚úù) = true then none else some ((4294967294#32).sshiftRight x‚úù.toNat)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:99:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:94:8: error: (kernel) declaration has metavariables 'lshr_exact_add_negative_shift_positive_thm'
[bv] [0.041113] Normalizing goal
  [Meta.synthInstance] [0.001907] ‚úÖÔ∏è Decidable
        ((if x‚úù + -1#32 ‚â• ‚Üë32 then none else some (2#32 >>> (x‚úù + -1#32))) ‚äë
          if x‚úù ‚â• ‚Üë32 then none else some (4#32 >>> x‚úù))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if x‚úù + -1#32 ‚â• ‚Üë32 then none else some (2#32 >>> (x‚úù + -1#32))) ‚äë
            if x‚úù ‚â• ‚Üë32 then none else some (4#32 >>> x‚úù)
      ‚ä¢ False
  [Meta.isDefEq] [0.002073] ‚úÖÔ∏è ?h‚ÇÅ =?= Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
        (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (32#32) (x‚úù + 4294967295#32))
          (Eq.trans
            (Eq.trans (congrArg Not (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù + 4294967295#32) 32#32))
              (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq (32#32 >·µ§ x‚úù + 4294967295#32) true))
            (congrArg (fun x => (!x) = true) (beq_true (32#32 >·µ§ x‚úù + 4294967295#32)))))
    [Meta.isDefEq.assign] [0.002068] ‚úÖÔ∏è ?h‚ÇÅ := Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
          (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (32#32) (x‚úù + 4294967295#32))
            (Eq.trans
              (Eq.trans (congrArg Not (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù + 4294967295#32) 32#32))
                (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq (32#32 >·µ§ x‚úù + 4294967295#32) true))
              (congrArg (fun x => (!x) = true) (beq_true (32#32 >·µ§ x‚úù + 4294967295#32)))))
      [Meta.isDefEq.assign.checkTypes] [0.002050] ‚úÖÔ∏è (?h‚ÇÅ : (x‚úù + -1#32 ‚â• ‚Üë32) =
            ((!32#32 >·µ§ x‚úù + 4294967295#32) =
              true)) := (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (32#32) (x‚úù + 4294967295#32))
              (Eq.trans
                (Eq.trans (congrArg Not (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù + 4294967295#32) 32#32))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq (32#32 >·µ§ x‚úù + 4294967295#32) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true
                    (32#32 >·µ§
                      x‚úù + 4294967295#32))))) : (x‚úù + 4294967295#32 ‚â• 32#32) = ((!32#32 >·µ§ x‚úù + 4294967295#32) = true))
        [Meta.isDefEq] [0.002045] ‚úÖÔ∏è (x‚úù + -1#32 ‚â• ‚Üë32) =
              ((!32#32 >·µ§ x‚úù + 4294967295#32) =
                true) =?= (x‚úù + 4294967295#32 ‚â• 32#32) = ((!32#32 >·µ§ x‚úù + 4294967295#32) = true)
          [Meta.isDefEq] [0.002007] ‚úÖÔ∏è x‚úù + -1#32 ‚â• ‚Üë32 =?= x‚úù + 4294967295#32 ‚â• 32#32
            [Meta.isDefEq.delta] [0.001984] ‚úÖÔ∏è x‚úù + -1#32 ‚â• ‚Üë32 =?= x‚úù + 4294967295#32 ‚â• 32#32
              [Meta.isDefEq] [0.001842] ‚úÖÔ∏è x‚úù + -1#32 =?= x‚úù + 4294967295#32
                [Meta.isDefEq] [0.001654] ‚úÖÔ∏è instHAdd.1 x‚úù (-1#32) =?= instHAdd.1 x‚úù 4294967295#32
                  [Meta.isDefEq] [0.001582] ‚úÖÔ∏è Add.add x‚úù (-1#32) =?= Add.add x‚úù 4294967295#32
                    [Meta.isDefEq] [0.001332] ‚úÖÔ∏è BitVec.instAdd.1 x‚úù (-1#32) =?= BitVec.instAdd.1 x‚úù 4294967295#32
                      [Meta.isDefEq] [0.001250] ‚úÖÔ∏è x‚úù.add (-1#32) =?= x‚úù.add 4294967295#32
                        [Meta.isDefEq.delta] [0.001233] ‚úÖÔ∏è x‚úù.add (-1#32) =?= x‚úù.add 4294967295#32
                          [Meta.isDefEq] [0.001188] ‚úÖÔ∏è -1#32 =?= 4294967295#32
                            [Meta.isDefEq] [0.001110] ‚úÖÔ∏è -1#32 =?= { toFin := Fin.ofNat' (2 ^ 32) 4294967295 }
                              [Meta.isDefEq] [0.001088] ‚úÖÔ∏è BitVec.instNeg.1
                                    1#32 =?= { toFin := Fin.ofNat' (2 ^ 32) 4294967295 }
                                [Meta.isDefEq] [0.001036] ‚úÖÔ∏è (1#32).neg =?= { toFin := Fin.ofNat' (2 ^ 32) 4294967295 }
                                  [Meta.isDefEq] [0.001009] ‚úÖÔ∏è BitVec.ofNat 32
                                        (2 ^ 32 - (1#32).toNat) =?= { toFin := Fin.ofNat' (2 ^ 32) 4294967295 }
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if (!32#32 >·µ§ x‚úù + 4294967295#32) = true then none else some (2#32 >>> (x‚úù + 4294967295#32))) ‚äë
            if (!32#32 >·µ§ x‚úù) = true then none else some (4#32 >>> x‚úù)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:108:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:103:8: error: (kernel) declaration has metavariables 'ashr_exact_add_negative_shift_negative_thm'
[bv] [0.032749] Normalizing goal
  [Meta.synthInstance] [0.001081] ‚úÖÔ∏è Decidable
        ((if x‚úù + -1#32 ‚â• ‚Üë32 then none else some ((4294967294#32).sshiftRight (x‚úù + -1#32).toNat)) ‚äë
          if x‚úù ‚â• ‚Üë32 then none else some ((4294967292#32).sshiftRight x‚úù.toNat))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if x‚úù + -1#32 ‚â• ‚Üë32 then none else some ((4294967294#32).sshiftRight (x‚úù + -1#32).toNat)) ‚äë
            if x‚úù ‚â• ‚Üë32 then none else some ((4294967292#32).sshiftRight x‚úù.toNat)
      ‚ä¢ False
  [Meta.isDefEq] [0.001345] ‚úÖÔ∏è ?h‚ÇÅ =?= Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
        (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (32#32) (x‚úù + 4294967295#32))
          (Eq.trans
            (Eq.trans (congrArg Not (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù + 4294967295#32) 32#32))
              (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq (32#32 >·µ§ x‚úù + 4294967295#32) true))
            (congrArg (fun x => (!x) = true) (beq_true (32#32 >·µ§ x‚úù + 4294967295#32)))))
    [Meta.isDefEq.assign] [0.001342] ‚úÖÔ∏è ?h‚ÇÅ := Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
          (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (32#32) (x‚úù + 4294967295#32))
            (Eq.trans
              (Eq.trans (congrArg Not (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù + 4294967295#32) 32#32))
                (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq (32#32 >·µ§ x‚úù + 4294967295#32) true))
              (congrArg (fun x => (!x) = true) (beq_true (32#32 >·µ§ x‚úù + 4294967295#32)))))
      [Meta.isDefEq.assign.checkTypes] [0.001329] ‚úÖÔ∏è (?h‚ÇÅ : (x‚úù + -1#32 ‚â• ‚Üë32) =
            ((!32#32 >·µ§ x‚úù + 4294967295#32) =
              true)) := (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (32#32) (x‚úù + 4294967295#32))
              (Eq.trans
                (Eq.trans (congrArg Not (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù + 4294967295#32) 32#32))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq (32#32 >·µ§ x‚úù + 4294967295#32) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true
                    (32#32 >·µ§
                      x‚úù + 4294967295#32))))) : (x‚úù + 4294967295#32 ‚â• 32#32) = ((!32#32 >·µ§ x‚úù + 4294967295#32) = true))
        [Meta.isDefEq] [0.001325] ‚úÖÔ∏è (x‚úù + -1#32 ‚â• ‚Üë32) =
              ((!32#32 >·µ§ x‚úù + 4294967295#32) =
                true) =?= (x‚úù + 4294967295#32 ‚â• 32#32) = ((!32#32 >·µ§ x‚úù + 4294967295#32) = true)
          [Meta.isDefEq] [0.001298] ‚úÖÔ∏è x‚úù + -1#32 ‚â• ‚Üë32 =?= x‚úù + 4294967295#32 ‚â• 32#32
            [Meta.isDefEq.delta] [0.001283] ‚úÖÔ∏è x‚úù + -1#32 ‚â• ‚Üë32 =?= x‚úù + 4294967295#32 ‚â• 32#32
              [Meta.isDefEq] [0.001134] ‚úÖÔ∏è x‚úù + -1#32 =?= x‚úù + 4294967295#32
  [Meta.isDefEq] [0.001013] ‚úÖÔ∏è ?h‚ÇÉ =?= fun a => Eq.refl (some ((4294967294#32).sshiftRight (x‚úù + 4294967295#32).toNat))
    [Meta.isDefEq.assign] [0.001007] ‚úÖÔ∏è ?h‚ÇÉ := fun a =>
          Eq.refl (some ((4294967294#32).sshiftRight (x‚úù + 4294967295#32).toNat))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if (!32#32 >·µ§ x‚úù + 4294967295#32) = true then none
            else some ((4294967294#32).sshiftRight (x‚úù + 4294967295#32).toNat)) ‚äë
            if (!32#32 >·µ§ x‚úù) = true then none else some ((4294967292#32).sshiftRight x‚úù.toNat)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:119:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:112:8: error: (kernel) declaration has metavariables 'shl_nsw_add_negative_thm'
[bv] [0.060832] Normalizing goal
  [Meta.synthInstance] [0.002250] ‚úÖÔ∏è Decidable
        ((if True ‚àß (2#32 <<< (x‚úù + -1#32)).sshiftRight (x‚úù + -1#32).toNat = 2#32 then none
          else if x‚úù + -1#32 ‚â• ‚Üë32 then none else some (2#32 <<< (x‚úù + -1#32))) ‚äë
          if True ‚àß 1#32 <<< x‚úù >>> x‚úù = 1#32 then none else if x‚úù ‚â• ‚Üë32 then none else some (1#32 <<< x‚úù))
    [Meta.check] [0.001273] ‚úÖÔ∏è BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if True ‚àß (2#32 <<< (x‚úù + -1#32)).sshiftRight (x‚úù + -1#32).toNat = 2#32 then none
          else if x‚úù + -1#32 ‚â• ‚Üë32 then none else some (2#32 <<< (x‚úù + -1#32)))
          (if True ‚àß 1#32 <<< x‚úù >>> x‚úù = 1#32 then none else if x‚úù ‚â• ‚Üë32 then none else some (1#32 <<< x‚úù))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if True ‚àß (2#32 <<< (x‚úù + -1#32)).sshiftRight (x‚úù + -1#32).toNat = 2#32 then none
            else if x‚úù + -1#32 ‚â• ‚Üë32 then none else some (2#32 <<< (x‚úù + -1#32))) ‚äë
            if True ‚àß 1#32 <<< x‚úù >>> x‚úù = 1#32 then none else if x‚úù ‚â• ‚Üë32 then none else some (1#32 <<< x‚úù)
      ‚ä¢ False
  [Meta.isDefEq] [0.002019] ‚úÖÔ∏è ?h‚ÇÅ =?= Eq.trans
        (congrArg (And True)
          (Std.Tactic.BVDecide.Normalize.BitVec.eq_to_beq
            ((2#32 <<< (x‚úù + 4294967295#32)).sshiftRight (x‚úù + 4294967295#32).toNat) 2#32))
        (true_and (((2#32 <<< (x‚úù + 4294967295#32)).sshiftRight (x‚úù + 4294967295#32).toNat == 2#32) = true))
    [Meta.isDefEq.assign] [0.002015] ‚úÖÔ∏è ?h‚ÇÅ := Eq.trans
          (congrArg (And True)
            (Std.Tactic.BVDecide.Normalize.BitVec.eq_to_beq
              ((2#32 <<< (x‚úù + 4294967295#32)).sshiftRight (x‚úù + 4294967295#32).toNat) 2#32))
          (true_and (((2#32 <<< (x‚úù + 4294967295#32)).sshiftRight (x‚úù + 4294967295#32).toNat == 2#32) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001991] ‚úÖÔ∏è (?h‚ÇÅ : (True ‚àß
              (2#32 <<< (x‚úù + -1#32)).sshiftRight (x‚úù + -1#32).toNat = 2#32) =
            (((2#32 <<< (x‚úù + 4294967295#32)).sshiftRight (x‚úù + 4294967295#32).toNat == 2#32) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Std.Tactic.BVDecide.Normalize.BitVec.eq_to_beq
                ((2#32 <<< (x‚úù + 4294967295#32)).sshiftRight (x‚úù + 4294967295#32).toNat) 2#32))
            (true_and
              (((2#32 <<< (x‚úù + 4294967295#32)).sshiftRight (x‚úù + 4294967295#32).toNat == 2#32) =
                true)) : (True ‚àß (2#32 <<< (x‚úù + 4294967295#32)).sshiftRight (x‚úù + 4294967295#32).toNat = 2#32) =
            (((2#32 <<< (x‚úù + 4294967295#32)).sshiftRight (x‚úù + 4294967295#32).toNat == 2#32) = true))
        [Meta.isDefEq] [0.001986] ‚úÖÔ∏è (True ‚àß (2#32 <<< (x‚úù + -1#32)).sshiftRight (x‚úù + -1#32).toNat = 2#32) =
              (((2#32 <<< (x‚úù + 4294967295#32)).sshiftRight (x‚úù + 4294967295#32).toNat == 2#32) =
                true) =?= (True ‚àß (2#32 <<< (x‚úù + 4294967295#32)).sshiftRight (x‚úù + 4294967295#32).toNat = 2#32) =
              (((2#32 <<< (x‚úù + 4294967295#32)).sshiftRight (x‚úù + 4294967295#32).toNat == 2#32) = true)
          [Meta.isDefEq] [0.001953] ‚úÖÔ∏è True ‚àß
                (2#32 <<< (x‚úù + -1#32)).sshiftRight (x‚úù + -1#32).toNat =
                  2#32 =?= True ‚àß (2#32 <<< (x‚úù + 4294967295#32)).sshiftRight (x‚úù + 4294967295#32).toNat = 2#32
            [Meta.isDefEq] [0.001928] ‚úÖÔ∏è (2#32 <<< (x‚úù + -1#32)).sshiftRight (x‚úù + -1#32).toNat =
                  2#32 =?= (2#32 <<< (x‚úù + 4294967295#32)).sshiftRight (x‚úù + 4294967295#32).toNat = 2#32
              [Meta.isDefEq] [0.001905] ‚úÖÔ∏è (2#32 <<< (x‚úù + -1#32)).sshiftRight
                    (x‚úù + -1#32).toNat =?= (2#32 <<< (x‚úù + 4294967295#32)).sshiftRight (x‚úù + 4294967295#32).toNat
                [Meta.isDefEq.delta] [0.001887] ‚úÖÔ∏è (2#32 <<< (x‚úù + -1#32)).sshiftRight
                      (x‚úù + -1#32).toNat =?= (2#32 <<< (x‚úù + 4294967295#32)).sshiftRight (x‚úù + 4294967295#32).toNat
                  [Meta.isDefEq] [0.001843] ‚úÖÔ∏è 2#32 <<< (x‚úù + -1#32) =?= 2#32 <<< (x‚úù + 4294967295#32)
                    [Meta.isDefEq] [0.001805] ‚úÖÔ∏è BitVec.instHShiftLeft.1 (2#32)
                          (x‚úù + -1#32) =?= BitVec.instHShiftLeft.1 (2#32) (x‚úù + 4294967295#32)
                      [Meta.isDefEq] [0.001712] ‚úÖÔ∏è 2#32 <<< (x‚úù + -1#32).toNat =?= 2#32 <<< (x‚úù + 4294967295#32).toNat
                        [Meta.isDefEq] [0.001681] ‚úÖÔ∏è BitVec.instHShiftLeftNat.1 (2#32)
                              (x‚úù + -1#32).toNat =?= BitVec.instHShiftLeftNat.1 (2#32) (x‚úù + 4294967295#32).toNat
                          [Meta.isDefEq] [0.001587] ‚úÖÔ∏è (2#32).shiftLeft
                                (x‚úù + -1#32).toNat =?= (2#32).shiftLeft (x‚úù + 4294967295#32).toNat
                            [Meta.isDefEq.delta] [0.001568] ‚úÖÔ∏è (2#32).shiftLeft
                                  (x‚úù + -1#32).toNat =?= (2#32).shiftLeft (x‚úù + 4294967295#32).toNat
                              [Meta.isDefEq] [0.001531] ‚úÖÔ∏è (x‚úù + -1#32).toNat =?= (x‚úù + 4294967295#32).toNat
                                [Meta.isDefEq.delta] [0.001511] ‚úÖÔ∏è (x‚úù + -1#32).toNat =?= (x‚úù + 4294967295#32).toNat
                                  [Meta.isDefEq] [0.001488] ‚úÖÔ∏è x‚úù + -1#32 =?= x‚úù + 4294967295#32
                                    [Meta.isDefEq] [0.001287] ‚úÖÔ∏è instHAdd.1 x‚úù (-1#32) =?= instHAdd.1 x‚úù 4294967295#32
                                      [Meta.isDefEq] [0.001226] ‚úÖÔ∏è Add.add x‚úù (-1#32) =?= Add.add x‚úù 4294967295#32
                                        [Meta.isDefEq] [0.001024] ‚úÖÔ∏è BitVec.instAdd.1 x‚úù
                                              (-1#32) =?= BitVec.instAdd.1 x‚úù 4294967295#32
  [Meta.isDefEq] [0.001142] ‚úÖÔ∏è ?h‚ÇÉ =?= fun a => Eq.refl (some (2#32 <<< (x‚úù + 4294967295#32)))
    [Meta.isDefEq.assign] [0.001137] ‚úÖÔ∏è ?h‚ÇÉ := fun a => Eq.refl (some (2#32 <<< (x‚úù + 4294967295#32)))
      [Meta.isDefEq.assign.checkTypes] [0.001069] ‚úÖÔ∏è (?h‚ÇÉ : ¬¨(!32#32 >·µ§ x‚úù + 4294967295#32) = true ‚Üí
            some (2#32 <<< (x‚úù + -1#32)) =
              some
                (2#32 <<<
                  (x‚úù +
                    4294967295#32))) := (fun a =>
            Eq.refl
              (some
                (2#32 <<<
                  (x‚úù +
                    4294967295#32))) : ¬¨(!32#32 >·µ§ x‚úù + 4294967295#32) = true ‚Üí
            some (2#32 <<< (x‚úù + 4294967295#32)) = some (2#32 <<< (x‚úù + 4294967295#32)))
        [Meta.isDefEq] [0.001064] ‚úÖÔ∏è ¬¨(!32#32 >·µ§ x‚úù + 4294967295#32) = true ‚Üí
              some (2#32 <<< (x‚úù + -1#32)) =
                some
                  (2#32 <<<
                    (x‚úù +
                      4294967295#32)) =?= ¬¨(!32#32 >·µ§ x‚úù + 4294967295#32) = true ‚Üí
              some (2#32 <<< (x‚úù + 4294967295#32)) = some (2#32 <<< (x‚úù + 4294967295#32))
          [Meta.isDefEq] [0.001007] ‚úÖÔ∏è some (2#32 <<< (x‚úù + -1#32)) =
                some
                  (2#32 <<<
                    (x‚úù +
                      4294967295#32)) =?= some (2#32 <<< (x‚úù + 4294967295#32)) = some (2#32 <<< (x‚úù + 4294967295#32))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if ((2#32 <<< (x‚úù + 4294967295#32)).sshiftRight (x‚úù + 4294967295#32).toNat == 2#32) = true then none
            else if (!32#32 >·µ§ x‚úù + 4294967295#32) = true then none else some (2#32 <<< (x‚úù + 4294967295#32))) ‚äë
            if (1#32 <<< x‚úù >>> x‚úù == 1#32) = true then none
            else if (!32#32 >·µ§ x‚úù) = true then none else some (1#32 <<< x‚úù)
      ‚ä¢ False
  [Meta.isDefEq] [0.002572] ‚ùåÔ∏è ?a == ?a =?= 1#32 <<< x‚úù >>> x‚úù == 1#32
    [Meta.isDefEq.onFailure] [0.002328] ‚ùåÔ∏è ?a == ?a =?= 1#32 <<< x‚úù >>> x‚úù == 1#32
      [Meta.synthInstance] [0.002309] üí•Ô∏è BEq ?Œ±
        [Meta.synthInstance] [0.002237] new goal BEq ?Œ±
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:130:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:123:8: error: (kernel) declaration has metavariables 'shl_nsw_add_negative_invalid_constant3_thm'
[bv] [0.046918] Normalizing goal
  [Meta.synthInstance] [0.001301] ‚úÖÔ∏è Decidable
        ((if True ‚àß (2#4 <<< (x‚úù + 8#4)).sshiftRight (x‚úù + 8#4).toNat = 2#4 then none
          else if x‚úù + 8#4 ‚â• ‚Üë4 then none else some (2#4 <<< (x‚úù + 8#4))) ‚äë
          if True ‚àß (2#4 <<< (x‚úù ^^^ 8#4)).sshiftRight (x‚úù ^^^ 8#4).toNat = 2#4 then none
          else if x‚úù ^^^ 8#4 ‚â• ‚Üë4 then none else some (2#4 <<< (x‚úù ^^^ 8#4)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 4
      x‚úù : BitVec 4
      a‚úù :
        ¬¨(if True ‚àß (2#4 <<< (x‚úù + 8#4)).sshiftRight (x‚úù + 8#4).toNat = 2#4 then none
            else if x‚úù + 8#4 ‚â• ‚Üë4 then none else some (2#4 <<< (x‚úù + 8#4))) ‚äë
            if True ‚àß (2#4 <<< (x‚úù ^^^ 8#4)).sshiftRight (x‚úù ^^^ 8#4).toNat = 2#4 then none
            else if x‚úù ^^^ 8#4 ‚â• ‚Üë4 then none else some (2#4 <<< (x‚úù ^^^ 8#4))
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 4
      x‚úù : BitVec 4
      a‚úù :
        ¬¨(if ((2#4 <<< (x‚úù + 8#4)).sshiftRight (x‚úù + 8#4).toNat == 2#4) = true then none
            else if (!4#4 >·µ§ x‚úù + 8#4) = true then none else some (2#4 <<< (x‚úù + 8#4))) ‚äë
            if ((2#4 <<< (x‚úù ^^^ 8#4)).sshiftRight (x‚úù ^^^ 8#4).toNat == 2#4) = true then none
            else if (!4#4 >·µ§ x‚úù ^^^ 8#4) = true then none else some (2#4 <<< (x‚úù ^^^ 8#4))
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:140:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:134:8: error: (kernel) declaration has metavariables 'lshr_2_add_zext_basic_thm'
[bv] [0.011531] Normalizing goal
  [Meta.synthInstance] [0.001096] ‚úÖÔ∏è Decidable
        ((if 1#2 ‚â• ‚Üë2 then none else some ((BitVec.zeroExtend 2 x‚úù + BitVec.zeroExtend 2 x‚úù¬π) >>> 1#2)) ‚äë
          some (BitVec.zeroExtend 2 (x‚úù &&& x‚úù¬π)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 1
      x‚úù¬π x‚úù : BitVec 1
      a‚úù :
        ¬¨(if 1#2 ‚â• ‚Üë2 then none else some ((BitVec.zeroExtend 2 x‚úù + BitVec.zeroExtend 2 x‚úù¬π) >>> 1#2)) ‚äë
            some (BitVec.zeroExtend 2 (x‚úù &&& x‚úù¬π))
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 1
      x‚úù¬π x‚úù : BitVec 1
      a‚úù : ¬¨some ((BitVec.zeroExtend 2 x‚úù + BitVec.zeroExtend 2 x‚úù¬π) >>> 1) ‚äë some (BitVec.zeroExtend 2 (x‚úù &&& x‚úù¬π))
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:151:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:144:8: error: (kernel) declaration has metavariables 'ashr_2_add_zext_basic_thm'
[bv] [0.018796] Normalizing goal
  [Meta.synthInstance] [0.001166] ‚úÖÔ∏è Decidable
        ((if 1#2 ‚â• ‚Üë2 then none
          else some ((BitVec.zeroExtend 2 x‚úù + BitVec.zeroExtend 2 x‚úù¬π).sshiftRight (1#2).toNat)) ‚äë
          if
              True ‚àß
                (BitVec.zeroExtend 2 x‚úù + BitVec.zeroExtend 2 x‚úù¬π < BitVec.zeroExtend 2 x‚úù ‚à®
                  BitVec.zeroExtend 2 x‚úù + BitVec.zeroExtend 2 x‚úù¬π < BitVec.zeroExtend 2 x‚úù¬π) then
            none
          else
            if 1#2 ‚â• ‚Üë2 then none
            else some ((BitVec.zeroExtend 2 x‚úù + BitVec.zeroExtend 2 x‚úù¬π).sshiftRight (1#2).toNat))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 1
      x‚úù¬π x‚úù : BitVec 1
      a‚úù :
        ¬¨(if 1#2 ‚â• ‚Üë2 then none
            else some ((BitVec.zeroExtend 2 x‚úù + BitVec.zeroExtend 2 x‚úù¬π).sshiftRight (1#2).toNat)) ‚äë
            if
                True ‚àß
                  (BitVec.zeroExtend 2 x‚úù + BitVec.zeroExtend 2 x‚úù¬π < BitVec.zeroExtend 2 x‚úù ‚à®
                    BitVec.zeroExtend 2 x‚úù + BitVec.zeroExtend 2 x‚úù¬π < BitVec.zeroExtend 2 x‚úù¬π) then
              none
            else
              if 1#2 ‚â• ‚Üë2 then none
              else some ((BitVec.zeroExtend 2 x‚úù + BitVec.zeroExtend 2 x‚úù¬π).sshiftRight (1#2).toNat)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 1
      x‚úù¬π x‚úù : BitVec 1
      a‚úù :
        ¬¨some ((BitVec.zeroExtend 2 x‚úù + BitVec.zeroExtend 2 x‚úù¬π).sshiftRight 1) ‚äë
            if
                (!((!BitVec.zeroExtend 2 x‚úù >·µ§ BitVec.zeroExtend 2 x‚úù + BitVec.zeroExtend 2 x‚úù¬π) &&
                      !BitVec.zeroExtend 2 x‚úù¬π >·µ§ BitVec.zeroExtend 2 x‚úù + BitVec.zeroExtend 2 x‚úù¬π)) =
                  true then
              none
            else some ((BitVec.zeroExtend 2 x‚úù + BitVec.zeroExtend 2 x‚úù¬π).sshiftRight 1)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:162:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:155:8: error: (kernel) declaration has metavariables 'lshr_16_add_zext_basic_thm'
[bv] [0.018150] Normalizing goal
  [Meta.synthInstance] [0.001161] ‚úÖÔ∏è Decidable
        ((if 16#32 ‚â• ‚Üë32 then none else some ((BitVec.zeroExtend 32 x‚úù + BitVec.zeroExtend 32 x‚úù¬π) >>> 16#32)) ‚äë
          some (BitVec.zeroExtend 32 (BitVec.ofBool (x‚úù¬π >·µ§ x‚úù ^^^ -1#16))))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 16
      x‚úù¬π x‚úù : BitVec 16
      a‚úù :
        ¬¨(if 16#32 ‚â• ‚Üë32 then none else some ((BitVec.zeroExtend 32 x‚úù + BitVec.zeroExtend 32 x‚úù¬π) >>> 16#32)) ‚äë
            some (BitVec.zeroExtend 32 (BitVec.ofBool (x‚úù¬π >·µ§ x‚úù ^^^ -1#16)))
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 16
      x‚úù¬π x‚úù : BitVec 16
      a‚úù :
        ¬¨some ((BitVec.zeroExtend 32 x‚úù + BitVec.zeroExtend 32 x‚úù¬π) >>> 16) ‚äë
            some (BitVec.zeroExtend 32 (if (x‚úù¬π >·µ§ x‚úù ^^^ 65535#16) = true then 1#1 else 0#1))
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:174:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:166:8: error: (kernel) declaration has metavariables 'lshr_16_add_zext_basic_multiuse_thm'
[bv] [0.051310] Normalizing goal
  [Meta.synthInstance] [0.001778] ‚úÖÔ∏è Decidable
        ((if 16#32 ‚â• ‚Üë32 then none
          else some ((BitVec.zeroExtend 32 x‚úù + BitVec.zeroExtend 32 x‚úù¬π) >>> 16#32 ||| BitVec.zeroExtend 32 x‚úù)) ‚äë
          if
              True ‚àß
                (BitVec.zeroExtend 32 x‚úù).msb = (BitVec.zeroExtend 32 x‚úù¬π).msb ‚àß
                  (BitVec.zeroExtend 32 x‚úù + BitVec.zeroExtend 32 x‚úù¬π).msb ‚â† (BitVec.zeroExtend 32 x‚úù).msb then
            none
          else
            if
                True ‚àß
                  (BitVec.zeroExtend 32 x‚úù + BitVec.zeroExtend 32 x‚úù¬π < BitVec.zeroExtend 32 x‚úù ‚à®
                    BitVec.zeroExtend 32 x‚úù + BitVec.zeroExtend 32 x‚úù¬π < BitVec.zeroExtend 32 x‚úù¬π) then
              none
            else
              if 16#32 ‚â• ‚Üë32 then none
              else some ((BitVec.zeroExtend 32 x‚úù + BitVec.zeroExtend 32 x‚úù¬π) >>> 16#32 ||| BitVec.zeroExtend 32 x‚úù))
    [Meta.check] [0.001161] ‚úÖÔ∏è BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if 16#32 ‚â• ‚Üë32 then none
          else some ((BitVec.zeroExtend 32 x‚úù + BitVec.zeroExtend 32 x‚úù¬π) >>> 16#32 ||| BitVec.zeroExtend 32 x‚úù))
          (if
              True ‚àß
                (BitVec.zeroExtend 32 x‚úù).msb = (BitVec.zeroExtend 32 x‚úù¬π).msb ‚àß
                  (BitVec.zeroExtend 32 x‚úù + BitVec.zeroExtend 32 x‚úù¬π).msb ‚â† (BitVec.zeroExtend 32 x‚úù).msb then
            none
          else
            if
                True ‚àß
                  (BitVec.zeroExtend 32 x‚úù + BitVec.zeroExtend 32 x‚úù¬π < BitVec.zeroExtend 32 x‚úù ‚à®
                    BitVec.zeroExtend 32 x‚úù + BitVec.zeroExtend 32 x‚úù¬π < BitVec.zeroExtend 32 x‚úù¬π) then
              none
            else
              if 16#32 ‚â• ‚Üë32 then none
              else some ((BitVec.zeroExtend 32 x‚úù + BitVec.zeroExtend 32 x‚úù¬π) >>> 16#32 ||| BitVec.zeroExtend 32 x‚úù))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 16
      x‚úù¬π x‚úù : BitVec 16
      a‚úù :
        ¬¨(if 16#32 ‚â• ‚Üë32 then none
            else some ((BitVec.zeroExtend 32 x‚úù + BitVec.zeroExtend 32 x‚úù¬π) >>> 16#32 ||| BitVec.zeroExtend 32 x‚úù)) ‚äë
            if
                True ‚àß
                  (BitVec.zeroExtend 32 x‚úù).msb = (BitVec.zeroExtend 32 x‚úù¬π).msb ‚àß
                    (BitVec.zeroExtend 32 x‚úù + BitVec.zeroExtend 32 x‚úù¬π).msb ‚â† (BitVec.zeroExtend 32 x‚úù).msb then
              none
            else
              if
                  True ‚àß
                    (BitVec.zeroExtend 32 x‚úù + BitVec.zeroExtend 32 x‚úù¬π < BitVec.zeroExtend 32 x‚úù ‚à®
                      BitVec.zeroExtend 32 x‚úù + BitVec.zeroExtend 32 x‚úù¬π < BitVec.zeroExtend 32 x‚úù¬π) then
                none
              else
                if 16#32 ‚â• ‚Üë32 then none
                else some ((BitVec.zeroExtend 32 x‚úù + BitVec.zeroExtend 32 x‚úù¬π) >>> 16#32 ||| BitVec.zeroExtend 32 x‚úù)
      ‚ä¢ False
  [Meta.isDefEq] [0.001156] ‚ùåÔ∏è ?a ==
        ?a =?= (BitVec.zeroExtend 32 x‚úù + BitVec.zeroExtend 32 x‚úù¬π).getLsbD 31 == (BitVec.zeroExtend 32 x‚úù).getLsbD 31
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 16
      x‚úù¬π x‚úù : BitVec 16
      a‚úù :
        ¬¨some ((BitVec.zeroExtend 32 x‚úù + BitVec.zeroExtend 32 x‚úù¬π) >>> 16 ||| BitVec.zeroExtend 32 x‚úù) ‚äë
            if
                ((BitVec.zeroExtend 32 x‚úù).getLsbD 31 == (BitVec.zeroExtend 32 x‚úù¬π).getLsbD 31 &&
                    !(BitVec.zeroExtend 32 x‚úù + BitVec.zeroExtend 32 x‚úù¬π).getLsbD 31 ==
                        (BitVec.zeroExtend 32 x‚úù).getLsbD 31) =
                  true then
              none
            else
              if
                  (!((!BitVec.zeroExtend 32 x‚úù >·µ§ BitVec.zeroExtend 32 x‚úù + BitVec.zeroExtend 32 x‚úù¬π) &&
                        !BitVec.zeroExtend 32 x‚úù¬π >·µ§ BitVec.zeroExtend 32 x‚úù + BitVec.zeroExtend 32 x‚úù¬π)) =
                    true then
                none
              else some ((BitVec.zeroExtend 32 x‚úù + BitVec.zeroExtend 32 x‚úù¬π) >>> 16 ||| BitVec.zeroExtend 32 x‚úù)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:186:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:178:8: error: (kernel) declaration has metavariables 'lshr_16_add_known_16_leading_zeroes_thm'
[bv] [0.034574] Normalizing goal
  [Meta.synthInstance] [0.001818] ‚úÖÔ∏è Decidable
        ((if 16#32 ‚â• ‚Üë32 then none else some (((x‚úù &&& 65535#32) + (x‚úù¬π &&& 65535#32)) >>> 16#32)) ‚äë
          if
              True ‚àß
                (x‚úù &&& 65535#32).msb = (x‚úù¬π &&& 65535#32).msb ‚àß
                  ((x‚úù &&& 65535#32) + (x‚úù¬π &&& 65535#32)).msb ‚â† (x‚úù &&& 65535#32).msb then
            none
          else
            if
                True ‚àß
                  ((x‚úù &&& 65535#32) + (x‚úù¬π &&& 65535#32) < x‚úù &&& 65535#32 ‚à®
                    (x‚úù &&& 65535#32) + (x‚úù¬π &&& 65535#32) < x‚úù¬π &&& 65535#32) then
              none
            else if 16#32 ‚â• ‚Üë32 then none else some (((x‚úù &&& 65535#32) + (x‚úù¬π &&& 65535#32)) >>> 16#32))
    [Meta.check] [0.001073] ‚úÖÔ∏è BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if 16#32 ‚â• ‚Üë32 then none else some (((x‚úù &&& 65535#32) + (x‚úù¬π &&& 65535#32)) >>> 16#32))
          (if
              True ‚àß
                (x‚úù &&& 65535#32).msb = (x‚úù¬π &&& 65535#32).msb ‚àß
                  ((x‚úù &&& 65535#32) + (x‚úù¬π &&& 65535#32)).msb ‚â† (x‚úù &&& 65535#32).msb then
            none
          else
            if
                True ‚àß
                  ((x‚úù &&& 65535#32) + (x‚úù¬π &&& 65535#32) < x‚úù &&& 65535#32 ‚à®
                    (x‚úù &&& 65535#32) + (x‚úù¬π &&& 65535#32) < x‚úù¬π &&& 65535#32) then
              none
            else if 16#32 ‚â• ‚Üë32 then none else some (((x‚úù &&& 65535#32) + (x‚úù¬π &&& 65535#32)) >>> 16#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x‚úù¬π x‚úù : BitVec 32
      a‚úù :
        ¬¨(if 16#32 ‚â• ‚Üë32 then none else some (((x‚úù &&& 65535#32) + (x‚úù¬π &&& 65535#32)) >>> 16#32)) ‚äë
            if
                True ‚àß
                  (x‚úù &&& 65535#32).msb = (x‚úù¬π &&& 65535#32).msb ‚àß
                    ((x‚úù &&& 65535#32) + (x‚úù¬π &&& 65535#32)).msb ‚â† (x‚úù &&& 65535#32).msb then
              none
            else
              if
                  True ‚àß
                    ((x‚úù &&& 65535#32) + (x‚úù¬π &&& 65535#32) < x‚úù &&& 65535#32 ‚à®
                      (x‚úù &&& 65535#32) + (x‚úù¬π &&& 65535#32) < x‚úù¬π &&& 65535#32) then
                none
              else if 16#32 ‚â• ‚Üë32 then none else some (((x‚úù &&& 65535#32) + (x‚úù¬π &&& 65535#32)) >>> 16#32)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x‚úù¬π x‚úù : BitVec 32
      a‚úù :
        ¬¨some (((x‚úù &&& 65535#32) + (x‚úù¬π &&& 65535#32)) >>> 16) ‚äë
            if
                ((x‚úù &&& 65535#32).getLsbD 31 == (x‚úù¬π &&& 65535#32).getLsbD 31 &&
                    !((x‚úù &&& 65535#32) + (x‚úù¬π &&& 65535#32)).getLsbD 31 == (x‚úù &&& 65535#32).getLsbD 31) =
                  true then
              none
            else
              if
                  (!((!x‚úù &&& 65535#32 >·µ§ (x‚úù &&& 65535#32) + (x‚úù¬π &&& 65535#32)) &&
                        !x‚úù¬π &&& 65535#32 >·µ§ (x‚úù &&& 65535#32) + (x‚úù¬π &&& 65535#32))) =
                    true then
                none
              else some (((x‚úù &&& 65535#32) + (x‚úù¬π &&& 65535#32)) >>> 16)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:198:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:190:8: error: (kernel) declaration has metavariables 'lshr_16_add_not_known_16_leading_zeroes_thm'
[bv] [0.034015] Normalizing goal
  [Meta.synthInstance] [0.001467] ‚úÖÔ∏è Decidable
        ((if 16#32 ‚â• ‚Üë32 then none else some (((x‚úù &&& 131071#32) + (x‚úù¬π &&& 65535#32)) >>> 16#32)) ‚äë
          if
              True ‚àß
                (x‚úù &&& 131071#32).msb = (x‚úù¬π &&& 65535#32).msb ‚àß
                  ((x‚úù &&& 131071#32) + (x‚úù¬π &&& 65535#32)).msb ‚â† (x‚úù &&& 131071#32).msb then
            none
          else
            if
                True ‚àß
                  ((x‚úù &&& 131071#32) + (x‚úù¬π &&& 65535#32) < x‚úù &&& 131071#32 ‚à®
                    (x‚úù &&& 131071#32) + (x‚úù¬π &&& 65535#32) < x‚úù¬π &&& 65535#32) then
              none
            else if 16#32 ‚â• ‚Üë32 then none else some (((x‚úù &&& 131071#32) + (x‚úù¬π &&& 65535#32)) >>> 16#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x‚úù¬π x‚úù : BitVec 32
      a‚úù :
        ¬¨(if 16#32 ‚â• ‚Üë32 then none else some (((x‚úù &&& 131071#32) + (x‚úù¬π &&& 65535#32)) >>> 16#32)) ‚äë
            if
                True ‚àß
                  (x‚úù &&& 131071#32).msb = (x‚úù¬π &&& 65535#32).msb ‚àß
                    ((x‚úù &&& 131071#32) + (x‚úù¬π &&& 65535#32)).msb ‚â† (x‚úù &&& 131071#32).msb then
              none
            else
              if
                  True ‚àß
                    ((x‚úù &&& 131071#32) + (x‚úù¬π &&& 65535#32) < x‚úù &&& 131071#32 ‚à®
                      (x‚úù &&& 131071#32) + (x‚úù¬π &&& 65535#32) < x‚úù¬π &&& 65535#32) then
                none
              else if 16#32 ‚â• ‚Üë32 then none else some (((x‚úù &&& 131071#32) + (x‚úù¬π &&& 65535#32)) >>> 16#32)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x‚úù¬π x‚úù : BitVec 32
      a‚úù :
        ¬¨some (((x‚úù &&& 131071#32) + (x‚úù¬π &&& 65535#32)) >>> 16) ‚äë
            if
                ((x‚úù &&& 131071#32).getLsbD 31 == (x‚úù¬π &&& 65535#32).getLsbD 31 &&
                    !((x‚úù &&& 131071#32) + (x‚úù¬π &&& 65535#32)).getLsbD 31 == (x‚úù &&& 131071#32).getLsbD 31) =
                  true then
              none
            else
              if
                  (!((!x‚úù &&& 131071#32 >·µ§ (x‚úù &&& 131071#32) + (x‚úù¬π &&& 65535#32)) &&
                        !x‚úù¬π &&& 65535#32 >·µ§ (x‚úù &&& 131071#32) + (x‚úù¬π &&& 65535#32))) =
                    true then
                none
              else some (((x‚úù &&& 131071#32) + (x‚úù¬π &&& 65535#32)) >>> 16)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:209:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:202:8: error: (kernel) declaration has metavariables 'lshr_32_add_zext_basic_thm'
[bv] [0.018491] Normalizing goal
  [Meta.synthInstance] [0.001192] ‚úÖÔ∏è Decidable
        ((if 32#64 ‚â• ‚Üë64 then none else some ((BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π) >>> 32#64)) ‚äë
          some (BitVec.zeroExtend 64 (BitVec.ofBool (x‚úù¬π >·µ§ x‚úù ^^^ -1#32))))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x‚úù¬π x‚úù : BitVec 32
      a‚úù :
        ¬¨(if 32#64 ‚â• ‚Üë64 then none else some ((BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π) >>> 32#64)) ‚äë
            some (BitVec.zeroExtend 64 (BitVec.ofBool (x‚úù¬π >·µ§ x‚úù ^^^ -1#32)))
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x‚úù¬π x‚úù : BitVec 32
      a‚úù :
        ¬¨some ((BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π) >>> 32) ‚äë
            some (BitVec.zeroExtend 64 (if (x‚úù¬π >·µ§ x‚úù ^^^ 4294967295#32) = true then 1#1 else 0#1))
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:220:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:213:8: error: (kernel) declaration has metavariables 'lshr_32_add_zext_basic_multiuse_thm'
[bv] [0.034818] Normalizing goal
  [Meta.synthInstance] [0.001424] ‚úÖÔ∏è Decidable
        ((if 32#64 ‚â• ‚Üë64 then none
          else some ((BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π) >>> 32#64 ||| BitVec.zeroExtend 64 x‚úù¬π)) ‚äë
          if
              True ‚àß
                (BitVec.zeroExtend 64 x‚úù).msb = (BitVec.zeroExtend 64 x‚úù¬π).msb ‚àß
                  (BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π).msb ‚â† (BitVec.zeroExtend 64 x‚úù).msb then
            none
          else
            if
                True ‚àß
                  (BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π < BitVec.zeroExtend 64 x‚úù ‚à®
                    BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π < BitVec.zeroExtend 64 x‚úù¬π) then
              none
            else
              if 32#64 ‚â• ‚Üë64 then none
              else some ((BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π) >>> 32#64 ||| BitVec.zeroExtend 64 x‚úù¬π))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x‚úù¬π x‚úù : BitVec 32
      a‚úù :
        ¬¨(if 32#64 ‚â• ‚Üë64 then none
            else some ((BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π) >>> 32#64 ||| BitVec.zeroExtend 64 x‚úù¬π)) ‚äë
            if
                True ‚àß
                  (BitVec.zeroExtend 64 x‚úù).msb = (BitVec.zeroExtend 64 x‚úù¬π).msb ‚àß
                    (BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π).msb ‚â† (BitVec.zeroExtend 64 x‚úù).msb then
              none
            else
              if
                  True ‚àß
                    (BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π < BitVec.zeroExtend 64 x‚úù ‚à®
                      BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π < BitVec.zeroExtend 64 x‚úù¬π) then
                none
              else
                if 32#64 ‚â• ‚Üë64 then none
                else some ((BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π) >>> 32#64 ||| BitVec.zeroExtend 64 x‚úù¬π)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x‚úù¬π x‚úù : BitVec 32
      a‚úù :
        ¬¨some ((BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π) >>> 32 ||| BitVec.zeroExtend 64 x‚úù¬π) ‚äë
            if
                ((BitVec.zeroExtend 64 x‚úù).getLsbD 63 == (BitVec.zeroExtend 64 x‚úù¬π).getLsbD 63 &&
                    !(BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π).getLsbD 63 ==
                        (BitVec.zeroExtend 64 x‚úù).getLsbD 63) =
                  true then
              none
            else
              if
                  (!((!BitVec.zeroExtend 64 x‚úù >·µ§ BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π) &&
                        !BitVec.zeroExtend 64 x‚úù¬π >·µ§ BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π)) =
                    true then
                none
              else some ((BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π) >>> 32 ||| BitVec.zeroExtend 64 x‚úù¬π)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:231:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:224:8: error: (kernel) declaration has metavariables 'lshr_31_i32_add_zext_basic_thm'
[bv] [0.034865] Normalizing goal
  [Meta.synthInstance] [0.001625] ‚úÖÔ∏è Decidable
        ((if 31#64 ‚â• ‚Üë64 then none else some ((BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π) >>> 31#64)) ‚äë
          if
              True ‚àß
                (BitVec.zeroExtend 64 x‚úù).msb = (BitVec.zeroExtend 64 x‚úù¬π).msb ‚àß
                  (BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π).msb ‚â† (BitVec.zeroExtend 64 x‚úù).msb then
            none
          else
            if
                True ‚àß
                  (BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π < BitVec.zeroExtend 64 x‚úù ‚à®
                    BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π < BitVec.zeroExtend 64 x‚úù¬π) then
              none
            else if 31#64 ‚â• ‚Üë64 then none else some ((BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π) >>> 31#64))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x‚úù¬π x‚úù : BitVec 32
      a‚úù :
        ¬¨(if 31#64 ‚â• ‚Üë64 then none else some ((BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π) >>> 31#64)) ‚äë
            if
                True ‚àß
                  (BitVec.zeroExtend 64 x‚úù).msb = (BitVec.zeroExtend 64 x‚úù¬π).msb ‚àß
                    (BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π).msb ‚â† (BitVec.zeroExtend 64 x‚úù).msb then
              none
            else
              if
                  True ‚àß
                    (BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π < BitVec.zeroExtend 64 x‚úù ‚à®
                      BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π < BitVec.zeroExtend 64 x‚úù¬π) then
                none
              else if 31#64 ‚â• ‚Üë64 then none else some ((BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π) >>> 31#64)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x‚úù¬π x‚úù : BitVec 32
      a‚úù :
        ¬¨some ((BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π) >>> 31) ‚äë
            if
                ((BitVec.zeroExtend 64 x‚úù).getLsbD 63 == (BitVec.zeroExtend 64 x‚úù¬π).getLsbD 63 &&
                    !(BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π).getLsbD 63 ==
                        (BitVec.zeroExtend 64 x‚úù).getLsbD 63) =
                  true then
              none
            else
              if
                  (!((!BitVec.zeroExtend 64 x‚úù >·µ§ BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π) &&
                        !BitVec.zeroExtend 64 x‚úù¬π >·µ§ BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π)) =
                    true then
                none
              else some ((BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π) >>> 31)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:240:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:235:8: error: (kernel) declaration has metavariables 'lshr_33_i32_add_zext_basic_thm'
[bv] [0.010138] Normalizing goal
  [Meta.synthInstance] [0.001215] ‚úÖÔ∏è Decidable
        ((if 33#64 ‚â• ‚Üë64 then none else some ((BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π) >>> 33#64)) ‚äë
          some 0#64)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x‚úù¬π x‚úù : BitVec 32
      a‚úù :
        ¬¨(if 33#64 ‚â• ‚Üë64 then none else some ((BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π) >>> 33#64)) ‚äë
            some 0#64
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x‚úù¬π x‚úù : BitVec 32
      a‚úù : ¬¨some ((BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π) >>> 33) ‚äë some 0#64
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:251:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:244:8: error: (kernel) declaration has metavariables 'lshr_16_to_64_add_zext_basic_thm'
[bv] [0.018872] Normalizing goal
  [Meta.synthInstance] [0.001191] ‚úÖÔ∏è Decidable
        ((if 16#64 ‚â• ‚Üë64 then none else some ((BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π) >>> 16#64)) ‚äë
          some (BitVec.zeroExtend 64 (BitVec.ofBool (x‚úù¬π >·µ§ x‚úù ^^^ -1#16))))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 16
      x‚úù¬π x‚úù : BitVec 16
      a‚úù :
        ¬¨(if 16#64 ‚â• ‚Üë64 then none else some ((BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π) >>> 16#64)) ‚äë
            some (BitVec.zeroExtend 64 (BitVec.ofBool (x‚úù¬π >·µ§ x‚úù ^^^ -1#16)))
      ‚ä¢ False
  [Meta.appBuilder] [0.001003] ‚úÖÔ∏è f: Eq.mp, xs: [congrArg Not
         (congr
           (congrArg BitVec.Refinement
             (ite_cond_eq_false none (some ((BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π) >>> 16#64))
               (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                 (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 64#64 16#64)
                   (Eq.trans
                     (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 16#64 64#64) (eq_self true)))
                     Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))))
           (congrArg (fun x => some (BitVec.zeroExtend 64 x))
             (Std.Tactic.BVDecide.Normalize.BitVec.ofBool_eq_if (x‚úù¬π >·µ§ x‚úù ^^^ 65535#16)))),
       a‚úù]
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 16
      x‚úù¬π x‚úù : BitVec 16
      a‚úù :
        ¬¨some ((BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π) >>> 16) ‚äë
            some (BitVec.zeroExtend 64 (if (x‚úù¬π >·µ§ x‚úù ^^^ 65535#16) = true then 1#1 else 0#1))
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:264:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:255:8: error: (kernel) declaration has metavariables 'lshr_32_add_known_32_leading_zeroes_thm'
[bv] [0.036005] Normalizing goal
  [Meta.synthInstance] [0.001582] ‚úÖÔ∏è Decidable
        ((if 32#64 ‚â• ‚Üë64 then none else some (((x‚úù &&& 4294967295#64) + (x‚úù¬π &&& 4294967295#64)) >>> 32#64)) ‚äë
          if
              True ‚àß
                (x‚úù &&& 4294967295#64).msb = (x‚úù¬π &&& 4294967295#64).msb ‚àß
                  ((x‚úù &&& 4294967295#64) + (x‚úù¬π &&& 4294967295#64)).msb ‚â† (x‚úù &&& 4294967295#64).msb then
            none
          else
            if
                True ‚àß
                  ((x‚úù &&& 4294967295#64) + (x‚úù¬π &&& 4294967295#64) < x‚úù &&& 4294967295#64 ‚à®
                    (x‚úù &&& 4294967295#64) + (x‚úù¬π &&& 4294967295#64) < x‚úù¬π &&& 4294967295#64) then
              none
            else if 32#64 ‚â• ‚Üë64 then none else some (((x‚úù &&& 4294967295#64) + (x‚úù¬π &&& 4294967295#64)) >>> 32#64))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 64
      x‚úù¬π x‚úù : BitVec 64
      a‚úù :
        ¬¨(if 32#64 ‚â• ‚Üë64 then none else some (((x‚úù &&& 4294967295#64) + (x‚úù¬π &&& 4294967295#64)) >>> 32#64)) ‚äë
            if
                True ‚àß
                  (x‚úù &&& 4294967295#64).msb = (x‚úù¬π &&& 4294967295#64).msb ‚àß
                    ((x‚úù &&& 4294967295#64) + (x‚úù¬π &&& 4294967295#64)).msb ‚â† (x‚úù &&& 4294967295#64).msb then
              none
            else
              if
                  True ‚àß
                    ((x‚úù &&& 4294967295#64) + (x‚úù¬π &&& 4294967295#64) < x‚úù &&& 4294967295#64 ‚à®
                      (x‚úù &&& 4294967295#64) + (x‚úù¬π &&& 4294967295#64) < x‚úù¬π &&& 4294967295#64) then
                none
              else if 32#64 ‚â• ‚Üë64 then none else some (((x‚úù &&& 4294967295#64) + (x‚úù¬π &&& 4294967295#64)) >>> 32#64)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 64
      x‚úù¬π x‚úù : BitVec 64
      a‚úù :
        ¬¨some (((x‚úù &&& 4294967295#64) + (x‚úù¬π &&& 4294967295#64)) >>> 32) ‚äë
            if
                ((x‚úù &&& 4294967295#64).getLsbD 63 == (x‚úù¬π &&& 4294967295#64).getLsbD 63 &&
                    !((x‚úù &&& 4294967295#64) + (x‚úù¬π &&& 4294967295#64)).getLsbD 63 ==
                        (x‚úù &&& 4294967295#64).getLsbD 63) =
                  true then
              none
            else
              if
                  (!((!x‚úù &&& 4294967295#64 >·µ§ (x‚úù &&& 4294967295#64) + (x‚úù¬π &&& 4294967295#64)) &&
                        !x‚úù¬π &&& 4294967295#64 >·µ§ (x‚úù &&& 4294967295#64) + (x‚úù¬π &&& 4294967295#64))) =
                    true then
                none
              else some (((x‚úù &&& 4294967295#64) + (x‚úù¬π &&& 4294967295#64)) >>> 32)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:277:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:268:8: error: (kernel) declaration has metavariables 'lshr_32_add_not_known_32_leading_zeroes_thm'
[bv] [0.034320] Normalizing goal
  [Meta.synthInstance] [0.001511] ‚úÖÔ∏è Decidable
        ((if 32#64 ‚â• ‚Üë64 then none else some (((x‚úù &&& 8589934591#64) + (x‚úù¬π &&& 4294967295#64)) >>> 32#64)) ‚äë
          if
              True ‚àß
                (x‚úù &&& 8589934591#64).msb = (x‚úù¬π &&& 4294967295#64).msb ‚àß
                  ((x‚úù &&& 8589934591#64) + (x‚úù¬π &&& 4294967295#64)).msb ‚â† (x‚úù &&& 8589934591#64).msb then
            none
          else
            if
                True ‚àß
                  ((x‚úù &&& 8589934591#64) + (x‚úù¬π &&& 4294967295#64) < x‚úù &&& 8589934591#64 ‚à®
                    (x‚úù &&& 8589934591#64) + (x‚úù¬π &&& 4294967295#64) < x‚úù¬π &&& 4294967295#64) then
              none
            else if 32#64 ‚â• ‚Üë64 then none else some (((x‚úù &&& 8589934591#64) + (x‚úù¬π &&& 4294967295#64)) >>> 32#64))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 64
      x‚úù¬π x‚úù : BitVec 64
      a‚úù :
        ¬¨(if 32#64 ‚â• ‚Üë64 then none else some (((x‚úù &&& 8589934591#64) + (x‚úù¬π &&& 4294967295#64)) >>> 32#64)) ‚äë
            if
                True ‚àß
                  (x‚úù &&& 8589934591#64).msb = (x‚úù¬π &&& 4294967295#64).msb ‚àß
                    ((x‚úù &&& 8589934591#64) + (x‚úù¬π &&& 4294967295#64)).msb ‚â† (x‚úù &&& 8589934591#64).msb then
              none
            else
              if
                  True ‚àß
                    ((x‚úù &&& 8589934591#64) + (x‚úù¬π &&& 4294967295#64) < x‚úù &&& 8589934591#64 ‚à®
                      (x‚úù &&& 8589934591#64) + (x‚úù¬π &&& 4294967295#64) < x‚úù¬π &&& 4294967295#64) then
                none
              else if 32#64 ‚â• ‚Üë64 then none else some (((x‚úù &&& 8589934591#64) + (x‚úù¬π &&& 4294967295#64)) >>> 32#64)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 64
      x‚úù¬π x‚úù : BitVec 64
      a‚úù :
        ¬¨some (((x‚úù &&& 8589934591#64) + (x‚úù¬π &&& 4294967295#64)) >>> 32) ‚äë
            if
                ((x‚úù &&& 8589934591#64).getLsbD 63 == (x‚úù¬π &&& 4294967295#64).getLsbD 63 &&
                    !((x‚úù &&& 8589934591#64) + (x‚úù¬π &&& 4294967295#64)).getLsbD 63 ==
                        (x‚úù &&& 8589934591#64).getLsbD 63) =
                  true then
              none
            else
              if
                  (!((!x‚úù &&& 8589934591#64 >·µ§ (x‚úù &&& 8589934591#64) + (x‚úù¬π &&& 4294967295#64)) &&
                        !x‚úù¬π &&& 4294967295#64 >·µ§ (x‚úù &&& 8589934591#64) + (x‚úù¬π &&& 4294967295#64))) =
                    true then
                none
              else some (((x‚úù &&& 8589934591#64) + (x‚úù¬π &&& 4294967295#64)) >>> 32)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:288:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:281:8: error: (kernel) declaration has metavariables 'ashr_16_add_zext_basic_thm'
[bv] [0.017802] Normalizing goal
  [Meta.synthInstance] [0.001153] ‚úÖÔ∏è Decidable
        ((if 16#32 ‚â• ‚Üë32 then none else some ((BitVec.zeroExtend 32 x‚úù + BitVec.zeroExtend 32 x‚úù¬π) >>> 16#32)) ‚äë
          some (BitVec.zeroExtend 32 (BitVec.ofBool (x‚úù¬π >·µ§ x‚úù ^^^ -1#16))))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 16
      x‚úù¬π x‚úù : BitVec 16
      a‚úù :
        ¬¨(if 16#32 ‚â• ‚Üë32 then none else some ((BitVec.zeroExtend 32 x‚úù + BitVec.zeroExtend 32 x‚úù¬π) >>> 16#32)) ‚äë
            some (BitVec.zeroExtend 32 (BitVec.ofBool (x‚úù¬π >·µ§ x‚úù ^^^ -1#16)))
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 16
      x‚úù¬π x‚úù : BitVec 16
      a‚úù :
        ¬¨some ((BitVec.zeroExtend 32 x‚úù + BitVec.zeroExtend 32 x‚úù¬π) >>> 16) ‚äë
            some (BitVec.zeroExtend 32 (if (x‚úù¬π >·µ§ x‚úù ^^^ 65535#16) = true then 1#1 else 0#1))
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:299:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:292:8: error: (kernel) declaration has metavariables 'ashr_32_add_zext_basic_thm'
[bv] [0.016672] Normalizing goal
  [Meta.synthInstance] [0.001130] ‚úÖÔ∏è Decidable
        ((if 32#64 ‚â• ‚Üë64 then none
          else some ((BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π).sshiftRight (32#64).toNat)) ‚äë
          some (BitVec.zeroExtend 64 (BitVec.ofBool (x‚úù¬π >·µ§ x‚úù ^^^ -1#32))))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x‚úù¬π x‚úù : BitVec 32
      a‚úù :
        ¬¨(if 32#64 ‚â• ‚Üë64 then none
            else some ((BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π).sshiftRight (32#64).toNat)) ‚äë
            some (BitVec.zeroExtend 64 (BitVec.ofBool (x‚úù¬π >·µ§ x‚úù ^^^ -1#32)))
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x‚úù¬π x‚úù : BitVec 32
      a‚úù :
        ¬¨some ((BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π).sshiftRight 32) ‚äë
            some (BitVec.zeroExtend 64 (if (x‚úù¬π >·µ§ x‚úù ^^^ 4294967295#32) = true then 1#1 else 0#1))
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:310:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:303:8: error: (kernel) declaration has metavariables 'ashr_16_to_64_add_zext_basic_thm'
[bv] [0.016718] Normalizing goal
  [Meta.synthInstance] [0.001132] ‚úÖÔ∏è Decidable
        ((if 16#64 ‚â• ‚Üë64 then none
          else some ((BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π).sshiftRight (16#64).toNat)) ‚äë
          some (BitVec.zeroExtend 64 (BitVec.ofBool (x‚úù¬π >·µ§ x‚úù ^^^ -1#16))))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 16
      x‚úù¬π x‚úù : BitVec 16
      a‚úù :
        ¬¨(if 16#64 ‚â• ‚Üë64 then none
            else some ((BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π).sshiftRight (16#64).toNat)) ‚äë
            some (BitVec.zeroExtend 64 (BitVec.ofBool (x‚úù¬π >·µ§ x‚úù ^^^ -1#16)))
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 16
      x‚úù¬π x‚úù : BitVec 16
      a‚úù :
        ¬¨some ((BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π).sshiftRight 16) ‚äë
            some (BitVec.zeroExtend 64 (if (x‚úù¬π >·µ§ x‚úù ^^^ 65535#16) = true then 1#1 else 0#1))
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:321:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:314:8: error: (kernel) declaration has metavariables 'lshr_32_add_zext_trunc_thm'
[bv] [0.022233] Normalizing goal
  [Meta.synthInstance] [0.001126] ‚úÖÔ∏è Decidable
        ((if 32#64 ‚â• ‚Üë64 then none
          else
            some
              (BitVec.truncate 32 (BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π) +
                BitVec.truncate 32 ((BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π) >>> 32#64))) ‚äë
          some (x‚úù + x‚úù¬π + BitVec.zeroExtend 32 (BitVec.ofBool (x‚úù >·µ§ x‚úù + x‚úù¬π))))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x‚úù¬π x‚úù : BitVec 32
      a‚úù :
        ¬¨(if 32#64 ‚â• ‚Üë64 then none
            else
              some
                (BitVec.truncate 32 (BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π) +
                  BitVec.truncate 32 ((BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π) >>> 32#64))) ‚äë
            some (x‚úù + x‚úù¬π + BitVec.zeroExtend 32 (BitVec.ofBool (x‚úù >·µ§ x‚úù + x‚úù¬π)))
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x‚úù¬π x‚úù : BitVec 32
      a‚úù :
        ¬¨some
              (BitVec.zeroExtend 32 (BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π) +
                BitVec.zeroExtend 32 ((BitVec.zeroExtend 64 x‚úù + BitVec.zeroExtend 64 x‚úù¬π) >>> 32)) ‚äë
            some (x‚úù + x‚úù¬π + BitVec.zeroExtend 32 (if (x‚úù >·µ§ x‚úù + x‚úù¬π) = true then 1#1 else 0#1))
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:330:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:325:8: error: (kernel) declaration has metavariables 'shl_fold_or_disjoint_cnt_thm'
[bv] [0.022371] Normalizing goal
  [Meta.synthInstance] [0.001137] ‚úÖÔ∏è Decidable
        ((if x‚úù ||| 3#8 ‚â• ‚Üë8 then none else some (2#8 <<< (x‚úù ||| 3#8))) ‚äë if x‚úù ‚â• ‚Üë8 then none else some (16#8 <<< x‚úù))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x‚úù : BitVec 8
      a‚úù :
        ¬¨(if x‚úù ||| 3#8 ‚â• ‚Üë8 then none else some (2#8 <<< (x‚úù ||| 3#8))) ‚äë if x‚úù ‚â• ‚Üë8 then none else some (16#8 <<< x‚úù)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x‚úù : BitVec 8
      a‚úù :
        ¬¨(if (!8#8 >·µ§ x‚úù ||| 3#8) = true then none else some (2#8 <<< (x‚úù ||| 3#8))) ‚äë
            if (!8#8 >·µ§ x‚úù) = true then none else some (16#8 <<< x‚úù)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
