âš  [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
âš  [878/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
âš  [881/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
âš  [887/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
âš  [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:17:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:11:8: error: (kernel) declaration has metavariables 'shl_C1_add_A_C2_i32_thm'
[bv] [0.071311] Normalizing goal
  [Meta.synthInstance] [0.001888] âœ…ï¸ Decidable
        ((if BitVec.zeroExtend 32 xâœ + 5#32 â‰¥ â†‘32 then none else some (6#32 <<< (BitVec.zeroExtend 32 xâœ + 5#32))) âŠ‘
          if BitVec.zeroExtend 32 xâœ â‰¥ â†‘32 then none else some (192#32 <<< BitVec.zeroExtend 32 xâœ))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 16
      xâœ : BitVec 16
      aâœ :
        Â¬(if BitVec.zeroExtend 32 xâœ + 5#32 â‰¥ â†‘32 then none else some (6#32 <<< (BitVec.zeroExtend 32 xâœ + 5#32))) âŠ‘
            if BitVec.zeroExtend 32 xâœ â‰¥ â†‘32 then none else some (192#32 <<< BitVec.zeroExtend 32 xâœ)
      âŠ¢ False
  [Meta.isDefEq] [0.002102] âŒï¸ ?a == ?a =?= (32#32 >áµ¤ BitVec.zeroExtend 32 xâœ + 5#32) == true
    [Meta.isDefEq.onFailure] [0.001684] âŒï¸ ?a == ?a =?= (32#32 >áµ¤ BitVec.zeroExtend 32 xâœ + 5#32) == true
      [Meta.synthInstance] [0.001654] ğŸ’¥ï¸ BEq ?Î±
        [Meta.synthInstance] [0.001539] new goal BEq ?Î±
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 16
      xâœ : BitVec 16
      aâœ :
        Â¬(if (!32#32 >áµ¤ BitVec.zeroExtend 32 xâœ + 5#32) = true then none
            else some (6#32 <<< (BitVec.zeroExtend 32 xâœ + 5#32))) âŠ‘
            if (!32#32 >áµ¤ BitVec.zeroExtend 32 xâœ) = true then none else some (192#32 <<< BitVec.zeroExtend 32 xâœ)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:27:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:21:8: error: (kernel) declaration has metavariables 'ashr_C1_add_A_C2_i32_thm'
[bv] [0.027953] Normalizing goal
  [Meta.synthInstance] [0.001780] âœ…ï¸ Decidable
        ((if (xâœ &&& 65535#32) + 5#32 â‰¥ â†‘32 then none else some ((6#32).sshiftRight ((xâœ &&& 65535#32) + 5#32).toNat)) âŠ‘
          some 0#32)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(if (xâœ &&& 65535#32) + 5#32 â‰¥ â†‘32 then none else some ((6#32).sshiftRight ((xâœ &&& 65535#32) + 5#32).toNat)) âŠ‘
            some 0#32
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(if (!32#32 >áµ¤ (xâœ &&& 65535#32) + 5#32) = true then none
            else some ((6#32).sshiftRight ((xâœ &&& 65535#32) + 5#32).toNat)) âŠ‘
            some 0#32
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:38:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:31:8: error: (kernel) declaration has metavariables 'lshr_C1_add_A_C2_i32_thm'
[bv] [0.039708] Normalizing goal
  [Meta.synthInstance] [0.001934] âœ…ï¸ Decidable
        ((if (xâœ &&& 65535#32) + 5#32 â‰¥ â†‘32 then none else some (6#32 <<< ((xâœ &&& 65535#32) + 5#32))) âŠ‘
          if xâœ &&& 65535#32 â‰¥ â†‘32 then none else some (192#32 <<< (xâœ &&& 65535#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(if (xâœ &&& 65535#32) + 5#32 â‰¥ â†‘32 then none else some (6#32 <<< ((xâœ &&& 65535#32) + 5#32))) âŠ‘
            if xâœ &&& 65535#32 â‰¥ â†‘32 then none else some (192#32 <<< (xâœ &&& 65535#32))
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(if (!32#32 >áµ¤ (xâœ &&& 65535#32) + 5#32) = true then none else some (6#32 <<< ((xâœ &&& 65535#32) + 5#32))) âŠ‘
            if (!32#32 >áµ¤ xâœ &&& 65535#32) = true then none else some (192#32 <<< (xâœ &&& 65535#32))
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:48:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:42:8: error: (kernel) declaration has metavariables 'shl_add_nuw_thm'
[bv] [0.050691] Normalizing goal
  [Meta.synthInstance] [0.002098] âœ…ï¸ Decidable
        ((if True âˆ§ (xâœ + 5#32 < xâœ âˆ¨ xâœ + 5#32 < 5#32) then none
          else if xâœ + 5#32 â‰¥ â†‘32 then none else some (6#32 <<< (xâœ + 5#32))) âŠ‘
          if xâœ â‰¥ â†‘32 then none else some (192#32 <<< xâœ))
    [Meta.check] [0.001105] âœ…ï¸ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if True âˆ§ (xâœ + 5#32 < xâœ âˆ¨ xâœ + 5#32 < 5#32) then none
          else if xâœ + 5#32 â‰¥ â†‘32 then none else some (6#32 <<< (xâœ + 5#32)))
          (if xâœ â‰¥ â†‘32 then none else some (192#32 <<< xâœ))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(if True âˆ§ (xâœ + 5#32 < xâœ âˆ¨ xâœ + 5#32 < 5#32) then none
            else if xâœ + 5#32 â‰¥ â†‘32 then none else some (6#32 <<< (xâœ + 5#32))) âŠ‘
            if xâœ â‰¥ â†‘32 then none else some (192#32 <<< xâœ)
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(if (!((!xâœ >áµ¤ xâœ + 5#32) && !5#32 >áµ¤ xâœ + 5#32)) = true then none
            else if (!32#32 >áµ¤ xâœ + 5#32) = true then none else some (6#32 <<< (xâœ + 5#32))) âŠ‘
            if (!32#32 >áµ¤ xâœ) = true then none else some (192#32 <<< xâœ)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:59:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:52:8: error: (kernel) declaration has metavariables 'shl_nuw_add_nuw_thm'
[bv] [0.073101] Normalizing goal
  [Meta.synthInstance] [0.002354] âœ…ï¸ Decidable
        ((if True âˆ§ (xâœ + 1#32 < xâœ âˆ¨ xâœ + 1#32 < 1#32) then none
          else
            if True âˆ§ 1#32 <<< (xâœ + 1#32) >>> (xâœ + 1#32) = 1#32 then none
            else if xâœ + 1#32 â‰¥ â†‘32 then none else some (1#32 <<< (xâœ + 1#32))) âŠ‘
          if True âˆ§ 2#32 <<< xâœ >>> xâœ = 2#32 then none else if xâœ â‰¥ â†‘32 then none else some (2#32 <<< xâœ))
    [Meta.check] [0.001365] âœ…ï¸ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if True âˆ§ (xâœ + 1#32 < xâœ âˆ¨ xâœ + 1#32 < 1#32) then none
          else
            if True âˆ§ 1#32 <<< (xâœ + 1#32) >>> (xâœ + 1#32) = 1#32 then none
            else if xâœ + 1#32 â‰¥ â†‘32 then none else some (1#32 <<< (xâœ + 1#32)))
          (if True âˆ§ 2#32 <<< xâœ >>> xâœ = 2#32 then none else if xâœ â‰¥ â†‘32 then none else some (2#32 <<< xâœ))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(if True âˆ§ (xâœ + 1#32 < xâœ âˆ¨ xâœ + 1#32 < 1#32) then none
            else
              if True âˆ§ 1#32 <<< (xâœ + 1#32) >>> (xâœ + 1#32) = 1#32 then none
              else if xâœ + 1#32 â‰¥ â†‘32 then none else some (1#32 <<< (xâœ + 1#32))) âŠ‘
            if True âˆ§ 2#32 <<< xâœ >>> xâœ = 2#32 then none else if xâœ â‰¥ â†‘32 then none else some (2#32 <<< xâœ)
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(if (!((!xâœ >áµ¤ xâœ + 1#32) && !1#32 >áµ¤ xâœ + 1#32)) = true then none
            else
              if (1#32 <<< (xâœ + 1#32) >>> (xâœ + 1#32) == 1#32) = true then none
              else if (!32#32 >áµ¤ xâœ + 1#32) = true then none else some (1#32 <<< (xâœ + 1#32))) âŠ‘
            if (2#32 <<< xâœ >>> xâœ == 2#32) = true then none
            else if (!32#32 >áµ¤ xâœ) = true then none else some (2#32 <<< xâœ)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:70:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:63:8: error: (kernel) declaration has metavariables 'shl_nsw_add_nuw_thm'
[bv] [0.073123] Normalizing goal
  [Meta.synthInstance] [0.002314] âœ…ï¸ Decidable
        ((if True âˆ§ (xâœ + 1#32 < xâœ âˆ¨ xâœ + 1#32 < 1#32) then none
          else
            if True âˆ§ ((-1#32) <<< (xâœ + 1#32)).sshiftRight (xâœ + 1#32).toNat = -1#32 then none
            else if xâœ + 1#32 â‰¥ â†‘32 then none else some ((-1#32) <<< (xâœ + 1#32))) âŠ‘
          if True âˆ§ (4294967294#32 <<< xâœ).sshiftRight xâœ.toNat = 4294967294#32 then none
          else if xâœ â‰¥ â†‘32 then none else some (4294967294#32 <<< xâœ))
    [Meta.check] [0.001327] âœ…ï¸ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if True âˆ§ (xâœ + 1#32 < xâœ âˆ¨ xâœ + 1#32 < 1#32) then none
          else
            if True âˆ§ ((-1#32) <<< (xâœ + 1#32)).sshiftRight (xâœ + 1#32).toNat = -1#32 then none
            else if xâœ + 1#32 â‰¥ â†‘32 then none else some ((-1#32) <<< (xâœ + 1#32)))
          (if True âˆ§ (4294967294#32 <<< xâœ).sshiftRight xâœ.toNat = 4294967294#32 then none
          else if xâœ â‰¥ â†‘32 then none else some (4294967294#32 <<< xâœ))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(if True âˆ§ (xâœ + 1#32 < xâœ âˆ¨ xâœ + 1#32 < 1#32) then none
            else
              if True âˆ§ ((-1#32) <<< (xâœ + 1#32)).sshiftRight (xâœ + 1#32).toNat = -1#32 then none
              else if xâœ + 1#32 â‰¥ â†‘32 then none else some ((-1#32) <<< (xâœ + 1#32))) âŠ‘
            if True âˆ§ (4294967294#32 <<< xâœ).sshiftRight xâœ.toNat = 4294967294#32 then none
            else if xâœ â‰¥ â†‘32 then none else some (4294967294#32 <<< xâœ)
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(if (!((!xâœ >áµ¤ xâœ + 1#32) && !1#32 >áµ¤ xâœ + 1#32)) = true then none
            else
              if ((4294967295#32 <<< (xâœ + 1#32)).sshiftRight (xâœ + 1#32).toNat == 4294967295#32) = true then none
              else if (!32#32 >áµ¤ xâœ + 1#32) = true then none else some (4294967295#32 <<< (xâœ + 1#32))) âŠ‘
            if ((4294967294#32 <<< xâœ).sshiftRight xâœ.toNat == 4294967294#32) = true then none
            else if (!32#32 >áµ¤ xâœ) = true then none else some (4294967294#32 <<< xâœ)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:80:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:74:8: error: (kernel) declaration has metavariables 'lshr_exact_add_nuw_thm'
[bv] [0.051162] Normalizing goal
  [Meta.synthInstance] [0.002078] âœ…ï¸ Decidable
        ((if True âˆ§ (xâœ + 1#32 < xâœ âˆ¨ xâœ + 1#32 < 1#32) then none
          else if xâœ + 1#32 â‰¥ â†‘32 then none else some (4#32 >>> (xâœ + 1#32))) âŠ‘
          if xâœ â‰¥ â†‘32 then none else some (2#32 >>> xâœ))
    [Meta.check] [0.001079] âœ…ï¸ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if True âˆ§ (xâœ + 1#32 < xâœ âˆ¨ xâœ + 1#32 < 1#32) then none
          else if xâœ + 1#32 â‰¥ â†‘32 then none else some (4#32 >>> (xâœ + 1#32)))
          (if xâœ â‰¥ â†‘32 then none else some (2#32 >>> xâœ))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(if True âˆ§ (xâœ + 1#32 < xâœ âˆ¨ xâœ + 1#32 < 1#32) then none
            else if xâœ + 1#32 â‰¥ â†‘32 then none else some (4#32 >>> (xâœ + 1#32))) âŠ‘
            if xâœ â‰¥ â†‘32 then none else some (2#32 >>> xâœ)
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(if (!((!xâœ >áµ¤ xâœ + 1#32) && !1#32 >áµ¤ xâœ + 1#32)) = true then none
            else if (!32#32 >áµ¤ xâœ + 1#32) = true then none else some (4#32 >>> (xâœ + 1#32))) âŠ‘
            if (!32#32 >áµ¤ xâœ) = true then none else some (2#32 >>> xâœ)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:90:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:84:8: error: (kernel) declaration has metavariables 'ashr_exact_add_nuw_thm'
[bv] [0.047095] Normalizing goal
  [Meta.synthInstance] [0.002011] âœ…ï¸ Decidable
        ((if True âˆ§ (xâœ + 1#32 < xâœ âˆ¨ xâœ + 1#32 < 1#32) then none
          else if xâœ + 1#32 â‰¥ â†‘32 then none else some ((4294967292#32).sshiftRight (xâœ + 1#32).toNat)) âŠ‘
          if xâœ â‰¥ â†‘32 then none else some ((4294967294#32).sshiftRight xâœ.toNat))
    [Meta.check] [0.001028] âœ…ï¸ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if True âˆ§ (xâœ + 1#32 < xâœ âˆ¨ xâœ + 1#32 < 1#32) then none
          else if xâœ + 1#32 â‰¥ â†‘32 then none else some ((4294967292#32).sshiftRight (xâœ + 1#32).toNat))
          (if xâœ â‰¥ â†‘32 then none else some ((4294967294#32).sshiftRight xâœ.toNat))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(if True âˆ§ (xâœ + 1#32 < xâœ âˆ¨ xâœ + 1#32 < 1#32) then none
            else if xâœ + 1#32 â‰¥ â†‘32 then none else some ((4294967292#32).sshiftRight (xâœ + 1#32).toNat)) âŠ‘
            if xâœ â‰¥ â†‘32 then none else some ((4294967294#32).sshiftRight xâœ.toNat)
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(if (!((!xâœ >áµ¤ xâœ + 1#32) && !1#32 >áµ¤ xâœ + 1#32)) = true then none
            else if (!32#32 >áµ¤ xâœ + 1#32) = true then none else some ((4294967292#32).sshiftRight (xâœ + 1#32).toNat)) âŠ‘
            if (!32#32 >áµ¤ xâœ) = true then none else some ((4294967294#32).sshiftRight xâœ.toNat)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:99:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:94:8: error: (kernel) declaration has metavariables 'lshr_exact_add_negative_shift_positive_thm'
[bv] [0.041113] Normalizing goal
  [Meta.synthInstance] [0.001907] âœ…ï¸ Decidable
        ((if xâœ + -1#32 â‰¥ â†‘32 then none else some (2#32 >>> (xâœ + -1#32))) âŠ‘
          if xâœ â‰¥ â†‘32 then none else some (4#32 >>> xâœ))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(if xâœ + -1#32 â‰¥ â†‘32 then none else some (2#32 >>> (xâœ + -1#32))) âŠ‘
            if xâœ â‰¥ â†‘32 then none else some (4#32 >>> xâœ)
      âŠ¢ False
  [Meta.isDefEq] [0.002073] âœ…ï¸ ?hâ‚ =?= Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
        (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (32#32) (xâœ + 4294967295#32))
          (Eq.trans
            (Eq.trans (congrArg Not (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (xâœ + 4294967295#32) 32#32))
              (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq (32#32 >áµ¤ xâœ + 4294967295#32) true))
            (congrArg (fun x => (!x) = true) (beq_true (32#32 >áµ¤ xâœ + 4294967295#32)))))
    [Meta.isDefEq.assign] [0.002068] âœ…ï¸ ?hâ‚ := Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
          (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (32#32) (xâœ + 4294967295#32))
            (Eq.trans
              (Eq.trans (congrArg Not (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (xâœ + 4294967295#32) 32#32))
                (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq (32#32 >áµ¤ xâœ + 4294967295#32) true))
              (congrArg (fun x => (!x) = true) (beq_true (32#32 >áµ¤ xâœ + 4294967295#32)))))
      [Meta.isDefEq.assign.checkTypes] [0.002050] âœ…ï¸ (?hâ‚ : (xâœ + -1#32 â‰¥ â†‘32) =
            ((!32#32 >áµ¤ xâœ + 4294967295#32) =
              true)) := (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (32#32) (xâœ + 4294967295#32))
              (Eq.trans
                (Eq.trans (congrArg Not (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (xâœ + 4294967295#32) 32#32))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq (32#32 >áµ¤ xâœ + 4294967295#32) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true
                    (32#32 >áµ¤
                      xâœ + 4294967295#32))))) : (xâœ + 4294967295#32 â‰¥ 32#32) = ((!32#32 >áµ¤ xâœ + 4294967295#32) = true))
        [Meta.isDefEq] [0.002045] âœ…ï¸ (xâœ + -1#32 â‰¥ â†‘32) =
              ((!32#32 >áµ¤ xâœ + 4294967295#32) =
                true) =?= (xâœ + 4294967295#32 â‰¥ 32#32) = ((!32#32 >áµ¤ xâœ + 4294967295#32) = true)
          [Meta.isDefEq] [0.002007] âœ…ï¸ xâœ + -1#32 â‰¥ â†‘32 =?= xâœ + 4294967295#32 â‰¥ 32#32
            [Meta.isDefEq.delta] [0.001984] âœ…ï¸ xâœ + -1#32 â‰¥ â†‘32 =?= xâœ + 4294967295#32 â‰¥ 32#32
              [Meta.isDefEq] [0.001842] âœ…ï¸ xâœ + -1#32 =?= xâœ + 4294967295#32
                [Meta.isDefEq] [0.001654] âœ…ï¸ instHAdd.1 xâœ (-1#32) =?= instHAdd.1 xâœ 4294967295#32
                  [Meta.isDefEq] [0.001582] âœ…ï¸ Add.add xâœ (-1#32) =?= Add.add xâœ 4294967295#32
                    [Meta.isDefEq] [0.001332] âœ…ï¸ BitVec.instAdd.1 xâœ (-1#32) =?= BitVec.instAdd.1 xâœ 4294967295#32
                      [Meta.isDefEq] [0.001250] âœ…ï¸ xâœ.add (-1#32) =?= xâœ.add 4294967295#32
                        [Meta.isDefEq.delta] [0.001233] âœ…ï¸ xâœ.add (-1#32) =?= xâœ.add 4294967295#32
                          [Meta.isDefEq] [0.001188] âœ…ï¸ -1#32 =?= 4294967295#32
                            [Meta.isDefEq] [0.001110] âœ…ï¸ -1#32 =?= { toFin := Fin.ofNat' (2 ^ 32) 4294967295 }
                              [Meta.isDefEq] [0.001088] âœ…ï¸ BitVec.instNeg.1
                                    1#32 =?= { toFin := Fin.ofNat' (2 ^ 32) 4294967295 }
                                [Meta.isDefEq] [0.001036] âœ…ï¸ (1#32).neg =?= { toFin := Fin.ofNat' (2 ^ 32) 4294967295 }
                                  [Meta.isDefEq] [0.001009] âœ…ï¸ BitVec.ofNat 32
                                        (2 ^ 32 - (1#32).toNat) =?= { toFin := Fin.ofNat' (2 ^ 32) 4294967295 }
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(if (!32#32 >áµ¤ xâœ + 4294967295#32) = true then none else some (2#32 >>> (xâœ + 4294967295#32))) âŠ‘
            if (!32#32 >áµ¤ xâœ) = true then none else some (4#32 >>> xâœ)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:108:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:103:8: error: (kernel) declaration has metavariables 'ashr_exact_add_negative_shift_negative_thm'
[bv] [0.032749] Normalizing goal
  [Meta.synthInstance] [0.001081] âœ…ï¸ Decidable
        ((if xâœ + -1#32 â‰¥ â†‘32 then none else some ((4294967294#32).sshiftRight (xâœ + -1#32).toNat)) âŠ‘
          if xâœ â‰¥ â†‘32 then none else some ((4294967292#32).sshiftRight xâœ.toNat))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(if xâœ + -1#32 â‰¥ â†‘32 then none else some ((4294967294#32).sshiftRight (xâœ + -1#32).toNat)) âŠ‘
            if xâœ â‰¥ â†‘32 then none else some ((4294967292#32).sshiftRight xâœ.toNat)
      âŠ¢ False
  [Meta.isDefEq] [0.001345] âœ…ï¸ ?hâ‚ =?= Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
        (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (32#32) (xâœ + 4294967295#32))
          (Eq.trans
            (Eq.trans (congrArg Not (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (xâœ + 4294967295#32) 32#32))
              (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq (32#32 >áµ¤ xâœ + 4294967295#32) true))
            (congrArg (fun x => (!x) = true) (beq_true (32#32 >áµ¤ xâœ + 4294967295#32)))))
    [Meta.isDefEq.assign] [0.001342] âœ…ï¸ ?hâ‚ := Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
          (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (32#32) (xâœ + 4294967295#32))
            (Eq.trans
              (Eq.trans (congrArg Not (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (xâœ + 4294967295#32) 32#32))
                (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq (32#32 >áµ¤ xâœ + 4294967295#32) true))
              (congrArg (fun x => (!x) = true) (beq_true (32#32 >áµ¤ xâœ + 4294967295#32)))))
      [Meta.isDefEq.assign.checkTypes] [0.001329] âœ…ï¸ (?hâ‚ : (xâœ + -1#32 â‰¥ â†‘32) =
            ((!32#32 >áµ¤ xâœ + 4294967295#32) =
              true)) := (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (32#32) (xâœ + 4294967295#32))
              (Eq.trans
                (Eq.trans (congrArg Not (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (xâœ + 4294967295#32) 32#32))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq (32#32 >áµ¤ xâœ + 4294967295#32) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true
                    (32#32 >áµ¤
                      xâœ + 4294967295#32))))) : (xâœ + 4294967295#32 â‰¥ 32#32) = ((!32#32 >áµ¤ xâœ + 4294967295#32) = true))
        [Meta.isDefEq] [0.001325] âœ…ï¸ (xâœ + -1#32 â‰¥ â†‘32) =
              ((!32#32 >áµ¤ xâœ + 4294967295#32) =
                true) =?= (xâœ + 4294967295#32 â‰¥ 32#32) = ((!32#32 >áµ¤ xâœ + 4294967295#32) = true)
          [Meta.isDefEq] [0.001298] âœ…ï¸ xâœ + -1#32 â‰¥ â†‘32 =?= xâœ + 4294967295#32 â‰¥ 32#32
            [Meta.isDefEq.delta] [0.001283] âœ…ï¸ xâœ + -1#32 â‰¥ â†‘32 =?= xâœ + 4294967295#32 â‰¥ 32#32
              [Meta.isDefEq] [0.001134] âœ…ï¸ xâœ + -1#32 =?= xâœ + 4294967295#32
  [Meta.isDefEq] [0.001013] âœ…ï¸ ?hâ‚ƒ =?= fun a => Eq.refl (some ((4294967294#32).sshiftRight (xâœ + 4294967295#32).toNat))
    [Meta.isDefEq.assign] [0.001007] âœ…ï¸ ?hâ‚ƒ := fun a =>
          Eq.refl (some ((4294967294#32).sshiftRight (xâœ + 4294967295#32).toNat))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(if (!32#32 >áµ¤ xâœ + 4294967295#32) = true then none
            else some ((4294967294#32).sshiftRight (xâœ + 4294967295#32).toNat)) âŠ‘
            if (!32#32 >áµ¤ xâœ) = true then none else some ((4294967292#32).sshiftRight xâœ.toNat)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:119:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:112:8: error: (kernel) declaration has metavariables 'shl_nsw_add_negative_thm'
[bv] [0.060832] Normalizing goal
  [Meta.synthInstance] [0.002250] âœ…ï¸ Decidable
        ((if True âˆ§ (2#32 <<< (xâœ + -1#32)).sshiftRight (xâœ + -1#32).toNat = 2#32 then none
          else if xâœ + -1#32 â‰¥ â†‘32 then none else some (2#32 <<< (xâœ + -1#32))) âŠ‘
          if True âˆ§ 1#32 <<< xâœ >>> xâœ = 1#32 then none else if xâœ â‰¥ â†‘32 then none else some (1#32 <<< xâœ))
    [Meta.check] [0.001273] âœ…ï¸ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if True âˆ§ (2#32 <<< (xâœ + -1#32)).sshiftRight (xâœ + -1#32).toNat = 2#32 then none
          else if xâœ + -1#32 â‰¥ â†‘32 then none else some (2#32 <<< (xâœ + -1#32)))
          (if True âˆ§ 1#32 <<< xâœ >>> xâœ = 1#32 then none else if xâœ â‰¥ â†‘32 then none else some (1#32 <<< xâœ))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(if True âˆ§ (2#32 <<< (xâœ + -1#32)).sshiftRight (xâœ + -1#32).toNat = 2#32 then none
            else if xâœ + -1#32 â‰¥ â†‘32 then none else some (2#32 <<< (xâœ + -1#32))) âŠ‘
            if True âˆ§ 1#32 <<< xâœ >>> xâœ = 1#32 then none else if xâœ â‰¥ â†‘32 then none else some (1#32 <<< xâœ)
      âŠ¢ False
  [Meta.isDefEq] [0.002019] âœ…ï¸ ?hâ‚ =?= Eq.trans
        (congrArg (And True)
          (Std.Tactic.BVDecide.Normalize.BitVec.eq_to_beq
            ((2#32 <<< (xâœ + 4294967295#32)).sshiftRight (xâœ + 4294967295#32).toNat) 2#32))
        (true_and (((2#32 <<< (xâœ + 4294967295#32)).sshiftRight (xâœ + 4294967295#32).toNat == 2#32) = true))
    [Meta.isDefEq.assign] [0.002015] âœ…ï¸ ?hâ‚ := Eq.trans
          (congrArg (And True)
            (Std.Tactic.BVDecide.Normalize.BitVec.eq_to_beq
              ((2#32 <<< (xâœ + 4294967295#32)).sshiftRight (xâœ + 4294967295#32).toNat) 2#32))
          (true_and (((2#32 <<< (xâœ + 4294967295#32)).sshiftRight (xâœ + 4294967295#32).toNat == 2#32) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001991] âœ…ï¸ (?hâ‚ : (True âˆ§
              (2#32 <<< (xâœ + -1#32)).sshiftRight (xâœ + -1#32).toNat = 2#32) =
            (((2#32 <<< (xâœ + 4294967295#32)).sshiftRight (xâœ + 4294967295#32).toNat == 2#32) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Std.Tactic.BVDecide.Normalize.BitVec.eq_to_beq
                ((2#32 <<< (xâœ + 4294967295#32)).sshiftRight (xâœ + 4294967295#32).toNat) 2#32))
            (true_and
              (((2#32 <<< (xâœ + 4294967295#32)).sshiftRight (xâœ + 4294967295#32).toNat == 2#32) =
                true)) : (True âˆ§ (2#32 <<< (xâœ + 4294967295#32)).sshiftRight (xâœ + 4294967295#32).toNat = 2#32) =
            (((2#32 <<< (xâœ + 4294967295#32)).sshiftRight (xâœ + 4294967295#32).toNat == 2#32) = true))
        [Meta.isDefEq] [0.001986] âœ…ï¸ (True âˆ§ (2#32 <<< (xâœ + -1#32)).sshiftRight (xâœ + -1#32).toNat = 2#32) =
              (((2#32 <<< (xâœ + 4294967295#32)).sshiftRight (xâœ + 4294967295#32).toNat == 2#32) =
                true) =?= (True âˆ§ (2#32 <<< (xâœ + 4294967295#32)).sshiftRight (xâœ + 4294967295#32).toNat = 2#32) =
              (((2#32 <<< (xâœ + 4294967295#32)).sshiftRight (xâœ + 4294967295#32).toNat == 2#32) = true)
          [Meta.isDefEq] [0.001953] âœ…ï¸ True âˆ§
                (2#32 <<< (xâœ + -1#32)).sshiftRight (xâœ + -1#32).toNat =
                  2#32 =?= True âˆ§ (2#32 <<< (xâœ + 4294967295#32)).sshiftRight (xâœ + 4294967295#32).toNat = 2#32
            [Meta.isDefEq] [0.001928] âœ…ï¸ (2#32 <<< (xâœ + -1#32)).sshiftRight (xâœ + -1#32).toNat =
                  2#32 =?= (2#32 <<< (xâœ + 4294967295#32)).sshiftRight (xâœ + 4294967295#32).toNat = 2#32
              [Meta.isDefEq] [0.001905] âœ…ï¸ (2#32 <<< (xâœ + -1#32)).sshiftRight
                    (xâœ + -1#32).toNat =?= (2#32 <<< (xâœ + 4294967295#32)).sshiftRight (xâœ + 4294967295#32).toNat
                [Meta.isDefEq.delta] [0.001887] âœ…ï¸ (2#32 <<< (xâœ + -1#32)).sshiftRight
                      (xâœ + -1#32).toNat =?= (2#32 <<< (xâœ + 4294967295#32)).sshiftRight (xâœ + 4294967295#32).toNat
                  [Meta.isDefEq] [0.001843] âœ…ï¸ 2#32 <<< (xâœ + -1#32) =?= 2#32 <<< (xâœ + 4294967295#32)
                    [Meta.isDefEq] [0.001805] âœ…ï¸ BitVec.instHShiftLeft.1 (2#32)
                          (xâœ + -1#32) =?= BitVec.instHShiftLeft.1 (2#32) (xâœ + 4294967295#32)
                      [Meta.isDefEq] [0.001712] âœ…ï¸ 2#32 <<< (xâœ + -1#32).toNat =?= 2#32 <<< (xâœ + 4294967295#32).toNat
                        [Meta.isDefEq] [0.001681] âœ…ï¸ BitVec.instHShiftLeftNat.1 (2#32)
                              (xâœ + -1#32).toNat =?= BitVec.instHShiftLeftNat.1 (2#32) (xâœ + 4294967295#32).toNat
                          [Meta.isDefEq] [0.001587] âœ…ï¸ (2#32).shiftLeft
                                (xâœ + -1#32).toNat =?= (2#32).shiftLeft (xâœ + 4294967295#32).toNat
                            [Meta.isDefEq.delta] [0.001568] âœ…ï¸ (2#32).shiftLeft
                                  (xâœ + -1#32).toNat =?= (2#32).shiftLeft (xâœ + 4294967295#32).toNat
                              [Meta.isDefEq] [0.001531] âœ…ï¸ (xâœ + -1#32).toNat =?= (xâœ + 4294967295#32).toNat
                                [Meta.isDefEq.delta] [0.001511] âœ…ï¸ (xâœ + -1#32).toNat =?= (xâœ + 4294967295#32).toNat
                                  [Meta.isDefEq] [0.001488] âœ…ï¸ xâœ + -1#32 =?= xâœ + 4294967295#32
                                    [Meta.isDefEq] [0.001287] âœ…ï¸ instHAdd.1 xâœ (-1#32) =?= instHAdd.1 xâœ 4294967295#32
                                      [Meta.isDefEq] [0.001226] âœ…ï¸ Add.add xâœ (-1#32) =?= Add.add xâœ 4294967295#32
                                        [Meta.isDefEq] [0.001024] âœ…ï¸ BitVec.instAdd.1 xâœ
                                              (-1#32) =?= BitVec.instAdd.1 xâœ 4294967295#32
  [Meta.isDefEq] [0.001142] âœ…ï¸ ?hâ‚ƒ =?= fun a => Eq.refl (some (2#32 <<< (xâœ + 4294967295#32)))
    [Meta.isDefEq.assign] [0.001137] âœ…ï¸ ?hâ‚ƒ := fun a => Eq.refl (some (2#32 <<< (xâœ + 4294967295#32)))
      [Meta.isDefEq.assign.checkTypes] [0.001069] âœ…ï¸ (?hâ‚ƒ : Â¬(!32#32 >áµ¤ xâœ + 4294967295#32) = true â†’
            some (2#32 <<< (xâœ + -1#32)) =
              some
                (2#32 <<<
                  (xâœ +
                    4294967295#32))) := (fun a =>
            Eq.refl
              (some
                (2#32 <<<
                  (xâœ +
                    4294967295#32))) : Â¬(!32#32 >áµ¤ xâœ + 4294967295#32) = true â†’
            some (2#32 <<< (xâœ + 4294967295#32)) = some (2#32 <<< (xâœ + 4294967295#32)))
        [Meta.isDefEq] [0.001064] âœ…ï¸ Â¬(!32#32 >áµ¤ xâœ + 4294967295#32) = true â†’
              some (2#32 <<< (xâœ + -1#32)) =
                some
                  (2#32 <<<
                    (xâœ +
                      4294967295#32)) =?= Â¬(!32#32 >áµ¤ xâœ + 4294967295#32) = true â†’
              some (2#32 <<< (xâœ + 4294967295#32)) = some (2#32 <<< (xâœ + 4294967295#32))
          [Meta.isDefEq] [0.001007] âœ…ï¸ some (2#32 <<< (xâœ + -1#32)) =
                some
                  (2#32 <<<
                    (xâœ +
                      4294967295#32)) =?= some (2#32 <<< (xâœ + 4294967295#32)) = some (2#32 <<< (xâœ + 4294967295#32))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(if ((2#32 <<< (xâœ + 4294967295#32)).sshiftRight (xâœ + 4294967295#32).toNat == 2#32) = true then none
            else if (!32#32 >áµ¤ xâœ + 4294967295#32) = true then none else some (2#32 <<< (xâœ + 4294967295#32))) âŠ‘
            if (1#32 <<< xâœ >>> xâœ == 1#32) = true then none
            else if (!32#32 >áµ¤ xâœ) = true then none else some (1#32 <<< xâœ)
      âŠ¢ False
  [Meta.isDefEq] [0.002572] âŒï¸ ?a == ?a =?= 1#32 <<< xâœ >>> xâœ == 1#32
    [Meta.isDefEq.onFailure] [0.002328] âŒï¸ ?a == ?a =?= 1#32 <<< xâœ >>> xâœ == 1#32
      [Meta.synthInstance] [0.002309] ğŸ’¥ï¸ BEq ?Î±
        [Meta.synthInstance] [0.002237] new goal BEq ?Î±
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:130:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:123:8: error: (kernel) declaration has metavariables 'shl_nsw_add_negative_invalid_constant3_thm'
[bv] [0.046918] Normalizing goal
  [Meta.synthInstance] [0.001301] âœ…ï¸ Decidable
        ((if True âˆ§ (2#4 <<< (xâœ + 8#4)).sshiftRight (xâœ + 8#4).toNat = 2#4 then none
          else if xâœ + 8#4 â‰¥ â†‘4 then none else some (2#4 <<< (xâœ + 8#4))) âŠ‘
          if True âˆ§ (2#4 <<< (xâœ ^^^ 8#4)).sshiftRight (xâœ ^^^ 8#4).toNat = 2#4 then none
          else if xâœ ^^^ 8#4 â‰¥ â†‘4 then none else some (2#4 <<< (xâœ ^^^ 8#4)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 4
      xâœ : BitVec 4
      aâœ :
        Â¬(if True âˆ§ (2#4 <<< (xâœ + 8#4)).sshiftRight (xâœ + 8#4).toNat = 2#4 then none
            else if xâœ + 8#4 â‰¥ â†‘4 then none else some (2#4 <<< (xâœ + 8#4))) âŠ‘
            if True âˆ§ (2#4 <<< (xâœ ^^^ 8#4)).sshiftRight (xâœ ^^^ 8#4).toNat = 2#4 then none
            else if xâœ ^^^ 8#4 â‰¥ â†‘4 then none else some (2#4 <<< (xâœ ^^^ 8#4))
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 4
      xâœ : BitVec 4
      aâœ :
        Â¬(if ((2#4 <<< (xâœ + 8#4)).sshiftRight (xâœ + 8#4).toNat == 2#4) = true then none
            else if (!4#4 >áµ¤ xâœ + 8#4) = true then none else some (2#4 <<< (xâœ + 8#4))) âŠ‘
            if ((2#4 <<< (xâœ ^^^ 8#4)).sshiftRight (xâœ ^^^ 8#4).toNat == 2#4) = true then none
            else if (!4#4 >áµ¤ xâœ ^^^ 8#4) = true then none else some (2#4 <<< (xâœ ^^^ 8#4))
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:140:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:134:8: error: (kernel) declaration has metavariables 'lshr_2_add_zext_basic_thm'
[bv] [0.011531] Normalizing goal
  [Meta.synthInstance] [0.001096] âœ…ï¸ Decidable
        ((if 1#2 â‰¥ â†‘2 then none else some ((BitVec.zeroExtend 2 xâœ + BitVec.zeroExtend 2 xâœÂ¹) >>> 1#2)) âŠ‘
          some (BitVec.zeroExtend 2 (xâœ &&& xâœÂ¹)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 1
      xâœÂ¹ xâœ : BitVec 1
      aâœ :
        Â¬(if 1#2 â‰¥ â†‘2 then none else some ((BitVec.zeroExtend 2 xâœ + BitVec.zeroExtend 2 xâœÂ¹) >>> 1#2)) âŠ‘
            some (BitVec.zeroExtend 2 (xâœ &&& xâœÂ¹))
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 1
      xâœÂ¹ xâœ : BitVec 1
      aâœ : Â¬some ((BitVec.zeroExtend 2 xâœ + BitVec.zeroExtend 2 xâœÂ¹) >>> 1) âŠ‘ some (BitVec.zeroExtend 2 (xâœ &&& xâœÂ¹))
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:151:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:144:8: error: (kernel) declaration has metavariables 'ashr_2_add_zext_basic_thm'
[bv] [0.018796] Normalizing goal
  [Meta.synthInstance] [0.001166] âœ…ï¸ Decidable
        ((if 1#2 â‰¥ â†‘2 then none
          else some ((BitVec.zeroExtend 2 xâœ + BitVec.zeroExtend 2 xâœÂ¹).sshiftRight (1#2).toNat)) âŠ‘
          if
              True âˆ§
                (BitVec.zeroExtend 2 xâœ + BitVec.zeroExtend 2 xâœÂ¹ < BitVec.zeroExtend 2 xâœ âˆ¨
                  BitVec.zeroExtend 2 xâœ + BitVec.zeroExtend 2 xâœÂ¹ < BitVec.zeroExtend 2 xâœÂ¹) then
            none
          else
            if 1#2 â‰¥ â†‘2 then none
            else some ((BitVec.zeroExtend 2 xâœ + BitVec.zeroExtend 2 xâœÂ¹).sshiftRight (1#2).toNat))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 1
      xâœÂ¹ xâœ : BitVec 1
      aâœ :
        Â¬(if 1#2 â‰¥ â†‘2 then none
            else some ((BitVec.zeroExtend 2 xâœ + BitVec.zeroExtend 2 xâœÂ¹).sshiftRight (1#2).toNat)) âŠ‘
            if
                True âˆ§
                  (BitVec.zeroExtend 2 xâœ + BitVec.zeroExtend 2 xâœÂ¹ < BitVec.zeroExtend 2 xâœ âˆ¨
                    BitVec.zeroExtend 2 xâœ + BitVec.zeroExtend 2 xâœÂ¹ < BitVec.zeroExtend 2 xâœÂ¹) then
              none
            else
              if 1#2 â‰¥ â†‘2 then none
              else some ((BitVec.zeroExtend 2 xâœ + BitVec.zeroExtend 2 xâœÂ¹).sshiftRight (1#2).toNat)
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 1
      xâœÂ¹ xâœ : BitVec 1
      aâœ :
        Â¬some ((BitVec.zeroExtend 2 xâœ + BitVec.zeroExtend 2 xâœÂ¹).sshiftRight 1) âŠ‘
            if
                (!((!BitVec.zeroExtend 2 xâœ >áµ¤ BitVec.zeroExtend 2 xâœ + BitVec.zeroExtend 2 xâœÂ¹) &&
                      !BitVec.zeroExtend 2 xâœÂ¹ >áµ¤ BitVec.zeroExtend 2 xâœ + BitVec.zeroExtend 2 xâœÂ¹)) =
                  true then
              none
            else some ((BitVec.zeroExtend 2 xâœ + BitVec.zeroExtend 2 xâœÂ¹).sshiftRight 1)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:162:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:155:8: error: (kernel) declaration has metavariables 'lshr_16_add_zext_basic_thm'
[bv] [0.018150] Normalizing goal
  [Meta.synthInstance] [0.001161] âœ…ï¸ Decidable
        ((if 16#32 â‰¥ â†‘32 then none else some ((BitVec.zeroExtend 32 xâœ + BitVec.zeroExtend 32 xâœÂ¹) >>> 16#32)) âŠ‘
          some (BitVec.zeroExtend 32 (BitVec.ofBool (xâœÂ¹ >áµ¤ xâœ ^^^ -1#16))))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 16
      xâœÂ¹ xâœ : BitVec 16
      aâœ :
        Â¬(if 16#32 â‰¥ â†‘32 then none else some ((BitVec.zeroExtend 32 xâœ + BitVec.zeroExtend 32 xâœÂ¹) >>> 16#32)) âŠ‘
            some (BitVec.zeroExtend 32 (BitVec.ofBool (xâœÂ¹ >áµ¤ xâœ ^^^ -1#16)))
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 16
      xâœÂ¹ xâœ : BitVec 16
      aâœ :
        Â¬some ((BitVec.zeroExtend 32 xâœ + BitVec.zeroExtend 32 xâœÂ¹) >>> 16) âŠ‘
            some (BitVec.zeroExtend 32 (if (xâœÂ¹ >áµ¤ xâœ ^^^ 65535#16) = true then 1#1 else 0#1))
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:174:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:166:8: error: (kernel) declaration has metavariables 'lshr_16_add_zext_basic_multiuse_thm'
[bv] [0.051310] Normalizing goal
  [Meta.synthInstance] [0.001778] âœ…ï¸ Decidable
        ((if 16#32 â‰¥ â†‘32 then none
          else some ((BitVec.zeroExtend 32 xâœ + BitVec.zeroExtend 32 xâœÂ¹) >>> 16#32 ||| BitVec.zeroExtend 32 xâœ)) âŠ‘
          if
              True âˆ§
                (BitVec.zeroExtend 32 xâœ).msb = (BitVec.zeroExtend 32 xâœÂ¹).msb âˆ§
                  (BitVec.zeroExtend 32 xâœ + BitVec.zeroExtend 32 xâœÂ¹).msb â‰  (BitVec.zeroExtend 32 xâœ).msb then
            none
          else
            if
                True âˆ§
                  (BitVec.zeroExtend 32 xâœ + BitVec.zeroExtend 32 xâœÂ¹ < BitVec.zeroExtend 32 xâœ âˆ¨
                    BitVec.zeroExtend 32 xâœ + BitVec.zeroExtend 32 xâœÂ¹ < BitVec.zeroExtend 32 xâœÂ¹) then
              none
            else
              if 16#32 â‰¥ â†‘32 then none
              else some ((BitVec.zeroExtend 32 xâœ + BitVec.zeroExtend 32 xâœÂ¹) >>> 16#32 ||| BitVec.zeroExtend 32 xâœ))
    [Meta.check] [0.001161] âœ…ï¸ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if 16#32 â‰¥ â†‘32 then none
          else some ((BitVec.zeroExtend 32 xâœ + BitVec.zeroExtend 32 xâœÂ¹) >>> 16#32 ||| BitVec.zeroExtend 32 xâœ))
          (if
              True âˆ§
                (BitVec.zeroExtend 32 xâœ).msb = (BitVec.zeroExtend 32 xâœÂ¹).msb âˆ§
                  (BitVec.zeroExtend 32 xâœ + BitVec.zeroExtend 32 xâœÂ¹).msb â‰  (BitVec.zeroExtend 32 xâœ).msb then
            none
          else
            if
                True âˆ§
                  (BitVec.zeroExtend 32 xâœ + BitVec.zeroExtend 32 xâœÂ¹ < BitVec.zeroExtend 32 xâœ âˆ¨
                    BitVec.zeroExtend 32 xâœ + BitVec.zeroExtend 32 xâœÂ¹ < BitVec.zeroExtend 32 xâœÂ¹) then
              none
            else
              if 16#32 â‰¥ â†‘32 then none
              else some ((BitVec.zeroExtend 32 xâœ + BitVec.zeroExtend 32 xâœÂ¹) >>> 16#32 ||| BitVec.zeroExtend 32 xâœ))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 16
      xâœÂ¹ xâœ : BitVec 16
      aâœ :
        Â¬(if 16#32 â‰¥ â†‘32 then none
            else some ((BitVec.zeroExtend 32 xâœ + BitVec.zeroExtend 32 xâœÂ¹) >>> 16#32 ||| BitVec.zeroExtend 32 xâœ)) âŠ‘
            if
                True âˆ§
                  (BitVec.zeroExtend 32 xâœ).msb = (BitVec.zeroExtend 32 xâœÂ¹).msb âˆ§
                    (BitVec.zeroExtend 32 xâœ + BitVec.zeroExtend 32 xâœÂ¹).msb â‰  (BitVec.zeroExtend 32 xâœ).msb then
              none
            else
              if
                  True âˆ§
                    (BitVec.zeroExtend 32 xâœ + BitVec.zeroExtend 32 xâœÂ¹ < BitVec.zeroExtend 32 xâœ âˆ¨
                      BitVec.zeroExtend 32 xâœ + BitVec.zeroExtend 32 xâœÂ¹ < BitVec.zeroExtend 32 xâœÂ¹) then
                none
              else
                if 16#32 â‰¥ â†‘32 then none
                else some ((BitVec.zeroExtend 32 xâœ + BitVec.zeroExtend 32 xâœÂ¹) >>> 16#32 ||| BitVec.zeroExtend 32 xâœ)
      âŠ¢ False
  [Meta.isDefEq] [0.001156] âŒï¸ ?a ==
        ?a =?= (BitVec.zeroExtend 32 xâœ + BitVec.zeroExtend 32 xâœÂ¹).getLsbD 31 == (BitVec.zeroExtend 32 xâœ).getLsbD 31
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 16
      xâœÂ¹ xâœ : BitVec 16
      aâœ :
        Â¬some ((BitVec.zeroExtend 32 xâœ + BitVec.zeroExtend 32 xâœÂ¹) >>> 16 ||| BitVec.zeroExtend 32 xâœ) âŠ‘
            if
                ((BitVec.zeroExtend 32 xâœ).getLsbD 31 == (BitVec.zeroExtend 32 xâœÂ¹).getLsbD 31 &&
                    !(BitVec.zeroExtend 32 xâœ + BitVec.zeroExtend 32 xâœÂ¹).getLsbD 31 ==
                        (BitVec.zeroExtend 32 xâœ).getLsbD 31) =
                  true then
              none
            else
              if
                  (!((!BitVec.zeroExtend 32 xâœ >áµ¤ BitVec.zeroExtend 32 xâœ + BitVec.zeroExtend 32 xâœÂ¹) &&
                        !BitVec.zeroExtend 32 xâœÂ¹ >áµ¤ BitVec.zeroExtend 32 xâœ + BitVec.zeroExtend 32 xâœÂ¹)) =
                    true then
                none
              else some ((BitVec.zeroExtend 32 xâœ + BitVec.zeroExtend 32 xâœÂ¹) >>> 16 ||| BitVec.zeroExtend 32 xâœ)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:186:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:178:8: error: (kernel) declaration has metavariables 'lshr_16_add_known_16_leading_zeroes_thm'
[bv] [0.034574] Normalizing goal
  [Meta.synthInstance] [0.001818] âœ…ï¸ Decidable
        ((if 16#32 â‰¥ â†‘32 then none else some (((xâœ &&& 65535#32) + (xâœÂ¹ &&& 65535#32)) >>> 16#32)) âŠ‘
          if
              True âˆ§
                (xâœ &&& 65535#32).msb = (xâœÂ¹ &&& 65535#32).msb âˆ§
                  ((xâœ &&& 65535#32) + (xâœÂ¹ &&& 65535#32)).msb â‰  (xâœ &&& 65535#32).msb then
            none
          else
            if
                True âˆ§
                  ((xâœ &&& 65535#32) + (xâœÂ¹ &&& 65535#32) < xâœ &&& 65535#32 âˆ¨
                    (xâœ &&& 65535#32) + (xâœÂ¹ &&& 65535#32) < xâœÂ¹ &&& 65535#32) then
              none
            else if 16#32 â‰¥ â†‘32 then none else some (((xâœ &&& 65535#32) + (xâœÂ¹ &&& 65535#32)) >>> 16#32))
    [Meta.check] [0.001073] âœ…ï¸ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if 16#32 â‰¥ â†‘32 then none else some (((xâœ &&& 65535#32) + (xâœÂ¹ &&& 65535#32)) >>> 16#32))
          (if
              True âˆ§
                (xâœ &&& 65535#32).msb = (xâœÂ¹ &&& 65535#32).msb âˆ§
                  ((xâœ &&& 65535#32) + (xâœÂ¹ &&& 65535#32)).msb â‰  (xâœ &&& 65535#32).msb then
            none
          else
            if
                True âˆ§
                  ((xâœ &&& 65535#32) + (xâœÂ¹ &&& 65535#32) < xâœ &&& 65535#32 âˆ¨
                    (xâœ &&& 65535#32) + (xâœÂ¹ &&& 65535#32) < xâœÂ¹ &&& 65535#32) then
              none
            else if 16#32 â‰¥ â†‘32 then none else some (((xâœ &&& 65535#32) + (xâœÂ¹ &&& 65535#32)) >>> 16#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      xâœÂ¹ xâœ : BitVec 32
      aâœ :
        Â¬(if 16#32 â‰¥ â†‘32 then none else some (((xâœ &&& 65535#32) + (xâœÂ¹ &&& 65535#32)) >>> 16#32)) âŠ‘
            if
                True âˆ§
                  (xâœ &&& 65535#32).msb = (xâœÂ¹ &&& 65535#32).msb âˆ§
                    ((xâœ &&& 65535#32) + (xâœÂ¹ &&& 65535#32)).msb â‰  (xâœ &&& 65535#32).msb then
              none
            else
              if
                  True âˆ§
                    ((xâœ &&& 65535#32) + (xâœÂ¹ &&& 65535#32) < xâœ &&& 65535#32 âˆ¨
                      (xâœ &&& 65535#32) + (xâœÂ¹ &&& 65535#32) < xâœÂ¹ &&& 65535#32) then
                none
              else if 16#32 â‰¥ â†‘32 then none else some (((xâœ &&& 65535#32) + (xâœÂ¹ &&& 65535#32)) >>> 16#32)
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      xâœÂ¹ xâœ : BitVec 32
      aâœ :
        Â¬some (((xâœ &&& 65535#32) + (xâœÂ¹ &&& 65535#32)) >>> 16) âŠ‘
            if
                ((xâœ &&& 65535#32).getLsbD 31 == (xâœÂ¹ &&& 65535#32).getLsbD 31 &&
                    !((xâœ &&& 65535#32) + (xâœÂ¹ &&& 65535#32)).getLsbD 31 == (xâœ &&& 65535#32).getLsbD 31) =
                  true then
              none
            else
              if
                  (!((!xâœ &&& 65535#32 >áµ¤ (xâœ &&& 65535#32) + (xâœÂ¹ &&& 65535#32)) &&
                        !xâœÂ¹ &&& 65535#32 >áµ¤ (xâœ &&& 65535#32) + (xâœÂ¹ &&& 65535#32))) =
                    true then
                none
              else some (((xâœ &&& 65535#32) + (xâœÂ¹ &&& 65535#32)) >>> 16)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:198:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:190:8: error: (kernel) declaration has metavariables 'lshr_16_add_not_known_16_leading_zeroes_thm'
[bv] [0.034015] Normalizing goal
  [Meta.synthInstance] [0.001467] âœ…ï¸ Decidable
        ((if 16#32 â‰¥ â†‘32 then none else some (((xâœ &&& 131071#32) + (xâœÂ¹ &&& 65535#32)) >>> 16#32)) âŠ‘
          if
              True âˆ§
                (xâœ &&& 131071#32).msb = (xâœÂ¹ &&& 65535#32).msb âˆ§
                  ((xâœ &&& 131071#32) + (xâœÂ¹ &&& 65535#32)).msb â‰  (xâœ &&& 131071#32).msb then
            none
          else
            if
                True âˆ§
                  ((xâœ &&& 131071#32) + (xâœÂ¹ &&& 65535#32) < xâœ &&& 131071#32 âˆ¨
                    (xâœ &&& 131071#32) + (xâœÂ¹ &&& 65535#32) < xâœÂ¹ &&& 65535#32) then
              none
            else if 16#32 â‰¥ â†‘32 then none else some (((xâœ &&& 131071#32) + (xâœÂ¹ &&& 65535#32)) >>> 16#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      xâœÂ¹ xâœ : BitVec 32
      aâœ :
        Â¬(if 16#32 â‰¥ â†‘32 then none else some (((xâœ &&& 131071#32) + (xâœÂ¹ &&& 65535#32)) >>> 16#32)) âŠ‘
            if
                True âˆ§
                  (xâœ &&& 131071#32).msb = (xâœÂ¹ &&& 65535#32).msb âˆ§
                    ((xâœ &&& 131071#32) + (xâœÂ¹ &&& 65535#32)).msb â‰  (xâœ &&& 131071#32).msb then
              none
            else
              if
                  True âˆ§
                    ((xâœ &&& 131071#32) + (xâœÂ¹ &&& 65535#32) < xâœ &&& 131071#32 âˆ¨
                      (xâœ &&& 131071#32) + (xâœÂ¹ &&& 65535#32) < xâœÂ¹ &&& 65535#32) then
                none
              else if 16#32 â‰¥ â†‘32 then none else some (((xâœ &&& 131071#32) + (xâœÂ¹ &&& 65535#32)) >>> 16#32)
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      xâœÂ¹ xâœ : BitVec 32
      aâœ :
        Â¬some (((xâœ &&& 131071#32) + (xâœÂ¹ &&& 65535#32)) >>> 16) âŠ‘
            if
                ((xâœ &&& 131071#32).getLsbD 31 == (xâœÂ¹ &&& 65535#32).getLsbD 31 &&
                    !((xâœ &&& 131071#32) + (xâœÂ¹ &&& 65535#32)).getLsbD 31 == (xâœ &&& 131071#32).getLsbD 31) =
                  true then
              none
            else
              if
                  (!((!xâœ &&& 131071#32 >áµ¤ (xâœ &&& 131071#32) + (xâœÂ¹ &&& 65535#32)) &&
                        !xâœÂ¹ &&& 65535#32 >áµ¤ (xâœ &&& 131071#32) + (xâœÂ¹ &&& 65535#32))) =
                    true then
                none
              else some (((xâœ &&& 131071#32) + (xâœÂ¹ &&& 65535#32)) >>> 16)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:209:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:202:8: error: (kernel) declaration has metavariables 'lshr_32_add_zext_basic_thm'
[bv] [0.018491] Normalizing goal
  [Meta.synthInstance] [0.001192] âœ…ï¸ Decidable
        ((if 32#64 â‰¥ â†‘64 then none else some ((BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹) >>> 32#64)) âŠ‘
          some (BitVec.zeroExtend 64 (BitVec.ofBool (xâœÂ¹ >áµ¤ xâœ ^^^ -1#32))))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      xâœÂ¹ xâœ : BitVec 32
      aâœ :
        Â¬(if 32#64 â‰¥ â†‘64 then none else some ((BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹) >>> 32#64)) âŠ‘
            some (BitVec.zeroExtend 64 (BitVec.ofBool (xâœÂ¹ >áµ¤ xâœ ^^^ -1#32)))
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      xâœÂ¹ xâœ : BitVec 32
      aâœ :
        Â¬some ((BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹) >>> 32) âŠ‘
            some (BitVec.zeroExtend 64 (if (xâœÂ¹ >áµ¤ xâœ ^^^ 4294967295#32) = true then 1#1 else 0#1))
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:220:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:213:8: error: (kernel) declaration has metavariables 'lshr_32_add_zext_basic_multiuse_thm'
[bv] [0.034818] Normalizing goal
  [Meta.synthInstance] [0.001424] âœ…ï¸ Decidable
        ((if 32#64 â‰¥ â†‘64 then none
          else some ((BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹) >>> 32#64 ||| BitVec.zeroExtend 64 xâœÂ¹)) âŠ‘
          if
              True âˆ§
                (BitVec.zeroExtend 64 xâœ).msb = (BitVec.zeroExtend 64 xâœÂ¹).msb âˆ§
                  (BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹).msb â‰  (BitVec.zeroExtend 64 xâœ).msb then
            none
          else
            if
                True âˆ§
                  (BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹ < BitVec.zeroExtend 64 xâœ âˆ¨
                    BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹ < BitVec.zeroExtend 64 xâœÂ¹) then
              none
            else
              if 32#64 â‰¥ â†‘64 then none
              else some ((BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹) >>> 32#64 ||| BitVec.zeroExtend 64 xâœÂ¹))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      xâœÂ¹ xâœ : BitVec 32
      aâœ :
        Â¬(if 32#64 â‰¥ â†‘64 then none
            else some ((BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹) >>> 32#64 ||| BitVec.zeroExtend 64 xâœÂ¹)) âŠ‘
            if
                True âˆ§
                  (BitVec.zeroExtend 64 xâœ).msb = (BitVec.zeroExtend 64 xâœÂ¹).msb âˆ§
                    (BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹).msb â‰  (BitVec.zeroExtend 64 xâœ).msb then
              none
            else
              if
                  True âˆ§
                    (BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹ < BitVec.zeroExtend 64 xâœ âˆ¨
                      BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹ < BitVec.zeroExtend 64 xâœÂ¹) then
                none
              else
                if 32#64 â‰¥ â†‘64 then none
                else some ((BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹) >>> 32#64 ||| BitVec.zeroExtend 64 xâœÂ¹)
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      xâœÂ¹ xâœ : BitVec 32
      aâœ :
        Â¬some ((BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹) >>> 32 ||| BitVec.zeroExtend 64 xâœÂ¹) âŠ‘
            if
                ((BitVec.zeroExtend 64 xâœ).getLsbD 63 == (BitVec.zeroExtend 64 xâœÂ¹).getLsbD 63 &&
                    !(BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹).getLsbD 63 ==
                        (BitVec.zeroExtend 64 xâœ).getLsbD 63) =
                  true then
              none
            else
              if
                  (!((!BitVec.zeroExtend 64 xâœ >áµ¤ BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹) &&
                        !BitVec.zeroExtend 64 xâœÂ¹ >áµ¤ BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹)) =
                    true then
                none
              else some ((BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹) >>> 32 ||| BitVec.zeroExtend 64 xâœÂ¹)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:231:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:224:8: error: (kernel) declaration has metavariables 'lshr_31_i32_add_zext_basic_thm'
[bv] [0.034865] Normalizing goal
  [Meta.synthInstance] [0.001625] âœ…ï¸ Decidable
        ((if 31#64 â‰¥ â†‘64 then none else some ((BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹) >>> 31#64)) âŠ‘
          if
              True âˆ§
                (BitVec.zeroExtend 64 xâœ).msb = (BitVec.zeroExtend 64 xâœÂ¹).msb âˆ§
                  (BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹).msb â‰  (BitVec.zeroExtend 64 xâœ).msb then
            none
          else
            if
                True âˆ§
                  (BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹ < BitVec.zeroExtend 64 xâœ âˆ¨
                    BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹ < BitVec.zeroExtend 64 xâœÂ¹) then
              none
            else if 31#64 â‰¥ â†‘64 then none else some ((BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹) >>> 31#64))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      xâœÂ¹ xâœ : BitVec 32
      aâœ :
        Â¬(if 31#64 â‰¥ â†‘64 then none else some ((BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹) >>> 31#64)) âŠ‘
            if
                True âˆ§
                  (BitVec.zeroExtend 64 xâœ).msb = (BitVec.zeroExtend 64 xâœÂ¹).msb âˆ§
                    (BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹).msb â‰  (BitVec.zeroExtend 64 xâœ).msb then
              none
            else
              if
                  True âˆ§
                    (BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹ < BitVec.zeroExtend 64 xâœ âˆ¨
                      BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹ < BitVec.zeroExtend 64 xâœÂ¹) then
                none
              else if 31#64 â‰¥ â†‘64 then none else some ((BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹) >>> 31#64)
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      xâœÂ¹ xâœ : BitVec 32
      aâœ :
        Â¬some ((BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹) >>> 31) âŠ‘
            if
                ((BitVec.zeroExtend 64 xâœ).getLsbD 63 == (BitVec.zeroExtend 64 xâœÂ¹).getLsbD 63 &&
                    !(BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹).getLsbD 63 ==
                        (BitVec.zeroExtend 64 xâœ).getLsbD 63) =
                  true then
              none
            else
              if
                  (!((!BitVec.zeroExtend 64 xâœ >áµ¤ BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹) &&
                        !BitVec.zeroExtend 64 xâœÂ¹ >áµ¤ BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹)) =
                    true then
                none
              else some ((BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹) >>> 31)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:240:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:235:8: error: (kernel) declaration has metavariables 'lshr_33_i32_add_zext_basic_thm'
[bv] [0.010138] Normalizing goal
  [Meta.synthInstance] [0.001215] âœ…ï¸ Decidable
        ((if 33#64 â‰¥ â†‘64 then none else some ((BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹) >>> 33#64)) âŠ‘
          some 0#64)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      xâœÂ¹ xâœ : BitVec 32
      aâœ :
        Â¬(if 33#64 â‰¥ â†‘64 then none else some ((BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹) >>> 33#64)) âŠ‘
            some 0#64
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      xâœÂ¹ xâœ : BitVec 32
      aâœ : Â¬some ((BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹) >>> 33) âŠ‘ some 0#64
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:251:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:244:8: error: (kernel) declaration has metavariables 'lshr_16_to_64_add_zext_basic_thm'
[bv] [0.018872] Normalizing goal
  [Meta.synthInstance] [0.001191] âœ…ï¸ Decidable
        ((if 16#64 â‰¥ â†‘64 then none else some ((BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹) >>> 16#64)) âŠ‘
          some (BitVec.zeroExtend 64 (BitVec.ofBool (xâœÂ¹ >áµ¤ xâœ ^^^ -1#16))))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 16
      xâœÂ¹ xâœ : BitVec 16
      aâœ :
        Â¬(if 16#64 â‰¥ â†‘64 then none else some ((BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹) >>> 16#64)) âŠ‘
            some (BitVec.zeroExtend 64 (BitVec.ofBool (xâœÂ¹ >áµ¤ xâœ ^^^ -1#16)))
      âŠ¢ False
  [Meta.appBuilder] [0.001003] âœ…ï¸ f: Eq.mp, xs: [congrArg Not
         (congr
           (congrArg BitVec.Refinement
             (ite_cond_eq_false none (some ((BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹) >>> 16#64))
               (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                 (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 64#64 16#64)
                   (Eq.trans
                     (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 16#64 64#64) (eq_self true)))
                     Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))))
           (congrArg (fun x => some (BitVec.zeroExtend 64 x))
             (Std.Tactic.BVDecide.Normalize.BitVec.ofBool_eq_if (xâœÂ¹ >áµ¤ xâœ ^^^ 65535#16)))),
       aâœ]
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 16
      xâœÂ¹ xâœ : BitVec 16
      aâœ :
        Â¬some ((BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹) >>> 16) âŠ‘
            some (BitVec.zeroExtend 64 (if (xâœÂ¹ >áµ¤ xâœ ^^^ 65535#16) = true then 1#1 else 0#1))
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:264:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:255:8: error: (kernel) declaration has metavariables 'lshr_32_add_known_32_leading_zeroes_thm'
[bv] [0.036005] Normalizing goal
  [Meta.synthInstance] [0.001582] âœ…ï¸ Decidable
        ((if 32#64 â‰¥ â†‘64 then none else some (((xâœ &&& 4294967295#64) + (xâœÂ¹ &&& 4294967295#64)) >>> 32#64)) âŠ‘
          if
              True âˆ§
                (xâœ &&& 4294967295#64).msb = (xâœÂ¹ &&& 4294967295#64).msb âˆ§
                  ((xâœ &&& 4294967295#64) + (xâœÂ¹ &&& 4294967295#64)).msb â‰  (xâœ &&& 4294967295#64).msb then
            none
          else
            if
                True âˆ§
                  ((xâœ &&& 4294967295#64) + (xâœÂ¹ &&& 4294967295#64) < xâœ &&& 4294967295#64 âˆ¨
                    (xâœ &&& 4294967295#64) + (xâœÂ¹ &&& 4294967295#64) < xâœÂ¹ &&& 4294967295#64) then
              none
            else if 32#64 â‰¥ â†‘64 then none else some (((xâœ &&& 4294967295#64) + (xâœÂ¹ &&& 4294967295#64)) >>> 32#64))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 64
      xâœÂ¹ xâœ : BitVec 64
      aâœ :
        Â¬(if 32#64 â‰¥ â†‘64 then none else some (((xâœ &&& 4294967295#64) + (xâœÂ¹ &&& 4294967295#64)) >>> 32#64)) âŠ‘
            if
                True âˆ§
                  (xâœ &&& 4294967295#64).msb = (xâœÂ¹ &&& 4294967295#64).msb âˆ§
                    ((xâœ &&& 4294967295#64) + (xâœÂ¹ &&& 4294967295#64)).msb â‰  (xâœ &&& 4294967295#64).msb then
              none
            else
              if
                  True âˆ§
                    ((xâœ &&& 4294967295#64) + (xâœÂ¹ &&& 4294967295#64) < xâœ &&& 4294967295#64 âˆ¨
                      (xâœ &&& 4294967295#64) + (xâœÂ¹ &&& 4294967295#64) < xâœÂ¹ &&& 4294967295#64) then
                none
              else if 32#64 â‰¥ â†‘64 then none else some (((xâœ &&& 4294967295#64) + (xâœÂ¹ &&& 4294967295#64)) >>> 32#64)
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 64
      xâœÂ¹ xâœ : BitVec 64
      aâœ :
        Â¬some (((xâœ &&& 4294967295#64) + (xâœÂ¹ &&& 4294967295#64)) >>> 32) âŠ‘
            if
                ((xâœ &&& 4294967295#64).getLsbD 63 == (xâœÂ¹ &&& 4294967295#64).getLsbD 63 &&
                    !((xâœ &&& 4294967295#64) + (xâœÂ¹ &&& 4294967295#64)).getLsbD 63 ==
                        (xâœ &&& 4294967295#64).getLsbD 63) =
                  true then
              none
            else
              if
                  (!((!xâœ &&& 4294967295#64 >áµ¤ (xâœ &&& 4294967295#64) + (xâœÂ¹ &&& 4294967295#64)) &&
                        !xâœÂ¹ &&& 4294967295#64 >áµ¤ (xâœ &&& 4294967295#64) + (xâœÂ¹ &&& 4294967295#64))) =
                    true then
                none
              else some (((xâœ &&& 4294967295#64) + (xâœÂ¹ &&& 4294967295#64)) >>> 32)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:277:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:268:8: error: (kernel) declaration has metavariables 'lshr_32_add_not_known_32_leading_zeroes_thm'
[bv] [0.034320] Normalizing goal
  [Meta.synthInstance] [0.001511] âœ…ï¸ Decidable
        ((if 32#64 â‰¥ â†‘64 then none else some (((xâœ &&& 8589934591#64) + (xâœÂ¹ &&& 4294967295#64)) >>> 32#64)) âŠ‘
          if
              True âˆ§
                (xâœ &&& 8589934591#64).msb = (xâœÂ¹ &&& 4294967295#64).msb âˆ§
                  ((xâœ &&& 8589934591#64) + (xâœÂ¹ &&& 4294967295#64)).msb â‰  (xâœ &&& 8589934591#64).msb then
            none
          else
            if
                True âˆ§
                  ((xâœ &&& 8589934591#64) + (xâœÂ¹ &&& 4294967295#64) < xâœ &&& 8589934591#64 âˆ¨
                    (xâœ &&& 8589934591#64) + (xâœÂ¹ &&& 4294967295#64) < xâœÂ¹ &&& 4294967295#64) then
              none
            else if 32#64 â‰¥ â†‘64 then none else some (((xâœ &&& 8589934591#64) + (xâœÂ¹ &&& 4294967295#64)) >>> 32#64))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 64
      xâœÂ¹ xâœ : BitVec 64
      aâœ :
        Â¬(if 32#64 â‰¥ â†‘64 then none else some (((xâœ &&& 8589934591#64) + (xâœÂ¹ &&& 4294967295#64)) >>> 32#64)) âŠ‘
            if
                True âˆ§
                  (xâœ &&& 8589934591#64).msb = (xâœÂ¹ &&& 4294967295#64).msb âˆ§
                    ((xâœ &&& 8589934591#64) + (xâœÂ¹ &&& 4294967295#64)).msb â‰  (xâœ &&& 8589934591#64).msb then
              none
            else
              if
                  True âˆ§
                    ((xâœ &&& 8589934591#64) + (xâœÂ¹ &&& 4294967295#64) < xâœ &&& 8589934591#64 âˆ¨
                      (xâœ &&& 8589934591#64) + (xâœÂ¹ &&& 4294967295#64) < xâœÂ¹ &&& 4294967295#64) then
                none
              else if 32#64 â‰¥ â†‘64 then none else some (((xâœ &&& 8589934591#64) + (xâœÂ¹ &&& 4294967295#64)) >>> 32#64)
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 64
      xâœÂ¹ xâœ : BitVec 64
      aâœ :
        Â¬some (((xâœ &&& 8589934591#64) + (xâœÂ¹ &&& 4294967295#64)) >>> 32) âŠ‘
            if
                ((xâœ &&& 8589934591#64).getLsbD 63 == (xâœÂ¹ &&& 4294967295#64).getLsbD 63 &&
                    !((xâœ &&& 8589934591#64) + (xâœÂ¹ &&& 4294967295#64)).getLsbD 63 ==
                        (xâœ &&& 8589934591#64).getLsbD 63) =
                  true then
              none
            else
              if
                  (!((!xâœ &&& 8589934591#64 >áµ¤ (xâœ &&& 8589934591#64) + (xâœÂ¹ &&& 4294967295#64)) &&
                        !xâœÂ¹ &&& 4294967295#64 >áµ¤ (xâœ &&& 8589934591#64) + (xâœÂ¹ &&& 4294967295#64))) =
                    true then
                none
              else some (((xâœ &&& 8589934591#64) + (xâœÂ¹ &&& 4294967295#64)) >>> 32)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:288:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:281:8: error: (kernel) declaration has metavariables 'ashr_16_add_zext_basic_thm'
[bv] [0.017802] Normalizing goal
  [Meta.synthInstance] [0.001153] âœ…ï¸ Decidable
        ((if 16#32 â‰¥ â†‘32 then none else some ((BitVec.zeroExtend 32 xâœ + BitVec.zeroExtend 32 xâœÂ¹) >>> 16#32)) âŠ‘
          some (BitVec.zeroExtend 32 (BitVec.ofBool (xâœÂ¹ >áµ¤ xâœ ^^^ -1#16))))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 16
      xâœÂ¹ xâœ : BitVec 16
      aâœ :
        Â¬(if 16#32 â‰¥ â†‘32 then none else some ((BitVec.zeroExtend 32 xâœ + BitVec.zeroExtend 32 xâœÂ¹) >>> 16#32)) âŠ‘
            some (BitVec.zeroExtend 32 (BitVec.ofBool (xâœÂ¹ >áµ¤ xâœ ^^^ -1#16)))
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 16
      xâœÂ¹ xâœ : BitVec 16
      aâœ :
        Â¬some ((BitVec.zeroExtend 32 xâœ + BitVec.zeroExtend 32 xâœÂ¹) >>> 16) âŠ‘
            some (BitVec.zeroExtend 32 (if (xâœÂ¹ >áµ¤ xâœ ^^^ 65535#16) = true then 1#1 else 0#1))
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:299:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:292:8: error: (kernel) declaration has metavariables 'ashr_32_add_zext_basic_thm'
[bv] [0.016672] Normalizing goal
  [Meta.synthInstance] [0.001130] âœ…ï¸ Decidable
        ((if 32#64 â‰¥ â†‘64 then none
          else some ((BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹).sshiftRight (32#64).toNat)) âŠ‘
          some (BitVec.zeroExtend 64 (BitVec.ofBool (xâœÂ¹ >áµ¤ xâœ ^^^ -1#32))))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      xâœÂ¹ xâœ : BitVec 32
      aâœ :
        Â¬(if 32#64 â‰¥ â†‘64 then none
            else some ((BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹).sshiftRight (32#64).toNat)) âŠ‘
            some (BitVec.zeroExtend 64 (BitVec.ofBool (xâœÂ¹ >áµ¤ xâœ ^^^ -1#32)))
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      xâœÂ¹ xâœ : BitVec 32
      aâœ :
        Â¬some ((BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹).sshiftRight 32) âŠ‘
            some (BitVec.zeroExtend 64 (if (xâœÂ¹ >áµ¤ xâœ ^^^ 4294967295#32) = true then 1#1 else 0#1))
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:310:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:303:8: error: (kernel) declaration has metavariables 'ashr_16_to_64_add_zext_basic_thm'
[bv] [0.016718] Normalizing goal
  [Meta.synthInstance] [0.001132] âœ…ï¸ Decidable
        ((if 16#64 â‰¥ â†‘64 then none
          else some ((BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹).sshiftRight (16#64).toNat)) âŠ‘
          some (BitVec.zeroExtend 64 (BitVec.ofBool (xâœÂ¹ >áµ¤ xâœ ^^^ -1#16))))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 16
      xâœÂ¹ xâœ : BitVec 16
      aâœ :
        Â¬(if 16#64 â‰¥ â†‘64 then none
            else some ((BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹).sshiftRight (16#64).toNat)) âŠ‘
            some (BitVec.zeroExtend 64 (BitVec.ofBool (xâœÂ¹ >áµ¤ xâœ ^^^ -1#16)))
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 16
      xâœÂ¹ xâœ : BitVec 16
      aâœ :
        Â¬some ((BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹).sshiftRight 16) âŠ‘
            some (BitVec.zeroExtend 64 (if (xâœÂ¹ >áµ¤ xâœ ^^^ 65535#16) = true then 1#1 else 0#1))
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:321:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:314:8: error: (kernel) declaration has metavariables 'lshr_32_add_zext_trunc_thm'
[bv] [0.022233] Normalizing goal
  [Meta.synthInstance] [0.001126] âœ…ï¸ Decidable
        ((if 32#64 â‰¥ â†‘64 then none
          else
            some
              (BitVec.truncate 32 (BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹) +
                BitVec.truncate 32 ((BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹) >>> 32#64))) âŠ‘
          some (xâœ + xâœÂ¹ + BitVec.zeroExtend 32 (BitVec.ofBool (xâœ >áµ¤ xâœ + xâœÂ¹))))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      xâœÂ¹ xâœ : BitVec 32
      aâœ :
        Â¬(if 32#64 â‰¥ â†‘64 then none
            else
              some
                (BitVec.truncate 32 (BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹) +
                  BitVec.truncate 32 ((BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹) >>> 32#64))) âŠ‘
            some (xâœ + xâœÂ¹ + BitVec.zeroExtend 32 (BitVec.ofBool (xâœ >áµ¤ xâœ + xâœÂ¹)))
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      xâœÂ¹ xâœ : BitVec 32
      aâœ :
        Â¬some
              (BitVec.zeroExtend 32 (BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹) +
                BitVec.zeroExtend 32 ((BitVec.zeroExtend 64 xâœ + BitVec.zeroExtend 64 xâœÂ¹) >>> 32)) âŠ‘
            some (xâœ + xâœÂ¹ + BitVec.zeroExtend 32 (if (xâœ >áµ¤ xâœ + xâœÂ¹) = true then 1#1 else 0#1))
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:330:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthadd_proof.lean:325:8: error: (kernel) declaration has metavariables 'shl_fold_or_disjoint_cnt_thm'
[bv] [0.022371] Normalizing goal
  [Meta.synthInstance] [0.001137] âœ…ï¸ Decidable
        ((if xâœ ||| 3#8 â‰¥ â†‘8 then none else some (2#8 <<< (xâœ ||| 3#8))) âŠ‘ if xâœ â‰¥ â†‘8 then none else some (16#8 <<< xâœ))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      xâœ : BitVec 8
      aâœ :
        Â¬(if xâœ ||| 3#8 â‰¥ â†‘8 then none else some (2#8 <<< (xâœ ||| 3#8))) âŠ‘ if xâœ â‰¥ â†‘8 then none else some (16#8 <<< xâœ)
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      xâœ : BitVec 8
      aâœ :
        Â¬(if (!8#8 >áµ¤ xâœ ||| 3#8) = true then none else some (2#8 <<< (xâœ ||| 3#8))) âŠ‘
            if (!8#8 >áµ¤ xâœ) = true then none else some (16#8 <<< xâœ)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
