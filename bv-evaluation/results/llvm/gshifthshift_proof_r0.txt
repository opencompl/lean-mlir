⚠ [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
⚠ [878/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [881/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
⚠ [887/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
⚠ [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthshift_proof.lean:16:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthshift_proof.lean:11:8: error: (kernel) declaration has metavariables 'shl_shl_thm'
[bv] [0.034659] Normalizing goal
  [Meta.synthInstance] [0.001132] ✅️ Decidable
        ((if 6#32 ≥ ↑32 then none else if 28#32 ≥ ↑32 then none else some (x✝ <<< 6#32 <<< 28#32)) ⊑ some 0#32)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ : ¬(if 6#32 ≥ ↑32 then none else if 28#32 ≥ ↑32 then none else some (x✝ <<< 6#32 <<< 28#32)) ⊑ some 0#32
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ : ¬some (x✝ <<< 6 <<< 28) ⊑ some 0#32
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthshift_proof.lean:25:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthshift_proof.lean:20:8: error: (kernel) declaration has metavariables 'lshr_lshr_thm'
[bv] [0.011797] Normalizing goal
  [Meta.synthInstance] [0.001222] ✅️ Decidable
        ((if 231#232 ≥ ↑232 then none else if 1#232 ≥ ↑232 then none else some (x✝ >>> 231#232 >>> 1#232)) ⊑ some 0#232)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 232
      x✝ : BitVec 232
      a✝ :
        ¬(if 231#232 ≥ ↑232 then none else if 1#232 ≥ ↑232 then none else some (x✝ >>> 231#232 >>> 1#232)) ⊑ some 0#232
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 232
      x✝ : BitVec 232
      a✝ : ¬some (x✝ >>> 231 >>> 1) ⊑ some 0#232
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthshift_proof.lean:35:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthshift_proof.lean:29:8: error: (kernel) declaration has metavariables 'shl_trunc_bigger_lshr_thm'
[bv] [0.016736] Normalizing goal
  [Meta.synthInstance] [0.001316] ✅️ Decidable
        ((if 5#32 ≥ ↑32 then none else if 3#8 ≥ ↑8 then none else some (BitVec.truncate 8 (x✝ >>> 5#32) <<< 3#8)) ⊑
          if 2#32 ≥ ↑32 then none else some (BitVec.truncate 8 (x✝ >>> 2#32) &&& 248#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if 5#32 ≥ ↑32 then none else if 3#8 ≥ ↑8 then none else some (BitVec.truncate 8 (x✝ >>> 5#32) <<< 3#8)) ⊑
            if 2#32 ≥ ↑32 then none else some (BitVec.truncate 8 (x✝ >>> 2#32) &&& 248#8)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ : ¬some (BitVec.zeroExtend 8 (x✝ >>> 5) <<< 3) ⊑ some (BitVec.zeroExtend 8 (x✝ >>> 2) &&& 248#8)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthshift_proof.lean:45:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthshift_proof.lean:39:8: error: (kernel) declaration has metavariables 'shl_trunc_smaller_lshr_thm'
[bv] [0.016644] Normalizing goal
  [Meta.synthInstance] [0.001409] ✅️ Decidable
        ((if 3#32 ≥ ↑32 then none else if 5#8 ≥ ↑8 then none else some (BitVec.truncate 8 (x✝ >>> 3#32) <<< 5#8)) ⊑
          if 2#8 ≥ ↑8 then none else some (BitVec.truncate 8 x✝ <<< 2#8 &&& 224#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if 3#32 ≥ ↑32 then none else if 5#8 ≥ ↑8 then none else some (BitVec.truncate 8 (x✝ >>> 3#32) <<< 5#8)) ⊑
            if 2#8 ≥ ↑8 then none else some (BitVec.truncate 8 x✝ <<< 2#8 &&& 224#8)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ : ¬some (BitVec.zeroExtend 8 (x✝ >>> 3) <<< 5) ⊑ some (BitVec.zeroExtend 8 x✝ <<< 2 &&& 224#8)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthshift_proof.lean:56:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthshift_proof.lean:49:8: error: (kernel) declaration has metavariables 'shl_trunc_bigger_ashr_thm'
[bv] [0.013904] Normalizing goal
  [Meta.synthInstance] [0.001267] ✅️ Decidable
        ((if 12#32 ≥ ↑32 then none
          else if 3#24 ≥ ↑24 then none else some (BitVec.truncate 24 (x✝.sshiftRight (12#32).toNat) <<< 3#24)) ⊑
          if 9#32 ≥ ↑32 then none else some (BitVec.truncate 24 (x✝.sshiftRight (9#32).toNat) &&& 16777208#24))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if 12#32 ≥ ↑32 then none
            else if 3#24 ≥ ↑24 then none else some (BitVec.truncate 24 (x✝.sshiftRight (12#32).toNat) <<< 3#24)) ⊑
            if 9#32 ≥ ↑32 then none else some (BitVec.truncate 24 (x✝.sshiftRight (9#32).toNat) &&& 16777208#24)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬some (BitVec.zeroExtend 24 (x✝.sshiftRight 12) <<< 3) ⊑
            some (BitVec.zeroExtend 24 (x✝.sshiftRight 9) &&& 16777208#24)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthshift_proof.lean:67:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthshift_proof.lean:60:8: error: (kernel) declaration has metavariables 'shl_trunc_smaller_ashr_thm'
[bv] [0.019994] Normalizing goal
  [Meta.synthInstance] [0.001908] ✅️ Decidable
        ((if 10#32 ≥ ↑32 then none
          else if 13#24 ≥ ↑24 then none else some (BitVec.truncate 24 (x✝.sshiftRight (10#32).toNat) <<< 13#24)) ⊑
          if 3#24 ≥ ↑24 then none else some (BitVec.truncate 24 x✝ <<< 3#24 &&& 16769024#24))
    [Meta.check] [0.001039] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if 10#32 ≥ ↑32 then none
          else if 13#24 ≥ ↑24 then none else some (BitVec.truncate 24 (x✝.sshiftRight (10#32).toNat) <<< 13#24))
          (if 3#24 ≥ ↑24 then none else some (BitVec.truncate 24 x✝ <<< 3#24 &&& 16769024#24))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if 10#32 ≥ ↑32 then none
            else if 13#24 ≥ ↑24 then none else some (BitVec.truncate 24 (x✝.sshiftRight (10#32).toNat) <<< 13#24)) ⊑
            if 3#24 ≥ ↑24 then none else some (BitVec.truncate 24 x✝ <<< 3#24 &&& 16769024#24)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬some (BitVec.zeroExtend 24 (x✝.sshiftRight 10) <<< 13) ⊑ some (BitVec.zeroExtend 24 x✝ <<< 3 &&& 16769024#24)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthshift_proof.lean:77:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthshift_proof.lean:71:8: error: (kernel) declaration has metavariables 'shl_trunc_bigger_shl_thm'
[bv] [0.013584] Normalizing goal
  [Meta.synthInstance] [0.001280] ✅️ Decidable
        ((if 4#32 ≥ ↑32 then none else if 2#8 ≥ ↑8 then none else some (BitVec.truncate 8 (x✝ <<< 4#32) <<< 2#8)) ⊑
          if 6#8 ≥ ↑8 then none else some (BitVec.truncate 8 x✝ <<< 6#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if 4#32 ≥ ↑32 then none else if 2#8 ≥ ↑8 then none else some (BitVec.truncate 8 (x✝ <<< 4#32) <<< 2#8)) ⊑
            if 6#8 ≥ ↑8 then none else some (BitVec.truncate 8 x✝ <<< 6#8)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ : ¬some (BitVec.zeroExtend 8 (x✝ <<< 4) <<< 2) ⊑ some (BitVec.zeroExtend 8 x✝ <<< 6)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthshift_proof.lean:87:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthshift_proof.lean:81:8: error: (kernel) declaration has metavariables 'shl_trunc_smaller_shl_thm'
[bv] [0.013556] Normalizing goal
  [Meta.synthInstance] [0.001244] ✅️ Decidable
        ((if 2#32 ≥ ↑32 then none else if 4#8 ≥ ↑8 then none else some (BitVec.truncate 8 (x✝ <<< 2#32) <<< 4#8)) ⊑
          if 6#8 ≥ ↑8 then none else some (BitVec.truncate 8 x✝ <<< 6#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if 2#32 ≥ ↑32 then none else if 4#8 ≥ ↑8 then none else some (BitVec.truncate 8 (x✝ <<< 2#32) <<< 4#8)) ⊑
            if 6#8 ≥ ↑8 then none else some (BitVec.truncate 8 x✝ <<< 6#8)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ : ¬some (BitVec.zeroExtend 8 (x✝ <<< 2) <<< 4) ⊑ some (BitVec.zeroExtend 8 x✝ <<< 6)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthshift_proof.lean:97:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthshift_proof.lean:91:8: error: (kernel) declaration has metavariables 'shl_shl_constants_div_thm'
[bv] [0.036265] Normalizing goal
  [Meta.synthInstance] [0.001400] ✅️ Decidable
        ((if x✝¹ ≥ ↑32 then none
          else
            if 2#32 ≥ ↑32 then none
            else if 1#32 <<< x✝¹ <<< 2#32 = 0 then none else some (x✝ / 1#32 <<< x✝¹ <<< 2#32)) ⊑
          if x✝¹ + 2#32 ≥ ↑32 then none else some (x✝ >>> (x✝¹ + 2#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if x✝¹ ≥ ↑32 then none
            else
              if 2#32 ≥ ↑32 then none
              else if 1#32 <<< x✝¹ <<< 2#32 = 0 then none else some (x✝ / 1#32 <<< x✝¹ <<< 2#32)) ⊑
            if x✝¹ + 2#32 ≥ ↑32 then none else some (x✝ >>> (x✝¹ + 2#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!32#32 >ᵤ x✝¹) = true then none
            else if (1#32 <<< x✝¹ <<< 2 == 0#32) = true then none else some (x✝ / 1#32 <<< x✝¹ <<< 2)) ⊑
            if (!32#32 >ᵤ x✝¹ + 2#32) = true then none else some (x✝ >>> (x✝¹ + 2#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthshift_proof.lean:106:4: error: tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthshift_proof.lean:106:4: error: tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthshift_proof.lean:108:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthshift_proof.lean:108:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthshift_proof.lean:101:8: error: (kernel) declaration has metavariables 'ashr_shl_constants_thm'
[bv] [0.040828] Normalizing goal
  [Meta.synthInstance] [0.001184] ✅️ Decidable
        ((do
            let x ← some x✝
            if x ≥ ↑32 then none
              else do
                let x' ← some ((BitVec.ofInt 32 (-33)).sshiftRight x.toNat)
                if 3#32 ≥ ↑32 then none else some (x' <<< 3#32)) ⊑
          do
          let x ← some x✝
          if x ≥ ↑32 then none
            else do
              let x' ← some ((BitVec.ofInt 32 (-33)).sshiftRight x.toNat)
              if True ∧ (x' <<< 3#32).sshiftRight (3#32).toNat = x' then none
                else if 3#32 ≥ ↑32 then none else some (x' <<< 3#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(do
              let x ← some x✝
              if x ≥ ↑32 then none
                else do
                  let x' ← some ((BitVec.ofInt 32 (-33)).sshiftRight x.toNat)
                  if 3#32 ≥ ↑32 then none else some (x' <<< 3#32)) ⊑
            do
            let x ← some x✝
            if x ≥ ↑32 then none
              else do
                let x' ← some ((BitVec.ofInt 32 (-33)).sshiftRight x.toNat)
                if True ∧ (x' <<< 3#32).sshiftRight (3#32).toNat = x' then none
                  else if 3#32 ≥ ↑32 then none else some (x' <<< 3#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(do
              let x ← some x✝
              if (!32#32 >ᵤ x) = true then none
                else do
                  let x' ← some ((4294967263#32).sshiftRight x.toNat)
                  some (x' <<< 3)) ⊑
            do
            let x ← some x✝
            if (!32#32 >ᵤ x) = true then none
              else do
                let x' ← some ((4294967263#32).sshiftRight x.toNat)
                if ((x' <<< 3).sshiftRight 3 == x') = true then none else some (x' <<< 3)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthshift_proof.lean:119:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthshift_proof.lean:112:8: error: (kernel) declaration has metavariables 'shl_lshr_demand1_thm'
[bv] [0.022256] Normalizing goal
  [Meta.synthInstance] [0.001119] ✅️ Decidable
        ((if x✝ ≥ ↑8 then none else if 3#8 ≥ ↑8 then none else some (40#8 <<< x✝ >>> 3#8 ||| 224#8)) ⊑
          if x✝ ≥ ↑8 then none else some (5#8 <<< x✝ ||| 224#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if x✝ ≥ ↑8 then none else if 3#8 ≥ ↑8 then none else some (40#8 <<< x✝ >>> 3#8 ||| 224#8)) ⊑
            if x✝ ≥ ↑8 then none else some (5#8 <<< x✝ ||| 224#8)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if (!8#8 >ᵤ x✝) = true then none else some (40#8 <<< x✝ >>> 3 ||| 224#8)) ⊑
            if (!8#8 >ᵤ x✝) = true then none else some (5#8 <<< x✝ ||| 224#8)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthshift_proof.lean:130:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthshift_proof.lean:123:8: error: (kernel) declaration has metavariables 'shl_lshr_demand6_thm'
[bv] [0.023716] Normalizing goal
  [Meta.synthInstance] [0.001129] ✅️ Decidable
        ((if x✝ ≥ ↑16 then none else if 4#16 ≥ ↑16 then none else some (32912#16 <<< x✝ >>> 4#16 &&& 4094#16)) ⊑
          if x✝ ≥ ↑16 then none else some (2057#16 <<< x✝ &&& 4094#16))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 16
      x✝ : BitVec 16
      a✝ :
        ¬(if x✝ ≥ ↑16 then none else if 4#16 ≥ ↑16 then none else some (32912#16 <<< x✝ >>> 4#16 &&& 4094#16)) ⊑
            if x✝ ≥ ↑16 then none else some (2057#16 <<< x✝ &&& 4094#16)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 16
      x✝ : BitVec 16
      a✝ :
        ¬(if (!16#16 >ᵤ x✝) = true then none else some (32912#16 <<< x✝ >>> 4 &&& 4094#16)) ⊑
            if (!16#16 >ᵤ x✝) = true then none else some (2057#16 <<< x✝ &&& 4094#16)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthshift_proof.lean:141:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthshift_proof.lean:134:8: error: (kernel) declaration has metavariables 'lshr_shl_demand1_thm'
[bv] [0.022208] Normalizing goal
  [Meta.synthInstance] [0.001135] ✅️ Decidable
        ((if x✝ ≥ ↑8 then none else if 3#8 ≥ ↑8 then none else some (28#8 >>> x✝ <<< 3#8 ||| 7#8)) ⊑
          if x✝ ≥ ↑8 then none else some (224#8 >>> x✝ ||| 7#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if x✝ ≥ ↑8 then none else if 3#8 ≥ ↑8 then none else some (28#8 >>> x✝ <<< 3#8 ||| 7#8)) ⊑
            if x✝ ≥ ↑8 then none else some (224#8 >>> x✝ ||| 7#8)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if (!8#8 >ᵤ x✝) = true then none else some (28#8 >>> x✝ <<< 3 ||| 7#8)) ⊑
            if (!8#8 >ᵤ x✝) = true then none else some (224#8 >>> x✝ ||| 7#8)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthshift_proof.lean:152:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthshift_proof.lean:145:8: error: (kernel) declaration has metavariables 'lshr_shl_demand3_thm'
[bv] [0.029655] Normalizing goal
  [Meta.synthInstance] [0.001175] ✅️ Decidable
        ((if x✝ ≥ ↑8 then none else if 3#8 ≥ ↑8 then none else some (28#8 >>> x✝ <<< 3#8 ||| 3#8)) ⊑
          if x✝ ≥ ↑8 then none
          else
            if True ∧ 28#8 >>> x✝ <<< 3#8 >>> 3#8 = 28#8 >>> x✝ then none
            else if 3#8 ≥ ↑8 then none else some (28#8 >>> x✝ <<< 3#8 ||| 3#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if x✝ ≥ ↑8 then none else if 3#8 ≥ ↑8 then none else some (28#8 >>> x✝ <<< 3#8 ||| 3#8)) ⊑
            if x✝ ≥ ↑8 then none
            else
              if True ∧ 28#8 >>> x✝ <<< 3#8 >>> 3#8 = 28#8 >>> x✝ then none
              else if 3#8 ≥ ↑8 then none else some (28#8 >>> x✝ <<< 3#8 ||| 3#8)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if (!8#8 >ᵤ x✝) = true then none else some (28#8 >>> x✝ <<< 3 ||| 3#8)) ⊑
            if (!8#8 >ᵤ x✝) = true then none
            else if (28#8 >>> x✝ <<< 3 >>> 3 == 28#8 >>> x✝) = true then none else some (28#8 >>> x✝ <<< 3 ||| 3#8)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
