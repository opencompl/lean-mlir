⚠ [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
⚠ [882/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
⚠ [883/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [886/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
⚠ [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:15:4: error: tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:15:4: error: tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:15:4: error: tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:17:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:17:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:11:8: error: (kernel) declaration has metavariables 't0_thm'
[bv] [0.052491] Normalizing goal
  [Meta.synthInstance] [0.001282] ✅️ Decidable
        ((do
            let x ← some x✝
            let x_1 ← some x✝¹
            if 32#32 - x_1 ≥ ↑32 then none
              else do
                let x' ← some (x >>> (32#32 - x_1))
                let x ← some x✝¹
                if x + BitVec.ofInt 32 (-2) ≥ ↑32 then none else some (x' >>> (x + BitVec.ofInt 32 (-2)))) ⊑
          do
          let x' ← some x✝
          if 30#32 ≥ ↑32 then none else some (x' >>> 30#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(do
              let x ← some x✝
              let x_1 ← some x✝¹
              if 32#32 - x_1 ≥ ↑32 then none
                else do
                  let x' ← some (x >>> (32#32 - x_1))
                  let x ← some x✝¹
                  if x + BitVec.ofInt 32 (-2) ≥ ↑32 then none else some (x' >>> (x + BitVec.ofInt 32 (-2)))) ⊑
            do
            let x' ← some x✝
            if 30#32 ≥ ↑32 then none else some (x' >>> 30#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(do
              let x ← some x✝
              let x_1 ← some x✝¹
              if (!32#32 >ᵤ 33#32 + ~~~x_1) = true then none
                else do
                  let x' ← some (x >>> (33#32 + ~~~x_1))
                  let x ← some x✝¹
                  if (!32#32 >ᵤ x + 4294967294#32) = true then none else some (x' >>> (x + 4294967294#32))) ⊑
            do
            let x' ← some x✝
            some (x' >>> 30)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:27:4: error: tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:27:4: error: tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:27:4: error: tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:29:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:29:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:21:8: error: (kernel) declaration has metavariables 't6_shl_thm'
[bv] [0.101699] Normalizing goal
  [Meta.synthInstance] [0.002133] ✅️ Decidable
        ((do
            let x ← some x✝
            let x_1 ← some x✝¹
            if True ∧ x <<< (32#32 - x_1) >>> (32#32 - x_1) = x then none
              else
                if 32#32 - x_1 ≥ ↑32 then none
                else do
                  let x' ← some (x <<< (32#32 - x_1))
                  let x ← some x✝¹
                  if True ∧ (x' <<< (x + BitVec.ofInt 32 (-2))).sshiftRight (x + BitVec.ofInt 32 (-2)).toNat = x' then
                      none
                    else if x + BitVec.ofInt 32 (-2) ≥ ↑32 then none else some (x' <<< (x + BitVec.ofInt 32 (-2)))) ⊑
          do
          let x' ← some x✝
          if 30#32 ≥ ↑32 then none else some (x' <<< 30#32))
    [Meta.check] [0.001379] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (do
            let x ← some x✝
            let x_1 ← some x✝¹
            if True ∧ x <<< (32#32 - x_1) >>> (32#32 - x_1) = x then none
              else
                if 32#32 - x_1 ≥ ↑32 then none
                else do
                  let x' ← some (x <<< (32#32 - x_1))
                  let x ← some x✝¹
                  if True ∧ (x' <<< (x + BitVec.ofInt 32 (-2))).sshiftRight (x + BitVec.ofInt 32 (-2)).toNat = x' then
                      none
                    else if x + BitVec.ofInt 32 (-2) ≥ ↑32 then none else some (x' <<< (x + BitVec.ofInt 32 (-2))))
          do
          let x' ← some x✝
          if 30#32 ≥ ↑32 then none else some (x' <<< 30#32)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(do
              let x ← some x✝
              let x_1 ← some x✝¹
              if True ∧ x <<< (32#32 - x_1) >>> (32#32 - x_1) = x then none
                else
                  if 32#32 - x_1 ≥ ↑32 then none
                  else do
                    let x' ← some (x <<< (32#32 - x_1))
                    let x ← some x✝¹
                    if True ∧ (x' <<< (x + BitVec.ofInt 32 (-2))).sshiftRight (x + BitVec.ofInt 32 (-2)).toNat = x' then
                        none
                      else if x + BitVec.ofInt 32 (-2) ≥ ↑32 then none else some (x' <<< (x + BitVec.ofInt 32 (-2)))) ⊑
            do
            let x' ← some x✝
            if 30#32 ≥ ↑32 then none else some (x' <<< 30#32)
      ⊢ False
  [Meta.isDefEq] [0.001051] ✅️ ?h₃ =?= fun a => Eq.refl (some (x' <<< (x + 4294967294#32)))
    [Meta.isDefEq.assign] [0.001047] ✅️ ?h₃ := fun a => Eq.refl (some (x' <<< (x + 4294967294#32)))
      [Meta.isDefEq.assign.checkTypes] [0.001014] ✅️ (?h₃ : ¬(!32#32 >ᵤ x + 4294967294#32) = true →
            some (x' <<< (x + BitVec.ofInt 32 (-2))) =
              some
                (x' <<<
                  (x +
                    4294967294#32))) := (fun a =>
            Eq.refl
              (some
                (x' <<<
                  (x +
                    4294967294#32))) : ¬(!32#32 >ᵤ x + 4294967294#32) = true →
            some (x' <<< (x + 4294967294#32)) = some (x' <<< (x + 4294967294#32)))
        [Meta.isDefEq] [0.001007] ✅️ ¬(!32#32 >ᵤ x + 4294967294#32) = true →
              some (x' <<< (x + BitVec.ofInt 32 (-2))) =
                some
                  (x' <<<
                    (x +
                      4294967294#32)) =?= ¬(!32#32 >ᵤ x + 4294967294#32) = true →
              some (x' <<< (x + 4294967294#32)) = some (x' <<< (x + 4294967294#32))
  [Meta.isDefEq] [0.001246] ✅️ ?h₃ =?= fun a =>
        congr
          (congrArg (fun x => bind (some (x✝ <<< x)))
            (Eq.trans (BitVec.sub_toAdd (32#32) x)
              (Eq.trans (congrArg (HAdd.hAdd 32#32) (BitVec.neg_eq_not_add x))
                (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (32#32) (~~~x) 1#32))))
          (funext fun x' =>
            congrArg (bind (some x✝²))
              (funext fun x =>
                ite_congr
                  (Eq.trans
                    (congrArg (And True)
                      (Std.Tactic.BVDecide.Normalize.BitVec.eq_to_beq
                        ((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat) x'))
                    (true_and (((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat == x') = true)))
                  (fun a => Eq.refl none) fun a =>
                  ite_congr
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (32#32) (x + 4294967294#32))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x + 4294967294#32) 32#32))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq (32#32 >ᵤ x + 4294967294#32) true))
                          (congrArg (fun x => (!x) = true) (beq_true (32#32 >ᵤ x + 4294967294#32))))))
                    (fun a => Eq.refl none) fun a => Eq.refl (some (x' <<< (x + 4294967294#32)))))
    [Meta.isDefEq.assign] [0.001241] ✅️ ?h₃ := fun a =>
          congr
            (congrArg (fun x => bind (some (x✝ <<< x)))
              (Eq.trans (BitVec.sub_toAdd (32#32) x)
                (Eq.trans (congrArg (HAdd.hAdd 32#32) (BitVec.neg_eq_not_add x))
                  (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (32#32) (~~~x) 1#32))))
            (funext fun x' =>
              congrArg (bind (some x✝²))
                (funext fun x =>
                  ite_congr
                    (Eq.trans
                      (congrArg (And True)
                        (Std.Tactic.BVDecide.Normalize.BitVec.eq_to_beq
                          ((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat) x'))
                      (true_and (((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat == x') = true)))
                    (fun a => Eq.refl none) fun a =>
                    ite_congr
                      (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                        (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (32#32) (x + 4294967294#32))
                          (Eq.trans
                            (Eq.trans
                              (congrArg Not (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x + 4294967294#32) 32#32))
                              (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq (32#32 >ᵤ x + 4294967294#32) true))
                            (congrArg (fun x => (!x) = true) (beq_true (32#32 >ᵤ x + 4294967294#32))))))
                      (fun a => Eq.refl none) fun a => Eq.refl (some (x' <<< (x + 4294967294#32)))))
      [Meta.isDefEq.assign.checkTypes] [0.001195] ✅️ (?h₃ : ¬(!32#32 >ᵤ 33#32 + ~~~x) = true →
            (do
                let x' ← some (x✝ <<< (32#32 - x))
                let x ← some x✝²
                if True ∧ (x' <<< (x + BitVec.ofInt 32 (-2))).sshiftRight (x + BitVec.ofInt 32 (-2)).toNat = x' then
                    none
                  else if x + BitVec.ofInt 32 (-2) ≥ ↑32 then none else some (x' <<< (x + BitVec.ofInt 32 (-2)))) =
              do
              let x' ← some (x✝ <<< (33#32 + ~~~x))
              let x ← some x✝²
              if ((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat == x') = true then none
                else
                  if (!32#32 >ᵤ x + 4294967294#32) = true then none
                  else
                    some
                      (x' <<<
                        (x +
                          4294967294#32))) := (fun a =>
            congr
              (congrArg (fun x => bind (some (x✝ <<< x)))
                (Eq.trans (BitVec.sub_toAdd (32#32) x)
                  (Eq.trans (congrArg (HAdd.hAdd 32#32) (BitVec.neg_eq_not_add x))
                    (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (32#32) (~~~x) 1#32))))
              (funext fun x' =>
                congrArg (bind (some x✝²))
                  (funext fun x =>
                    ite_congr
                      (Eq.trans
                        (congrArg (And True)
                          (Std.Tactic.BVDecide.Normalize.BitVec.eq_to_beq
                            ((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat) x'))
                        (true_and (((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat == x') = true)))
                      (fun a => Eq.refl none) fun a =>
                      ite_congr
                        (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                          (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (32#32) (x + 4294967294#32))
                            (Eq.trans
                              (Eq.trans
                                (congrArg Not (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x + 4294967294#32) 32#32))
                                (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq (32#32 >ᵤ x + 4294967294#32) true))
                              (congrArg (fun x => (!x) = true) (beq_true (32#32 >ᵤ x + 4294967294#32))))))
                        (fun a => Eq.refl none) fun a =>
                        Eq.refl (some (x' <<< (x + 4294967294#32))))) : ¬(!32#32 >ᵤ 33#32 + ~~~x) = true →
            (do
                let x ← some (x✝ <<< (32#32 - x))
                let x_1 ← some x✝²
                if True ∧ (x <<< (x_1 + BitVec.ofInt 32 (-2))).sshiftRight (x_1 + BitVec.ofInt 32 (-2)).toNat = x then
                    none
                  else if x_1 + BitVec.ofInt 32 (-2) ≥ ↑32 then none else some (x <<< (x_1 + BitVec.ofInt 32 (-2)))) =
              do
              let x ← some (x✝ <<< (32#32 + 1#32 + ~~~x))
              let x_1 ← some x✝²
              if ((x <<< (x_1 + 4294967294#32)).sshiftRight (x_1 + 4294967294#32).toNat == x) = true then none
                else if (!32#32 >ᵤ x_1 + 4294967294#32) = true then none else some (x <<< (x_1 + 4294967294#32)))
        [Meta.isDefEq] [0.001191] ✅️ ¬(!32#32 >ᵤ 33#32 + ~~~x) = true →
              (do
                  let x' ← some (x✝ <<< (32#32 - x))
                  let x ← some x✝²
                  if True ∧ (x' <<< (x + BitVec.ofInt 32 (-2))).sshiftRight (x + BitVec.ofInt 32 (-2)).toNat = x' then
                      none
                    else if x + BitVec.ofInt 32 (-2) ≥ ↑32 then none else some (x' <<< (x + BitVec.ofInt 32 (-2)))) =
                do
                let x' ← some (x✝ <<< (33#32 + ~~~x))
                let x ← some x✝²
                if ((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat == x') = true then none
                  else
                    if (!32#32 >ᵤ x + 4294967294#32) = true then none
                    else some (x' <<< (x + 4294967294#32)) =?= ¬(!32#32 >ᵤ 33#32 + ~~~x) = true →
              (do
                  let x ← some (x✝ <<< (32#32 - x))
                  let x_1 ← some x✝²
                  if True ∧ (x <<< (x_1 + BitVec.ofInt 32 (-2))).sshiftRight (x_1 + BitVec.ofInt 32 (-2)).toNat = x then
                      none
                    else if x_1 + BitVec.ofInt 32 (-2) ≥ ↑32 then none else some (x <<< (x_1 + BitVec.ofInt 32 (-2)))) =
                do
                let x ← some (x✝ <<< (32#32 + 1#32 + ~~~x))
                let x_1 ← some x✝²
                if ((x <<< (x_1 + 4294967294#32)).sshiftRight (x_1 + 4294967294#32).toNat == x) = true then none
                  else if (!32#32 >ᵤ x_1 + 4294967294#32) = true then none else some (x <<< (x_1 + 4294967294#32))
          [Meta.isDefEq] [0.001143] ✅️ (do
                  let x' ← some (x✝ <<< (32#32 - x))
                  let x ← some x✝²
                  if True ∧ (x' <<< (x + BitVec.ofInt 32 (-2))).sshiftRight (x + BitVec.ofInt 32 (-2)).toNat = x' then
                      none
                    else if x + BitVec.ofInt 32 (-2) ≥ ↑32 then none else some (x' <<< (x + BitVec.ofInt 32 (-2)))) =
                do
                let x' ← some (x✝ <<< (33#32 + ~~~x))
                let x ← some x✝²
                if ((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat == x') = true then none
                  else if (!32#32 >ᵤ x + 4294967294#32) = true then none else some (x' <<< (x + 4294967294#32)) =?= (do
                  let x ← some (x✝ <<< (32#32 - x))
                  let x_1 ← some x✝²
                  if True ∧ (x <<< (x_1 + BitVec.ofInt 32 (-2))).sshiftRight (x_1 + BitVec.ofInt 32 (-2)).toNat = x then
                      none
                    else if x_1 + BitVec.ofInt 32 (-2) ≥ ↑32 then none else some (x <<< (x_1 + BitVec.ofInt 32 (-2)))) =
                do
                let x ← some (x✝ <<< (32#32 + 1#32 + ~~~x))
                let x_1 ← some x✝²
                if ((x <<< (x_1 + 4294967294#32)).sshiftRight (x_1 + 4294967294#32).toNat == x) = true then none
                  else if (!32#32 >ᵤ x_1 + 4294967294#32) = true then none else some (x <<< (x_1 + 4294967294#32))
            [Meta.isDefEq] [0.001100] ✅️ do
                  let x' ← some (x✝ <<< (33#32 + ~~~x))
                  let x ← some x✝²
                  if ((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat == x') = true then none
                    else if (!32#32 >ᵤ x + 4294967294#32) = true then none else some (x' <<< (x + 4294967294#32)) =?= do
                  let x ← some (x✝ <<< (32#32 + 1#32 + ~~~x))
                  let x_1 ← some x✝²
                  if ((x <<< (x_1 + 4294967294#32)).sshiftRight (x_1 + 4294967294#32).toNat == x) = true then none
                    else if (!32#32 >ᵤ x_1 + 4294967294#32) = true then none else some (x <<< (x_1 + 4294967294#32))
              [Meta.isDefEq] [0.001072] ✅️ Monad.toBind.1 (some (x✝ <<< (33#32 + ~~~x))) fun x' => do
                    let x ← some x✝²
                    if ((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat == x') = true then none
                      else
                        if (!32#32 >ᵤ x + 4294967294#32) = true then none
                        else
                          some
                            (x' <<<
                              (x + 4294967294#32)) =?= Monad.toBind.1 (some (x✝ <<< (32#32 + 1#32 + ~~~x))) fun x => do
                    let x_1 ← some x✝²
                    if ((x <<< (x_1 + 4294967294#32)).sshiftRight (x_1 + 4294967294#32).toNat == x) = true then none
                      else if (!32#32 >ᵤ x_1 + 4294967294#32) = true then none else some (x <<< (x_1 + 4294967294#32))
                [Meta.isDefEq] [0.001000] ✅️ (some (x✝ <<< (33#32 + ~~~x))).bind fun x' => do
                      let x ← some x✝²
                      if ((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat == x') = true then none
                        else
                          if (!32#32 >ᵤ x + 4294967294#32) = true then none
                          else
                            some (x' <<< (x + 4294967294#32)) =?= (some (x✝ <<< (32#32 + 1#32 + ~~~x))).bind fun x => do
                      let x_1 ← some x✝²
                      if ((x <<< (x_1 + 4294967294#32)).sshiftRight (x_1 + 4294967294#32).toNat == x) = true then none
                        else if (!32#32 >ᵤ x_1 + 4294967294#32) = true then none else some (x <<< (x_1 + 4294967294#32))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(do
              let x ← some x✝
              let x_1 ← some x✝¹
              if (x <<< (33#32 + ~~~x_1) >>> (33#32 + ~~~x_1) == x) = true then none
                else
                  if (!32#32 >ᵤ 33#32 + ~~~x_1) = true then none
                  else do
                    let x' ← some (x <<< (33#32 + ~~~x_1))
                    let x ← some x✝¹
                    if ((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat == x') = true then none
                      else if (!32#32 >ᵤ x + 4294967294#32) = true then none else some (x' <<< (x + 4294967294#32))) ⊑
            do
            let x' ← some x✝
            some (x' <<< 30)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:37:4: error: tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:37:4: error: tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:37:4: error: tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:39:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:39:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:33:8: error: (kernel) declaration has metavariables 't7_ashr_thm'
[bv] [0.048902] Normalizing goal
  [Meta.synthInstance] [0.001342] ✅️ Decidable
        ((do
            let x ← some x✝
            let x_1 ← some x✝¹
            if 32#32 - x_1 ≥ ↑32 then none
              else do
                let x' ← some (x.sshiftRight (32#32 - x_1).toNat)
                let x ← some x✝¹
                if x + BitVec.ofInt 32 (-2) ≥ ↑32 then none
                  else some (x'.sshiftRight (x + BitVec.ofInt 32 (-2)).toNat)) ⊑
          do
          let x' ← some x✝
          if 30#32 ≥ ↑32 then none else some (x'.sshiftRight (30#32).toNat))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(do
              let x ← some x✝
              let x_1 ← some x✝¹
              if 32#32 - x_1 ≥ ↑32 then none
                else do
                  let x' ← some (x.sshiftRight (32#32 - x_1).toNat)
                  let x ← some x✝¹
                  if x + BitVec.ofInt 32 (-2) ≥ ↑32 then none
                    else some (x'.sshiftRight (x + BitVec.ofInt 32 (-2)).toNat)) ⊑
            do
            let x' ← some x✝
            if 30#32 ≥ ↑32 then none else some (x'.sshiftRight (30#32).toNat)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(do
              let x ← some x✝
              let x_1 ← some x✝¹
              if (!32#32 >ᵤ 33#32 + ~~~x_1) = true then none
                else do
                  let x' ← some (x.sshiftRight (33#32 + ~~~x_1).toNat)
                  let x ← some x✝¹
                  if (!32#32 >ᵤ x + 4294967294#32) = true then none
                    else some (x'.sshiftRight (x + 4294967294#32).toNat)) ⊑
            do
            let x' ← some x✝
            some (x'.sshiftRight 30)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:47:4: error: tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:47:4: error: tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:47:4: error: tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:49:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:49:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:43:8: error: (kernel) declaration has metavariables 't8_lshr_exact_flag_preservation_thm'
[bv] [0.058075] Normalizing goal
  [Meta.synthInstance] [0.001340] ✅️ Decidable
        ((do
            let x ← some x✝
            let x_1 ← some x✝¹
            if 32#32 - x_1 ≥ ↑32 then none
              else do
                let x' ← some (x >>> (32#32 - x_1))
                let x ← some x✝¹
                if x + BitVec.ofInt 32 (-2) ≥ ↑32 then none else some (x' >>> (x + BitVec.ofInt 32 (-2)))) ⊑
          do
          let x' ← some x✝
          if 30#32 ≥ ↑32 then none else some (x' >>> 30#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(do
              let x ← some x✝
              let x_1 ← some x✝¹
              if 32#32 - x_1 ≥ ↑32 then none
                else do
                  let x' ← some (x >>> (32#32 - x_1))
                  let x ← some x✝¹
                  if x + BitVec.ofInt 32 (-2) ≥ ↑32 then none else some (x' >>> (x + BitVec.ofInt 32 (-2)))) ⊑
            do
            let x' ← some x✝
            if 30#32 ≥ ↑32 then none else some (x' >>> 30#32)
      ⊢ False
  [Meta.isDefEq] [0.001211] ✅️ ?h₃ =?= fun a => Eq.refl (some (x' >>> (x + 4294967294#32)))
    [Meta.isDefEq.assign] [0.001207] ✅️ ?h₃ := fun a => Eq.refl (some (x' >>> (x + 4294967294#32)))
      [Meta.isDefEq.assign.checkTypes] [0.001169] ✅️ (?h₃ : ¬(!32#32 >ᵤ x + 4294967294#32) = true →
            some (x' >>> (x + BitVec.ofInt 32 (-2))) =
              some
                (x' >>>
                  (x +
                    4294967294#32))) := (fun a =>
            Eq.refl
              (some
                (x' >>>
                  (x +
                    4294967294#32))) : ¬(!32#32 >ᵤ x + 4294967294#32) = true →
            some (x' >>> (x + 4294967294#32)) = some (x' >>> (x + 4294967294#32)))
        [Meta.isDefEq] [0.001164] ✅️ ¬(!32#32 >ᵤ x + 4294967294#32) = true →
              some (x' >>> (x + BitVec.ofInt 32 (-2))) =
                some
                  (x' >>>
                    (x +
                      4294967294#32)) =?= ¬(!32#32 >ᵤ x + 4294967294#32) = true →
              some (x' >>> (x + 4294967294#32)) = some (x' >>> (x + 4294967294#32))
          [Meta.isDefEq] [0.001095] ✅️ some (x' >>> (x + BitVec.ofInt 32 (-2))) =
                some
                  (x' >>> (x + 4294967294#32)) =?= some (x' >>> (x + 4294967294#32)) = some (x' >>> (x + 4294967294#32))
            [Meta.isDefEq] [0.001056] ✅️ some (x' >>> (x + BitVec.ofInt 32 (-2))) =?= some (x' >>> (x + 4294967294#32))
              [Meta.isDefEq] [0.001036] ✅️ x' >>> (x + BitVec.ofInt 32 (-2)) =?= x' >>> (x + 4294967294#32)
                [Meta.isDefEq] [0.001005] ✅️ BitVec.instHShiftRight.1 x'
                      (x + BitVec.ofInt 32 (-2)) =?= BitVec.instHShiftRight.1 x' (x + 4294967294#32)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(do
              let x ← some x✝
              let x_1 ← some x✝¹
              if (!32#32 >ᵤ 33#32 + ~~~x_1) = true then none
                else do
                  let x' ← some (x >>> (33#32 + ~~~x_1))
                  let x ← some x✝¹
                  if (!32#32 >ᵤ x + 4294967294#32) = true then none else some (x' >>> (x + 4294967294#32))) ⊑
            do
            let x' ← some x✝
            some (x' >>> 30)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:57:4: error: tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:57:4: error: tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:57:4: error: tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:59:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:59:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:53:8: error: (kernel) declaration has metavariables 't9_ashr_exact_flag_preservation_thm'
[bv] [0.050453] Normalizing goal
  [Meta.synthInstance] [0.002051] ✅️ Decidable
        ((do
            let x ← some x✝
            let x_1 ← some x✝¹
            if 32#32 - x_1 ≥ ↑32 then none
              else do
                let x' ← some (x.sshiftRight (32#32 - x_1).toNat)
                let x ← some x✝¹
                if x + BitVec.ofInt 32 (-2) ≥ ↑32 then none
                  else some (x'.sshiftRight (x + BitVec.ofInt 32 (-2)).toNat)) ⊑
          do
          let x' ← some x✝
          if 30#32 ≥ ↑32 then none else some (x'.sshiftRight (30#32).toNat))
    [Meta.check] [0.001207] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (do
            let x ← some x✝
            let x_1 ← some x✝¹
            if 32#32 - x_1 ≥ ↑32 then none
              else do
                let x' ← some (x.sshiftRight (32#32 - x_1).toNat)
                let x ← some x✝¹
                if x + BitVec.ofInt 32 (-2) ≥ ↑32 then none else some (x'.sshiftRight (x + BitVec.ofInt 32 (-2)).toNat))
          do
          let x' ← some x✝
          if 30#32 ≥ ↑32 then none else some (x'.sshiftRight (30#32).toNat)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(do
              let x ← some x✝
              let x_1 ← some x✝¹
              if 32#32 - x_1 ≥ ↑32 then none
                else do
                  let x' ← some (x.sshiftRight (32#32 - x_1).toNat)
                  let x ← some x✝¹
                  if x + BitVec.ofInt 32 (-2) ≥ ↑32 then none
                    else some (x'.sshiftRight (x + BitVec.ofInt 32 (-2)).toNat)) ⊑
            do
            let x' ← some x✝
            if 30#32 ≥ ↑32 then none else some (x'.sshiftRight (30#32).toNat)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(do
              let x ← some x✝
              let x_1 ← some x✝¹
              if (!32#32 >ᵤ 33#32 + ~~~x_1) = true then none
                else do
                  let x' ← some (x.sshiftRight (33#32 + ~~~x_1).toNat)
                  let x ← some x✝¹
                  if (!32#32 >ᵤ x + 4294967294#32) = true then none
                    else some (x'.sshiftRight (x + 4294967294#32).toNat)) ⊑
            do
            let x' ← some x✝
            some (x'.sshiftRight 30)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:69:4: error: tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:69:4: error: tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:69:4: error: tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:71:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:71:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:63:8: error: (kernel) declaration has metavariables 't10_shl_nuw_flag_preservation_thm'
[bv] [0.098668] Normalizing goal
  [Meta.synthInstance] [0.001808] ✅️ Decidable
        ((do
            let x ← some x✝
            let x_1 ← some x✝¹
            if True ∧ x <<< (32#32 - x_1) >>> (32#32 - x_1) = x then none
              else
                if 32#32 - x_1 ≥ ↑32 then none
                else do
                  let x' ← some (x <<< (32#32 - x_1))
                  let x ← some x✝¹
                  if True ∧ (x' <<< (x + BitVec.ofInt 32 (-2))).sshiftRight (x + BitVec.ofInt 32 (-2)).toNat = x' then
                      none
                    else
                      if True ∧ x' <<< (x + BitVec.ofInt 32 (-2)) >>> (x + BitVec.ofInt 32 (-2)) = x' then none
                      else if x + BitVec.ofInt 32 (-2) ≥ ↑32 then none else some (x' <<< (x + BitVec.ofInt 32 (-2)))) ⊑
          do
          let x' ← some x✝
          if True ∧ x' <<< 30#32 >>> 30#32 = x' then none else if 30#32 ≥ ↑32 then none else some (x' <<< 30#32))
    [Meta.check] [0.001156] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (do
            let x ← some x✝
            let x_1 ← some x✝¹
            if True ∧ x <<< (32#32 - x_1) >>> (32#32 - x_1) = x then none
              else
                if 32#32 - x_1 ≥ ↑32 then none
                else do
                  let x' ← some (x <<< (32#32 - x_1))
                  let x ← some x✝¹
                  if True ∧ (x' <<< (x + BitVec.ofInt 32 (-2))).sshiftRight (x + BitVec.ofInt 32 (-2)).toNat = x' then
                      none
                    else
                      if True ∧ x' <<< (x + BitVec.ofInt 32 (-2)) >>> (x + BitVec.ofInt 32 (-2)) = x' then none
                      else if x + BitVec.ofInt 32 (-2) ≥ ↑32 then none else some (x' <<< (x + BitVec.ofInt 32 (-2))))
          do
          let x' ← some x✝
          if True ∧ x' <<< 30#32 >>> 30#32 = x' then none else if 30#32 ≥ ↑32 then none else some (x' <<< 30#32)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(do
              let x ← some x✝
              let x_1 ← some x✝¹
              if True ∧ x <<< (32#32 - x_1) >>> (32#32 - x_1) = x then none
                else
                  if 32#32 - x_1 ≥ ↑32 then none
                  else do
                    let x' ← some (x <<< (32#32 - x_1))
                    let x ← some x✝¹
                    if True ∧ (x' <<< (x + BitVec.ofInt 32 (-2))).sshiftRight (x + BitVec.ofInt 32 (-2)).toNat = x' then
                        none
                      else
                        if True ∧ x' <<< (x + BitVec.ofInt 32 (-2)) >>> (x + BitVec.ofInt 32 (-2)) = x' then none
                        else
                          if x + BitVec.ofInt 32 (-2) ≥ ↑32 then none else some (x' <<< (x + BitVec.ofInt 32 (-2)))) ⊑
            do
            let x' ← some x✝
            if True ∧ x' <<< 30#32 >>> 30#32 = x' then none else if 30#32 ≥ ↑32 then none else some (x' <<< 30#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(do
              let x ← some x✝
              let x_1 ← some x✝¹
              if (x <<< (33#32 + ~~~x_1) >>> (33#32 + ~~~x_1) == x) = true then none
                else
                  if (!32#32 >ᵤ 33#32 + ~~~x_1) = true then none
                  else do
                    let x' ← some (x <<< (33#32 + ~~~x_1))
                    let x ← some x✝¹
                    if ((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat == x') = true then none
                      else
                        if (x' <<< (x + 4294967294#32) >>> (x + 4294967294#32) == x') = true then none
                        else if (!32#32 >ᵤ x + 4294967294#32) = true then none else some (x' <<< (x + 4294967294#32))) ⊑
            do
            let x' ← some x✝
            if (x' <<< 30 >>> 30 == x') = true then none else some (x' <<< 30)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:81:4: error: tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:81:4: error: tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:81:4: error: tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:83:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:83:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthamounthreassociation_proof.lean:75:8: error: (kernel) declaration has metavariables 't11_shl_nsw_flag_preservation_thm'
[bv] [0.153126] Normalizing goal
  [Meta.synthInstance] [0.002781] ✅️ Decidable
        ((do
            let x ← some x✝
            let x_1 ← some x✝¹
            if True ∧ (x <<< (32#32 - x_1)).sshiftRight (32#32 - x_1).toNat = x then none
              else
                if 32#32 - x_1 ≥ ↑32 then none
                else do
                  let x' ← some (x <<< (32#32 - x_1))
                  let x ← some x✝¹
                  if True ∧ (x' <<< (x + BitVec.ofInt 32 (-2))).sshiftRight (x + BitVec.ofInt 32 (-2)).toNat = x' then
                      none
                    else
                      if True ∧ x' <<< (x + BitVec.ofInt 32 (-2)) >>> (x + BitVec.ofInt 32 (-2)) = x' then none
                      else if x + BitVec.ofInt 32 (-2) ≥ ↑32 then none else some (x' <<< (x + BitVec.ofInt 32 (-2)))) ⊑
          do
          let x' ← some x✝
          if True ∧ (x' <<< 30#32).sshiftRight (30#32).toNat = x' then none
            else if 30#32 ≥ ↑32 then none else some (x' <<< 30#32))
    [Meta.check] [0.001915] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (do
            let x ← some x✝
            let x_1 ← some x✝¹
            if True ∧ (x <<< (32#32 - x_1)).sshiftRight (32#32 - x_1).toNat = x then none
              else
                if 32#32 - x_1 ≥ ↑32 then none
                else do
                  let x' ← some (x <<< (32#32 - x_1))
                  let x ← some x✝¹
                  if True ∧ (x' <<< (x + BitVec.ofInt 32 (-2))).sshiftRight (x + BitVec.ofInt 32 (-2)).toNat = x' then
                      none
                    else
                      if True ∧ x' <<< (x + BitVec.ofInt 32 (-2)) >>> (x + BitVec.ofInt 32 (-2)) = x' then none
                      else if x + BitVec.ofInt 32 (-2) ≥ ↑32 then none else some (x' <<< (x + BitVec.ofInt 32 (-2))))
          do
          let x' ← some x✝
          if True ∧ (x' <<< 30#32).sshiftRight (30#32).toNat = x' then none
            else if 30#32 ≥ ↑32 then none else some (x' <<< 30#32)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(do
              let x ← some x✝
              let x_1 ← some x✝¹
              if True ∧ (x <<< (32#32 - x_1)).sshiftRight (32#32 - x_1).toNat = x then none
                else
                  if 32#32 - x_1 ≥ ↑32 then none
                  else do
                    let x' ← some (x <<< (32#32 - x_1))
                    let x ← some x✝¹
                    if True ∧ (x' <<< (x + BitVec.ofInt 32 (-2))).sshiftRight (x + BitVec.ofInt 32 (-2)).toNat = x' then
                        none
                      else
                        if True ∧ x' <<< (x + BitVec.ofInt 32 (-2)) >>> (x + BitVec.ofInt 32 (-2)) = x' then none
                        else
                          if x + BitVec.ofInt 32 (-2) ≥ ↑32 then none else some (x' <<< (x + BitVec.ofInt 32 (-2)))) ⊑
            do
            let x' ← some x✝
            if True ∧ (x' <<< 30#32).sshiftRight (30#32).toNat = x' then none
              else if 30#32 ≥ ↑32 then none else some (x' <<< 30#32)
      ⊢ False
  [Meta.isDefEq] [0.001027] ❌️ ?a =
        ?a =?= ((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat == x') = true
  [Meta.isDefEq] [0.001301] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Std.Tactic.BVDecide.Normalize.BitVec.eq_to_beq
            ((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat) x'))
        (true_and (((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat == x') = true))
    [Meta.isDefEq.assign] [0.001297] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Std.Tactic.BVDecide.Normalize.BitVec.eq_to_beq
              ((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat) x'))
          (true_and (((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat == x') = true))
      [Meta.isDefEq.assign.checkTypes] [0.001283] ✅️ (?h₁ : (True ∧
              (x' <<< (x + BitVec.ofInt 32 (-2))).sshiftRight (x + BitVec.ofInt 32 (-2)).toNat = x') =
            (((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat == x') =
              true)) := (Eq.trans
            (congrArg (And True)
              (Std.Tactic.BVDecide.Normalize.BitVec.eq_to_beq
                ((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat) x'))
            (true_and
              (((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat == x') =
                true)) : (True ∧ (x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat = x') =
            (((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat == x') = true))
        [Meta.isDefEq] [0.001278] ✅️ (True ∧
                (x' <<< (x + BitVec.ofInt 32 (-2))).sshiftRight (x + BitVec.ofInt 32 (-2)).toNat = x') =
              (((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat == x') =
                true) =?= (True ∧ (x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat = x') =
              (((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat == x') = true)
          [Meta.isDefEq] [0.001243] ✅️ True ∧
                (x' <<< (x + BitVec.ofInt 32 (-2))).sshiftRight (x + BitVec.ofInt 32 (-2)).toNat =
                  x' =?= True ∧ (x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat = x'
            [Meta.isDefEq] [0.001226] ✅️ (x' <<< (x + BitVec.ofInt 32 (-2))).sshiftRight
                    (x + BitVec.ofInt 32 (-2)).toNat =
                  x' =?= (x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat = x'
              [Meta.isDefEq] [0.001203] ✅️ (x' <<< (x + BitVec.ofInt 32 (-2))).sshiftRight
                    (x +
                        BitVec.ofInt 32
                          (-2)).toNat =?= (x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat
                [Meta.isDefEq.delta] [0.001183] ✅️ (x' <<< (x + BitVec.ofInt 32 (-2))).sshiftRight
                      (x +
                          BitVec.ofInt 32
                            (-2)).toNat =?= (x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat
                  [Meta.isDefEq] [0.001160] ✅️ x' <<< (x + BitVec.ofInt 32 (-2)) =?= x' <<< (x + 4294967294#32)
                    [Meta.isDefEq] [0.001130] ✅️ BitVec.instHShiftLeft.1 x'
                          (x + BitVec.ofInt 32 (-2)) =?= BitVec.instHShiftLeft.1 x' (x + 4294967294#32)
                      [Meta.isDefEq] [0.001076] ✅️ x' <<<
                            (x + BitVec.ofInt 32 (-2)).toNat =?= x' <<< (x + 4294967294#32).toNat
                        [Meta.isDefEq] [0.001047] ✅️ BitVec.instHShiftLeftNat.1 x'
                              (x +
                                  BitVec.ofInt 32
                                    (-2)).toNat =?= BitVec.instHShiftLeftNat.1 x' (x + 4294967294#32).toNat
                          [Meta.isDefEq] [0.001008] ✅️ x'.shiftLeft
                                (x + BitVec.ofInt 32 (-2)).toNat =?= x'.shiftLeft (x + 4294967294#32).toNat
  [Meta.isDefEq] [0.001381] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Std.Tactic.BVDecide.Normalize.BitVec.eq_to_beq (x' <<< (x + 4294967294#32) >>> (x + 4294967294#32)) x'))
        (true_and ((x' <<< (x + 4294967294#32) >>> (x + 4294967294#32) == x') = true))
    [Meta.isDefEq.assign] [0.001377] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Std.Tactic.BVDecide.Normalize.BitVec.eq_to_beq (x' <<< (x + 4294967294#32) >>> (x + 4294967294#32)) x'))
          (true_and ((x' <<< (x + 4294967294#32) >>> (x + 4294967294#32) == x') = true))
      [Meta.isDefEq.assign.checkTypes] [0.001361] ✅️ (?h₁ : (True ∧
              x' <<< (x + BitVec.ofInt 32 (-2)) >>> (x + BitVec.ofInt 32 (-2)) = x') =
            ((x' <<< (x + 4294967294#32) >>> (x + 4294967294#32) == x') =
              true)) := (Eq.trans
            (congrArg (And True)
              (Std.Tactic.BVDecide.Normalize.BitVec.eq_to_beq (x' <<< (x + 4294967294#32) >>> (x + 4294967294#32)) x'))
            (true_and
              ((x' <<< (x + 4294967294#32) >>> (x + 4294967294#32) == x') =
                true)) : (True ∧ x' <<< (x + 4294967294#32) >>> (x + 4294967294#32) = x') =
            ((x' <<< (x + 4294967294#32) >>> (x + 4294967294#32) == x') = true))
        [Meta.isDefEq] [0.001356] ✅️ (True ∧ x' <<< (x + BitVec.ofInt 32 (-2)) >>> (x + BitVec.ofInt 32 (-2)) = x') =
              ((x' <<< (x + 4294967294#32) >>> (x + 4294967294#32) == x') =
                true) =?= (True ∧ x' <<< (x + 4294967294#32) >>> (x + 4294967294#32) = x') =
              ((x' <<< (x + 4294967294#32) >>> (x + 4294967294#32) == x') = true)
          [Meta.isDefEq] [0.001323] ✅️ True ∧
                x' <<< (x + BitVec.ofInt 32 (-2)) >>> (x + BitVec.ofInt 32 (-2)) =
                  x' =?= True ∧ x' <<< (x + 4294967294#32) >>> (x + 4294967294#32) = x'
            [Meta.isDefEq] [0.001306] ✅️ x' <<< (x + BitVec.ofInt 32 (-2)) >>> (x + BitVec.ofInt 32 (-2)) =
                  x' =?= x' <<< (x + 4294967294#32) >>> (x + 4294967294#32) = x'
              [Meta.isDefEq] [0.001261] ✅️ x' <<< (x + BitVec.ofInt 32 (-2)) >>>
                    (x + BitVec.ofInt 32 (-2)) =?= x' <<< (x + 4294967294#32) >>> (x + 4294967294#32)
                [Meta.isDefEq] [0.001230] ✅️ BitVec.instHShiftRight.1 (x' <<< (x + BitVec.ofInt 32 (-2)))
                      (x +
                        BitVec.ofInt 32
                          (-2)) =?= BitVec.instHShiftRight.1 (x' <<< (x + 4294967294#32)) (x + 4294967294#32)
                  [Meta.isDefEq] [0.001173] ✅️ x' <<< (x + BitVec.ofInt 32 (-2)) >>>
                        (x + BitVec.ofInt 32 (-2)).toNat =?= x' <<< (x + 4294967294#32) >>> (x + 4294967294#32).toNat
                    [Meta.isDefEq] [0.001143] ✅️ BitVec.instHShiftRightNat.1 (x' <<< (x + BitVec.ofInt 32 (-2)))
                          (x +
                              BitVec.ofInt 32
                                (-2)).toNat =?= BitVec.instHShiftRightNat.1 (x' <<< (x + 4294967294#32))
                          (x + 4294967294#32).toNat
                      [Meta.isDefEq] [0.001101] ✅️ (x' <<< (x + BitVec.ofInt 32 (-2))).ushiftRight
                            (x +
                                BitVec.ofInt 32
                                  (-2)).toNat =?= (x' <<< (x + 4294967294#32)).ushiftRight (x + 4294967294#32).toNat
                        [Meta.isDefEq.delta] [0.001083] ✅️ (x' <<< (x + BitVec.ofInt 32 (-2))).ushiftRight
                              (x +
                                  BitVec.ofInt 32
                                    (-2)).toNat =?= (x' <<< (x + 4294967294#32)).ushiftRight (x + 4294967294#32).toNat
                          [Meta.isDefEq] [0.001059] ✅️ x' <<< (x + BitVec.ofInt 32 (-2)) =?= x' <<< (x + 4294967294#32)
                            [Meta.isDefEq] [0.001029] ✅️ BitVec.instHShiftLeft.1 x'
                                  (x + BitVec.ofInt 32 (-2)) =?= BitVec.instHShiftLeft.1 x' (x + 4294967294#32)
  [Meta.isDefEq] [0.001039] ✅️ ?h₁ =?= Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
        (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (32#32) (x + 4294967294#32))
          (Eq.trans
            (Eq.trans (congrArg Not (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x + 4294967294#32) 32#32))
              (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq (32#32 >ᵤ x + 4294967294#32) true))
            (congrArg (fun x => (!x) = true) (beq_true (32#32 >ᵤ x + 4294967294#32)))))
    [Meta.isDefEq.assign] [0.001035] ✅️ ?h₁ := Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
          (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (32#32) (x + 4294967294#32))
            (Eq.trans
              (Eq.trans (congrArg Not (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x + 4294967294#32) 32#32))
                (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq (32#32 >ᵤ x + 4294967294#32) true))
              (congrArg (fun x => (!x) = true) (beq_true (32#32 >ᵤ x + 4294967294#32)))))
      [Meta.isDefEq.assign.checkTypes] [0.001014] ✅️ (?h₁ : (x + BitVec.ofInt 32 (-2) ≥ ↑32) =
            ((!32#32 >ᵤ x + 4294967294#32) =
              true)) := (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (32#32) (x + 4294967294#32))
              (Eq.trans
                (Eq.trans (congrArg Not (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x + 4294967294#32) 32#32))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq (32#32 >ᵤ x + 4294967294#32) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true
                    (32#32 >ᵤ
                      x + 4294967294#32))))) : (x + 4294967294#32 ≥ 32#32) = ((!32#32 >ᵤ x + 4294967294#32) = true))
        [Meta.isDefEq] [0.001006] ✅️ (x + BitVec.ofInt 32 (-2) ≥ ↑32) =
              ((!32#32 >ᵤ x + 4294967294#32) =
                true) =?= (x + 4294967294#32 ≥ 32#32) = ((!32#32 >ᵤ x + 4294967294#32) = true)
  [Meta.isDefEq] [0.001234] ✅️ ?h₃ =?= fun a => Eq.refl (some (x' <<< (x + 4294967294#32)))
    [Meta.isDefEq.assign] [0.001230] ✅️ ?h₃ := fun a => Eq.refl (some (x' <<< (x + 4294967294#32)))
      [Meta.isDefEq.assign.checkTypes] [0.001190] ✅️ (?h₃ : ¬(!32#32 >ᵤ x + 4294967294#32) = true →
            some (x' <<< (x + BitVec.ofInt 32 (-2))) =
              some
                (x' <<<
                  (x +
                    4294967294#32))) := (fun a =>
            Eq.refl
              (some
                (x' <<<
                  (x +
                    4294967294#32))) : ¬(!32#32 >ᵤ x + 4294967294#32) = true →
            some (x' <<< (x + 4294967294#32)) = some (x' <<< (x + 4294967294#32)))
        [Meta.isDefEq] [0.001185] ✅️ ¬(!32#32 >ᵤ x + 4294967294#32) = true →
              some (x' <<< (x + BitVec.ofInt 32 (-2))) =
                some
                  (x' <<<
                    (x +
                      4294967294#32)) =?= ¬(!32#32 >ᵤ x + 4294967294#32) = true →
              some (x' <<< (x + 4294967294#32)) = some (x' <<< (x + 4294967294#32))
          [Meta.isDefEq] [0.001111] ✅️ some (x' <<< (x + BitVec.ofInt 32 (-2))) =
                some
                  (x' <<< (x + 4294967294#32)) =?= some (x' <<< (x + 4294967294#32)) = some (x' <<< (x + 4294967294#32))
            [Meta.isDefEq] [0.001059] ✅️ some (x' <<< (x + BitVec.ofInt 32 (-2))) =?= some (x' <<< (x + 4294967294#32))
              [Meta.isDefEq] [0.001035] ✅️ x' <<< (x + BitVec.ofInt 32 (-2)) =?= x' <<< (x + 4294967294#32)
                [Meta.isDefEq] [0.001002] ✅️ BitVec.instHShiftLeft.1 x'
                      (x + BitVec.ofInt 32 (-2)) =?= BitVec.instHShiftLeft.1 x' (x + 4294967294#32)
  [Meta.isDefEq] [0.001385] ✅️ ?h₃ =?= fun a =>
        congr
          (congrArg (fun x => bind (some (x✝ <<< x)))
            (Eq.trans (BitVec.sub_toAdd (32#32) x)
              (Eq.trans (congrArg (HAdd.hAdd 32#32) (BitVec.neg_eq_not_add x))
                (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (32#32) (~~~x) 1#32))))
          (funext fun x' =>
            congrArg (bind (some x✝²))
              (funext fun x =>
                ite_congr
                  (Eq.trans
                    (congrArg (And True)
                      (Std.Tactic.BVDecide.Normalize.BitVec.eq_to_beq
                        ((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat) x'))
                    (true_and (((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat == x') = true)))
                  (fun a => Eq.refl none) fun a =>
                  ite_congr
                    (Eq.trans
                      (congrArg (And True)
                        (Std.Tactic.BVDecide.Normalize.BitVec.eq_to_beq
                          (x' <<< (x + 4294967294#32) >>> (x + 4294967294#32)) x'))
                      (true_and ((x' <<< (x + 4294967294#32) >>> (x + 4294967294#32) == x') = true)))
                    (fun a => Eq.refl none) fun a =>
                    ite_congr
                      (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                        (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (32#32) (x + 4294967294#32))
                          (Eq.trans
                            (Eq.trans
                              (congrArg Not (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x + 4294967294#32) 32#32))
                              (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq (32#32 >ᵤ x + 4294967294#32) true))
                            (congrArg (fun x => (!x) = true) (beq_true (32#32 >ᵤ x + 4294967294#32))))))
                      (fun a => Eq.refl none) fun a => Eq.refl (some (x' <<< (x + 4294967294#32)))))
    [Meta.isDefEq.assign] [0.001381] ✅️ ?h₃ := fun a =>
          congr
            (congrArg (fun x => bind (some (x✝ <<< x)))
              (Eq.trans (BitVec.sub_toAdd (32#32) x)
                (Eq.trans (congrArg (HAdd.hAdd 32#32) (BitVec.neg_eq_not_add x))
                  (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (32#32) (~~~x) 1#32))))
            (funext fun x' =>
              congrArg (bind (some x✝²))
                (funext fun x =>
                  ite_congr
                    (Eq.trans
                      (congrArg (And True)
                        (Std.Tactic.BVDecide.Normalize.BitVec.eq_to_beq
                          ((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat) x'))
                      (true_and (((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat == x') = true)))
                    (fun a => Eq.refl none) fun a =>
                    ite_congr
                      (Eq.trans
                        (congrArg (And True)
                          (Std.Tactic.BVDecide.Normalize.BitVec.eq_to_beq
                            (x' <<< (x + 4294967294#32) >>> (x + 4294967294#32)) x'))
                        (true_and ((x' <<< (x + 4294967294#32) >>> (x + 4294967294#32) == x') = true)))
                      (fun a => Eq.refl none) fun a =>
                      ite_congr
                        (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                          (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (32#32) (x + 4294967294#32))
                            (Eq.trans
                              (Eq.trans
                                (congrArg Not (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x + 4294967294#32) 32#32))
                                (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq (32#32 >ᵤ x + 4294967294#32) true))
                              (congrArg (fun x => (!x) = true) (beq_true (32#32 >ᵤ x + 4294967294#32))))))
                        (fun a => Eq.refl none) fun a => Eq.refl (some (x' <<< (x + 4294967294#32)))))
      [Meta.isDefEq.assign.checkTypes] [0.001329] ✅️ (?h₃ : ¬(!32#32 >ᵤ 33#32 + ~~~x) = true →
            (do
                let x' ← some (x✝ <<< (32#32 - x))
                let x ← some x✝²
                if True ∧ (x' <<< (x + BitVec.ofInt 32 (-2))).sshiftRight (x + BitVec.ofInt 32 (-2)).toNat = x' then
                    none
                  else
                    if True ∧ x' <<< (x + BitVec.ofInt 32 (-2)) >>> (x + BitVec.ofInt 32 (-2)) = x' then none
                    else if x + BitVec.ofInt 32 (-2) ≥ ↑32 then none else some (x' <<< (x + BitVec.ofInt 32 (-2)))) =
              do
              let x' ← some (x✝ <<< (33#32 + ~~~x))
              let x ← some x✝²
              if ((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat == x') = true then none
                else
                  if (x' <<< (x + 4294967294#32) >>> (x + 4294967294#32) == x') = true then none
                  else
                    if (!32#32 >ᵤ x + 4294967294#32) = true then none
                    else
                      some
                        (x' <<<
                          (x +
                            4294967294#32))) := (fun a =>
            congr
              (congrArg (fun x => bind (some (x✝ <<< x)))
                (Eq.trans (BitVec.sub_toAdd (32#32) x)
                  (Eq.trans (congrArg (HAdd.hAdd 32#32) (BitVec.neg_eq_not_add x))
                    (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (32#32) (~~~x) 1#32))))
              (funext fun x' =>
                congrArg (bind (some x✝²))
                  (funext fun x =>
                    ite_congr
                      (Eq.trans
                        (congrArg (And True)
                          (Std.Tactic.BVDecide.Normalize.BitVec.eq_to_beq
                            ((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat) x'))
                        (true_and (((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat == x') = true)))
                      (fun a => Eq.refl none) fun a =>
                      ite_congr
                        (Eq.trans
                          (congrArg (And True)
                            (Std.Tactic.BVDecide.Normalize.BitVec.eq_to_beq
                              (x' <<< (x + 4294967294#32) >>> (x + 4294967294#32)) x'))
                          (true_and ((x' <<< (x + 4294967294#32) >>> (x + 4294967294#32) == x') = true)))
                        (fun a => Eq.refl none) fun a =>
                        ite_congr
                          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                            (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (32#32) (x + 4294967294#32))
                              (Eq.trans
                                (Eq.trans
                                  (congrArg Not (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x + 4294967294#32) 32#32))
                                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq (32#32 >ᵤ x + 4294967294#32) true))
                                (congrArg (fun x => (!x) = true) (beq_true (32#32 >ᵤ x + 4294967294#32))))))
                          (fun a => Eq.refl none) fun a =>
                          Eq.refl (some (x' <<< (x + 4294967294#32))))) : ¬(!32#32 >ᵤ 33#32 + ~~~x) = true →
            (do
                let x ← some (x✝ <<< (32#32 - x))
                let x_1 ← some x✝²
                if True ∧ (x <<< (x_1 + BitVec.ofInt 32 (-2))).sshiftRight (x_1 + BitVec.ofInt 32 (-2)).toNat = x then
                    none
                  else
                    if True ∧ x <<< (x_1 + BitVec.ofInt 32 (-2)) >>> (x_1 + BitVec.ofInt 32 (-2)) = x then none
                    else if x_1 + BitVec.ofInt 32 (-2) ≥ ↑32 then none else some (x <<< (x_1 + BitVec.ofInt 32 (-2)))) =
              do
              let x ← some (x✝ <<< (32#32 + 1#32 + ~~~x))
              let x_1 ← some x✝²
              if ((x <<< (x_1 + 4294967294#32)).sshiftRight (x_1 + 4294967294#32).toNat == x) = true then none
                else
                  if (x <<< (x_1 + 4294967294#32) >>> (x_1 + 4294967294#32) == x) = true then none
                  else if (!32#32 >ᵤ x_1 + 4294967294#32) = true then none else some (x <<< (x_1 + 4294967294#32)))
        [Meta.isDefEq] [0.001323] ✅️ ¬(!32#32 >ᵤ 33#32 + ~~~x) = true →
              (do
                  let x' ← some (x✝ <<< (32#32 - x))
                  let x ← some x✝²
                  if True ∧ (x' <<< (x + BitVec.ofInt 32 (-2))).sshiftRight (x + BitVec.ofInt 32 (-2)).toNat = x' then
                      none
                    else
                      if True ∧ x' <<< (x + BitVec.ofInt 32 (-2)) >>> (x + BitVec.ofInt 32 (-2)) = x' then none
                      else if x + BitVec.ofInt 32 (-2) ≥ ↑32 then none else some (x' <<< (x + BitVec.ofInt 32 (-2)))) =
                do
                let x' ← some (x✝ <<< (33#32 + ~~~x))
                let x ← some x✝²
                if ((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat == x') = true then none
                  else
                    if (x' <<< (x + 4294967294#32) >>> (x + 4294967294#32) == x') = true then none
                    else
                      if (!32#32 >ᵤ x + 4294967294#32) = true then none
                      else some (x' <<< (x + 4294967294#32)) =?= ¬(!32#32 >ᵤ 33#32 + ~~~x) = true →
              (do
                  let x ← some (x✝ <<< (32#32 - x))
                  let x_1 ← some x✝²
                  if True ∧ (x <<< (x_1 + BitVec.ofInt 32 (-2))).sshiftRight (x_1 + BitVec.ofInt 32 (-2)).toNat = x then
                      none
                    else
                      if True ∧ x <<< (x_1 + BitVec.ofInt 32 (-2)) >>> (x_1 + BitVec.ofInt 32 (-2)) = x then none
                      else
                        if x_1 + BitVec.ofInt 32 (-2) ≥ ↑32 then none else some (x <<< (x_1 + BitVec.ofInt 32 (-2)))) =
                do
                let x ← some (x✝ <<< (32#32 + 1#32 + ~~~x))
                let x_1 ← some x✝²
                if ((x <<< (x_1 + 4294967294#32)).sshiftRight (x_1 + 4294967294#32).toNat == x) = true then none
                  else
                    if (x <<< (x_1 + 4294967294#32) >>> (x_1 + 4294967294#32) == x) = true then none
                    else if (!32#32 >ᵤ x_1 + 4294967294#32) = true then none else some (x <<< (x_1 + 4294967294#32))
          [Meta.isDefEq] [0.001273] ✅️ (do
                  let x' ← some (x✝ <<< (32#32 - x))
                  let x ← some x✝²
                  if True ∧ (x' <<< (x + BitVec.ofInt 32 (-2))).sshiftRight (x + BitVec.ofInt 32 (-2)).toNat = x' then
                      none
                    else
                      if True ∧ x' <<< (x + BitVec.ofInt 32 (-2)) >>> (x + BitVec.ofInt 32 (-2)) = x' then none
                      else if x + BitVec.ofInt 32 (-2) ≥ ↑32 then none else some (x' <<< (x + BitVec.ofInt 32 (-2)))) =
                do
                let x' ← some (x✝ <<< (33#32 + ~~~x))
                let x ← some x✝²
                if ((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat == x') = true then none
                  else
                    if (x' <<< (x + 4294967294#32) >>> (x + 4294967294#32) == x') = true then none
                    else
                      if (!32#32 >ᵤ x + 4294967294#32) = true then none else some (x' <<< (x + 4294967294#32)) =?= (do
                  let x ← some (x✝ <<< (32#32 - x))
                  let x_1 ← some x✝²
                  if True ∧ (x <<< (x_1 + BitVec.ofInt 32 (-2))).sshiftRight (x_1 + BitVec.ofInt 32 (-2)).toNat = x then
                      none
                    else
                      if True ∧ x <<< (x_1 + BitVec.ofInt 32 (-2)) >>> (x_1 + BitVec.ofInt 32 (-2)) = x then none
                      else
                        if x_1 + BitVec.ofInt 32 (-2) ≥ ↑32 then none else some (x <<< (x_1 + BitVec.ofInt 32 (-2)))) =
                do
                let x ← some (x✝ <<< (32#32 + 1#32 + ~~~x))
                let x_1 ← some x✝²
                if ((x <<< (x_1 + 4294967294#32)).sshiftRight (x_1 + 4294967294#32).toNat == x) = true then none
                  else
                    if (x <<< (x_1 + 4294967294#32) >>> (x_1 + 4294967294#32) == x) = true then none
                    else if (!32#32 >ᵤ x_1 + 4294967294#32) = true then none else some (x <<< (x_1 + 4294967294#32))
            [Meta.isDefEq] [0.001229] ✅️ do
                  let x' ← some (x✝ <<< (33#32 + ~~~x))
                  let x ← some x✝²
                  if ((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat == x') = true then none
                    else
                      if (x' <<< (x + 4294967294#32) >>> (x + 4294967294#32) == x') = true then none
                      else
                        if (!32#32 >ᵤ x + 4294967294#32) = true then none else some (x' <<< (x + 4294967294#32)) =?= do
                  let x ← some (x✝ <<< (32#32 + 1#32 + ~~~x))
                  let x_1 ← some x✝²
                  if ((x <<< (x_1 + 4294967294#32)).sshiftRight (x_1 + 4294967294#32).toNat == x) = true then none
                    else
                      if (x <<< (x_1 + 4294967294#32) >>> (x_1 + 4294967294#32) == x) = true then none
                      else if (!32#32 >ᵤ x_1 + 4294967294#32) = true then none else some (x <<< (x_1 + 4294967294#32))
              [Meta.isDefEq] [0.001198] ✅️ Monad.toBind.1 (some (x✝ <<< (33#32 + ~~~x))) fun x' => do
                    let x ← some x✝²
                    if ((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat == x') = true then none
                      else
                        if (x' <<< (x + 4294967294#32) >>> (x + 4294967294#32) == x') = true then none
                        else
                          if (!32#32 >ᵤ x + 4294967294#32) = true then none
                          else
                            some
                              (x' <<<
                                (x +
                                  4294967294#32)) =?= Monad.toBind.1 (some (x✝ <<< (32#32 + 1#32 + ~~~x))) fun x => do
                    let x_1 ← some x✝²
                    if ((x <<< (x_1 + 4294967294#32)).sshiftRight (x_1 + 4294967294#32).toNat == x) = true then none
                      else
                        if (x <<< (x_1 + 4294967294#32) >>> (x_1 + 4294967294#32) == x) = true then none
                        else if (!32#32 >ᵤ x_1 + 4294967294#32) = true then none else some (x <<< (x_1 + 4294967294#32))
                [Meta.isDefEq] [0.001124] ✅️ (some (x✝ <<< (33#32 + ~~~x))).bind fun x' => do
                      let x ← some x✝²
                      if ((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat == x') = true then none
                        else
                          if (x' <<< (x + 4294967294#32) >>> (x + 4294967294#32) == x') = true then none
                          else
                            if (!32#32 >ᵤ x + 4294967294#32) = true then none
                            else
                              some
                                (x' <<< (x + 4294967294#32)) =?= (some (x✝ <<< (32#32 + 1#32 + ~~~x))).bind fun x => do
                      let x_1 ← some x✝²
                      if ((x <<< (x_1 + 4294967294#32)).sshiftRight (x_1 + 4294967294#32).toNat == x) = true then none
                        else
                          if (x <<< (x_1 + 4294967294#32) >>> (x_1 + 4294967294#32) == x) = true then none
                          else
                            if (!32#32 >ᵤ x_1 + 4294967294#32) = true then none else some (x <<< (x_1 + 4294967294#32))
                  [Meta.isDefEq.delta] [0.001105] ✅️ (some (x✝ <<< (33#32 + ~~~x))).bind fun x' => do
                        let x ← some x✝²
                        if ((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat == x') = true then none
                          else
                            if (x' <<< (x + 4294967294#32) >>> (x + 4294967294#32) == x') = true then none
                            else
                              if (!32#32 >ᵤ x + 4294967294#32) = true then none
                              else
                                some
                                  (x' <<<
                                    (x + 4294967294#32)) =?= (some (x✝ <<< (32#32 + 1#32 + ~~~x))).bind fun x => do
                        let x_1 ← some x✝²
                        if ((x <<< (x_1 + 4294967294#32)).sshiftRight (x_1 + 4294967294#32).toNat == x) = true then none
                          else
                            if (x <<< (x_1 + 4294967294#32) >>> (x_1 + 4294967294#32) == x) = true then none
                            else
                              if (!32#32 >ᵤ x_1 + 4294967294#32) = true then none
                              else some (x <<< (x_1 + 4294967294#32))
                    [Meta.isDefEq] [0.001080] ✅️ some (x✝ <<< (33#32 + ~~~x)) =?= some (x✝ <<< (32#32 + 1#32 + ~~~x))
                      [Meta.isDefEq] [0.001058] ✅️ x✝ <<< (33#32 + ~~~x) =?= x✝ <<< (32#32 + 1#32 + ~~~x)
                        [Meta.isDefEq] [0.001004] ✅️ BitVec.instHShiftLeft.1 x✝
                              (33#32 + ~~~x) =?= BitVec.instHShiftLeft.1 x✝ (32#32 + 1#32 + ~~~x)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(do
              let x ← some x✝
              let x_1 ← some x✝¹
              if ((x <<< (33#32 + ~~~x_1)).sshiftRight (33#32 + ~~~x_1).toNat == x) = true then none
                else
                  if (!32#32 >ᵤ 33#32 + ~~~x_1) = true then none
                  else do
                    let x' ← some (x <<< (33#32 + ~~~x_1))
                    let x ← some x✝¹
                    if ((x' <<< (x + 4294967294#32)).sshiftRight (x + 4294967294#32).toNat == x') = true then none
                      else
                        if (x' <<< (x + 4294967294#32) >>> (x + 4294967294#32) == x') = true then none
                        else if (!32#32 >ᵤ x + 4294967294#32) = true then none else some (x' <<< (x + 4294967294#32))) ⊑
            do
            let x' ← some x✝
            if ((x' <<< 30).sshiftRight 30 == x') = true then none else some (x' <<< 30)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
