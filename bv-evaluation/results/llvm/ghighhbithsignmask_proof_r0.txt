⚠ [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
⚠ [849/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
⚠ [883/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [886/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
⚠ [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
Bitwuzla proved the goal after 0.934640ms, solving context: 0.000000ms
LeanSAT proved the goal after 4.426599ms: rewriting 4.372189ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 89.607489ms, solving context: 3.000000ms
LeanSAT proved the goal after 107.576450ms: rewriting 28.111990ms, bitblasting 0.000000ms, SAT solving 57.756790ms, LRAT trimming 2.840810ms, LRAT checking 13.639810ms
Bitwuzla proved the goal after 0.583870ms, solving context: 0.000000ms
LeanSAT proved the goal after 3.480290ms: rewriting 3.463120ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 77.169739ms, solving context: 0.000000ms
LeanSAT proved the goal after 86.379179ms: rewriting 22.587949ms, bitblasting 0.000000ms, SAT solving 55.026900ms, LRAT trimming 1.282980ms, LRAT checking 4.433720ms
Bitwuzla proved the goal after 0.727930ms, solving context: 0.000000ms
LeanSAT proved the goal after 3.376660ms: rewriting 3.358150ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 79.936309ms, solving context: 2.000000ms
LeanSAT proved the goal after 140.334650ms: rewriting 24.158990ms, bitblasting 0.000000ms, SAT solving 108.619950ms, LRAT trimming 0.000000ms, LRAT checking 3.561010ms
Bitwuzla proved the goal after 0.709030ms, solving context: 0.000000ms
LeanSAT proved the goal after 3.471240ms: rewriting 3.454570ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 80.728100ms, solving context: 1.000000ms
LeanSAT proved the goal after 90.323430ms: rewriting 21.512690ms, bitblasting 0.000000ms, SAT solving 57.401420ms, LRAT trimming 1.062120ms, LRAT checking 8.882050ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/ghighhbithsignmask_proof.lean:54:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/ghighhbithsignmask_proof.lean:47:8: error: (kernel) declaration has metavariables 'n9_thm'
[bv] [0.037370] Normalizing goal
  [Meta.synthInstance] [0.001357] ✅️ Decidable
        ((if 62#64 ≥ ↑64 then none else some (0#64 - x✝ >>> 62#64)) ⊑
          if 62#64 ≥ ↑64 then none
          else
            if
                True ∧
                  (BitVec.signExtend (64 + 1) 0#64 - BitVec.signExtend (64 + 1) (x✝ >>> 62#64)).msb ≠
                    (BitVec.signExtend (64 + 1) 0#64 - BitVec.signExtend (64 + 1) (x✝ >>> 62#64)).getMsbD 1 then
              none
            else some (0#64 - x✝ >>> 62#64))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      x✝ : BitVec 64
      a✝ :
        ¬(if 62#64 ≥ ↑64 then none else some (0#64 - x✝ >>> 62#64)) ⊑
            if 62#64 ≥ ↑64 then none
            else
              if
                  True ∧
                    (BitVec.signExtend (64 + 1) 0#64 - BitVec.signExtend (64 + 1) (x✝ >>> 62#64)).msb ≠
                      (BitVec.signExtend (64 + 1) 0#64 - BitVec.signExtend (64 + 1) (x✝ >>> 62#64)).getMsbD 1 then
                none
              else some (0#64 - x✝ >>> 62#64)
      ⊢ False
  [Meta.isDefEq] [0.003659] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (congr
              (congrArg Ne
                (Eq.trans
                  (congrArg BitVec.msb
                    (Eq.trans (BitVec.sub_toAdd (0#65) (BitVec.signExtend 65 (x✝ >>> 62)))
                      (Eq.trans (congrArg (HAdd.hAdd 0#65) (BitVec.neg_eq_not_add (BitVec.signExtend 65 (x✝ >>> 62))))
                        (BitVec.zero_add (~~~BitVec.signExtend 65 (x✝ >>> 62) + 1#65)))))
                  (BitVec.msb_eq_getLsbD_last (~~~BitVec.signExtend 65 (x✝ >>> 62) + 1#65))))
              (congrArg (fun x => x.getMsbD 1)
                (Eq.trans (BitVec.sub_toAdd (0#65) (BitVec.signExtend 65 (x✝ >>> 62)))
                  (Eq.trans (congrArg (HAdd.hAdd 0#65) (BitVec.neg_eq_not_add (BitVec.signExtend 65 (x✝ >>> 62))))
                    (BitVec.zero_add (~~~BitVec.signExtend 65 (x✝ >>> 62) + 1#65))))))
            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq ((~~~BitVec.signExtend 65 (x✝ >>> 62) + 1#65).getLsbD 64)
              ((~~~BitVec.signExtend 65 (x✝ >>> 62) + 1#65).getMsbD 1))))
        (true_and
          ((!(~~~BitVec.signExtend 65 (x✝ >>> 62) + 1#65).getLsbD 64 ==
                (~~~BitVec.signExtend 65 (x✝ >>> 62) + 1#65).getMsbD 1) =
            true))
    [Meta.isDefEq.assign] [0.003657] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (congr
                (congrArg Ne
                  (Eq.trans
                    (congrArg BitVec.msb
                      (Eq.trans (BitVec.sub_toAdd (0#65) (BitVec.signExtend 65 (x✝ >>> 62)))
                        (Eq.trans (congrArg (HAdd.hAdd 0#65) (BitVec.neg_eq_not_add (BitVec.signExtend 65 (x✝ >>> 62))))
                          (BitVec.zero_add (~~~BitVec.signExtend 65 (x✝ >>> 62) + 1#65)))))
                    (BitVec.msb_eq_getLsbD_last (~~~BitVec.signExtend 65 (x✝ >>> 62) + 1#65))))
                (congrArg (fun x => x.getMsbD 1)
                  (Eq.trans (BitVec.sub_toAdd (0#65) (BitVec.signExtend 65 (x✝ >>> 62)))
                    (Eq.trans (congrArg (HAdd.hAdd 0#65) (BitVec.neg_eq_not_add (BitVec.signExtend 65 (x✝ >>> 62))))
                      (BitVec.zero_add (~~~BitVec.signExtend 65 (x✝ >>> 62) + 1#65))))))
              (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq ((~~~BitVec.signExtend 65 (x✝ >>> 62) + 1#65).getLsbD 64)
                ((~~~BitVec.signExtend 65 (x✝ >>> 62) + 1#65).getMsbD 1))))
          (true_and
            ((!(~~~BitVec.signExtend 65 (x✝ >>> 62) + 1#65).getLsbD 64 ==
                  (~~~BitVec.signExtend 65 (x✝ >>> 62) + 1#65).getMsbD 1) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.003635] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (64 + 1) 0#64 - BitVec.signExtend (64 + 1) (x✝ >>> 62#64)).msb ≠
                (BitVec.signExtend (64 + 1) 0#64 - BitVec.signExtend (64 + 1) (x✝ >>> 62#64)).getMsbD 1) =
            ((!(~~~BitVec.signExtend 65 (x✝ >>> 62) + 1#65).getLsbD 64 ==
                  (~~~BitVec.signExtend 65 (x✝ >>> 62) + 1#65).getMsbD 1) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (congr
                  (congrArg Ne
                    (Eq.trans
                      (congrArg BitVec.msb
                        (Eq.trans (BitVec.sub_toAdd (0#65) (BitVec.signExtend 65 (x✝ >>> 62)))
                          (Eq.trans
                            (congrArg (HAdd.hAdd 0#65) (BitVec.neg_eq_not_add (BitVec.signExtend 65 (x✝ >>> 62))))
                            (BitVec.zero_add (~~~BitVec.signExtend 65 (x✝ >>> 62) + 1#65)))))
                      (BitVec.msb_eq_getLsbD_last (~~~BitVec.signExtend 65 (x✝ >>> 62) + 1#65))))
                  (congrArg (fun x => x.getMsbD 1)
                    (Eq.trans (BitVec.sub_toAdd (0#65) (BitVec.signExtend 65 (x✝ >>> 62)))
                      (Eq.trans (congrArg (HAdd.hAdd 0#65) (BitVec.neg_eq_not_add (BitVec.signExtend 65 (x✝ >>> 62))))
                        (BitVec.zero_add (~~~BitVec.signExtend 65 (x✝ >>> 62) + 1#65))))))
                (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq ((~~~BitVec.signExtend 65 (x✝ >>> 62) + 1#65).getLsbD 64)
                  ((~~~BitVec.signExtend 65 (x✝ >>> 62) + 1#65).getMsbD 1))))
            (true_and
              ((!(~~~BitVec.signExtend 65 (x✝ >>> 62) + 1#65).getLsbD 64 ==
                    (~~~BitVec.signExtend 65 (x✝ >>> 62) + 1#65).getMsbD 1) =
                true)) : (True ∧
              (0#65 - BitVec.signExtend 65 (x✝ >>> 62)).msb ≠ (0#65 - BitVec.signExtend 65 (x✝ >>> 62)).getMsbD 1) =
            ((!(~~~BitVec.signExtend 65 (x✝ >>> 62) + 1#65).getLsbD 64 ==
                  (~~~BitVec.signExtend 65 (x✝ >>> 62) + 1#65).getMsbD 1) =
              true))
        [Meta.isDefEq] [0.003632] ✅️ (True ∧
                (BitVec.signExtend (64 + 1) 0#64 - BitVec.signExtend (64 + 1) (x✝ >>> 62#64)).msb ≠
                  (BitVec.signExtend (64 + 1) 0#64 - BitVec.signExtend (64 + 1) (x✝ >>> 62#64)).getMsbD 1) =
              ((!(~~~BitVec.signExtend 65 (x✝ >>> 62) + 1#65).getLsbD 64 ==
                    (~~~BitVec.signExtend 65 (x✝ >>> 62) + 1#65).getMsbD 1) =
                true) =?= (True ∧
                (0#65 - BitVec.signExtend 65 (x✝ >>> 62)).msb ≠ (0#65 - BitVec.signExtend 65 (x✝ >>> 62)).getMsbD 1) =
              ((!(~~~BitVec.signExtend 65 (x✝ >>> 62) + 1#65).getLsbD 64 ==
                    (~~~BitVec.signExtend 65 (x✝ >>> 62) + 1#65).getMsbD 1) =
                true)
          [Meta.isDefEq] [0.003611] ✅️ True ∧
                (BitVec.signExtend (64 + 1) 0#64 - BitVec.signExtend (64 + 1) (x✝ >>> 62#64)).msb ≠
                  (BitVec.signExtend (64 + 1) 0#64 - BitVec.signExtend (64 + 1) (x✝ >>> 62#64)).getMsbD
                    1 =?= True ∧
                (0#65 - BitVec.signExtend 65 (x✝ >>> 62)).msb ≠ (0#65 - BitVec.signExtend 65 (x✝ >>> 62)).getMsbD 1
            [Meta.isDefEq] [0.003595] ✅️ (BitVec.signExtend (64 + 1) 0#64 -
                      BitVec.signExtend (64 + 1) (x✝ >>> 62#64)).msb ≠
                  (BitVec.signExtend (64 + 1) 0#64 - BitVec.signExtend (64 + 1) (x✝ >>> 62#64)).getMsbD
                    1 =?= (0#65 - BitVec.signExtend 65 (x✝ >>> 62)).msb ≠
                  (0#65 - BitVec.signExtend 65 (x✝ >>> 62)).getMsbD 1
              [Meta.isDefEq.delta] [0.003581] ✅️ (BitVec.signExtend (64 + 1) 0#64 -
                        BitVec.signExtend (64 + 1) (x✝ >>> 62#64)).msb ≠
                    (BitVec.signExtend (64 + 1) 0#64 - BitVec.signExtend (64 + 1) (x✝ >>> 62#64)).getMsbD
                      1 =?= (0#65 - BitVec.signExtend 65 (x✝ >>> 62)).msb ≠
                    (0#65 - BitVec.signExtend 65 (x✝ >>> 62)).getMsbD 1
                [Meta.isDefEq] [0.003521] ✅️ (BitVec.signExtend (64 + 1) 0#64 -
                        BitVec.signExtend (64 + 1) (x✝ >>> 62#64)).msb =?= (0#65 - BitVec.signExtend 65 (x✝ >>> 62)).msb
                  [Meta.isDefEq.delta] [0.003510] ✅️ (BitVec.signExtend (64 + 1) 0#64 -
                          BitVec.signExtend (64 + 1)
                            (x✝ >>> 62#64)).msb =?= (0#65 - BitVec.signExtend 65 (x✝ >>> 62)).msb
                    [Meta.isDefEq] [0.003489] ✅️ BitVec.signExtend (64 + 1) 0#64 -
                          BitVec.signExtend (64 + 1) (x✝ >>> 62#64) =?= 0#65 - BitVec.signExtend 65 (x✝ >>> 62)
                      [Meta.isDefEq] [0.003461] ✅️ instHSub.1 (BitVec.signExtend (64 + 1) 0#64)
                            (BitVec.signExtend (64 + 1)
                              (x✝ >>> 62#64)) =?= instHSub.1 (0#65) (BitVec.signExtend 65 (x✝ >>> 62))
                        [Meta.isDefEq] [0.003400] ✅️ Sub.sub (BitVec.signExtend (64 + 1) 0#64)
                              (BitVec.signExtend (64 + 1)
                                (x✝ >>> 62#64)) =?= Sub.sub (0#65) (BitVec.signExtend 65 (x✝ >>> 62))
                          [Meta.isDefEq] [0.003377] ✅️ BitVec.instSub.1 (BitVec.signExtend (64 + 1) 0#64)
                                (BitVec.signExtend (64 + 1)
                                  (x✝ >>> 62#64)) =?= BitVec.instSub.1 (0#65) (BitVec.signExtend 65 (x✝ >>> 62))
                            [Meta.isDefEq] [0.003335] ✅️ (BitVec.signExtend (64 + 1) 0#64).sub
                                  (BitVec.signExtend (64 + 1)
                                    (x✝ >>> 62#64)) =?= (0#65).sub (BitVec.signExtend 65 (x✝ >>> 62))
                              [Meta.isDefEq.delta] [0.003325] ✅️ (BitVec.signExtend (64 + 1) 0#64).sub
                                    (BitVec.signExtend (64 + 1)
                                      (x✝ >>> 62#64)) =?= (0#65).sub (BitVec.signExtend 65 (x✝ >>> 62))
                                [Meta.isDefEq] [0.002932] ✅️ BitVec.signExtend (64 + 1) 0#64 =?= 0#65
                                  [Meta.isDefEq] [0.002911] ✅️ BitVec.ofInt (64 + 1) (0#64).toInt =?= 0#65
                                    [Meta.isDefEq] [0.002889] ✅️ ((0#64).toInt %
                                              Int.ofNat (2 ^ (64 + 1))).toNat#'⋯ =?= 0#65
                                      [Meta.isDefEq] [0.002858] ✅️ ((0#64).toInt %
                                                Int.ofNat
                                                  (2 ^ (64 + 1))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 65) 0 }
                                        [Meta.isDefEq] [0.002839] ✅️ {
                                              toFin :=
                                                ⟨((0#64).toInt % Int.ofNat (2 ^ (64 + 1))).toNat,
                                                  ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 65) 0 }
                                          [Meta.isDefEq] [0.002777] ✅️ ⟨((0#64).toInt % Int.ofNat (2 ^ (64 + 1))).toNat,
                                                ⋯⟩ =?= Fin.ofNat' (2 ^ 65) 0
                                            [Meta.isDefEq] [0.002759] ✅️ ⟨((0#64).toInt %
                                                      Int.ofNat (2 ^ (64 + 1))).toNat,
                                                  ⋯⟩ =?= ⟨0 % 2 ^ 65, ⋯⟩
                                              [Meta.isDefEq] [0.002656] ✅️ ((0#64).toInt %
                                                      Int.ofNat (2 ^ (64 + 1))).toNat =?= 0 % 2 ^ 65
                                                [Meta.isDefEq] [0.002553] ✅️ match
                                                      (0#64).toInt % Int.ofNat (2 ^ (64 + 1)) with
                                                    | Int.ofNat n => n
                                                    | Int.negSucc a => 0 =?= 0 % 2 ^ 65
                                                  [Meta.isDefEq] [0.001796] ✅️ (0#64).toNat %
                                                        (Int.ofNat (2 ^ (64 + 1))).natAbs =?= 0 % 2 ^ 65
                                                    [Meta.isDefEq] [0.001756] ✅️ instHMod.1 (0#64).toNat
                                                          (Int.ofNat (2 ^ (64 + 1))).natAbs =?= instHMod.1 0 (2 ^ 65)
                                                      [Meta.isDefEq] [0.001685] ✅️ Mod.mod (0#64).toNat
                                                            (Int.ofNat (2 ^ (64 + 1))).natAbs =?= Mod.mod 0 (2 ^ 65)
                                                        [Meta.isDefEq] [0.001656] ✅️ Nat.instMod.1 (0#64).toNat
                                                              (Int.ofNat
                                                                  (2 ^ (64 + 1))).natAbs =?= Nat.instMod.1 0 (2 ^ 65)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      x✝ : BitVec 64
      a✝ :
        ¬some (~~~(x✝ >>> 62) + 1#64) ⊑
            if
                (!(~~~BitVec.signExtend 65 (x✝ >>> 62) + 1#65).getLsbD 64 ==
                      (~~~BitVec.signExtend 65 (x✝ >>> 62) + 1#65).getMsbD 1) =
                  true then
              none
            else some (~~~(x✝ >>> 62) + 1#64)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/ghighhbithsignmask_proof.lean:64:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/ghighhbithsignmask_proof.lean:58:8: error: (kernel) declaration has metavariables 'n10_thm'
[bv] [0.028436] Normalizing goal
  [Meta.synthInstance] [0.001334] ✅️ Decidable
        ((if 63#64 ≥ ↑64 then none else some (1#64 - x✝ >>> 63#64)) ⊑
          some (BitVec.zeroExtend 64 (BitVec.ofBool (x✝ >ₛ -1#64))))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      x✝ : BitVec 64
      a✝ :
        ¬(if 63#64 ≥ ↑64 then none else some (1#64 - x✝ >>> 63#64)) ⊑
            some (BitVec.zeroExtend 64 (BitVec.ofBool (x✝ >ₛ -1#64)))
      ⊢ False
  [Meta.appBuilder] [0.001143] ✅️ f: Eq.mp, xs: [congrArg Not
         (congr
           (congrArg BitVec.Refinement
             (Eq.trans
               (ite_cond_eq_false none (some (1#64 - x✝ >>> 63#64))
                 (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                   (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 64#64 63#64)
                     (Eq.trans
                       (congrArg Not
                         (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 63#64 64#64) (eq_self true)))
                       Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
               (congrArg some
                 (Eq.trans (BitVec.sub_toAdd (1#64) (x✝ >>> 63))
                   (Eq.trans (congrArg (HAdd.hAdd 1#64) (BitVec.neg_eq_not_add (x✝ >>> 63)))
                     (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (1#64) (~~~(x✝ >>> 63)) 1#64))))))
           (congrArg (fun x => some (BitVec.zeroExtend 64 x))
             (Eq.trans
               (congrArg BitVec.ofBool
                 (Eq.trans (BitVec.slt_eq_ult (18446744073709551615#64) x✝)
                   (Eq.trans
                     (Eq.trans
                       (congr
                         (congrArg xor
                           (Eq.trans
                             (Eq.trans
                               (congr (congrArg bne (BitVec.msb_eq_getLsbD_last 18446744073709551615#64))
                                 (BitVec.msb_eq_getLsbD_last x✝))
                               (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq true (x✝.getLsbD 63)))
                             (congrArg not (Bool.true_beq (x✝.getLsbD 63)))))
                         (Std.Tactic.BVDecide.Normalize.BitVec.max_ult' x✝))
                       (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (!x✝.getLsbD 63) false))
                     (congrArg not (Eq.trans (beq_false !x✝.getLsbD 63) (Bool.not_not (x✝.getLsbD 63)))))))
               (Std.Tactic.BVDecide.Normalize.BitVec.ofBool_eq_if !x✝.getLsbD 63)))),
       a✝]
    [Meta.isDefEq] [0.001026] ✅️ ¬(if 63#64 ≥ ↑64 then none else some (1#64 - x✝ >>> 63#64)) ⊑
            some
              (BitVec.zeroExtend 64
                (BitVec.ofBool
                  (x✝ >ₛ
                    18446744073709551615#64))) =?= ¬(if 63#64 ≥ ↑64 then none else some (1#64 - x✝ >>> 63#64)) ⊑
            some (BitVec.zeroExtend 64 (BitVec.ofBool (x✝ >ₛ -1#64)))
      [Meta.isDefEq] [0.001007] ✅️ ¬(if 63#64 ≥ ↑64 then none else some (1#64 - x✝ >>> 63#64)) ⊑
              some
                (BitVec.zeroExtend 64
                  (BitVec.ofBool
                    (x✝ >ₛ
                      18446744073709551615#64))) =?= ¬(if 63#64 ≥ ↑64 then none else some (1#64 - x✝ >>> 63#64)) ⊑
              some (BitVec.zeroExtend 64 (BitVec.ofBool (x✝ >ₛ -1#64)))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      x✝ : BitVec 64
      a✝ : ¬some (2#64 + ~~~(x✝ >>> 63)) ⊑ some (BitVec.zeroExtend 64 (if (!x✝.getLsbD 63) = true then 1#1 else 0#1))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
