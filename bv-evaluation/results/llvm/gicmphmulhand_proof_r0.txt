⚠ [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
⚠ [878/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [881/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
⚠ [887/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
⚠ [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
Bitwuzla proved the goal after 102.936390ms, solving context: 0.000000ms
LeanSAT proved the goal after 100.231779ms: rewriting 28.164309ms, bitblasting 0.000000ms, SAT solving 56.242950ms, LRAT trimming 0.000000ms, LRAT checking 7.017890ms
Bitwuzla proved the goal after 127.258549ms, solving context: 1.000000ms
LeanSAT proved the goal after 131.118750ms: rewriting 47.915650ms, bitblasting 0.000000ms, SAT solving 59.007360ms, LRAT trimming 0.000000ms, LRAT checking 11.823160ms
Bitwuzla proved the goal after 97.883090ms, solving context: 1.000000ms
LeanSAT proved the goal after 104.043240ms: rewriting 31.343640ms, bitblasting 0.000000ms, SAT solving 59.011960ms, LRAT trimming 0.000000ms, LRAT checking 5.010120ms
Bitwuzla proved the goal after 98.105420ms, solving context: 1.000000ms
LeanSAT proved the goal after 97.103679ms: rewriting 24.797930ms, bitblasting 0.000000ms, SAT solving 58.228280ms, LRAT trimming 0.000000ms, LRAT checking 5.165421ms
Bitwuzla proved the goal after 89.118240ms, solving context: 0.000000ms
LeanSAT proved the goal after 111.051229ms: rewriting 25.940810ms, bitblasting 0.000000ms, SAT solving 58.149690ms, LRAT trimming 0.000000ms, LRAT checking 12.457940ms
Bitwuzla proved the goal after 95.132050ms, solving context: 2.000000ms
LeanSAT proved the goal after 294.375289ms: rewriting 25.693430ms, bitblasting 8.758270ms, SAT solving 108.606179ms, LRAT trimming 0.000000ms, LRAT checking 125.868830ms
Bitwuzla proved the goal after 95.832209ms, solving context: 5.000000ms
LeanSAT proved the goal after 212.251010ms: rewriting 25.315620ms, bitblasting 38.787550ms, SAT solving 109.917730ms, LRAT trimming 0.000000ms, LRAT checking 26.253190ms
Bitwuzla proved the goal after 95.935520ms, solving context: 1.000000ms
LeanSAT proved the goal after 181.777160ms: rewriting 23.443860ms, bitblasting 9.337320ms, SAT solving 108.366969ms, LRAT trimming 0.000000ms, LRAT checking 28.237320ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmulhand_proof.lean:105:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmulhand_proof.lean:99:8: error: (kernel) declaration has metavariables 'pr40493_neg3_thm'
[bv] [0.010290] Normalizing goal
  [Meta.synthInstance] [0.001156] ✅️ Decidable
        (some (x✝ * 12#32 &&& 4#32) ⊑ if 2#32 ≥ ↑32 then none else some (x✝ <<< 2#32 &&& 4#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ : ¬some (x✝ * 12#32 &&& 4#32) ⊑ if 2#32 ≥ ↑32 then none else some (x✝ <<< 2#32 &&& 4#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ : ¬some (x✝ * 12#32 &&& 4#32) ⊑ some (x✝ <<< 2 &&& 4#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmulhand_proof.lean:119:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmulhand_proof.lean:109:8: error: (kernel) declaration has metavariables 'pr51551_thm'
[bv] [0.036646] Normalizing goal
  [Meta.synthInstance] [0.001494] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 32) (x✝ &&& 4294967289#32 ||| 1#32) * BitVec.signExtend (2 * 32) x✝¹ <
                    BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                  BitVec.signExtend (2 * 32) (x✝ &&& 4294967289#32 ||| 1#32) * BitVec.signExtend (2 * 32) x✝¹ ≥
                    BitVec.twoPow (2 * 32) (32 - 1)) then
            none
          else some (BitVec.ofBool ((x✝ &&& 4294967289#32 ||| 1#32) * x✝¹ &&& 3#32 == 0#32))) ⊑
          some (BitVec.ofBool (x✝¹ &&& 3#32 == 0#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 32) (x✝ &&& 4294967289#32 ||| 1#32) * BitVec.signExtend (2 * 32) x✝¹ <
                      BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                    BitVec.signExtend (2 * 32) (x✝ &&& 4294967289#32 ||| 1#32) * BitVec.signExtend (2 * 32) x✝¹ ≥
                      BitVec.twoPow (2 * 32) (32 - 1)) then
              none
            else some (BitVec.ofBool ((x✝ &&& 4294967289#32 ||| 1#32) * x✝¹ &&& 3#32 == 0#32))) ⊑
            some (BitVec.ofBool (x✝¹ &&& 3#32 == 0#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                          BitVec.signExtend 64 (x✝ &&& 4294967289#32 ||| 1#32) * BitVec.signExtend 64 x✝¹) &&
                      BitVec.twoPow 64 31 >ᵤ
                        BitVec.signExtend 64 (x✝ &&& 4294967289#32 ||| 1#32) * BitVec.signExtend 64 x✝¹)) =
                  true then
              none
            else some (if ((x✝ &&& 4294967289#32 ||| 1#32) * x✝¹ &&& 3#32 == 0#32) = true then 1#1 else 0#1)) ⊑
            some (if (x✝¹ &&& 3#32 == 0#32) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmulhand_proof.lean:133:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmulhand_proof.lean:123:8: error: (kernel) declaration has metavariables 'pr51551_2_thm'
[bv] [0.038235] Normalizing goal
  [Meta.synthInstance] [0.002462] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 32) (x✝ &&& 4294967289#32 ||| 1#32) * BitVec.signExtend (2 * 32) x✝¹ <
                    BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                  BitVec.signExtend (2 * 32) (x✝ &&& 4294967289#32 ||| 1#32) * BitVec.signExtend (2 * 32) x✝¹ ≥
                    BitVec.twoPow (2 * 32) (32 - 1)) then
            none
          else some (BitVec.ofBool ((x✝ &&& 4294967289#32 ||| 1#32) * x✝¹ &&& 1#32 == 0#32))) ⊑
          some (BitVec.ofBool (x✝¹ &&& 1#32 == 0#32)))
    [Meta.check] [0.001459] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if
              True ∧
                (BitVec.signExtend (2 * 32) (x✝ &&& 4294967289#32 ||| 1#32) * BitVec.signExtend (2 * 32) x✝¹ <
                    BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                  BitVec.signExtend (2 * 32) (x✝ &&& 4294967289#32 ||| 1#32) * BitVec.signExtend (2 * 32) x✝¹ ≥
                    BitVec.twoPow (2 * 32) (32 - 1)) then
            none
          else some (BitVec.ofBool ((x✝ &&& 4294967289#32 ||| 1#32) * x✝¹ &&& 1#32 == 0#32)))
          (some (BitVec.ofBool (x✝¹ &&& 1#32 == 0#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 32) (x✝ &&& 4294967289#32 ||| 1#32) * BitVec.signExtend (2 * 32) x✝¹ <
                      BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                    BitVec.signExtend (2 * 32) (x✝ &&& 4294967289#32 ||| 1#32) * BitVec.signExtend (2 * 32) x✝¹ ≥
                      BitVec.twoPow (2 * 32) (32 - 1)) then
              none
            else some (BitVec.ofBool ((x✝ &&& 4294967289#32 ||| 1#32) * x✝¹ &&& 1#32 == 0#32))) ⊑
            some (BitVec.ofBool (x✝¹ &&& 1#32 == 0#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                          BitVec.signExtend 64 (x✝ &&& 4294967289#32 ||| 1#32) * BitVec.signExtend 64 x✝¹) &&
                      BitVec.twoPow 64 31 >ᵤ
                        BitVec.signExtend 64 (x✝ &&& 4294967289#32 ||| 1#32) * BitVec.signExtend 64 x✝¹)) =
                  true then
              none
            else some (if ((x✝ &&& 4294967289#32 ||| 1#32) * x✝¹ &&& 1#32 == 0#32) = true then 1#1 else 0#1)) ⊑
            some (if (x✝¹ &&& 1#32 == 0#32) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmulhand_proof.lean:148:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmulhand_proof.lean:137:8: error: (kernel) declaration has metavariables 'pr51551_neg1_thm'
[bv] [0.037590] Normalizing goal
  [Meta.synthInstance] [0.001516] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 32) (x✝ &&& 4294967293#32 ||| 1#32) * BitVec.signExtend (2 * 32) x✝¹ <
                    BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                  BitVec.signExtend (2 * 32) (x✝ &&& 4294967293#32 ||| 1#32) * BitVec.signExtend (2 * 32) x✝¹ ≥
                    BitVec.twoPow (2 * 32) (32 - 1)) then
            none
          else some (BitVec.ofBool ((x✝ &&& 4294967293#32 ||| 1#32) * x✝¹ &&& 7#32 == 0#32))) ⊑
          some (BitVec.ofBool ((x✝ &&& 4#32 ||| 1#32) * x✝¹ &&& 7#32 == 0#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 32) (x✝ &&& 4294967293#32 ||| 1#32) * BitVec.signExtend (2 * 32) x✝¹ <
                      BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                    BitVec.signExtend (2 * 32) (x✝ &&& 4294967293#32 ||| 1#32) * BitVec.signExtend (2 * 32) x✝¹ ≥
                      BitVec.twoPow (2 * 32) (32 - 1)) then
              none
            else some (BitVec.ofBool ((x✝ &&& 4294967293#32 ||| 1#32) * x✝¹ &&& 7#32 == 0#32))) ⊑
            some (BitVec.ofBool ((x✝ &&& 4#32 ||| 1#32) * x✝¹ &&& 7#32 == 0#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                          BitVec.signExtend 64 (x✝ &&& 4294967293#32 ||| 1#32) * BitVec.signExtend 64 x✝¹) &&
                      BitVec.twoPow 64 31 >ᵤ
                        BitVec.signExtend 64 (x✝ &&& 4294967293#32 ||| 1#32) * BitVec.signExtend 64 x✝¹)) =
                  true then
              none
            else some (if ((x✝ &&& 4294967293#32 ||| 1#32) * x✝¹ &&& 7#32 == 0#32) = true then 1#1 else 0#1)) ⊑
            some (if ((x✝ &&& 4#32 ||| 1#32) * x✝¹ &&& 7#32 == 0#32) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmulhand_proof.lean:161:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmulhand_proof.lean:152:8: error: (kernel) declaration has metavariables 'pr51551_neg2_thm'
[bv] [0.058304] Normalizing goal
  [Meta.synthInstance] [0.002084] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 32) (x✝ &&& 4294967289#32) * BitVec.signExtend (2 * 32) x✝¹ <
                    BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                  BitVec.signExtend (2 * 32) (x✝ &&& 4294967289#32) * BitVec.signExtend (2 * 32) x✝¹ ≥
                    BitVec.twoPow (2 * 32) (32 - 1)) then
            none
          else some (BitVec.ofBool ((x✝ &&& 4294967289#32) * x✝¹ &&& 7#32 == 0#32))) ⊑
          match some (BitVec.truncate 1 x✝ ^^^ 1#1) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some 1#1
          | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.ofBool (x✝¹ &&& 7#32 == 0#32)))
    [Meta.check] [0.001153] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if
              True ∧
                (BitVec.signExtend (2 * 32) (x✝ &&& 4294967289#32) * BitVec.signExtend (2 * 32) x✝¹ <
                    BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                  BitVec.signExtend (2 * 32) (x✝ &&& 4294967289#32) * BitVec.signExtend (2 * 32) x✝¹ ≥
                    BitVec.twoPow (2 * 32) (32 - 1)) then
            none
          else some (BitVec.ofBool ((x✝ &&& 4294967289#32) * x✝¹ &&& 7#32 == 0#32)))
          (match some (BitVec.truncate 1 x✝ ^^^ 1#1) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some 1#1
          | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.ofBool (x✝¹ &&& 7#32 == 0#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 32) (x✝ &&& 4294967289#32) * BitVec.signExtend (2 * 32) x✝¹ <
                      BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                    BitVec.signExtend (2 * 32) (x✝ &&& 4294967289#32) * BitVec.signExtend (2 * 32) x✝¹ ≥
                      BitVec.twoPow (2 * 32) (32 - 1)) then
              none
            else some (BitVec.ofBool ((x✝ &&& 4294967289#32) * x✝¹ &&& 7#32 == 0#32))) ⊑
            match some (BitVec.truncate 1 x✝ ^^^ 1#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 1#1
            | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.ofBool (x✝¹ &&& 7#32 == 0#32))
      ⊢ False
  [Meta.appBuilder] [0.001113] ✅️ f: Eq.mp, xs: [congrArg Not
         (congr
           (congrArg BitVec.Refinement
             (ite_congr
               (Eq.trans
                 (congrArg (And True)
                   (Eq.trans
                     (Eq.trans
                       (congr
                         (congrArg Or
                           (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                             (BitVec.signExtend 64 (x✝ &&& 4294967289#32) * BitVec.signExtend 64 x✝¹)
                             (BitVec.signExtend 64 (BitVec.twoPow 32 31))))
                         (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                           (Eq.trans
                             (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31)
                               (BitVec.signExtend 64 (x✝ &&& 4294967289#32) * BitVec.signExtend 64 x✝¹))
                             (Eq.trans
                               (Eq.trans
                                 (congrArg Not
                                   (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                                     (BitVec.signExtend 64 (x✝ &&& 4294967289#32) * BitVec.signExtend 64 x✝¹)
                                     (BitVec.twoPow 64 31)))
                                 (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                                   (BitVec.twoPow 64 31 >ᵤ
                                     BitVec.signExtend 64 (x✝ &&& 4294967289#32) * BitVec.signExtend 64 x✝¹)
                                   true))
                               (congrArg (fun x => (!x) = true)
                                 (beq_true
                                   (BitVec.twoPow 64 31 >ᵤ
                                     BitVec.signExtend 64 (x✝ &&& 4294967289#32) * BitVec.signExtend 64 x✝¹)))))))
                       (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                         (BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                           BitVec.signExtend 64 (x✝ &&& 4294967289#32) * BitVec.signExtend 64 x✝¹)
                         !BitVec.twoPow 64 31 >ᵤ
                             BitVec.signExtend 64 (x✝ &&& 4294967289#32) * BitVec.signExtend 64 x✝¹))
                     (congrArg (fun x => x = true)
                       (Eq.trans
                         (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                           (BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                             BitVec.signExtend 64 (x✝ &&& 4294967289#32) * BitVec.signExtend 64 x✝¹)
                           !BitVec.twoPow 64 31 >ᵤ
                               BitVec.signExtend 64 (x✝ &&& 4294967289#32) * BitVec.signExtend 64 x✝¹)
                         (congrArg
                           (fun x =>
                             !((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                                     BitVec.signExtend 64 (x✝ &&& 4294967289#32) * BitVec.signExtend 64 x✝¹) &&
                                 x))
                           (Bool.not_not
                             (BitVec.twoPow 64 31 >ᵤ
                               BitVec.signExtend 64 (x✝ &&& 4294967289#32) * BitVec.signExtend 64 x✝¹)))))))
                 (true_and
                   ((!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                             BitVec.signExtend 64 (x✝ &&& 4294967289#32) * BitVec.signExtend 64 x✝¹) &&
                         BitVec.twoPow 64 31 >ᵤ
                           BitVec.signExtend 64 (x✝ &&& 4294967289#32) * BitVec.signExtend 64 x✝¹)) =
                     true)))
               (fun a => Eq.refl none) fun a =>
               congrArg some
                 (Std.Tactic.BVDecide.Normalize.BitVec.ofBool_eq_if ((x✝ &&& 4294967289#32) * x✝¹ &&& 7#32 == 0#32))))
           (congrArg
             (LLVM.select.match_1 (fun c? => LLVM.IntW 1) (some (BitVec.zeroExtend 1 x✝ ^^^ 1#1)) (fun _ => none)
               fun _ => some 1#1)
             (funext fun _ =>
               congrArg some (Std.Tactic.BVDecide.Normalize.BitVec.ofBool_eq_if (x✝¹ &&& 7#32 == 0#32))))),
       a✝]
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                          BitVec.signExtend 64 (x✝ &&& 4294967289#32) * BitVec.signExtend 64 x✝¹) &&
                      BitVec.twoPow 64 31 >ᵤ BitVec.signExtend 64 (x✝ &&& 4294967289#32) * BitVec.signExtend 64 x✝¹)) =
                  true then
              none
            else some (if ((x✝ &&& 4294967289#32) * x✝¹ &&& 7#32 == 0#32) = true then 1#1 else 0#1)) ⊑
            match some (BitVec.zeroExtend 1 x✝ ^^^ 1#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 1#1
            | some { toFin := ⟨0, ⋯⟩ } => some (if (x✝¹ &&& 7#32 == 0#32) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmulhand_proof.lean:173:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmulhand_proof.lean:165:8: error: (kernel) declaration has metavariables 'pr51551_demand3bits_thm'
[bv] [0.026861] Normalizing goal
  [Meta.synthInstance] [0.001382] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 32) (x✝ &&& 4294967289#32 ||| 1#32) * BitVec.signExtend (2 * 32) x✝¹ <
                    BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                  BitVec.signExtend (2 * 32) (x✝ &&& 4294967289#32 ||| 1#32) * BitVec.signExtend (2 * 32) x✝¹ ≥
                    BitVec.twoPow (2 * 32) (32 - 1)) then
            none
          else some ((x✝ &&& 4294967289#32 ||| 1#32) * x✝¹ &&& 7#32)) ⊑
          some (x✝¹ &&& 7#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 32) (x✝ &&& 4294967289#32 ||| 1#32) * BitVec.signExtend (2 * 32) x✝¹ <
                      BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                    BitVec.signExtend (2 * 32) (x✝ &&& 4294967289#32 ||| 1#32) * BitVec.signExtend (2 * 32) x✝¹ ≥
                      BitVec.twoPow (2 * 32) (32 - 1)) then
              none
            else some ((x✝ &&& 4294967289#32 ||| 1#32) * x✝¹ &&& 7#32)) ⊑
            some (x✝¹ &&& 7#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                          BitVec.signExtend 64 (x✝ &&& 4294967289#32 ||| 1#32) * BitVec.signExtend 64 x✝¹) &&
                      BitVec.twoPow 64 31 >ᵤ
                        BitVec.signExtend 64 (x✝ &&& 4294967289#32 ||| 1#32) * BitVec.signExtend 64 x✝¹)) =
                  true then
              none
            else some ((x✝ &&& 4294967289#32 ||| 1#32) * x✝¹ &&& 7#32)) ⊑
            some (x✝¹ &&& 7#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
