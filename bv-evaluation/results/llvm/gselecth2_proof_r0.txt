⚠ [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
⚠ [881/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [884/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
⚠ [887/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
⚠ [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecth2_proof.lean:17:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecth2_proof.lean:17:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecth2_proof.lean:11:8: error: (kernel) declaration has metavariables 'ashr_exact_poison_constant_fold_thm'
[bv] [0.053796] Normalizing goal
  [Meta.synthInstance] [0.001808] ✅️ Decidable
        ((Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some 42#8)
            fun x' => if 3#8 ≥ ↑8 then none else some (x'.sshiftRight (3#8).toNat)) ⊑
          match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => if 3#8 ≥ ↑8 then none else some (x✝¹.sshiftRight (3#8).toNat)
          | some { toFin := ⟨0, ⋯⟩ } => some 5#8)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 1
      x✝¹ : BitVec 8
      x✝ : BitVec 1
      a✝ :
        ¬(Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some 42#8)
              fun x' => if 3#8 ≥ ↑8 then none else some (x'.sshiftRight (3#8).toNat)) ⊑
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => if 3#8 ≥ ↑8 then none else some (x✝¹.sshiftRight (3#8).toNat)
            | some { toFin := ⟨0, ⋯⟩ } => some 5#8
      ⊢ False
  [Meta.isDefEq] [0.001107] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some 42#8
  [Meta.isDefEq] [0.001019] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some 42#8
  [Meta.isDefEq] [0.001060] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => if 3#8 ≥ ↑8 then none else some (x✝¹.sshiftRight (3#8).toNat)
      | some { toFin := ⟨0, ⋯⟩ } => some 5#8
  [Meta.isDefEq] [0.001095] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹.sshiftRight 3)
      | some { toFin := ⟨0, ⋯⟩ } => some 5#8
  [Meta.isDefEq] [0.001077] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some 42#8
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 1
      x✝¹ : BitVec 8
      x✝ : BitVec 1
      a✝ :
        ¬(Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some 42#8)
              fun a => some (a.sshiftRight 3)) ⊑
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹.sshiftRight 3)
            | some { toFin := ⟨0, ⋯⟩ } => some 5#8
      ⊢ False
  [Meta.isDefEq] [0.001032] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some 42#8
  [Meta.isDefEq] [0.001125] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some 42#8
  [Meta.isDefEq] [0.001071] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹.sshiftRight 3)
      | some { toFin := ⟨0, ⋯⟩ } => some 5#8
  [Meta.isDefEq] [0.001074] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹.sshiftRight 3)
      | some { toFin := ⟨0, ⋯⟩ } => some 5#8
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecth2_proof.lean:27:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecth2_proof.lean:27:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecth2_proof.lean:21:8: error: (kernel) declaration has metavariables 'ashr_exact_thm'
[bv] [0.069379] Normalizing goal
  [Meta.synthInstance] [0.002481] ✅️ Decidable
        ((Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some 16#8)
            fun x' => if 3#8 ≥ ↑8 then none else some (x'.sshiftRight (3#8).toNat)) ⊑
          match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => if 3#8 ≥ ↑8 then none else some (x✝¹.sshiftRight (3#8).toNat)
          | some { toFin := ⟨0, ⋯⟩ } => some 2#8)
    [Meta.check] [0.001157] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some 16#8)
            fun x' => if 3#8 ≥ ↑8 then none else some (x'.sshiftRight (3#8).toNat))
          (match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => if 3#8 ≥ ↑8 then none else some (x✝¹.sshiftRight (3#8).toNat)
          | some { toFin := ⟨0, ⋯⟩ } => some 2#8)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 1
      x✝¹ : BitVec 8
      x✝ : BitVec 1
      a✝ :
        ¬(Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some 16#8)
              fun x' => if 3#8 ≥ ↑8 then none else some (x'.sshiftRight (3#8).toNat)) ⊑
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => if 3#8 ≥ ↑8 then none else some (x✝¹.sshiftRight (3#8).toNat)
            | some { toFin := ⟨0, ⋯⟩ } => some 2#8
      ⊢ False
  [Meta.isDefEq] [0.001107] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some 16#8
  [Meta.isDefEq] [0.001282] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some 16#8
  [Meta.isDefEq] [0.001236] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some 16#8
  [Meta.isDefEq] [0.001431] ✅️ ?x ≥ ?y =?= 3#8 ≥ 8#8
  [Meta.isDefEq] [0.001164] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => if 3#8 ≥ ↑8 then none else some (x✝¹.sshiftRight (3#8).toNat)
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.isDefEq] [0.001256] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => if 3#8 ≥ ↑8 then none else some (x✝¹.sshiftRight (3#8).toNat)
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.isDefEq] [0.001270] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => if 3#8 ≥ ↑8 then none else some (x✝¹.sshiftRight (3#8).toNat)
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.isDefEq] [0.001120] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹.sshiftRight 3)
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.isDefEq] [0.001162] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹.sshiftRight 3)
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.isDefEq] [0.001191] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹.sshiftRight 3)
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.isDefEq] [0.001102] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some 16#8
  [Meta.isDefEq] [0.001209] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some 16#8
  [Meta.isDefEq] [0.001246] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some 16#8
  [Meta.isDefEq] [0.001103] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹.sshiftRight 3)
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.isDefEq] [0.001311] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹.sshiftRight 3)
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.isDefEq] [0.001203] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹.sshiftRight 3)
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 1
      x✝¹ : BitVec 8
      x✝ : BitVec 1
      a✝ :
        ¬(Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some 16#8)
              fun a => some (a.sshiftRight 3)) ⊑
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹.sshiftRight 3)
            | some { toFin := ⟨0, ⋯⟩ } => some 2#8
      ⊢ False
  [Meta.isDefEq] [0.001132] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some 16#8
  [Meta.isDefEq] [0.001292] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some 16#8
  [Meta.isDefEq] [0.001246] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some 16#8
  [Meta.isDefEq] [0.001193] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹.sshiftRight 3)
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.isDefEq] [0.001250] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹.sshiftRight 3)
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.isDefEq] [0.001164] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some 16#8
  [Meta.isDefEq] [0.001289] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some 16#8
  [Meta.isDefEq] [0.001247] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some 16#8
  [Meta.isDefEq] [0.001119] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹.sshiftRight 3)
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.isDefEq] [0.001283] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹.sshiftRight 3)
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.isDefEq] [0.001220] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹.sshiftRight 3)
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecth2_proof.lean:38:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecth2_proof.lean:38:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecth2_proof.lean:31:8: error: (kernel) declaration has metavariables 'shl_nsw_nuw_poison_constant_fold_thm'
[bv] [0.126987] Normalizing goal
  [Meta.synthInstance] [0.001946] ✅️ Decidable
        ((Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 3#8
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
            fun y' =>
            if True ∧ (16#8 <<< y').sshiftRight y'.toNat = 16#8 then none
            else if True ∧ 16#8 <<< y' >>> y' = 16#8 then none else if y' ≥ ↑8 then none else some (16#8 <<< y')) ⊑
          match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some 128#8
          | some { toFin := ⟨0, ⋯⟩ } =>
            if True ∧ (16#8 <<< x✝¹).sshiftRight x✝¹.toNat = 16#8 then none
            else if True ∧ 16#8 <<< x✝¹ >>> x✝¹ = 16#8 then none else if x✝¹ ≥ ↑8 then none else some (16#8 <<< x✝¹))
    [Meta.check] [0.001087] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 3#8
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
            fun y' =>
            if True ∧ (16#8 <<< y').sshiftRight y'.toNat = 16#8 then none
            else if True ∧ 16#8 <<< y' >>> y' = 16#8 then none else if y' ≥ ↑8 then none else some (16#8 <<< y'))
          (match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some 128#8
          | some { toFin := ⟨0, ⋯⟩ } =>
            if True ∧ (16#8 <<< x✝¹).sshiftRight x✝¹.toNat = 16#8 then none
            else if True ∧ 16#8 <<< x✝¹ >>> x✝¹ = 16#8 then none else if x✝¹ ≥ ↑8 then none else some (16#8 <<< x✝¹))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 1
      x✝¹ : BitVec 8
      x✝ : BitVec 1
      a✝ :
        ¬(Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 3#8
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun y' =>
              if True ∧ (16#8 <<< y').sshiftRight y'.toNat = 16#8 then none
              else if True ∧ 16#8 <<< y' >>> y' = 16#8 then none else if y' ≥ ↑8 then none else some (16#8 <<< y')) ⊑
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 128#8
            | some { toFin := ⟨0, ⋯⟩ } =>
              if True ∧ (16#8 <<< x✝¹).sshiftRight x✝¹.toNat = 16#8 then none
              else if True ∧ 16#8 <<< x✝¹ >>> x✝¹ = 16#8 then none else if x✝¹ ≥ ↑8 then none else some (16#8 <<< x✝¹)
      ⊢ False
  [Meta.isDefEq] [0.001495] ✅️ ?hf =?= fun a a_1 =>
        ite_congr
          (Eq.trans
            (congrArg (And True)
              (Std.Tactic.BVDecide.Normalize.BitVec.eq_to_beq ((16#8 <<< a).sshiftRight a.toNat) 16#8))
            (true_and (((16#8 <<< a).sshiftRight a.toNat == 16#8) = true)))
          (fun a => Eq.refl none) fun a_2 =>
          ite_congr
            (Eq.trans (congrArg (And True) (Std.Tactic.BVDecide.Normalize.BitVec.eq_to_beq (16#8 <<< a >>> a) 16#8))
              (true_and ((16#8 <<< a >>> a == 16#8) = true)))
            (fun a => Eq.refl none) fun a_3 =>
            ite_congr
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (8#8) a)
                  (Eq.trans
                    (Eq.trans (congrArg Not (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult a 8#8))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq (8#8 >ᵤ a) true))
                    (congrArg (fun x => (!x) = true) (beq_true (8#8 >ᵤ a))))))
              (fun a => Eq.refl none) fun a_4 => Eq.refl (some (16#8 <<< a))
    [Meta.isDefEq.assign] [0.001492] ✅️ ?hf := fun a a_1 =>
          ite_congr
            (Eq.trans
              (congrArg (And True)
                (Std.Tactic.BVDecide.Normalize.BitVec.eq_to_beq ((16#8 <<< a).sshiftRight a.toNat) 16#8))
              (true_and (((16#8 <<< a).sshiftRight a.toNat == 16#8) = true)))
            (fun a => Eq.refl none) fun a_2 =>
            ite_congr
              (Eq.trans (congrArg (And True) (Std.Tactic.BVDecide.Normalize.BitVec.eq_to_beq (16#8 <<< a >>> a) 16#8))
                (true_and ((16#8 <<< a >>> a == 16#8) = true)))
              (fun a => Eq.refl none) fun a_3 =>
              ite_congr
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (8#8) a)
                    (Eq.trans
                      (Eq.trans (congrArg Not (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult a 8#8))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq (8#8 >ᵤ a) true))
                      (congrArg (fun x => (!x) = true) (beq_true (8#8 >ᵤ a))))))
                (fun a => Eq.refl none) fun a_4 => Eq.refl (some (16#8 <<< a))
      [Meta.isDefEq.assign.checkTypes] [0.001390] ✅️ (?hf : ∀
            a ∈
              match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 3#8
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹,
            (if True ∧ (16#8 <<< a).sshiftRight a.toNat = 16#8 then none
              else if True ∧ 16#8 <<< a >>> a = 16#8 then none else if a ≥ ↑8 then none else some (16#8 <<< a)) =
              if ((16#8 <<< a).sshiftRight a.toNat == 16#8) = true then none
              else
                if (16#8 <<< a >>> a == 16#8) = true then none
                else
                  if (!8#8 >ᵤ a) = true then none
                  else
                    some
                      (16#8 <<<
                        a)) := (fun a a_1 =>
            ite_congr
              (Eq.trans
                (congrArg (And True)
                  (Std.Tactic.BVDecide.Normalize.BitVec.eq_to_beq ((16#8 <<< a).sshiftRight a.toNat) 16#8))
                (true_and (((16#8 <<< a).sshiftRight a.toNat == 16#8) = true)))
              (fun a => Eq.refl none) fun a_2 =>
              ite_congr
                (Eq.trans (congrArg (And True) (Std.Tactic.BVDecide.Normalize.BitVec.eq_to_beq (16#8 <<< a >>> a) 16#8))
                  (true_and ((16#8 <<< a >>> a == 16#8) = true)))
                (fun a => Eq.refl none) fun a_3 =>
                ite_congr
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (8#8) a)
                      (Eq.trans
                        (Eq.trans (congrArg Not (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult a 8#8))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq (8#8 >ᵤ a) true))
                        (congrArg (fun x => (!x) = true) (beq_true (8#8 >ᵤ a))))))
                  (fun a => Eq.refl none) fun a_4 => Eq.refl (some (16#8 <<< a)) : ∀
            a ∈
              match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 3#8
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹,
            (if True ∧ (16#8 <<< a).sshiftRight a.toNat = 16#8 then none
              else if True ∧ 16#8 <<< a >>> a = 16#8 then none else if a ≥ ↑8 then none else some (16#8 <<< a)) =
              if ((16#8 <<< a).sshiftRight a.toNat == 16#8) = true then none
              else
                if (16#8 <<< a >>> a == 16#8) = true then none
                else if (!8#8 >ᵤ a) = true then none else some (16#8 <<< a))
        [Meta.isDefEq] [0.001386] ✅️ ∀
              a ∈
                match some x✝ with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some 3#8
                | some { toFin := ⟨0, ⋯⟩ } => some x✝¹,
              (if True ∧ (16#8 <<< a).sshiftRight a.toNat = 16#8 then none
                else if True ∧ 16#8 <<< a >>> a = 16#8 then none else if a ≥ ↑8 then none else some (16#8 <<< a)) =
                if ((16#8 <<< a).sshiftRight a.toNat == 16#8) = true then none
                else
                  if (16#8 <<< a >>> a == 16#8) = true then none
                  else if (!8#8 >ᵤ a) = true then none else some (16#8 <<< a) =?= ∀
              a ∈
                match some x✝ with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some 3#8
                | some { toFin := ⟨0, ⋯⟩ } => some x✝¹,
              (if True ∧ (16#8 <<< a).sshiftRight a.toNat = 16#8 then none
                else if True ∧ 16#8 <<< a >>> a = 16#8 then none else if a ≥ ↑8 then none else some (16#8 <<< a)) =
                if ((16#8 <<< a).sshiftRight a.toNat == 16#8) = true then none
                else
                  if (16#8 <<< a >>> a == 16#8) = true then none
                  else if (!8#8 >ᵤ a) = true then none else some (16#8 <<< a)
          [Meta.isDefEq] [0.001327] ✅️ (if True ∧ (16#8 <<< a).sshiftRight a.toNat = 16#8 then none
                else if True ∧ 16#8 <<< a >>> a = 16#8 then none else if a ≥ ↑8 then none else some (16#8 <<< a)) =
                if ((16#8 <<< a).sshiftRight a.toNat == 16#8) = true then none
                else
                  if (16#8 <<< a >>> a == 16#8) = true then none
                  else
                    if (!8#8 >ᵤ a) = true then none
                    else
                      some
                        (16#8 <<<
                          a) =?= (if True ∧ (16#8 <<< a).sshiftRight a.toNat = 16#8 then none
                else if True ∧ 16#8 <<< a >>> a = 16#8 then none else if a ≥ ↑8 then none else some (16#8 <<< a)) =
                if ((16#8 <<< a).sshiftRight a.toNat == 16#8) = true then none
                else
                  if (16#8 <<< a >>> a == 16#8) = true then none
                  else if (!8#8 >ᵤ a) = true then none else some (16#8 <<< a)
  [Meta.isDefEq] [0.001543] ✅️ ?x ≥ ?y =?= 8#8 ≤ x✝¹
    [Meta.isDefEq] [0.001516] ✅️ ?y ≤ ?x =?= 8#8 ≤ x✝¹
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 1
      x✝¹ : BitVec 8
      x✝ : BitVec 1
      a✝ :
        ¬(Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 3#8
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun a =>
              if ((16#8 <<< a).sshiftRight a.toNat == 16#8) = true then none
              else
                if (16#8 <<< a >>> a == 16#8) = true then none
                else if (!8#8 >ᵤ a) = true then none else some (16#8 <<< a)) ⊑
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 128#8
            | some { toFin := ⟨0, ⋯⟩ } =>
              if ((16#8 <<< x✝¹).sshiftRight x✝¹.toNat == 16#8) = true then none
              else
                if (16#8 <<< x✝¹ >>> x✝¹ == 16#8) = true then none
                else if (!8#8 >ᵤ x✝¹) = true then none else some (16#8 <<< x✝¹)
      ⊢ False
  [Meta.isDefEq] [0.001102] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 128#8
      | some { toFin := ⟨0, ⋯⟩ } =>
        if ((16#8 <<< x✝¹).sshiftRight x✝¹.toNat == 16#8) = true then none
        else
          if (16#8 <<< x✝¹ >>> x✝¹ == 16#8) = true then none
          else if (!8#8 >ᵤ x✝¹) = true then none else some (16#8 <<< x✝¹)
  [Meta.isDefEq] [0.001245] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 128#8
      | some { toFin := ⟨0, ⋯⟩ } =>
        if ((16#8 <<< x✝¹).sshiftRight x✝¹.toNat == 16#8) = true then none
        else
          if (16#8 <<< x✝¹ >>> x✝¹ == 16#8) = true then none
          else if (!8#8 >ᵤ x✝¹) = true then none else some (16#8 <<< x✝¹)
  [Meta.isDefEq] [0.001202] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 128#8
      | some { toFin := ⟨0, ⋯⟩ } =>
        if ((16#8 <<< x✝¹).sshiftRight x✝¹.toNat == 16#8) = true then none
        else
          if (16#8 <<< x✝¹ >>> x✝¹ == 16#8) = true then none
          else if (!8#8 >ᵤ x✝¹) = true then none else some (16#8 <<< x✝¹)
  [Meta.isDefEq] [0.001132] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 3#8
      | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
  [Meta.isDefEq] [0.001176] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 3#8
      | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
  [Meta.isDefEq] [0.001056] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 128#8
      | some { toFin := ⟨0, ⋯⟩ } =>
        if ((16#8 <<< x✝¹).sshiftRight x✝¹.toNat == 16#8) = true then none
        else
          if (16#8 <<< x✝¹ >>> x✝¹ == 16#8) = true then none
          else if (!8#8 >ᵤ x✝¹) = true then none else some (16#8 <<< x✝¹)
  [Meta.isDefEq] [0.001194] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 128#8
      | some { toFin := ⟨0, ⋯⟩ } =>
        if ((16#8 <<< x✝¹).sshiftRight x✝¹.toNat == 16#8) = true then none
        else
          if (16#8 <<< x✝¹ >>> x✝¹ == 16#8) = true then none
          else if (!8#8 >ᵤ x✝¹) = true then none else some (16#8 <<< x✝¹)
  [Meta.isDefEq] [0.001163] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 128#8
      | some { toFin := ⟨0, ⋯⟩ } =>
        if ((16#8 <<< x✝¹).sshiftRight x✝¹.toNat == 16#8) = true then none
        else
          if (16#8 <<< x✝¹ >>> x✝¹ == 16#8) = true then none
          else if (!8#8 >ᵤ x✝¹) = true then none else some (16#8 <<< x✝¹)
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecth2_proof.lean:49:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecth2_proof.lean:49:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecth2_proof.lean:42:8: error: (kernel) declaration has metavariables 'shl_nsw_nuw_thm'
[bv] [0.128005] Normalizing goal
  [Meta.synthInstance] [0.001855] ✅️ Decidable
        ((Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 3#8
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
            fun y' =>
            if True ∧ (7#8 <<< y').sshiftRight y'.toNat = 7#8 then none
            else if True ∧ 7#8 <<< y' >>> y' = 7#8 then none else if y' ≥ ↑8 then none else some (7#8 <<< y')) ⊑
          match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some 56#8
          | some { toFin := ⟨0, ⋯⟩ } =>
            if True ∧ (7#8 <<< x✝¹).sshiftRight x✝¹.toNat = 7#8 then none
            else if True ∧ 7#8 <<< x✝¹ >>> x✝¹ = 7#8 then none else if x✝¹ ≥ ↑8 then none else some (7#8 <<< x✝¹))
    [Meta.check] [0.001036] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 3#8
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
            fun y' =>
            if True ∧ (7#8 <<< y').sshiftRight y'.toNat = 7#8 then none
            else if True ∧ 7#8 <<< y' >>> y' = 7#8 then none else if y' ≥ ↑8 then none else some (7#8 <<< y'))
          (match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some 56#8
          | some { toFin := ⟨0, ⋯⟩ } =>
            if True ∧ (7#8 <<< x✝¹).sshiftRight x✝¹.toNat = 7#8 then none
            else if True ∧ 7#8 <<< x✝¹ >>> x✝¹ = 7#8 then none else if x✝¹ ≥ ↑8 then none else some (7#8 <<< x✝¹))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 1
      x✝¹ : BitVec 8
      x✝ : BitVec 1
      a✝ :
        ¬(Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 3#8
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun y' =>
              if True ∧ (7#8 <<< y').sshiftRight y'.toNat = 7#8 then none
              else if True ∧ 7#8 <<< y' >>> y' = 7#8 then none else if y' ≥ ↑8 then none else some (7#8 <<< y')) ⊑
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 56#8
            | some { toFin := ⟨0, ⋯⟩ } =>
              if True ∧ (7#8 <<< x✝¹).sshiftRight x✝¹.toNat = 7#8 then none
              else if True ∧ 7#8 <<< x✝¹ >>> x✝¹ = 7#8 then none else if x✝¹ ≥ ↑8 then none else some (7#8 <<< x✝¹)
      ⊢ False
  [Meta.isDefEq] [0.001786] ✅️ if ?b then ?x else ?y =?= if x✝¹ ≥ ↑8 then none else some (7#8 <<< x✝¹)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 1
      x✝¹ : BitVec 8
      x✝ : BitVec 1
      a✝ :
        ¬(Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 3#8
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun a =>
              if ((7#8 <<< a).sshiftRight a.toNat == 7#8) = true then none
              else
                if (7#8 <<< a >>> a == 7#8) = true then none
                else if (!8#8 >ᵤ a) = true then none else some (7#8 <<< a)) ⊑
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 56#8
            | some { toFin := ⟨0, ⋯⟩ } =>
              if ((7#8 <<< x✝¹).sshiftRight x✝¹.toNat == 7#8) = true then none
              else
                if (7#8 <<< x✝¹ >>> x✝¹ == 7#8) = true then none
                else if (!8#8 >ᵤ x✝¹) = true then none else some (7#8 <<< x✝¹)
      ⊢ False
  [Meta.isDefEq] [0.001074] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 56#8
      | some { toFin := ⟨0, ⋯⟩ } =>
        if ((7#8 <<< x✝¹).sshiftRight x✝¹.toNat == 7#8) = true then none
        else
          if (7#8 <<< x✝¹ >>> x✝¹ == 7#8) = true then none
          else if (!8#8 >ᵤ x✝¹) = true then none else some (7#8 <<< x✝¹)
  [Meta.isDefEq] [0.001227] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 56#8
      | some { toFin := ⟨0, ⋯⟩ } =>
        if ((7#8 <<< x✝¹).sshiftRight x✝¹.toNat == 7#8) = true then none
        else
          if (7#8 <<< x✝¹ >>> x✝¹ == 7#8) = true then none
          else if (!8#8 >ᵤ x✝¹) = true then none else some (7#8 <<< x✝¹)
  [Meta.isDefEq] [0.001181] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 56#8
      | some { toFin := ⟨0, ⋯⟩ } =>
        if ((7#8 <<< x✝¹).sshiftRight x✝¹.toNat == 7#8) = true then none
        else
          if (7#8 <<< x✝¹ >>> x✝¹ == 7#8) = true then none
          else if (!8#8 >ᵤ x✝¹) = true then none else some (7#8 <<< x✝¹)
  [Meta.isDefEq] [0.001072] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 3#8
      | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
  [Meta.isDefEq] [0.001191] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 3#8
      | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
  [Meta.isDefEq] [0.001125] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 3#8
      | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
  [Meta.isDefEq] [0.001081] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 56#8
      | some { toFin := ⟨0, ⋯⟩ } =>
        if ((7#8 <<< x✝¹).sshiftRight x✝¹.toNat == 7#8) = true then none
        else
          if (7#8 <<< x✝¹ >>> x✝¹ == 7#8) = true then none
          else if (!8#8 >ᵤ x✝¹) = true then none else some (7#8 <<< x✝¹)
  [Meta.isDefEq] [0.001215] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 56#8
      | some { toFin := ⟨0, ⋯⟩ } =>
        if ((7#8 <<< x✝¹).sshiftRight x✝¹.toNat == 7#8) = true then none
        else
          if (7#8 <<< x✝¹ >>> x✝¹ == 7#8) = true then none
          else if (!8#8 >ᵤ x✝¹) = true then none else some (7#8 <<< x✝¹)
  [Meta.isDefEq] [0.001184] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 56#8
      | some { toFin := ⟨0, ⋯⟩ } =>
        if ((7#8 <<< x✝¹).sshiftRight x✝¹.toNat == 7#8) = true then none
        else
          if (7#8 <<< x✝¹ >>> x✝¹ == 7#8) = true then none
          else if (!8#8 >ᵤ x✝¹) = true then none else some (7#8 <<< x✝¹)
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecth2_proof.lean:60:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecth2_proof.lean:60:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecth2_proof.lean:53:8: error: (kernel) declaration has metavariables 'add_nsw_poison_constant_fold_thm'
[bv] [0.074916] Normalizing goal
  [Meta.synthInstance] [0.001717] ✅️ Decidable
        ((Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some 65#8)
            fun x' => if True ∧ x'.msb = (64#8).msb ∧ (x' + 64#8).msb ≠ x'.msb then none else some (x' + 64#8)) ⊑
          match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } =>
            if True ∧ x✝¹.msb = (64#8).msb ∧ (x✝¹ + 64#8).msb ≠ x✝¹.msb then none else some (x✝¹ + 64#8)
          | some { toFin := ⟨0, ⋯⟩ } => some 129#8)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 1
      x✝¹ : BitVec 8
      x✝ : BitVec 1
      a✝ :
        ¬(Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some 65#8)
              fun x' => if True ∧ x'.msb = (64#8).msb ∧ (x' + 64#8).msb ≠ x'.msb then none else some (x' + 64#8)) ⊑
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } =>
              if True ∧ x✝¹.msb = (64#8).msb ∧ (x✝¹ + 64#8).msb ≠ x✝¹.msb then none else some (x✝¹ + 64#8)
            | some { toFin := ⟨0, ⋯⟩ } => some 129#8
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 1
      x✝¹ : BitVec 8
      x✝ : BitVec 1
      a✝ :
        ¬(Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some 65#8)
              fun a =>
              if (!a.getLsbD 7 && !(a + 64#8).getLsbD 7 == a.getLsbD 7) = true then none else some (a + 64#8)) ⊑
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } =>
              if (!x✝¹.getLsbD 7 && !(x✝¹ + 64#8).getLsbD 7 == x✝¹.getLsbD 7) = true then none else some (x✝¹ + 64#8)
            | some { toFin := ⟨0, ⋯⟩ } => some 129#8
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecth2_proof.lean:71:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecth2_proof.lean:71:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecth2_proof.lean:64:8: error: (kernel) declaration has metavariables 'add_nsw_thm'
[bv] [0.076492] Normalizing goal
  [Meta.synthInstance] [0.001670] ✅️ Decidable
        ((Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some 7#8)
            fun x' => if True ∧ x'.msb = (64#8).msb ∧ (x' + 64#8).msb ≠ x'.msb then none else some (x' + 64#8)) ⊑
          match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } =>
            if True ∧ x✝¹.msb = (64#8).msb ∧ (x✝¹ + 64#8).msb ≠ x✝¹.msb then none else some (x✝¹ + 64#8)
          | some { toFin := ⟨0, ⋯⟩ } => some 71#8)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 1
      x✝¹ : BitVec 8
      x✝ : BitVec 1
      a✝ :
        ¬(Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some 7#8)
              fun x' => if True ∧ x'.msb = (64#8).msb ∧ (x' + 64#8).msb ≠ x'.msb then none else some (x' + 64#8)) ⊑
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } =>
              if True ∧ x✝¹.msb = (64#8).msb ∧ (x✝¹ + 64#8).msb ≠ x✝¹.msb then none else some (x✝¹ + 64#8)
            | some { toFin := ⟨0, ⋯⟩ } => some 71#8
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 1
      x✝¹ : BitVec 8
      x✝ : BitVec 1
      a✝ :
        ¬(Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some 7#8)
              fun a =>
              if (!a.getLsbD 7 && !(a + 64#8).getLsbD 7 == a.getLsbD 7) = true then none else some (a + 64#8)) ⊑
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } =>
              if (!x✝¹.getLsbD 7 && !(x✝¹ + 64#8).getLsbD 7 == x✝¹.getLsbD 7) = true then none else some (x✝¹ + 64#8)
            | some { toFin := ⟨0, ⋯⟩ } => some 71#8
      ⊢ False
  [Meta.appBuilder] [0.001930] ✅️ f: Subsingleton.elim, xs: [h✝, h]
    [Meta.synthInstance] [0.001884] ✅️ Subsingleton (Decidable c✝)
      [Meta.synthInstance] [0.001826] ✅️ apply instSubsingletonDecidable to Subsingleton (Decidable c✝)
        [Meta.synthInstance.tryResolve] [0.001802] ✅️ Subsingleton (Decidable c✝) ≟ Subsingleton (Decidable c✝)
          [Meta.isDefEq] [0.001761] ✅️ ?m.97146 =?= instSubsingletonDecidable c✝
            [Meta.isDefEq.assign] [0.001758] ✅️ ?m.97146 := instSubsingletonDecidable c✝
              [Meta.isDefEq.assign.checkTypes] [0.001742] ✅️ (?m.97146 : Subsingleton
                    (Decidable c✝)) := (instSubsingletonDecidable c✝ : Subsingleton (Decidable c✝))
  [Meta.isDefEq] [0.002009] ✅️ if ?b then ?x
      else ?y =?= if (!a.getLsbD 7 && !(a + 64#8).getLsbD 7 == a.getLsbD 7) = true then none else some (a + 64#8)
  [Meta.Tactic.bv] Pipeline reached a fixpoint
