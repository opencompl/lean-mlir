âš  [872/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
âš  [878/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
âš  [882/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
âš  [885/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
âš  [886/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gzexthboolhaddhsub_proof.lean:18:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gzexthboolhaddhsub_proof.lean:11:8: error: (kernel) declaration has metavariables 'a_thm'
[bv] [0.087092] Normalizing goal
  [Meta.synthInstance] [0.001828] âœ…ï¸ Decidable
        (some (BitVec.zeroExtend 32 xâœ + 1#32 + (0#32 - BitVec.zeroExtend 32 xâœÂ¹)) âŠ‘
          Option.bind
            (match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some 2#32
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some 1#32)
            fun x' =>
            if True âˆ§ x'.msb = (BitVec.signExtend 32 xâœÂ¹).msb âˆ§ (x' + BitVec.signExtend 32 xâœÂ¹).msb â‰  x'.msb then none
            else some (x' + BitVec.signExtend 32 xâœÂ¹))
    [Meta.check] [0.001028] âœ…ï¸ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (some (BitVec.zeroExtend 32 xâœ + 1#32 + (0#32 - BitVec.zeroExtend 32 xâœÂ¹)))
          (Option.bind
            (match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some 2#32
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some 1#32)
            fun x' =>
            if True âˆ§ x'.msb = (BitVec.signExtend 32 xâœÂ¹).msb âˆ§ (x' + BitVec.signExtend 32 xâœÂ¹).msb â‰  x'.msb then none
            else some (x' + BitVec.signExtend 32 xâœÂ¹))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 1
      xâœÂ¹ xâœ : BitVec 1
      aâœ :
        Â¬some (BitVec.zeroExtend 32 xâœ + 1#32 + (0#32 - BitVec.zeroExtend 32 xâœÂ¹)) âŠ‘
            Option.bind
              (match some xâœ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some 2#32
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some 1#32)
              fun x' =>
              if True âˆ§ x'.msb = (BitVec.signExtend 32 xâœÂ¹).msb âˆ§ (x' + BitVec.signExtend 32 xâœÂ¹).msb â‰  x'.msb then none
              else some (x' + BitVec.signExtend 32 xâœÂ¹)
      âŠ¢ False
  [Meta.isDefEq] [0.001323] âŒï¸ match none with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= LLVM.select.match_1
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 1
      xâœÂ¹ xâœ : BitVec 1
      aâœ :
        Â¬some (BitVec.zeroExtend 32 xâœ + 1#32 + (~~~BitVec.zeroExtend 32 xâœÂ¹ + 1#32)) âŠ‘
            Option.bind
              (match some xâœ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some 2#32
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some 1#32)
              fun a =>
              if
                  (a.getLsbD 31 == (BitVec.signExtend 32 xâœÂ¹).getLsbD 31 &&
                      !(a + BitVec.signExtend 32 xâœÂ¹).getLsbD 31 == a.getLsbD 31) =
                    true then
                none
              else some (a + BitVec.signExtend 32 xâœÂ¹)
      âŠ¢ False
  [Meta.isDefEq] [0.003970] âŒï¸ match none with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => some 2#32
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some 1#32
    [Meta.isDefEq] [0.003513] âŒï¸ ?h_1 () =?= match some xâœ with
        | none => none
        | some { toFin := âŸ¨1, â‹¯âŸ© } => some 2#32
        | some { toFin := âŸ¨0, â‹¯âŸ© } => some 1#32
      [Meta.whnf] [0.003435] Non-easy whnf: match some xâœ with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } => some 2#32
          | some { toFin := âŸ¨0, â‹¯âŸ© } => some 1#32
        [Meta.whnf] [0.003274] Non-easy whnf: (fun motive c? h_1 h_2 h_3 =>
                Option.casesOn c? (h_1 ()) fun val =>
                  BitVec.casesOn val fun toFin =>
                    Fin.casesOn toFin fun val isLt =>
                      Nat.casesOn (motive := fun x => (isLt : x < 2 ^ 1) â†’ motive (some { toFin := âŸ¨x, isLtâŸ© })) val
                        (fun isLt => h_3 ())
                        (fun n isLt =>
                          Nat.casesOn (motive := fun x =>
                            (isLt : x.succ < 2 ^ 1) â†’ motive (some { toFin := âŸ¨x.succ, isLtâŸ© })) n (fun isLt => h_2 ())
                            (fun n isLt => â‹¯.elim) isLt)
                        isLt)
              (fun c? => LLVM.IntW 32) (some xâœ) h_1 h_2 h_3
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gzexthboolhaddhsub_proof.lean:33:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gzexthboolhaddhsub_proof.lean:33:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gzexthboolhaddhsub_proof.lean:33:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gzexthboolhaddhsub_proof.lean:33:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gzexthboolhaddhsub_proof.lean:22:8: error: (kernel) declaration has metavariables 'PR30273_three_bools_thm'
[bv] [0.739984] Normalizing goal
  [Meta.synthInstance] [0.002986] âœ…ï¸ Decidable
        ((match some xâœ with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } =>
            Option.bind
              (match some xâœÂ¹ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } =>
                if
                    True âˆ§
                      (BitVec.zeroExtend 32 xâœÂ²).msb = (1#32).msb âˆ§
                        (BitVec.zeroExtend 32 xâœÂ² + 1#32).msb â‰  (BitVec.zeroExtend 32 xâœÂ²).msb then
                  none
                else some (BitVec.zeroExtend 32 xâœÂ² + 1#32)
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some (BitVec.zeroExtend 32 xâœÂ²))
              fun x' => if True âˆ§ x'.msb = (1#32).msb âˆ§ (x' + 1#32).msb â‰  x'.msb then none else some (x' + 1#32)
          | some { toFin := âŸ¨0, â‹¯âŸ© } =>
            match some xâœÂ¹ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              if
                  True âˆ§
                    (BitVec.zeroExtend 32 xâœÂ²).msb = (1#32).msb âˆ§
                      (BitVec.zeroExtend 32 xâœÂ² + 1#32).msb â‰  (BitVec.zeroExtend 32 xâœÂ²).msb then
                none
              else some (BitVec.zeroExtend 32 xâœÂ² + 1#32)
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some (BitVec.zeroExtend 32 xâœÂ²)) âŠ‘
          Option.bind
            (match some xâœÂ¹ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              match some xâœÂ² with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some 2#32
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some 1#32
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some (BitVec.zeroExtend 32 xâœÂ²))
            fun a =>
            if True âˆ§ a.msb = (BitVec.zeroExtend 32 xâœ).msb âˆ§ (a + BitVec.zeroExtend 32 xâœ).msb â‰  a.msb then none
            else
              if True âˆ§ (a + BitVec.zeroExtend 32 xâœ < a âˆ¨ a + BitVec.zeroExtend 32 xâœ < BitVec.zeroExtend 32 xâœ) then
                none
              else some (a + BitVec.zeroExtend 32 xâœ))
    [Meta.check] [0.001852] âœ…ï¸ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (match some xâœ with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } =>
            Option.bind
              (match some xâœÂ¹ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } =>
                if
                    True âˆ§
                      (BitVec.zeroExtend 32 xâœÂ²).msb = (1#32).msb âˆ§
                        (BitVec.zeroExtend 32 xâœÂ² + 1#32).msb â‰  (BitVec.zeroExtend 32 xâœÂ²).msb then
                  none
                else some (BitVec.zeroExtend 32 xâœÂ² + 1#32)
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some (BitVec.zeroExtend 32 xâœÂ²))
              fun x' => if True âˆ§ x'.msb = (1#32).msb âˆ§ (x' + 1#32).msb â‰  x'.msb then none else some (x' + 1#32)
          | some { toFin := âŸ¨0, â‹¯âŸ© } =>
            match some xâœÂ¹ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              if
                  True âˆ§
                    (BitVec.zeroExtend 32 xâœÂ²).msb = (1#32).msb âˆ§
                      (BitVec.zeroExtend 32 xâœÂ² + 1#32).msb â‰  (BitVec.zeroExtend 32 xâœÂ²).msb then
                none
              else some (BitVec.zeroExtend 32 xâœÂ² + 1#32)
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some (BitVec.zeroExtend 32 xâœÂ²))
          (Option.bind
            (match some xâœÂ¹ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              match some xâœÂ² with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some 2#32
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some 1#32
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some (BitVec.zeroExtend 32 xâœÂ²))
            fun a =>
            if True âˆ§ a.msb = (BitVec.zeroExtend 32 xâœ).msb âˆ§ (a + BitVec.zeroExtend 32 xâœ).msb â‰  a.msb then none
            else
              if True âˆ§ (a + BitVec.zeroExtend 32 xâœ < a âˆ¨ a + BitVec.zeroExtend 32 xâœ < BitVec.zeroExtend 32 xâœ) then
                none
              else some (a + BitVec.zeroExtend 32 xâœ))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 1
      xâœÂ² xâœÂ¹ xâœ : BitVec 1
      aâœ :
        Â¬(match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              Option.bind
                (match some xâœÂ¹ with
                | none => none
                | some { toFin := âŸ¨1, â‹¯âŸ© } =>
                  if
                      True âˆ§
                        (BitVec.zeroExtend 32 xâœÂ²).msb = (1#32).msb âˆ§
                          (BitVec.zeroExtend 32 xâœÂ² + 1#32).msb â‰  (BitVec.zeroExtend 32 xâœÂ²).msb then
                    none
                  else some (BitVec.zeroExtend 32 xâœÂ² + 1#32)
                | some { toFin := âŸ¨0, â‹¯âŸ© } => some (BitVec.zeroExtend 32 xâœÂ²))
                fun x' => if True âˆ§ x'.msb = (1#32).msb âˆ§ (x' + 1#32).msb â‰  x'.msb then none else some (x' + 1#32)
            | some { toFin := âŸ¨0, â‹¯âŸ© } =>
              match some xâœÂ¹ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } =>
                if
                    True âˆ§
                      (BitVec.zeroExtend 32 xâœÂ²).msb = (1#32).msb âˆ§
                        (BitVec.zeroExtend 32 xâœÂ² + 1#32).msb â‰  (BitVec.zeroExtend 32 xâœÂ²).msb then
                  none
                else some (BitVec.zeroExtend 32 xâœÂ² + 1#32)
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some (BitVec.zeroExtend 32 xâœÂ²)) âŠ‘
            Option.bind
              (match some xâœÂ¹ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } =>
                match some xâœÂ² with
                | none => none
                | some { toFin := âŸ¨1, â‹¯âŸ© } => some 2#32
                | some { toFin := âŸ¨0, â‹¯âŸ© } => some 1#32
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some (BitVec.zeroExtend 32 xâœÂ²))
              fun a =>
              if True âˆ§ a.msb = (BitVec.zeroExtend 32 xâœ).msb âˆ§ (a + BitVec.zeroExtend 32 xâœ).msb â‰  a.msb then none
              else
                if True âˆ§ (a + BitVec.zeroExtend 32 xâœ < a âˆ¨ a + BitVec.zeroExtend 32 xâœ < BitVec.zeroExtend 32 xâœ) then
                  none
                else some (a + BitVec.zeroExtend 32 xâœ)
      âŠ¢ False
  [Meta.isDefEq] [0.003550] âŒï¸ match some { toFin := âŸ¨1, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœÂ¹ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } =>
        if
            True âˆ§
              (BitVec.zeroExtend 32 xâœÂ²).msb = (1#32).msb âˆ§
                (BitVec.zeroExtend 32 xâœÂ² + 1#32).msb â‰  (BitVec.zeroExtend 32 xâœÂ²).msb then
          none
        else some (BitVec.zeroExtend 32 xâœÂ² + 1#32)
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some (BitVec.zeroExtend 32 xâœÂ²)
    [Meta.isDefEq] [0.003001] âŒï¸ ?h_2 () =?= match some xâœÂ¹ with
        | none => none
        | some { toFin := âŸ¨1, â‹¯âŸ© } =>
          if
              True âˆ§
                (BitVec.zeroExtend 32 xâœÂ²).msb = (1#32).msb âˆ§
                  (BitVec.zeroExtend 32 xâœÂ² + 1#32).msb â‰  (BitVec.zeroExtend 32 xâœÂ²).msb then
            none
          else some (BitVec.zeroExtend 32 xâœÂ² + 1#32)
        | some { toFin := âŸ¨0, â‹¯âŸ© } => some (BitVec.zeroExtend 32 xâœÂ²)
      [Meta.whnf] [0.002937] Non-easy whnf: match some xâœÂ¹ with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } =>
            if
                True âˆ§
                  (BitVec.zeroExtend 32 xâœÂ²).msb = (1#32).msb âˆ§
                    (BitVec.zeroExtend 32 xâœÂ² + 1#32).msb â‰  (BitVec.zeroExtend 32 xâœÂ²).msb then
              none
            else some (BitVec.zeroExtend 32 xâœÂ² + 1#32)
          | some { toFin := âŸ¨0, â‹¯âŸ© } => some (BitVec.zeroExtend 32 xâœÂ²)
        [Meta.whnf] [0.002779] Non-easy whnf: (fun motive c? h_1 h_2 h_3 =>
                Option.casesOn c? (h_1 ()) fun val =>
                  BitVec.casesOn val fun toFin =>
                    Fin.casesOn toFin fun val isLt =>
                      Nat.casesOn (motive := fun x => (isLt : x < 2 ^ 1) â†’ motive (some { toFin := âŸ¨x, isLtâŸ© })) val
                        (fun isLt => h_3 ())
                        (fun n isLt =>
                          Nat.casesOn (motive := fun x =>
                            (isLt : x.succ < 2 ^ 1) â†’ motive (some { toFin := âŸ¨x.succ, isLtâŸ© })) n (fun isLt => h_2 ())
                            (fun n isLt => â‹¯.elim) isLt)
                        isLt)
              (fun c? => LLVM.IntW 32) (some xâœÂ¹) h_1 h_2 h_3
  [Meta.isDefEq] [0.001038] âŒï¸ ?a ==
        ?a =?= (BitVec.zeroExtend 32 xâœÂ² + 1#32).getLsbD 31 == (BitVec.zeroExtend 32 xâœÂ²).getLsbD 31
  [Meta.isDefEq] [0.004873] âŒï¸ match some { toFin := âŸ¨0, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœÂ¹ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } =>
        if
            (!(BitVec.zeroExtend 32 xâœÂ²).getLsbD 31 &&
                !(BitVec.zeroExtend 32 xâœÂ² + 1#32).getLsbD 31 == (BitVec.zeroExtend 32 xâœÂ²).getLsbD 31) =
              true then
          none
        else some (BitVec.zeroExtend 32 xâœÂ² + 1#32)
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some (BitVec.zeroExtend 32 xâœÂ²)
    [Meta.whnf] [0.004114] Non-easy whnf: (fun motive c? h_1 h_2 h_3 =>
            Option.casesOn c? (h_1 ()) fun val =>
              BitVec.casesOn val fun toFin =>
                Fin.casesOn toFin fun val isLt =>
                  Nat.casesOn (motive := fun x => (isLt : x < 2 ^ 1) â†’ motive (some { toFin := âŸ¨x, isLtâŸ© })) val
                    (fun isLt => h_3 ())
                    (fun n isLt =>
                      Nat.casesOn (motive := fun x =>
                        (isLt : x.succ < 2 ^ 1) â†’ motive (some { toFin := âŸ¨x.succ, isLtâŸ© })) n (fun isLt => h_2 ())
                        (fun n isLt => â‹¯.elim) isLt)
                    isLt)
          ?motive (some { toFin := âŸ¨0, â‹¯âŸ© }) h_1 h_2 h_3
      [Meta.whnf] [0.004023] Non-easy whnf: 0
        [Meta.whnf] [0.004010] Non-easy whnf: instOfNatNat 0
  [Meta.isDefEq] [0.194848] âŒï¸ ?a + ?a =?= a + 1#32
    [Meta.isDefEq] [0.194502] âŒï¸ a =?= 1#32
      [Meta.isDefEq] [0.194487] âŒï¸ a =?= 1#32
  [Meta.isDefEq] [0.071622] âŒï¸ ?b && ?b =?= !a.getLsbD 31 && !(a + 1#32).getLsbD 31 == a.getLsbD 31
    [Meta.isDefEq] [0.071537] âŒï¸ !a.getLsbD 31 =?= !(a + 1#32).getLsbD 31 == a.getLsbD 31
      [Meta.isDefEq] [0.071530] âŒï¸ !a.getLsbD 31 =?= !(a + 1#32).getLsbD 31 == a.getLsbD 31
        [Meta.isDefEq] [0.071487] âŒï¸ a.getLsbD 31 =?= (a + 1#32).getLsbD 31 == a.getLsbD 31
          [Meta.isDefEq] [0.071338] âŒï¸ @BitVec.getLsbD =?= @BEq.beq
  [Meta.isDefEq] [0.077782] âŒï¸ ?a == ?a =?= (a + 1#32).getLsbD 31 == a.getLsbD 31
    [Meta.isDefEq] [0.077582] âŒï¸ (a + 1#32).getLsbD 31 =?= a.getLsbD 31
      [Meta.isDefEq] [0.077574] âŒï¸ (a + 1#32).getLsbD 31 =?= a.getLsbD 31
        [Meta.isDefEq] [0.077538] âŒï¸ a + 1#32 =?= a
          [Meta.isDefEq] [0.077490] âŒï¸ instHAdd =?= instHAdd
  [Meta.isDefEq] [0.001022] âŒï¸ ?a == ?a =?= (a + 1#32).getLsbD 31 == a.getLsbD 31
  [Meta.isDefEq] [0.068471] âœ…ï¸ ?g =?= fun a =>
        if (!a.getLsbD 31 && !(a + 1#32).getLsbD 31 == a.getLsbD 31) = true then none else some (a + 1#32)
    [Meta.isDefEq.assign] [0.068464] âœ…ï¸ ?g := fun a =>
          if (!a.getLsbD 31 && !(a + 1#32).getLsbD 31 == a.getLsbD 31) = true then none else some (a + 1#32)
      [Meta.isDefEq.assign.checkTypes] [0.068450] âœ…ï¸ (?g : BitVec 32 â†’
            Option
              (BitVec
                32)) := (fun a =>
            if (!a.getLsbD 31 && !(a + 1#32).getLsbD 31 == a.getLsbD 31) = true then none
            else some (a + 1#32) : BitVec 32 â†’ Option (BitVec 32))
        [Meta.isDefEq] [0.068440] âœ…ï¸ BitVec 32 â†’ Option (BitVec 32) =?= BitVec 32 â†’ Option (BitVec 32)
          [Meta.isDefEq] [0.068422] âœ…ï¸ Option (BitVec 32) =?= Option (BitVec 32)
  [Meta.isDefEq] [0.060058] âŒï¸ ?a == ?a =?= (a + 1#32).getLsbD 31 == a.getLsbD 31
    [Meta.isDefEq.onFailure] [0.059313] âŒï¸ ?a == ?a =?= (a + 1#32).getLsbD 31 == a.getLsbD 31
      [Meta.synthInstance] [0.059243] ğŸ’¥ï¸ BEq ?Î±
        [Meta.synthInstance] [0.058771] ğŸ’¥ï¸ apply Nat.Linear.instBEqPolyCnstr to BEq ?Î±
          [Meta.synthInstance.tryResolve] [0.058725] ğŸ’¥ï¸ BEq ?Î± â‰Ÿ BEq Nat.Linear.PolyCnstr
            [Meta.isDefEq] [0.058709] ğŸ’¥ï¸ BEq ?Î± =?= BEq Nat.Linear.PolyCnstr
  [Meta.isDefEq] [0.004919] âŒï¸ if ?c then ?a
      else ?a =?= if (!a.getLsbD 31 && !(a + 1#32).getLsbD 31 == a.getLsbD 31) = true then none else some (a + 1#32)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 1
      xâœÂ² xâœÂ¹ xâœ : BitVec 1
      aâœ :
        Â¬(match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              Option.bind
                (match some xâœÂ¹ with
                | none => none
                | some { toFin := âŸ¨1, â‹¯âŸ© } =>
                  if
                      (!(BitVec.zeroExtend 32 xâœÂ²).getLsbD 31 &&
                          !(BitVec.zeroExtend 32 xâœÂ² + 1#32).getLsbD 31 == (BitVec.zeroExtend 32 xâœÂ²).getLsbD 31) =
                        true then
                    none
                  else some (BitVec.zeroExtend 32 xâœÂ² + 1#32)
                | some { toFin := âŸ¨0, â‹¯âŸ© } => some (BitVec.zeroExtend 32 xâœÂ²))
                fun a =>
                if (!a.getLsbD 31 && !(a + 1#32).getLsbD 31 == a.getLsbD 31) = true then none else some (a + 1#32)
            | some { toFin := âŸ¨0, â‹¯âŸ© } =>
              match some xâœÂ¹ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } =>
                if
                    (!(BitVec.zeroExtend 32 xâœÂ²).getLsbD 31 &&
                        !(BitVec.zeroExtend 32 xâœÂ² + 1#32).getLsbD 31 == (BitVec.zeroExtend 32 xâœÂ²).getLsbD 31) =
                      true then
                  none
                else some (BitVec.zeroExtend 32 xâœÂ² + 1#32)
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some (BitVec.zeroExtend 32 xâœÂ²)) âŠ‘
            Option.bind
              (match some xâœÂ¹ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } =>
                match some xâœÂ² with
                | none => none
                | some { toFin := âŸ¨1, â‹¯âŸ© } => some 2#32
                | some { toFin := âŸ¨0, â‹¯âŸ© } => some 1#32
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some (BitVec.zeroExtend 32 xâœÂ²))
              fun a =>
              if
                  (a.getLsbD 31 == (BitVec.zeroExtend 32 xâœ).getLsbD 31 &&
                      !(a + BitVec.zeroExtend 32 xâœ).getLsbD 31 == a.getLsbD 31) =
                    true then
                none
              else
                if
                    (!((!a >áµ¤ a + BitVec.zeroExtend 32 xâœ) &&
                          !BitVec.zeroExtend 32 xâœ >áµ¤ a + BitVec.zeroExtend 32 xâœ)) =
                      true then
                  none
                else some (a + BitVec.zeroExtend 32 xâœ)
      âŠ¢ False
  [Meta.isDefEq] [0.001041] âŒï¸ ?a ==
        ?a =?= (BitVec.zeroExtend 32 xâœÂ² + 1#32).getLsbD 31 == (BitVec.zeroExtend 32 xâœÂ²).getLsbD 31
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gzexthboolhaddhsub_proof.lean:42:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gzexthboolhaddhsub_proof.lean:37:8: error: (kernel) declaration has metavariables 'zext_add_scalar_thm'
[bv] [0.032696] Normalizing goal
  [Meta.synthInstance] [0.002033] âœ…ï¸ Decidable
        (some (BitVec.zeroExtend 32 xâœ + 42#32) âŠ‘
          match some xâœ with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } => some 43#32
          | some { toFin := âŸ¨0, â‹¯âŸ© } => some 42#32)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 1
      xâœ : BitVec 1
      aâœ :
        Â¬some (BitVec.zeroExtend 32 xâœ + 42#32) âŠ‘
            match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some 43#32
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some 42#32
      âŠ¢ False
  [Meta.isDefEq] [0.001040] âŒï¸ match none with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => some 43#32
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some 42#32
  [Meta.isDefEq] [0.001156] âŒï¸ match some { toFin := âŸ¨1, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => some 43#32
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some 42#32
  [Meta.isDefEq] [0.001112] âŒï¸ match some { toFin := âŸ¨0, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => some 43#32
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some 42#32
  [Meta.isDefEq] [0.001030] âŒï¸ match none with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => some 43#32
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some 42#32
  [Meta.isDefEq] [0.001142] âŒï¸ match some { toFin := âŸ¨1, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => some 43#32
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some 42#32
  [Meta.isDefEq] [0.001165] âŒï¸ match some { toFin := âŸ¨0, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => some 43#32
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some 42#32
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 1
      xâœ : BitVec 1
      aâœ :
        Â¬some (BitVec.zeroExtend 32 xâœ + 42#32) âŠ‘
            match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some 43#32
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some 42#32
      âŠ¢ False
  [Meta.isDefEq] [0.001049] âŒï¸ match none with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => some 43#32
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some 42#32
  [Meta.isDefEq] [0.001155] âŒï¸ match some { toFin := âŸ¨1, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => some 43#32
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some 42#32
  [Meta.isDefEq] [0.001176] âŒï¸ match some { toFin := âŸ¨0, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => some 43#32
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some 42#32
  [Meta.isDefEq] [0.001046] âŒï¸ match none with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => some 43#32
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some 42#32
  [Meta.isDefEq] [0.001175] âŒï¸ match some { toFin := âŸ¨1, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => some 43#32
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some 42#32
  [Meta.isDefEq] [0.001148] âŒï¸ match some { toFin := âŸ¨0, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => some 43#32
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some 42#32
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 82.696049ms, solving context: 0.000000ms
LeanSAT proved the goal after 953.576505ms: rewriting 36.848070ms, bitblasting 0.000000ms, SAT solving 889.481565ms, LRAT trimming 1.648150ms, LRAT checking 21.428220ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gzexthboolhaddhsub_proof.lean:60:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gzexthboolhaddhsub_proof.lean:55:8: error: (kernel) declaration has metavariables 'zext_sub_const_thm'
[bv] [0.027038] Normalizing goal
  [Meta.synthInstance] [0.001363] âœ…ï¸ Decidable
        (some (42#64 - BitVec.zeroExtend 64 xâœ) âŠ‘
          match some xâœ with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } => some 41#64
          | some { toFin := âŸ¨0, â‹¯âŸ© } => some 42#64)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 1
      xâœ : BitVec 1
      aâœ :
        Â¬some (42#64 - BitVec.zeroExtend 64 xâœ) âŠ‘
            match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some 41#64
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some 42#64
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 1
      xâœ : BitVec 1
      aâœ :
        Â¬some (43#64 + ~~~BitVec.zeroExtend 64 xâœ) âŠ‘
            match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some 41#64
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some 42#64
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 367.002498ms, solving context: 0.000000ms
LeanSAT proved the goal after 897.601336ms: rewriting 15.525600ms, bitblasting 0.000000ms, SAT solving 869.609336ms, LRAT trimming 1.032260ms, LRAT checking 9.751980ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gzexthboolhaddhsub_proof.lean:78:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gzexthboolhaddhsub_proof.lean:73:8: error: (kernel) declaration has metavariables 'sext_sub_const_thm'
[bv] [0.056102] Normalizing goal
  [Meta.synthInstance] [0.001704] âœ…ï¸ Decidable
        (some (42#64 - BitVec.signExtend 64 xâœ) âŠ‘
          match some xâœ with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } => some 43#64
          | some { toFin := âŸ¨0, â‹¯âŸ© } => some 42#64)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 1
      xâœ : BitVec 1
      aâœ :
        Â¬some (42#64 - BitVec.signExtend 64 xâœ) âŠ‘
            match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some 43#64
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some 42#64
      âŠ¢ False
  [Meta.isDefEq] [0.002023] âŒï¸ ~~~?a + ?a =?= ~~~BitVec.signExtend 64 xâœ + 1#64
    [Meta.isDefEq] [0.001805] âŒï¸ instHAdd =?= instHAdd
  [Meta.isDefEq] [0.005986] âŒï¸ ?a + ?a =?= 43#64 + ~~~BitVec.signExtend 64 xâœ
    [Meta.isDefEq] [0.005814] âŒï¸ instHAdd =?= instHAdd
      [Meta.isDefEq] [0.005749] âŒï¸ { hAdd := fun a b => Add.add a b } =?= { hAdd := fun a b => Add.add a b }
  [Meta.isDefEq] [0.001155] âŒï¸ match none with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => some 43#64
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some 42#64
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 1
      xâœ : BitVec 1
      aâœ :
        Â¬some (43#64 + ~~~BitVec.signExtend 64 xâœ) âŠ‘
            match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some 43#64
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some 42#64
      âŠ¢ False
  [Meta.isDefEq] [0.002372] âŒï¸ match some { toFin := âŸ¨0, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => some 43#64
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some 42#64
    [Meta.isDefEq] [0.001938] âŒï¸ ?h_3 () =?= match some xâœ with
        | none => none
        | some { toFin := âŸ¨1, â‹¯âŸ© } => some 43#64
        | some { toFin := âŸ¨0, â‹¯âŸ© } => some 42#64
      [Meta.whnf] [0.001884] Non-easy whnf: match some xâœ with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } => some 43#64
          | some { toFin := âŸ¨0, â‹¯âŸ© } => some 42#64
  [Meta.isDefEq] [0.003517] âŒï¸ match some { toFin := âŸ¨1, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => some 43#64
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some 42#64
    [Meta.whnf] [0.002804] Non-easy whnf: (fun motive c? h_1 h_2 h_3 =>
            Option.casesOn c? (h_1 ()) fun val =>
              BitVec.casesOn val fun toFin =>
                Fin.casesOn toFin fun val isLt =>
                  Nat.casesOn (motive := fun x => (isLt : x < 2 ^ 1) â†’ motive (some { toFin := âŸ¨x, isLtâŸ© })) val
                    (fun isLt => h_3 ())
                    (fun n isLt =>
                      Nat.casesOn (motive := fun x =>
                        (isLt : x.succ < 2 ^ 1) â†’ motive (some { toFin := âŸ¨x.succ, isLtâŸ© })) n (fun isLt => h_2 ())
                        (fun n isLt => â‹¯.elim) isLt)
                    isLt)
          ?motive (some { toFin := âŸ¨1, â‹¯âŸ© }) h_1 h_2 h_3
  [Meta.isDefEq] [0.001691] âŒï¸ match some { toFin := âŸ¨0, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => some 43#64
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some 42#64
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 113.066739ms, solving context: 0.000000ms
LeanSAT proved the goal after 188.105550ms: rewriting 105.027080ms, bitblasting 0.000000ms, SAT solving 65.010570ms, LRAT trimming 3.197800ms, LRAT checking 9.267080ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gzexthboolhaddhsub_proof.lean:97:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gzexthboolhaddhsub_proof.lean:91:8: error: (kernel) declaration has metavariables 'sext_sub_nuw_thm'
[bv] [0.020557] Normalizing goal
  [Meta.synthInstance] [0.001450] âœ…ï¸ Decidable
        ((if True âˆ§ xâœ < BitVec.signExtend 8 xâœÂ¹ then none else some (xâœ - BitVec.signExtend 8 xâœÂ¹)) âŠ‘
          some (xâœ + BitVec.zeroExtend 8 xâœÂ¹))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 1
      e_1 : LLVM.IntW 8
      xâœÂ¹ : BitVec 1
      xâœ : BitVec 8
      aâœ :
        Â¬(if True âˆ§ xâœ < BitVec.signExtend 8 xâœÂ¹ then none else some (xâœ - BitVec.signExtend 8 xâœÂ¹)) âŠ‘
            some (xâœ + BitVec.zeroExtend 8 xâœÂ¹)
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 1
      e_1 : LLVM.IntW 8
      xâœÂ¹ : BitVec 1
      xâœ : BitVec 8
      aâœ :
        Â¬(if (BitVec.signExtend 8 xâœÂ¹ >áµ¤ xâœ) = true then none else some (xâœ + (~~~BitVec.signExtend 8 xâœÂ¹ + 1#8))) âŠ‘
            some (xâœ + BitVec.zeroExtend 8 xâœÂ¹)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 78.458530ms, solving context: 0.000000ms
LeanSAT proved the goal after 90.243079ms: rewriting 25.477060ms, bitblasting 0.000000ms, SAT solving 61.009479ms, LRAT trimming 0.000000ms, LRAT checking 1.761510ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gzexthboolhaddhsub_proof.lean:117:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gzexthboolhaddhsub_proof.lean:110:8: error: (kernel) declaration has metavariables 'sextbool_add_commute_thm'
[bv] [0.027708] Normalizing goal
  [Meta.synthInstance] [0.001438] âœ…ï¸ Decidable
        ((if 42#32 = 0 then none else some (xâœ % 42#32 + BitVec.signExtend 32 xâœÂ¹)) âŠ‘
          if 42#32 = 0 then none
          else
            if
                True âˆ§
                  (xâœ % 42#32).msb = (BitVec.signExtend 32 xâœÂ¹).msb âˆ§
                    (xâœ % 42#32 + BitVec.signExtend 32 xâœÂ¹).msb â‰  (xâœ % 42#32).msb then
              none
            else some (xâœ % 42#32 + BitVec.signExtend 32 xâœÂ¹))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 1
      e_1 : LLVM.IntW 32
      xâœÂ¹ : BitVec 1
      xâœ : BitVec 32
      aâœ :
        Â¬(if 42#32 = 0 then none else some (xâœ % 42#32 + BitVec.signExtend 32 xâœÂ¹)) âŠ‘
            if 42#32 = 0 then none
            else
              if
                  True âˆ§
                    (xâœ % 42#32).msb = (BitVec.signExtend 32 xâœÂ¹).msb âˆ§
                      (xâœ % 42#32 + BitVec.signExtend 32 xâœÂ¹).msb â‰  (xâœ % 42#32).msb then
                none
              else some (xâœ % 42#32 + BitVec.signExtend 32 xâœÂ¹)
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 1
      e_1 : LLVM.IntW 32
      xâœÂ¹ : BitVec 1
      xâœ : BitVec 32
      aâœ :
        Â¬some (xâœ % 42#32 + BitVec.signExtend 32 xâœÂ¹) âŠ‘
            if
                ((xâœ % 42#32).getLsbD 31 == (BitVec.signExtend 32 xâœÂ¹).getLsbD 31 &&
                    !(xâœ % 42#32 + BitVec.signExtend 32 xâœÂ¹).getLsbD 31 == (xâœ % 42#32).getLsbD 31) =
                  true then
              none
            else some (xâœ % 42#32 + BitVec.signExtend 32 xâœÂ¹)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
