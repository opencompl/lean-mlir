‚ö† [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
‚ö† [878/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
‚ö† [884/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
‚ö† [887/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
‚ö† [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
Bitwuzla proved the goal after 7.676300ms, solving context: 0.000000ms
LeanSAT proved the goal after 5.772200ms: rewriting 5.735930ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 4.799040ms, solving context: 0.000000ms
LeanSAT proved the goal after 3.657110ms: rewriting 3.633600ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 21.125560ms, solving context: 0.000000ms
LeanSAT proved the goal after 17.794300ms: rewriting 17.764980ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 19.916110ms, solving context: 0.000000ms
LeanSAT proved the goal after 18.889580ms: rewriting 18.859230ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 94.234219ms, solving context: 1.000000ms
LeanSAT proved the goal after 806.362538ms: rewriting 27.991980ms, bitblasting 0.000000ms, SAT solving 464.374099ms, LRAT trimming 205.209669ms, LRAT checking 100.311420ms
Bitwuzla proved the goal after 93.552800ms, solving context: 4.000000ms
LeanSAT proved the goal after 312.290728ms: rewriting 18.040310ms, bitblasting 0.000000ms, SAT solving 214.952928ms, LRAT trimming 51.972600ms, LRAT checking 17.630690ms
Bitwuzla proved the goal after 91.680629ms, solving context: 0.000000ms
LeanSAT proved the goal after 258.233590ms: rewriting 16.398970ms, bitblasting 0.000000ms, SAT solving 108.552470ms, LRAT trimming 26.605580ms, LRAT checking 71.282700ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gapinthsub_proof.lean:79:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gapinthsub_proof.lean:74:8: error: (kernel) declaration has metavariables 'test8_thm'
[bv] [0.014906] Normalizing goal
  [Meta.synthInstance] [0.001228] ‚úÖÔ∏è Decidable (some (9#27 * x‚úù - x‚úù) ‚äë if 3#27 ‚â• ‚Üë27 then none else some (x‚úù <<< 3#27))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 27
      x‚úù : BitVec 27
      a‚úù : ¬¨some (9#27 * x‚úù - x‚úù) ‚äë if 3#27 ‚â• ‚Üë27 then none else some (x‚úù <<< 3#27)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 27
      x‚úù : BitVec 27
      a‚úù : ¬¨some (9#27 * x‚úù + (~~~x‚úù + 1#27)) ‚äë some (x‚úù <<< 3)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gapinthsub_proof.lean:88:4: error: The SAT solver timed out while solving the problem.
Consider increasing the timeout with `set_option sat.timeout <sec>`.
If solving your problem relies inherently on using associativity or commutativity, consider enabling the `bv.ac_nf` option.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gapinthsub_proof.lean:83:8: error: (kernel) declaration has metavariables 'test9_thm'
[bv] [0.016236] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 42
      x‚úù : BitVec 42
      a‚úù : ¬¨x‚úù - 3#42 * x‚úù = x‚úù * 4398046511102#42
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 42
      x‚úù : BitVec 42
      a‚úù : (!x‚úù + (~~~(3#42 * x‚úù) + 1#42) == x‚úù * 4398046511102#42) = true
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
[Meta.Tactic.bv] New atom of width 42: x‚úù
[Meta.Tactic.bv] Reflected bv logical expression: !((var0 + ((~ (0x00000000003#42 * var0)) + 0x00000000001#42)) == (var0 * 0x3fffffffffe#42))
[bv] [0.110755] Preparing LRAT reflection term
  [Meta.Tactic.bv] Encoded as SMT: (set-logic QF_BV)
      (declare-const x_0 (_ BitVec 42))
      (assert (not (= (bvadd x_0 (bvadd (bvnot (bvmul #b000000000000000000000000000000000000000011 x_0)) #b000000000000000000000000000000000000000001)) (bvmul x_0 #b111111111111111111111111111111111111111110))))
      (check-sat)
      (exit)
      
  [bv] [0.109784] Proving with bitwuzla
    [Meta.Tactic.bv] solving_context::time_solve: 37ms
[bv] [0.035371] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case some.h
      x‚úù : BitVec 42
      a‚úù : ¬¨x‚úù - 3#42 * x‚úù = x‚úù * 4398046511102#42
      ‚ä¢ False
  [Meta.isDefEq] [0.004448] ‚ùåÔ∏è ?a + (~~~?a + 1#?w) =?= x‚úù + (~~~(3#42 * x‚úù) + 1#42)
    [Meta.isDefEq] [0.004283] ‚ùåÔ∏è ~~~x‚úù + 1#42 =?= ~~~(3#42 * x‚úù) + 1#42
      [Meta.isDefEq] [0.004165] ‚ùåÔ∏è instHAdd =?= instHAdd
        [Meta.isDefEq] [0.004128] ‚ùåÔ∏è { hAdd := fun a b => Add.add a b } =?= { hAdd := fun a b => Add.add a b }
  [Meta.isDefEq] [0.003495] ‚ùåÔ∏è ?a == ?a =?= x‚úù + (~~~(3#42 * x‚úù) + 1#42) == x‚úù * 4398046511102#42
    [Meta.isDefEq.onFailure] [0.003036] ‚ùåÔ∏è ?a == ?a =?= x‚úù + (~~~(3#42 * x‚úù) + 1#42) == x‚úù * 4398046511102#42
      [Meta.synthInstance] [0.002996] üí•Ô∏è BEq ?Œ±
        [Meta.synthInstance] [0.002681] üí•Ô∏è apply Nat.Linear.instBEqPolyCnstr to BEq ?Œ±
          [Meta.synthInstance.tryResolve] [0.002657] üí•Ô∏è BEq ?Œ± ‚âü BEq Nat.Linear.PolyCnstr
            [Meta.isDefEq] [0.002648] üí•Ô∏è BEq ?Œ± =?= BEq Nat.Linear.PolyCnstr
  [Meta.Tactic.bv] Rerunning pipeline on:
      case some.h
      x‚úù : BitVec 42
      a‚úù : (!x‚úù + (~~~(3#42 * x‚úù) + 1#42) == x‚úù * 4398046511102#42) = true
      ‚ä¢ False
  [Meta.isDefEq] [0.002626] ‚ùåÔ∏è ?a == ?a =?= x‚úù + (~~~(3#42 * x‚úù) + 1#42) == x‚úù * 4398046511102#42
    [Meta.isDefEq.onFailure] [0.002257] ‚ùåÔ∏è ?a == ?a =?= x‚úù + (~~~(3#42 * x‚úù) + 1#42) == x‚úù * 4398046511102#42
      [Meta.synthInstance] [0.002236] üí•Ô∏è BEq ?Œ±
        [Meta.synthInstance] [0.002154] new goal BEq ?Œ±
  [Meta.Tactic.bv] Pipeline reached a fixpoint
[Meta.Tactic.bv] New atom of width 42: x‚úù
[Meta.Tactic.bv] Reflected bv logical expression: !((var0 + ((~ (0x00000000003#42 * var0)) + 0x00000000001#42)) == (var0 * 0x3fffffffffe#42))
[bv] [11.676884] Preparing LRAT reflection term
  [bv] [0.404486] Bitblasting BVLogicalExpr to AIG
  [Meta.Tactic.bv] AIG has 32578 nodes.
  [sat] [1.150879] Converting AIG to CNF
  [sat] [10.121391] Obtaining external proof certificate
    [sat] [0.082087] Serializing SAT problem to DIMACS file
    [sat] [10.038939] Running SAT solver
Bitwuzla proved the goal after 90.259720ms, solving context: 0.000000ms
LeanSAT proved the goal after 96.603810ms: rewriting 27.056580ms, bitblasting 0.000000ms, SAT solving 54.397030ms, LRAT trimming 1.463770ms, LRAT checking 6.976050ms
Bitwuzla proved the goal after 0.634730ms, solving context: 0.000000ms
LeanSAT proved the goal after 2.820940ms: rewriting 2.805500ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 71.989829ms, solving context: 0.000000ms
LeanSAT proved the goal after 78.987670ms: rewriting 17.115300ms, bitblasting 0.000000ms, SAT solving 54.148390ms, LRAT trimming 0.000000ms, LRAT checking 3.811760ms
Bitwuzla proved the goal after 0.647130ms, solving context: 0.000000ms
LeanSAT proved the goal after 2.749730ms: rewriting 2.732030ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 72.749920ms, solving context: 0.000000ms
LeanSAT proved the goal after 79.599420ms: rewriting 17.460590ms, bitblasting 0.000000ms, SAT solving 54.122310ms, LRAT trimming 1.353120ms, LRAT checking 4.589940ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gapinthsub_proof.lean:126:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gapinthsub_proof.lean:120:8: error: (kernel) declaration has metavariables 'test16_thm'
[bv] [0.037979] Normalizing goal
  [Meta.synthInstance] [0.001065] ‚úÖÔ∏è Decidable
        ((if (1123#51 == 0 || 51 != 1 && x‚úù == BitVec.intMin 51 && 1123#51 == -1) = true then none
          else some (0#51 - x‚úù.sdiv 1123#51)) ‚äë
          if (2251799813684125#51 == 0 || 51 != 1 && x‚úù == BitVec.intMin 51 && 2251799813684125#51 == -1) = true then
            none
          else some (x‚úù.sdiv 2251799813684125#51))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 51
      x‚úù : BitVec 51
      a‚úù :
        ¬¨(if (1123#51 == 0 || 51 != 1 && x‚úù == BitVec.intMin 51 && 1123#51 == -1) = true then none
            else some (0#51 - x‚úù.sdiv 1123#51)) ‚äë
            if (2251799813684125#51 == 0 || 51 != 1 && x‚úù == BitVec.intMin 51 && 2251799813684125#51 == -1) = true then
              none
            else some (x‚úù.sdiv 2251799813684125#51)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 51
      x‚úù : BitVec 51
      a‚úù :
        ¬¨some ((~~~if x‚úù.getLsbD 50 = true then ~~~((~~~x‚úù + 1#51) / 1123#51) + 1#51 else x‚úù / 1123#51) + 1#51) ‚äë
            some (if x‚úù.getLsbD 50 = true then (~~~x‚úù + 1#51) / 1123#51 else ~~~(x‚úù / 1123#51) + 1#51)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gapinthsub_proof.lean:135:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gapinthsub_proof.lean:130:8: error: (kernel) declaration has metavariables 'test18_thm'
[bv] [0.009470] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 128
      x‚úù : BitVec 128
      a‚úù :
        ¬¨(if 2#128 ‚â• ‚Üë128 then none else if 2#128 ‚â• ‚Üë128 then none else some (x‚úù <<< 2#128 - x‚úù <<< 2#128)) ‚äë some 0#128
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 128
      x‚úù : BitVec 128
      a‚úù : ¬¨some 0#128 ‚äë some 0#128
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 71.365970ms, solving context: 0.000000ms
LeanSAT proved the goal after 95.472469ms: rewriting 14.980940ms, bitblasting 0.000000ms, SAT solving 54.414890ms, LRAT trimming 10.222760ms, LRAT checking 13.140569ms
Bitwuzla proved the goal after 90.386910ms, solving context: 0.000000ms
LeanSAT proved the goal after 97.905239ms: rewriting 26.918120ms, bitblasting 0.000000ms, SAT solving 54.349870ms, LRAT trimming 1.268210ms, LRAT checking 7.514940ms
Bitwuzla proved the goal after 90.221339ms, solving context: 0.000000ms
LeanSAT proved the goal after 139.021510ms: rewriting 26.943090ms, bitblasting 3.601230ms, SAT solving 54.442690ms, LRAT trimming 10.847080ms, LRAT checking 27.651820ms
