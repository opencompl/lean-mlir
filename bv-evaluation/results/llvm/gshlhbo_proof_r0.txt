โ [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
โ [881/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
โ [884/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
โ [887/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
โ [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:18:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:18:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:11:8: error: (kernel) declaration has metavariables 'lshr_add_thm'
[bv] [0.077265] Normalizing goal
  [Meta.synthInstance] [0.002183] โ๏ธ Decidable
        ((if 5#8 โฅ โ8 then none
          else
            (Option.map (fun div => xโยน - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && xโยน == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (xโยน.sdiv 42#8))).bind
              fun x => if 5#8 โฅ โ8 then none else some ((xโ >>> 5#8 + x) <<< 5#8)) โ
          (Option.map (fun div => xโยน - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโยน == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโยน.sdiv 42#8))).bind
            fun x => if 5#8 โฅ โ8 then none else some (xโ + x <<< 5#8 &&& 224#8))
    [Meta.check] [0.001399] โ๏ธ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if 5#8 โฅ โ8 then none
          else
            (Option.map (fun div => xโยน - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && xโยน == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (xโยน.sdiv 42#8))).bind
              fun x => if 5#8 โฅ โ8 then none else some ((xโ >>> 5#8 + x) <<< 5#8))
          ((Option.map (fun div => xโยน - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโยน == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโยน.sdiv 42#8))).bind
            fun x => if 5#8 โฅ โ8 then none else some (xโ + x <<< 5#8 &&& 224#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      xโยน xโ : BitVec 8
      aโ :
        ยฌ(if 5#8 โฅ โ8 then none
            else
              (Option.map (fun div => xโยน - div * 42#8)
                    (if (42#8 == 0 || 8 != 1 && xโยน == BitVec.intMin 8 && 42#8 == -1) = true then none
                    else some (xโยน.sdiv 42#8))).bind
                fun x => if 5#8 โฅ โ8 then none else some ((xโ >>> 5#8 + x) <<< 5#8)) โ
            (Option.map (fun div => xโยน - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && xโยน == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (xโยน.sdiv 42#8))).bind
              fun x => if 5#8 โฅ โ8 then none else some (xโ + x <<< 5#8 &&& 224#8)
      โข False
  [Meta.isDefEq] [0.002560] โ๏ธ ?a == ?a =?= 42#8 == 0#8
    [Meta.isDefEq.onFailure] [0.002219] โ๏ธ ?a == ?a =?= 42#8 == 0#8
      [Meta.synthInstance] [0.002195] ๐ฅ๏ธ BEq ?ฮฑ
        [Meta.synthInstance] [0.001276] new goal BEq ?ฮฑ
  [Meta.appBuilder] [0.001095] โ๏ธ f: eq_false', xs: [fun h => Bool.noConfusion h]
    [Meta.isDefEq] [0.001054] โ๏ธ ?p โ False =?= false = true โ Bool.noConfusionType False false true
      [Meta.isDefEq] [0.001031] โ๏ธ False =?= Bool.noConfusionType False false true
  [Meta.isDefEq] [0.002127] โ๏ธ ?hf =?= fun a a_1 =>
        ite_cond_eq_false none (some ((xโ >>> 5#8 + a) <<< 5#8))
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 5#8)
              (Eq.trans (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 5#8 8#8) (eq_self true)))
                Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))
    [Meta.isDefEq.assign] [0.002123] โ๏ธ ?hf := fun a a_1 =>
          ite_cond_eq_false none (some ((xโ >>> 5#8 + a) <<< 5#8))
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 5#8)
                (Eq.trans (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 5#8 8#8) (eq_self true)))
                  Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))
      [Meta.isDefEq.assign.checkTypes] [0.002084] โ๏ธ (?hf : โ
            a โ
              Option.map (fun div => xโยน + (~~~(div * 42#8) + 1#8))
                (some (if xโยน.getLsbD 7 = true then ~~~((~~~xโยน + 1#8) / 42#8) + 1#8 else xโยน / 42#8)),
            (if 5#8 โฅ โ8 then none else some ((xโ >>> 5#8 + a) <<< 5#8)) =
              some
                ((xโ >>> 5 + a) <<<
                  5)) := (fun a a_1 =>
            ite_cond_eq_false none (some ((xโ >>> 5#8 + a) <<< 5#8))
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 5#8)
                  (Eq.trans
                    (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 5#8 8#8) (eq_self true)))
                    Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))) : โ
            a โ
              Option.map (fun div => xโยน + (~~~(div * 42#8) + 1#8))
                (some (if xโยน.getLsbD 7 = true then ~~~((~~~xโยน + 1#8) / 42#8) + 1#8 else xโยน / 42#8)),
            (if 5#8 โฅ โ8 then none else some ((xโ >>> 5#8 + a) <<< 5#8)) = some ((xโ >>> 5#8 + a) <<< 5#8))
        [Meta.isDefEq] [0.002079] โ๏ธ โ
              a โ
                Option.map (fun div => xโยน + (~~~(div * 42#8) + 1#8))
                  (some (if xโยน.getLsbD 7 = true then ~~~((~~~xโยน + 1#8) / 42#8) + 1#8 else xโยน / 42#8)),
              (if 5#8 โฅ โ8 then none else some ((xโ >>> 5#8 + a) <<< 5#8)) =
                some
                  ((xโ >>> 5 + a) <<<
                    5) =?= โ
              a โ
                Option.map (fun div => xโยน + (~~~(div * 42#8) + 1#8))
                  (some (if xโยน.getLsbD 7 = true then ~~~((~~~xโยน + 1#8) / 42#8) + 1#8 else xโยน / 42#8)),
              (if 5#8 โฅ โ8 then none else some ((xโ >>> 5#8 + a) <<< 5#8)) = some ((xโ >>> 5#8 + a) <<< 5#8)
          [Meta.isDefEq] [0.002036] โ๏ธ (if 5#8 โฅ โ8 then none else some ((xโ >>> 5#8 + a) <<< 5#8)) =
                some
                  ((xโ >>> 5 + a) <<<
                    5) =?= (if 5#8 โฅ โ8 then none else some ((xโ >>> 5#8 + a) <<< 5#8)) =
                some ((xโ >>> 5#8 + a) <<< 5#8)
            [Meta.isDefEq] [0.001993] โ๏ธ some ((xโ >>> 5 + a) <<< 5) =?= some ((xโ >>> 5#8 + a) <<< 5#8)
              [Meta.isDefEq] [0.001967] โ๏ธ (xโ >>> 5 + a) <<< 5 =?= (xโ >>> 5#8 + a) <<< 5#8
                [Meta.isDefEq] [0.001944] โ๏ธ BitVec.instHShiftLeftNat.1 (xโ >>> 5 + a)
                      5 =?= BitVec.instHShiftLeft.1 (xโ >>> 5#8 + a) 5#8
                  [Meta.isDefEq] [0.001880] โ๏ธ (xโ >>> 5 + a).shiftLeft 5 =?= (xโ >>> 5#8 + a) <<< (5#8).toNat
                    [Meta.isDefEq] [0.001853] โ๏ธ (xโ >>> 5 + a).shiftLeft 5 =?= (xโ >>> 5#8 + a).shiftLeft (5#8).toNat
                      [Meta.isDefEq.delta] [0.001844] โ๏ธ (xโ >>> 5 + a).shiftLeft
                            5 =?= (xโ >>> 5#8 + a).shiftLeft (5#8).toNat
                        [Meta.isDefEq] [0.001812] โ๏ธ xโ >>> 5 + a =?= xโ >>> 5#8 + a
                          [Meta.isDefEq] [0.001694] โ๏ธ instHAdd.1 (xโ >>> 5) a =?= instHAdd.1 (xโ >>> 5#8) a
                            [Meta.isDefEq] [0.001640] โ๏ธ Add.add (xโ >>> 5) a =?= Add.add (xโ >>> 5#8) a
                              [Meta.isDefEq] [0.001124] โ๏ธ BitVec.instAdd =?= instAddNat
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      xโยน xโ : BitVec 8
      aโ :
        ยฌ((Option.map (fun div => xโยน + (~~~(div * 42#8) + 1#8))
                  (some (if xโยน.getLsbD 7 = true then ~~~((~~~xโยน + 1#8) / 42#8) + 1#8 else xโยน / 42#8))).bind
              fun a => some ((xโ >>> 5 + a) <<< 5)) โ
            (Option.map (fun div => xโยน + (~~~(div * 42#8) + 1#8))
                  (some (if xโยน.getLsbD 7 = true then ~~~((~~~xโยน + 1#8) / 42#8) + 1#8 else xโยน / 42#8))).bind
              fun a => some (xโ + a <<< 5 &&& 224#8)
      โข False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:30:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:22:8: error: (kernel) declaration has metavariables 'lshr_sub_thm'
[bv] [0.124385] Normalizing goal
  [Meta.synthInstance] [0.002689] โ๏ธ Decidable
        (((Option.map (fun div => xโ - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโ.sdiv 42#8))).bind
            fun x => if 3#8 โฅ โ8 then none else if 3#8 โฅ โ8 then none else some ((x - xโยน >>> 3#8) <<< 3#8)) โ
          (Option.map (fun div => xโ - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโ.sdiv 42#8))).bind
            fun x =>
            if 3#8 โฅ โ8 then none
            else
              if
                  True โง
                    (BitVec.signExtend (8 + 1) x - BitVec.signExtend (8 + 1) (xโยน >>> 3#8)).msb โ
                      (BitVec.signExtend (8 + 1) x - BitVec.signExtend (8 + 1) (xโยน >>> 3#8)).getMsbD 1 then
                none
              else if 3#8 โฅ โ8 then none else some ((x - xโยน >>> 3#8) <<< 3#8))
    [Meta.check] [0.001972] โ๏ธ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          ((Option.map (fun div => xโ - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโ.sdiv 42#8))).bind
            fun x => if 3#8 โฅ โ8 then none else if 3#8 โฅ โ8 then none else some ((x - xโยน >>> 3#8) <<< 3#8))
          ((Option.map (fun div => xโ - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโ.sdiv 42#8))).bind
            fun x =>
            if 3#8 โฅ โ8 then none
            else
              if
                  True โง
                    (BitVec.signExtend (8 + 1) x - BitVec.signExtend (8 + 1) (xโยน >>> 3#8)).msb โ
                      (BitVec.signExtend (8 + 1) x - BitVec.signExtend (8 + 1) (xโยน >>> 3#8)).getMsbD 1 then
                none
              else if 3#8 โฅ โ8 then none else some ((x - xโยน >>> 3#8) <<< 3#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      xโยน xโ : BitVec 8
      aโ :
        ยฌ((Option.map (fun div => xโ - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (xโ.sdiv 42#8))).bind
              fun x => if 3#8 โฅ โ8 then none else if 3#8 โฅ โ8 then none else some ((x - xโยน >>> 3#8) <<< 3#8)) โ
            (Option.map (fun div => xโ - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (xโ.sdiv 42#8))).bind
              fun x =>
              if 3#8 โฅ โ8 then none
              else
                if
                    True โง
                      (BitVec.signExtend (8 + 1) x - BitVec.signExtend (8 + 1) (xโยน >>> 3#8)).msb โ
                        (BitVec.signExtend (8 + 1) x - BitVec.signExtend (8 + 1) (xโยน >>> 3#8)).getMsbD 1 then
                  none
                else if 3#8 โฅ โ8 then none else some ((x - xโยน >>> 3#8) <<< 3#8)
      โข False
  [Meta.isDefEq] [0.001033] โ๏ธ ?hโ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (congr
              (congrArg Ne
                (Eq.trans
                  (congrArg BitVec.msb
                    (Eq.trans (BitVec.sub_toAdd (BitVec.signExtend 9 a) (BitVec.signExtend 9 (xโยน >>> 3)))
                      (congrArg (HAdd.hAdd (BitVec.signExtend 9 a))
                        (BitVec.neg_eq_not_add (BitVec.signExtend 9 (xโยน >>> 3))))))
                  (BitVec.msb_eq_getLsbD_last (BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 3) + 1#9)))))
              (congrArg (fun x => x.getMsbD 1)
                (Eq.trans (BitVec.sub_toAdd (BitVec.signExtend 9 a) (BitVec.signExtend 9 (xโยน >>> 3)))
                  (congrArg (HAdd.hAdd (BitVec.signExtend 9 a))
                    (BitVec.neg_eq_not_add (BitVec.signExtend 9 (xโยน >>> 3)))))))
            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
              ((BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 3) + 1#9)).getLsbD 8)
              ((BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 3) + 1#9)).getMsbD 1))))
        (true_and
          ((!(BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 3) + 1#9)).getLsbD 8 ==
                (BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 3) + 1#9)).getMsbD 1) =
            true))
    [Meta.isDefEq.assign] [0.001025] โ๏ธ ?hโ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (congr
                (congrArg Ne
                  (Eq.trans
                    (congrArg BitVec.msb
                      (Eq.trans (BitVec.sub_toAdd (BitVec.signExtend 9 a) (BitVec.signExtend 9 (xโยน >>> 3)))
                        (congrArg (HAdd.hAdd (BitVec.signExtend 9 a))
                          (BitVec.neg_eq_not_add (BitVec.signExtend 9 (xโยน >>> 3))))))
                    (BitVec.msb_eq_getLsbD_last (BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 3) + 1#9)))))
                (congrArg (fun x => x.getMsbD 1)
                  (Eq.trans (BitVec.sub_toAdd (BitVec.signExtend 9 a) (BitVec.signExtend 9 (xโยน >>> 3)))
                    (congrArg (HAdd.hAdd (BitVec.signExtend 9 a))
                      (BitVec.neg_eq_not_add (BitVec.signExtend 9 (xโยน >>> 3)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                ((BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 3) + 1#9)).getLsbD 8)
                ((BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 3) + 1#9)).getMsbD 1))))
          (true_and
            ((!(BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 3) + 1#9)).getLsbD 8 ==
                  (BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 3) + 1#9)).getMsbD 1) =
              true))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      xโยน xโ : BitVec 8
      aโ :
        ยฌ((Option.map (fun div => xโ + (~~~(div * 42#8) + 1#8))
                  (some (if xโ.getLsbD 7 = true then ~~~((~~~xโ + 1#8) / 42#8) + 1#8 else xโ / 42#8))).bind
              fun a => some ((a + (~~~(xโยน >>> 3) + 1#8)) <<< 3)) โ
            (Option.map (fun div => xโ + (~~~(div * 42#8) + 1#8))
                  (some (if xโ.getLsbD 7 = true then ~~~((~~~xโ + 1#8) / 42#8) + 1#8 else xโ / 42#8))).bind
              fun a =>
              if
                  (!(BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 3) + 1#9)).getLsbD 8 ==
                        (BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 3) + 1#9)).getMsbD 1) =
                    true then
                none
              else some ((a + (~~~(xโยน >>> 3) + 1#8)) <<< 3)
      โข False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:41:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:41:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:34:8: error: (kernel) declaration has metavariables 'lshr_and_thm'
[bv] [0.175357] Normalizing goal
  [Meta.isDefEq] [0.001670] โ๏ธ ?p =?= (if 6#8 โฅ โ8 then none
        else
          (Option.map (fun div => xโยน - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโยน == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโยน.sdiv 42#8))).bind
            fun x => if 6#8 โฅ โ8 then none else some ((xโ >>> 6#8 &&& x) <<< 6#8)) โ
        (Option.map (fun div => xโยน - div * 42#8)
              (if (42#8 == 0 || 8 != 1 && xโยน == BitVec.intMin 8 && 42#8 == -1) = true then none
              else some (xโยน.sdiv 42#8))).bind
          fun x => if 6#8 โฅ โ8 then none else some (xโ &&& x <<< 6#8)
    [Meta.isDefEq.assign] [0.001663] โ๏ธ ?p := (if 6#8 โฅ โ8 then none
          else
            (Option.map (fun div => xโยน - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && xโยน == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (xโยน.sdiv 42#8))).bind
              fun x => if 6#8 โฅ โ8 then none else some ((xโ >>> 6#8 &&& x) <<< 6#8)) โ
          (Option.map (fun div => xโยน - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโยน == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโยน.sdiv 42#8))).bind
            fun x => if 6#8 โฅ โ8 then none else some (xโ &&& x <<< 6#8)
  [Meta.synthInstance] [0.001673] โ๏ธ Decidable
        ((if 6#8 โฅ โ8 then none
          else
            (Option.map (fun div => xโยน - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && xโยน == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (xโยน.sdiv 42#8))).bind
              fun x => if 6#8 โฅ โ8 then none else some ((xโ >>> 6#8 &&& x) <<< 6#8)) โ
          (Option.map (fun div => xโยน - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโยน == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโยน.sdiv 42#8))).bind
            fun x => if 6#8 โฅ โ8 then none else some (xโ &&& x <<< 6#8))
    [Meta.check] [0.001011] โ๏ธ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if 6#8 โฅ โ8 then none
          else
            (Option.map (fun div => xโยน - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && xโยน == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (xโยน.sdiv 42#8))).bind
              fun x => if 6#8 โฅ โ8 then none else some ((xโ >>> 6#8 &&& x) <<< 6#8))
          ((Option.map (fun div => xโยน - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโยน == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโยน.sdiv 42#8))).bind
            fun x => if 6#8 โฅ โ8 then none else some (xโ &&& x <<< 6#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      xโยน xโ : BitVec 8
      aโ :
        ยฌ(if 6#8 โฅ โ8 then none
            else
              (Option.map (fun div => xโยน - div * 42#8)
                    (if (42#8 == 0 || 8 != 1 && xโยน == BitVec.intMin 8 && 42#8 == -1) = true then none
                    else some (xโยน.sdiv 42#8))).bind
                fun x => if 6#8 โฅ โ8 then none else some ((xโ >>> 6#8 &&& x) <<< 6#8)) โ
            (Option.map (fun div => xโยน - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && xโยน == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (xโยน.sdiv 42#8))).bind
              fun x => if 6#8 โฅ โ8 then none else some (xโ &&& x <<< 6#8)
      โข False
  [Meta.appBuilder] [0.003910] โ๏ธ f: Complement.complement, xs: [div * 42#8]
    [Meta.synthInstance] [0.002050] โ๏ธ Complement (BitVec 8)
      [Meta.whnf] [0.001789] Non-easy whnf: Complement (BitVec 8)
  [Meta.appBuilder] [0.007561] โ๏ธ f: HAdd.hAdd, xs: [~~~(div * 42#8), 1#8]
    [Meta.isDefEq] [0.001839] โ๏ธ ?ฮฒ =?= BitVec 8
      [Meta.isDefEq.assign] [0.001833] โ๏ธ ?ฮฒ := BitVec 8
    [Meta.synthInstance] [0.005635] โ๏ธ HAdd (BitVec 8) (BitVec 8) (BitVec 8)
      [Meta.synthInstance] [0.005243] โ๏ธ apply @instHAdd to HAdd (BitVec 8) (BitVec 8) (BitVec 8)
        [Meta.synthInstance.tryResolve] [0.005122] โ๏ธ HAdd (BitVec 8) (BitVec 8)
              (BitVec 8) โ HAdd (BitVec 8) (BitVec 8) (BitVec 8)
          [Meta.isDefEq] [0.001341] โ๏ธ HAdd (BitVec 8) (BitVec 8) ?m.47578 =?= HAdd ?m.47581 ?m.47581 ?m.47581
          [Meta.isDefEq] [0.001828] โ๏ธ ?m.47579 =?= instHAdd
            [Meta.isDefEq.assign] [0.001825] โ๏ธ ?m.47579 := instHAdd
              [Meta.isDefEq.assign.checkTypes] [0.001804] โ๏ธ (?m.47579 : HAdd (BitVec 8) (BitVec 8)
                    (BitVec 8)) := (instHAdd : HAdd (BitVec 8) (BitVec 8) (BitVec 8))
                [Meta.isDefEq] [0.001797] โ๏ธ HAdd (BitVec 8) (BitVec 8)
                      (BitVec 8) =?= HAdd (BitVec 8) (BitVec 8) (BitVec 8)
  [Meta.isDefEq] [0.004194] โ๏ธ ?a + ?a =?= ~~~(div * 42#8) + 1#8
    [Meta.isDefEq] [0.002069] โ๏ธ instHAdd =?= instHAdd
      [Meta.isDefEq] [0.001974] โ๏ธ { hAdd := fun a b => Add.add a b } =?= { hAdd := fun a b => Add.add a b }
        [Meta.isDefEq.onFailure] [0.001846] โ๏ธ { hAdd := fun a b => Add.add a b } =?= { hAdd := fun a b => Add.add a b }
    [Meta.isDefEq] [0.001908] โ๏ธ ~~~(div * 42#8) =?= 1#8
      [Meta.isDefEq] [0.001896] โ๏ธ ~~~(div * 42#8) =?= 1#8
  [Meta.appBuilder] [0.002170] โ๏ธ f: funext, xs: [fun div =>
         Eq.trans (BitVec.sub_toAdd xโยน (div * 42#8)) (congrArg (HAdd.hAdd xโยน) (BitVec.neg_eq_not_add (div * 42#8)))]
  [Meta.isDefEq] [0.002763] โ๏ธ ?a == ?a =?= 42#8 == 0#8
    [Meta.isDefEq] [0.002078] โ๏ธ ?instโ =?= instBEqOfDecidableEq
      [Meta.isDefEq.assign] [0.002075] โ๏ธ ?instโ := instBEqOfDecidableEq
        [Meta.isDefEq.assign.checkTypes] [0.002068] โ๏ธ (?instโ : BEq
              (BitVec 8)) := (instBEqOfDecidableEq : BEq (BitVec 8))
          [Meta.isDefEq] [0.002064] โ๏ธ BEq (BitVec 8) =?= BEq (BitVec 8)
  [Meta.appBuilder] [0.002173] โ๏ธ f: eq_false', xs: [fun h => Bool.noConfusion h]
    [Meta.isDefEq] [0.002113] โ๏ธ ?p โ False =?= false = true โ Bool.noConfusionType False false true
      [Meta.isDefEq] [0.002080] โ๏ธ False =?= Bool.noConfusionType False false true
  [Meta.appBuilder] [0.002831] โ๏ธ f: HAdd.hAdd, xs: [~~~xโยน, 1#8]
    [Meta.isDefEq] [0.001891] โ๏ธ ?ฮฒ =?= BitVec 8
      [Meta.isDefEq.assign] [0.001872] โ๏ธ ?ฮฒ := BitVec 8
  [Meta.isDefEq] [0.002317] โ๏ธ ~~~?a + ?a =?= ~~~((~~~xโยน + 1#8) / 42#8) + 1#8
  [Meta.isDefEq] [0.002073] โ๏ธ ?hx =?= congr
        (congrArg Option.map
          (funext fun div =>
            Eq.trans (BitVec.sub_toAdd xโยน (div * 42#8))
              (congrArg (HAdd.hAdd xโยน) (BitVec.neg_eq_not_add (div * 42#8)))))
        (Eq.trans
          (ite_cond_eq_false none (some (xโยน.sdiv 42#8))
            (Eq.trans
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Eq.trans
                    (congrArg false.or
                      (Eq.trans (congrArg (fun x => x && false) (Bool.true_and (xโยน == BitVec.intMin 8)))
                        (Bool.and_false (xโยน == BitVec.intMin 8))))
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim false false))
                  (Eq.trans
                    (congrArg not
                      (Eq.trans (congr (congrArg Bool.and Bool.not_false) Bool.not_false) (Bool.and_self true)))
                    Bool.not_true)))
              (eq_false' fun h => Bool.noConfusion h)))
          (congrArg some
            (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv xโยน 42#8)
              (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last xโยน))
                (fun a =>
                  Eq.trans
                    (ite_cond_eq_false (-xโยน / -42#8) (-(-xโยน / 42#8))
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#8))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (Eq.trans (congrArg (fun x => -(x / 42#8)) (BitVec.neg_eq_not_add xโยน))
                      (BitVec.neg_eq_not_add ((~~~xโยน + 1#8) / 42#8))))
                fun a =>
                ite_cond_eq_false (-(xโยน / -42#8)) (xโยน / 42#8)
                  (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#8))
                    (eq_false' fun h => Bool.noConfusion h))))))
    [Meta.isDefEq.assign] [0.002066] โ๏ธ ?hx := congr
          (congrArg Option.map
            (funext fun div =>
              Eq.trans (BitVec.sub_toAdd xโยน (div * 42#8))
                (congrArg (HAdd.hAdd xโยน) (BitVec.neg_eq_not_add (div * 42#8)))))
          (Eq.trans
            (ite_cond_eq_false none (some (xโยน.sdiv 42#8))
              (Eq.trans
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Eq.trans
                      (congrArg false.or
                        (Eq.trans (congrArg (fun x => x && false) (Bool.true_and (xโยน == BitVec.intMin 8)))
                          (Bool.and_false (xโยน == BitVec.intMin 8))))
                      (Std.Tactic.BVDecide.Normalize.Bool.or_elim false false))
                    (Eq.trans
                      (congrArg not
                        (Eq.trans (congr (congrArg Bool.and Bool.not_false) Bool.not_false) (Bool.and_self true)))
                      Bool.not_true)))
                (eq_false' fun h => Bool.noConfusion h)))
            (congrArg some
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv xโยน 42#8)
                (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last xโยน))
                  (fun a =>
                    Eq.trans
                      (ite_cond_eq_false (-xโยน / -42#8) (-(-xโยน / 42#8))
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#8))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (Eq.trans (congrArg (fun x => -(x / 42#8)) (BitVec.neg_eq_not_add xโยน))
                        (BitVec.neg_eq_not_add ((~~~xโยน + 1#8) / 42#8))))
                  fun a =>
                  ite_cond_eq_false (-(xโยน / -42#8)) (xโยน / 42#8)
                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#8))
                      (eq_false' fun h => Bool.noConfusion h))))))
  [Meta.isDefEq] [0.019963] โ๏ธ ?hf =?= fun a a_1 =>
        ite_cond_eq_false none (some ((xโ >>> 6#8 &&& a) <<< 6#8))
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 6#8)
              (Eq.trans (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 6#8 8#8) (eq_self true)))
                Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))
    [Meta.isDefEq.assign] [0.019957] โ๏ธ ?hf := fun a a_1 =>
          ite_cond_eq_false none (some ((xโ >>> 6#8 &&& a) <<< 6#8))
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 6#8)
                (Eq.trans (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 6#8 8#8) (eq_self true)))
                  Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))
      [Meta.isDefEq.assign.checkTypes] [0.019891] โ๏ธ (?hf : โ
            a โ
              Option.map (fun div => xโยน + (~~~(div * 42#8) + 1#8))
                (some (if xโยน.getLsbD 7 = true then ~~~((~~~xโยน + 1#8) / 42#8) + 1#8 else xโยน / 42#8)),
            (if 6#8 โฅ โ8 then none else some ((xโ >>> 6#8 &&& a) <<< 6#8)) =
              some
                ((xโ >>> 6 &&& a) <<<
                  6)) := (fun a a_1 =>
            ite_cond_eq_false none (some ((xโ >>> 6#8 &&& a) <<< 6#8))
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 6#8)
                  (Eq.trans
                    (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 6#8 8#8) (eq_self true)))
                    Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))) : โ
            a โ
              Option.map (fun div => xโยน + (~~~(div * 42#8) + 1#8))
                (some (if xโยน.getLsbD 7 = true then ~~~((~~~xโยน + 1#8) / 42#8) + 1#8 else xโยน / 42#8)),
            (if 6#8 โฅ โ8 then none else some ((xโ >>> 6#8 &&& a) <<< 6#8)) = some ((xโ >>> 6#8 &&& a) <<< 6#8))
        [Meta.isDefEq] [0.019883] โ๏ธ โ
              a โ
                Option.map (fun div => xโยน + (~~~(div * 42#8) + 1#8))
                  (some (if xโยน.getLsbD 7 = true then ~~~((~~~xโยน + 1#8) / 42#8) + 1#8 else xโยน / 42#8)),
              (if 6#8 โฅ โ8 then none else some ((xโ >>> 6#8 &&& a) <<< 6#8)) =
                some
                  ((xโ >>> 6 &&& a) <<<
                    6) =?= โ
              a โ
                Option.map (fun div => xโยน + (~~~(div * 42#8) + 1#8))
                  (some (if xโยน.getLsbD 7 = true then ~~~((~~~xโยน + 1#8) / 42#8) + 1#8 else xโยน / 42#8)),
              (if 6#8 โฅ โ8 then none else some ((xโ >>> 6#8 &&& a) <<< 6#8)) = some ((xโ >>> 6#8 &&& a) <<< 6#8)
          [Meta.isDefEq] [0.019803] โ๏ธ (if 6#8 โฅ โ8 then none else some ((xโ >>> 6#8 &&& a) <<< 6#8)) =
                some
                  ((xโ >>> 6 &&& a) <<<
                    6) =?= (if 6#8 โฅ โ8 then none else some ((xโ >>> 6#8 &&& a) <<< 6#8)) =
                some ((xโ >>> 6#8 &&& a) <<< 6#8)
            [Meta.isDefEq] [0.017812] โ๏ธ some ((xโ >>> 6 &&& a) <<< 6) =?= some ((xโ >>> 6#8 &&& a) <<< 6#8)
              [Meta.isDefEq] [0.017759] โ๏ธ (xโ >>> 6 &&& a) <<< 6 =?= (xโ >>> 6#8 &&& a) <<< 6#8
                [Meta.isDefEq] [0.017706] โ๏ธ BitVec.instHShiftLeftNat.1 (xโ >>> 6 &&& a)
                      6 =?= BitVec.instHShiftLeft.1 (xโ >>> 6#8 &&& a) 6#8
                  [Meta.isDefEq] [0.017601] โ๏ธ (xโ >>> 6 &&& a).shiftLeft 6 =?= (xโ >>> 6#8 &&& a) <<< (6#8).toNat
                    [Meta.isDefEq] [0.017559] โ๏ธ (xโ >>> 6 &&& a).shiftLeft
                          6 =?= (xโ >>> 6#8 &&& a).shiftLeft (6#8).toNat
                      [Meta.isDefEq.delta] [0.017543] โ๏ธ (xโ >>> 6 &&& a).shiftLeft
                            6 =?= (xโ >>> 6#8 &&& a).shiftLeft (6#8).toNat
                        [Meta.isDefEq] [0.017491] โ๏ธ xโ >>> 6 &&& a =?= xโ >>> 6#8 &&& a
                          [Meta.isDefEq] [0.015517] โ๏ธ instHAndOfAndOp.1 (xโ >>> 6)
                                a =?= instHAndOfAndOp.1 (xโ >>> 6#8) a
                            [Meta.isDefEq] [0.014142] โ๏ธ AndOp.and (xโ >>> 6) a =?= AndOp.and (xโ >>> 6#8) a
                              [Meta.isDefEq] [0.014105] โ๏ธ BitVec.instAndOp.1 (xโ >>> 6)
                                    a =?= BitVec.instAndOp.1 (xโ >>> 6#8) a
                                [Meta.whnf] [0.001847] Non-easy whnf: AndOp (BitVec 8)
                                [Meta.isDefEq] [0.010260] โ๏ธ (xโ >>> 6).and a =?= (xโ >>> 6#8).and a
                                  [Meta.isDefEq.delta] [0.010238] โ๏ธ (xโ >>> 6).and a =?= (xโ >>> 6#8).and a
                                    [Meta.isDefEq] [0.010190] โ๏ธ xโ >>> 6 =?= xโ >>> 6#8
                                      [Meta.isDefEq] [0.010127] โ๏ธ BitVec.instHShiftRightNat.1 xโ
                                            6 =?= BitVec.instHShiftRight.1 xโ 6#8
                                        [Meta.isDefEq] [0.009995] โ๏ธ xโ.ushiftRight 6 =?= xโ >>> (6#8).toNat
                                          [Meta.isDefEq] [0.009944] โ๏ธ xโ.ushiftRight 6 =?= xโ.ushiftRight (6#8).toNat
                                            [Meta.isDefEq.delta] [0.007985] โ๏ธ xโ.ushiftRight
                                                  6 =?= xโ.ushiftRight (6#8).toNat
                                              [Meta.isDefEq] [0.007933] โ๏ธ 6 =?= (6#8).toNat
                                                [Meta.whnf] [0.001959] Non-easy whnf: instOfNatNat 6
                                                  [Meta.whnf] [0.001941] Non-easy whnf: { ofNat := 6 }
                                                [Meta.isDefEq] [0.005898] โ๏ธ 6 =?= โ(6#8).toFin
                                                  [Meta.isDefEq] [0.005845] โ๏ธ 6 =?= (6#8).toFin.1
                                                    [Meta.whnf] [0.005664] Non-easy whnf: (6#8).toFin
  [Meta.isDefEq] [0.002131] โ๏ธ ?x.bind
        ?f =?= (Option.map (fun div => xโยน + (~~~(div * 42#8) + 1#8))
            (some (if xโยน.getLsbD 7 = true then ~~~((~~~xโยน + 1#8) / 42#8) + 1#8 else xโยน / 42#8))).bind
        fun a => some ((xโ >>> 6 &&& a) <<< 6)
    [Meta.isDefEq] [0.001917] โ๏ธ ?ฮฑ =?= BitVec 8
      [Meta.isDefEq.assign] [0.001911] โ๏ธ ?ฮฑ := BitVec 8
        [Meta.isDefEq.assign.checkTypes] [0.001901] โ๏ธ (?ฮฑ : Type ?u.48404) := (BitVec 8 : Type)
  [Meta.isDefEq] [0.003794] โ๏ธ ?hx =?= congr
        (congrArg Option.map
          (funext fun div =>
            Eq.trans (BitVec.sub_toAdd xโยน (div * 42#8))
              (congrArg (HAdd.hAdd xโยน) (BitVec.neg_eq_not_add (div * 42#8)))))
        (Eq.trans
          (ite_cond_eq_false none (some (xโยน.sdiv 42#8))
            (Eq.trans
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Eq.trans
                    (congrArg false.or
                      (Eq.trans (congrArg (fun x => x && false) (Bool.true_and (xโยน == BitVec.intMin 8)))
                        (Bool.and_false (xโยน == BitVec.intMin 8))))
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim false false))
                  (Eq.trans
                    (congrArg not
                      (Eq.trans (congr (congrArg Bool.and Bool.not_false) Bool.not_false) (Bool.and_self true)))
                    Bool.not_true)))
              (eq_false' fun h => Bool.noConfusion h)))
          (congrArg some
            (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv xโยน 42#8)
              (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last xโยน))
                (fun a =>
                  Eq.trans
                    (ite_cond_eq_false (-xโยน / -42#8) (-(-xโยน / 42#8))
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#8))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (Eq.trans (congrArg (fun x => -(x / 42#8)) (BitVec.neg_eq_not_add xโยน))
                      (BitVec.neg_eq_not_add ((~~~xโยน + 1#8) / 42#8))))
                fun a =>
                ite_cond_eq_false (-(xโยน / -42#8)) (xโยน / 42#8)
                  (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#8))
                    (eq_false' fun h => Bool.noConfusion h))))))
    [Meta.isDefEq.assign] [0.003788] โ๏ธ ?hx := congr
          (congrArg Option.map
            (funext fun div =>
              Eq.trans (BitVec.sub_toAdd xโยน (div * 42#8))
                (congrArg (HAdd.hAdd xโยน) (BitVec.neg_eq_not_add (div * 42#8)))))
          (Eq.trans
            (ite_cond_eq_false none (some (xโยน.sdiv 42#8))
              (Eq.trans
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Eq.trans
                      (congrArg false.or
                        (Eq.trans (congrArg (fun x => x && false) (Bool.true_and (xโยน == BitVec.intMin 8)))
                          (Bool.and_false (xโยน == BitVec.intMin 8))))
                      (Std.Tactic.BVDecide.Normalize.Bool.or_elim false false))
                    (Eq.trans
                      (congrArg not
                        (Eq.trans (congr (congrArg Bool.and Bool.not_false) Bool.not_false) (Bool.and_self true)))
                      Bool.not_true)))
                (eq_false' fun h => Bool.noConfusion h)))
            (congrArg some
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv xโยน 42#8)
                (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last xโยน))
                  (fun a =>
                    Eq.trans
                      (ite_cond_eq_false (-xโยน / -42#8) (-(-xโยน / 42#8))
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#8))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (Eq.trans (congrArg (fun x => -(x / 42#8)) (BitVec.neg_eq_not_add xโยน))
                        (BitVec.neg_eq_not_add ((~~~xโยน + 1#8) / 42#8))))
                  fun a =>
                  ite_cond_eq_false (-(xโยน / -42#8)) (xโยน / 42#8)
                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#8))
                      (eq_false' fun h => Bool.noConfusion h))))))
  [Meta.appBuilder] [0.004588] โ๏ธ f: HShiftLeft.hShiftLeft, xs: [a, 6]
    [Meta.synthInstance] [0.004487] โ๏ธ HShiftLeft (BitVec 8) โ (BitVec 8)
      [Meta.synthInstance] [0.004218] โ๏ธ apply @BitVec.instHShiftLeftNat to HShiftLeft (BitVec 8) โ (BitVec 8)
        [Meta.synthInstance.tryResolve] [0.004175] โ๏ธ HShiftLeft (BitVec 8) โ
              (BitVec 8) โ HShiftLeft (BitVec 8) โ (BitVec 8)
          [Meta.isDefEq] [0.002127] โ๏ธ HShiftLeft (BitVec 8) โ
                ?m.48457 =?= HShiftLeft (BitVec ?m.48460) โ (BitVec ?m.48460)
  [Meta.isDefEq] [0.002165] โ๏ธ ?x &&& ?x =?= xโ &&& a <<< 6
    [Meta.isDefEq] [0.002034] โ๏ธ ?x =?= xโ
      [Meta.isDefEq.assign] [0.002028] โ๏ธ ?x := xโ
        [Meta.isDefEq.assign.checkTypes] [0.002019] โ๏ธ (?x : BitVec ?w) := (xโ : BitVec 8)
          [Meta.isDefEq] [0.002013] โ๏ธ BitVec ?w =?= BitVec 8
  [Meta.isDefEq] [0.003685] โ๏ธ ?x &&& ?x =?= xโ &&& a <<< 6
    [Meta.isDefEq] [0.003535] โ๏ธ ?x =?= xโ
      [Meta.isDefEq.assign] [0.003529] โ๏ธ ?x := xโ
        [Meta.isDefEq.assign.checkTypes] [0.003521] โ๏ธ (?x : BitVec ?w) := (xโ : BitVec 8)
          [Meta.isDefEq] [0.003515] โ๏ธ BitVec ?w =?= BitVec 8
  [Meta.isDefEq] [0.005739] โ๏ธ ?hf =?= fun a a_1 =>
        ite_cond_eq_false none (some (xโ &&& a <<< 6#8))
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 6#8)
              (Eq.trans (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 6#8 8#8) (eq_self true)))
                Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))
    [Meta.isDefEq.assign] [0.005734] โ๏ธ ?hf := fun a a_1 =>
          ite_cond_eq_false none (some (xโ &&& a <<< 6#8))
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 6#8)
                (Eq.trans (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 6#8 8#8) (eq_self true)))
                  Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))
      [Meta.isDefEq.assign.checkTypes] [0.005673] โ๏ธ (?hf : โ
            a โ
              Option.map (fun div => xโยน + (~~~(div * 42#8) + 1#8))
                (some (if xโยน.getLsbD 7 = true then ~~~((~~~xโยน + 1#8) / 42#8) + 1#8 else xโยน / 42#8)),
            (if 6#8 โฅ โ8 then none else some (xโ &&& a <<< 6#8)) =
              some
                (xโ &&&
                  a <<<
                    6)) := (fun a a_1 =>
            ite_cond_eq_false none (some (xโ &&& a <<< 6#8))
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 6#8)
                  (Eq.trans
                    (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 6#8 8#8) (eq_self true)))
                    Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))) : โ
            a โ
              Option.map (fun div => xโยน + (~~~(div * 42#8) + 1#8))
                (some (if xโยน.getLsbD 7 = true then ~~~((~~~xโยน + 1#8) / 42#8) + 1#8 else xโยน / 42#8)),
            (if 6#8 โฅ โ8 then none else some (xโ &&& a <<< 6#8)) = some (xโ &&& a <<< 6#8))
        [Meta.isDefEq] [0.005667] โ๏ธ โ
              a โ
                Option.map (fun div => xโยน + (~~~(div * 42#8) + 1#8))
                  (some (if xโยน.getLsbD 7 = true then ~~~((~~~xโยน + 1#8) / 42#8) + 1#8 else xโยน / 42#8)),
              (if 6#8 โฅ โ8 then none else some (xโ &&& a <<< 6#8)) =
                some
                  (xโ &&&
                    a <<<
                      6) =?= โ
              a โ
                Option.map (fun div => xโยน + (~~~(div * 42#8) + 1#8))
                  (some (if xโยน.getLsbD 7 = true then ~~~((~~~xโยน + 1#8) / 42#8) + 1#8 else xโยน / 42#8)),
              (if 6#8 โฅ โ8 then none else some (xโ &&& a <<< 6#8)) = some (xโ &&& a <<< 6#8)
          [Meta.isDefEq] [0.005594] โ๏ธ (if 6#8 โฅ โ8 then none else some (xโ &&& a <<< 6#8)) =
                some (xโ &&& a <<< 6) =?= (if 6#8 โฅ โ8 then none else some (xโ &&& a <<< 6#8)) = some (xโ &&& a <<< 6#8)
            [Meta.isDefEq] [0.005557] โ๏ธ some (xโ &&& a <<< 6) =?= some (xโ &&& a <<< 6#8)
              [Meta.isDefEq] [0.005531] โ๏ธ xโ &&& a <<< 6 =?= xโ &&& a <<< 6#8
                [Meta.isDefEq] [0.005491] โ๏ธ instHAndOfAndOp.1 xโ (a <<< 6) =?= instHAndOfAndOp.1 xโ (a <<< 6#8)
                  [Meta.isDefEq] [0.005438] โ๏ธ AndOp.and xโ (a <<< 6) =?= AndOp.and xโ (a <<< 6#8)
                    [Meta.isDefEq] [0.005408] โ๏ธ BitVec.instAndOp.1 xโ (a <<< 6) =?= BitVec.instAndOp.1 xโ (a <<< 6#8)
                      [Meta.isDefEq] [0.005362] โ๏ธ xโ.and (a <<< 6) =?= xโ.and (a <<< 6#8)
                        [Meta.isDefEq.delta] [0.005345] โ๏ธ xโ.and (a <<< 6) =?= xโ.and (a <<< 6#8)
                          [Meta.isDefEq] [0.005330] โ๏ธ a <<< 6 =?= a <<< 6#8
                            [Meta.isDefEq] [0.005298] โ๏ธ BitVec.instHShiftLeftNat.1 a
                                  6 =?= BitVec.instHShiftLeft.1 a 6#8
                              [Meta.whnf] [0.001856] Non-easy whnf: BitVec.instHShiftLeftNat
                              [Meta.isDefEq] [0.003392] โ๏ธ a.shiftLeft 6 =?= a <<< (6#8).toNat
                                [Meta.isDefEq] [0.003359] โ๏ธ a.shiftLeft 6 =?= a.shiftLeft (6#8).toNat
                                  [Meta.isDefEq.delta] [0.003343] โ๏ธ a.shiftLeft 6 =?= a.shiftLeft (6#8).toNat
                                    [Meta.isDefEq] [0.001471] โ๏ธ 6 =?= (6#8).toNat
                                      [Meta.isDefEq] [0.001413] โ๏ธ 6 =?= โ(6#8).toFin
                                        [Meta.isDefEq] [0.001376] โ๏ธ 6 =?= (6#8).toFin.1
                                          [Meta.isDefEq] [0.001322] โ๏ธ 6 =?= 6 % 2 ^ 8
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      xโยน xโ : BitVec 8
      aโ :
        ยฌ((Option.map (fun div => xโยน + (~~~(div * 42#8) + 1#8))
                  (some (if xโยน.getLsbD 7 = true then ~~~((~~~xโยน + 1#8) / 42#8) + 1#8 else xโยน / 42#8))).bind
              fun a => some ((xโ >>> 6 &&& a) <<< 6)) โ
            (Option.map (fun div => xโยน + (~~~(div * 42#8) + 1#8))
                  (some (if xโยน.getLsbD 7 = true then ~~~((~~~xโยน + 1#8) / 42#8) + 1#8 else xโยน / 42#8))).bind
              fun a => some (xโ &&& a <<< 6)
      โข False
  [Meta.isDefEq] [0.004319] โ๏ธ ?a + ?a =?= ~~~xโยน + 1#8
    [Meta.isDefEq] [0.004098] โ๏ธ instHAdd =?= instHAdd
      [Meta.isDefEq] [0.004018] โ๏ธ { hAdd := fun a b => Add.add a b } =?= { hAdd := fun a b => Add.add a b }
        [Meta.isDefEq] [0.003957] โ๏ธ fun a b => Add.add a b =?= fun a b => Add.add a b
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:52:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:45:8: error: (kernel) declaration has metavariables 'lshr_or_thm'
[bv] [0.063469] Normalizing goal
  [Meta.synthInstance] [0.001703] โ๏ธ Decidable
        (((Option.map (fun div => xโ - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโ.sdiv 42#8))).bind
            fun x => if 4#8 โฅ โ8 then none else if 4#8 โฅ โ8 then none else some ((x ||| xโยน >>> 4#8) <<< 4#8)) โ
          (Option.map (fun div => xโ - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโ.sdiv 42#8))).bind
            fun x => if 4#8 โฅ โ8 then none else some (xโยน &&& 240#8 ||| x <<< 4#8))
    [Meta.check] [0.001057] โ๏ธ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          ((Option.map (fun div => xโ - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโ.sdiv 42#8))).bind
            fun x => if 4#8 โฅ โ8 then none else if 4#8 โฅ โ8 then none else some ((x ||| xโยน >>> 4#8) <<< 4#8))
          ((Option.map (fun div => xโ - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโ.sdiv 42#8))).bind
            fun x => if 4#8 โฅ โ8 then none else some (xโยน &&& 240#8 ||| x <<< 4#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      xโยน xโ : BitVec 8
      aโ :
        ยฌ((Option.map (fun div => xโ - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (xโ.sdiv 42#8))).bind
              fun x => if 4#8 โฅ โ8 then none else if 4#8 โฅ โ8 then none else some ((x ||| xโยน >>> 4#8) <<< 4#8)) โ
            (Option.map (fun div => xโ - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (xโ.sdiv 42#8))).bind
              fun x => if 4#8 โฅ โ8 then none else some (xโยน &&& 240#8 ||| x <<< 4#8)
      โข False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      xโยน xโ : BitVec 8
      aโ :
        ยฌ((Option.map (fun div => xโ + (~~~(div * 42#8) + 1#8))
                  (some (if xโ.getLsbD 7 = true then ~~~((~~~xโ + 1#8) / 42#8) + 1#8 else xโ / 42#8))).bind
              fun a => some ((a ||| xโยน >>> 4) <<< 4)) โ
            (Option.map (fun div => xโ + (~~~(div * 42#8) + 1#8))
                  (some (if xโ.getLsbD 7 = true then ~~~((~~~xโ + 1#8) / 42#8) + 1#8 else xโ / 42#8))).bind
              fun a => some (xโยน &&& 240#8 ||| a <<< 4)
      โข False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:63:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:63:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:56:8: error: (kernel) declaration has metavariables 'lshr_xor_thm'
[bv] [0.075965] Normalizing goal
  [Meta.synthInstance] [0.001801] โ๏ธ Decidable
        ((if 3#8 โฅ โ8 then none
          else
            (Option.map (fun div => xโยน - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && xโยน == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (xโยน.sdiv 42#8))).bind
              fun x => if 3#8 โฅ โ8 then none else some ((xโ >>> 3#8 ^^^ x) <<< 3#8)) โ
          (Option.map (fun div => xโยน - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโยน == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโยน.sdiv 42#8))).bind
            fun x => if 3#8 โฅ โ8 then none else some (xโ &&& 248#8 ^^^ x <<< 3#8))
    [Meta.check] [0.001229] โ๏ธ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if 3#8 โฅ โ8 then none
          else
            (Option.map (fun div => xโยน - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && xโยน == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (xโยน.sdiv 42#8))).bind
              fun x => if 3#8 โฅ โ8 then none else some ((xโ >>> 3#8 ^^^ x) <<< 3#8))
          ((Option.map (fun div => xโยน - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโยน == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโยน.sdiv 42#8))).bind
            fun x => if 3#8 โฅ โ8 then none else some (xโ &&& 248#8 ^^^ x <<< 3#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      xโยน xโ : BitVec 8
      aโ :
        ยฌ(if 3#8 โฅ โ8 then none
            else
              (Option.map (fun div => xโยน - div * 42#8)
                    (if (42#8 == 0 || 8 != 1 && xโยน == BitVec.intMin 8 && 42#8 == -1) = true then none
                    else some (xโยน.sdiv 42#8))).bind
                fun x => if 3#8 โฅ โ8 then none else some ((xโ >>> 3#8 ^^^ x) <<< 3#8)) โ
            (Option.map (fun div => xโยน - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && xโยน == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (xโยน.sdiv 42#8))).bind
              fun x => if 3#8 โฅ โ8 then none else some (xโ &&& 248#8 ^^^ x <<< 3#8)
      โข False
  [Meta.appBuilder] [0.002682] โ๏ธ f: HAdd.hAdd, xs: [~~~(div * 42#8), 1#8]
    [Meta.synthInstance] [0.002593] โ๏ธ HAdd (BitVec 8) (BitVec 8) (BitVec 8)
      [Meta.synthInstance] [0.002130] โ๏ธ apply @instHAdd to HAdd (BitVec 8) (BitVec 8) (BitVec 8)
        [Meta.synthInstance.tryResolve] [0.002069] โ๏ธ HAdd (BitVec 8) (BitVec 8)
              (BitVec 8) โ HAdd (BitVec 8) (BitVec 8) (BitVec 8)
          [Meta.isDefEq] [0.001994] โ๏ธ HAdd (BitVec 8) (BitVec 8) ?m.78537 =?= HAdd ?m.78540 ?m.78540 ?m.78540
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      xโยน xโ : BitVec 8
      aโ :
        ยฌ((Option.map (fun div => xโยน + (~~~(div * 42#8) + 1#8))
                  (some (if xโยน.getLsbD 7 = true then ~~~((~~~xโยน + 1#8) / 42#8) + 1#8 else xโยน / 42#8))).bind
              fun a => some ((xโ >>> 3 ^^^ a) <<< 3)) โ
            (Option.map (fun div => xโยน + (~~~(div * 42#8) + 1#8))
                  (some (if xโยน.getLsbD 7 = true then ~~~((~~~xโยน + 1#8) / 42#8) + 1#8 else xโยน / 42#8))).bind
              fun a => some (xโ &&& 248#8 ^^^ a <<< 3)
      โข False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:74:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:67:8: error: (kernel) declaration has metavariables 'lshr_and_add_thm'
[bv] [0.091671] Normalizing goal
  [Meta.synthInstance] [0.001734] โ๏ธ Decidable
        (((Option.map (fun div => xโ - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโ.sdiv 42#8))).bind
            fun x =>
            if 3#8 โฅ โ8 then none else if 3#8 โฅ โ8 then none else some ((x + (xโยน >>> 3#8 &&& 12#8)) <<< 3#8)) โ
          (Option.map (fun div => xโ - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโ.sdiv 42#8))).bind
            fun x => if 3#8 โฅ โ8 then none else some ((xโยน &&& 96#8) + x <<< 3#8))
    [Meta.check] [0.001140] โ๏ธ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          ((Option.map (fun div => xโ - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโ.sdiv 42#8))).bind
            fun x => if 3#8 โฅ โ8 then none else if 3#8 โฅ โ8 then none else some ((x + (xโยน >>> 3#8 &&& 12#8)) <<< 3#8))
          ((Option.map (fun div => xโ - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโ.sdiv 42#8))).bind
            fun x => if 3#8 โฅ โ8 then none else some ((xโยน &&& 96#8) + x <<< 3#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      xโยน xโ : BitVec 8
      aโ :
        ยฌ((Option.map (fun div => xโ - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (xโ.sdiv 42#8))).bind
              fun x =>
              if 3#8 โฅ โ8 then none else if 3#8 โฅ โ8 then none else some ((x + (xโยน >>> 3#8 &&& 12#8)) <<< 3#8)) โ
            (Option.map (fun div => xโ - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (xโ.sdiv 42#8))).bind
              fun x => if 3#8 โฅ โ8 then none else some ((xโยน &&& 96#8) + x <<< 3#8)
      โข False
  [Meta.isDefEq] [0.003607] โ๏ธ ?hf =?= fun a a_1 =>
        Eq.trans
          (ite_cond_eq_false none (if 3#8 โฅ โ8 then none else some ((a + (xโยน >>> 3#8 &&& 12#8)) <<< 3#8))
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 3#8)
                (Eq.trans (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 3#8 8#8) (eq_self true)))
                  Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
          (ite_cond_eq_false none (some ((a + (xโยน >>> 3#8 &&& 12#8)) <<< 3#8))
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 3#8)
                (Eq.trans (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 3#8 8#8) (eq_self true)))
                  Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
    [Meta.isDefEq.assign] [0.003602] โ๏ธ ?hf := fun a a_1 =>
          Eq.trans
            (ite_cond_eq_false none (if 3#8 โฅ โ8 then none else some ((a + (xโยน >>> 3#8 &&& 12#8)) <<< 3#8))
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 3#8)
                  (Eq.trans
                    (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 3#8 8#8) (eq_self true)))
                    Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
            (ite_cond_eq_false none (some ((a + (xโยน >>> 3#8 &&& 12#8)) <<< 3#8))
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 3#8)
                  (Eq.trans
                    (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 3#8 8#8) (eq_self true)))
                    Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
      [Meta.isDefEq.assign.checkTypes] [0.003536] โ๏ธ (?hf : โ
            a โ
              Option.map (fun div => xโ + (~~~(div * 42#8) + 1#8))
                (some (if xโ.getLsbD 7 = true then ~~~((~~~xโ + 1#8) / 42#8) + 1#8 else xโ / 42#8)),
            (if 3#8 โฅ โ8 then none else if 3#8 โฅ โ8 then none else some ((a + (xโยน >>> 3#8 &&& 12#8)) <<< 3#8)) =
              some
                ((a + (xโยน >>> 3 &&& 12#8)) <<<
                  3)) := (fun a a_1 =>
            Eq.trans
              (ite_cond_eq_false none (if 3#8 โฅ โ8 then none else some ((a + (xโยน >>> 3#8 &&& 12#8)) <<< 3#8))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 3#8)
                    (Eq.trans
                      (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 3#8 8#8) (eq_self true)))
                      Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
              (ite_cond_eq_false none (some ((a + (xโยน >>> 3#8 &&& 12#8)) <<< 3#8))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 3#8)
                    (Eq.trans
                      (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 3#8 8#8) (eq_self true)))
                      Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))) : โ
            a โ
              Option.map (fun div => xโ + (~~~(div * 42#8) + 1#8))
                (some (if xโ.getLsbD 7 = true then ~~~((~~~xโ + 1#8) / 42#8) + 1#8 else xโ / 42#8)),
            (if 3#8 โฅ โ8 then none else if 3#8 โฅ โ8 then none else some ((a + (xโยน >>> 3#8 &&& 12#8)) <<< 3#8)) =
              some ((a + (xโยน >>> 3#8 &&& 12#8)) <<< 3#8))
        [Meta.isDefEq] [0.003531] โ๏ธ โ
              a โ
                Option.map (fun div => xโ + (~~~(div * 42#8) + 1#8))
                  (some (if xโ.getLsbD 7 = true then ~~~((~~~xโ + 1#8) / 42#8) + 1#8 else xโ / 42#8)),
              (if 3#8 โฅ โ8 then none else if 3#8 โฅ โ8 then none else some ((a + (xโยน >>> 3#8 &&& 12#8)) <<< 3#8)) =
                some
                  ((a + (xโยน >>> 3 &&& 12#8)) <<<
                    3) =?= โ
              a โ
                Option.map (fun div => xโ + (~~~(div * 42#8) + 1#8))
                  (some (if xโ.getLsbD 7 = true then ~~~((~~~xโ + 1#8) / 42#8) + 1#8 else xโ / 42#8)),
              (if 3#8 โฅ โ8 then none else if 3#8 โฅ โ8 then none else some ((a + (xโยน >>> 3#8 &&& 12#8)) <<< 3#8)) =
                some ((a + (xโยน >>> 3#8 &&& 12#8)) <<< 3#8)
          [Meta.isDefEq] [0.003455] โ๏ธ (if 3#8 โฅ โ8 then none
                else if 3#8 โฅ โ8 then none else some ((a + (xโยน >>> 3#8 &&& 12#8)) <<< 3#8)) =
                some
                  ((a + (xโยน >>> 3 &&& 12#8)) <<<
                    3) =?= (if 3#8 โฅ โ8 then none
                else if 3#8 โฅ โ8 then none else some ((a + (xโยน >>> 3#8 &&& 12#8)) <<< 3#8)) =
                some ((a + (xโยน >>> 3#8 &&& 12#8)) <<< 3#8)
            [Meta.isDefEq] [0.003420] โ๏ธ some
                  ((a + (xโยน >>> 3 &&& 12#8)) <<< 3) =?= some ((a + (xโยน >>> 3#8 &&& 12#8)) <<< 3#8)
              [Meta.isDefEq] [0.003385] โ๏ธ (a + (xโยน >>> 3 &&& 12#8)) <<< 3 =?= (a + (xโยน >>> 3#8 &&& 12#8)) <<< 3#8
                [Meta.isDefEq] [0.003347] โ๏ธ BitVec.instHShiftLeftNat.1 (a + (xโยน >>> 3 &&& 12#8))
                      3 =?= BitVec.instHShiftLeft.1 (a + (xโยน >>> 3#8 &&& 12#8)) 3#8
                  [Meta.isDefEq] [0.003267] โ๏ธ (a + (xโยน >>> 3 &&& 12#8)).shiftLeft
                        3 =?= (a + (xโยน >>> 3#8 &&& 12#8)) <<< (3#8).toNat
                    [Meta.isDefEq] [0.003226] โ๏ธ (a + (xโยน >>> 3 &&& 12#8)).shiftLeft
                          3 =?= (a + (xโยน >>> 3#8 &&& 12#8)).shiftLeft (3#8).toNat
                      [Meta.isDefEq.delta] [0.003211] โ๏ธ (a + (xโยน >>> 3 &&& 12#8)).shiftLeft
                            3 =?= (a + (xโยน >>> 3#8 &&& 12#8)).shiftLeft (3#8).toNat
                        [Meta.isDefEq] [0.003171] โ๏ธ a + (xโยน >>> 3 &&& 12#8) =?= a + (xโยน >>> 3#8 &&& 12#8)
                          [Meta.isDefEq] [0.002975] โ๏ธ instHAdd.1 a
                                (xโยน >>> 3 &&& 12#8) =?= instHAdd.1 a (xโยน >>> 3#8 &&& 12#8)
                            [Meta.isDefEq] [0.002888] โ๏ธ Add.add a
                                  (xโยน >>> 3 &&& 12#8) =?= Add.add a (xโยน >>> 3#8 &&& 12#8)
                              [Meta.isDefEq] [0.002234] โ๏ธ BitVec.instAdd =?= instAddNat
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      xโยน xโ : BitVec 8
      aโ :
        ยฌ((Option.map (fun div => xโ + (~~~(div * 42#8) + 1#8))
                  (some (if xโ.getLsbD 7 = true then ~~~((~~~xโ + 1#8) / 42#8) + 1#8 else xโ / 42#8))).bind
              fun a => some ((a + (xโยน >>> 3 &&& 12#8)) <<< 3)) โ
            (Option.map (fun div => xโ + (~~~(div * 42#8) + 1#8))
                  (some (if xโ.getLsbD 7 = true then ~~~((~~~xโ + 1#8) / 42#8) + 1#8 else xโ / 42#8))).bind
              fun a => some ((xโยน &&& 96#8) + a <<< 3)
      โข False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:88:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:78:8: error: (kernel) declaration has metavariables 'lshr_and_sub_thm'
[bv] [0.135502] Normalizing goal
  [Meta.synthInstance] [0.001964] โ๏ธ Decidable
        (((Option.map (fun div => xโ - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโ.sdiv 42#8))).bind
            fun x =>
            if 2#8 โฅ โ8 then none else if 2#8 โฅ โ8 then none else some ((x - (xโยน >>> 2#8 &&& 13#8)) <<< 2#8)) โ
          (Option.map (fun div => xโ - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโ.sdiv 42#8))).bind
            fun x =>
            if 2#8 โฅ โ8 then none
            else
              if
                  True โง
                    (BitVec.signExtend (8 + 1) x - BitVec.signExtend (8 + 1) (xโยน >>> 2#8 &&& 13#8)).msb โ
                      (BitVec.signExtend (8 + 1) x - BitVec.signExtend (8 + 1) (xโยน >>> 2#8 &&& 13#8)).getMsbD 1 then
                none
              else if 2#8 โฅ โ8 then none else some ((x - (xโยน >>> 2#8 &&& 13#8)) <<< 2#8))
    [Meta.check] [0.001357] โ๏ธ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          ((Option.map (fun div => xโ - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโ.sdiv 42#8))).bind
            fun x => if 2#8 โฅ โ8 then none else if 2#8 โฅ โ8 then none else some ((x - (xโยน >>> 2#8 &&& 13#8)) <<< 2#8))
          ((Option.map (fun div => xโ - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโ.sdiv 42#8))).bind
            fun x =>
            if 2#8 โฅ โ8 then none
            else
              if
                  True โง
                    (BitVec.signExtend (8 + 1) x - BitVec.signExtend (8 + 1) (xโยน >>> 2#8 &&& 13#8)).msb โ
                      (BitVec.signExtend (8 + 1) x - BitVec.signExtend (8 + 1) (xโยน >>> 2#8 &&& 13#8)).getMsbD 1 then
                none
              else if 2#8 โฅ โ8 then none else some ((x - (xโยน >>> 2#8 &&& 13#8)) <<< 2#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      xโยน xโ : BitVec 8
      aโ :
        ยฌ((Option.map (fun div => xโ - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (xโ.sdiv 42#8))).bind
              fun x =>
              if 2#8 โฅ โ8 then none else if 2#8 โฅ โ8 then none else some ((x - (xโยน >>> 2#8 &&& 13#8)) <<< 2#8)) โ
            (Option.map (fun div => xโ - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (xโ.sdiv 42#8))).bind
              fun x =>
              if 2#8 โฅ โ8 then none
              else
                if
                    True โง
                      (BitVec.signExtend (8 + 1) x - BitVec.signExtend (8 + 1) (xโยน >>> 2#8 &&& 13#8)).msb โ
                        (BitVec.signExtend (8 + 1) x - BitVec.signExtend (8 + 1) (xโยน >>> 2#8 &&& 13#8)).getMsbD 1 then
                  none
                else if 2#8 โฅ โ8 then none else some ((x - (xโยน >>> 2#8 &&& 13#8)) <<< 2#8)
      โข False
  [Meta.isDefEq] [0.001393] โ๏ธ ?hโ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (congr
              (congrArg Ne
                (Eq.trans
                  (congrArg BitVec.msb
                    (Eq.trans (BitVec.sub_toAdd (BitVec.signExtend 9 a) (BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8)))
                      (congrArg (HAdd.hAdd (BitVec.signExtend 9 a))
                        (BitVec.neg_eq_not_add (BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8))))))
                  (BitVec.msb_eq_getLsbD_last
                    (BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8) + 1#9)))))
              (congrArg (fun x => x.getMsbD 1)
                (Eq.trans (BitVec.sub_toAdd (BitVec.signExtend 9 a) (BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8)))
                  (congrArg (HAdd.hAdd (BitVec.signExtend 9 a))
                    (BitVec.neg_eq_not_add (BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8)))))))
            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
              ((BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8) + 1#9)).getLsbD 8)
              ((BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8) + 1#9)).getMsbD 1))))
        (true_and
          ((!(BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8) + 1#9)).getLsbD 8 ==
                (BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8) + 1#9)).getMsbD 1) =
            true))
    [Meta.isDefEq.assign] [0.001388] โ๏ธ ?hโ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (congr
                (congrArg Ne
                  (Eq.trans
                    (congrArg BitVec.msb
                      (Eq.trans (BitVec.sub_toAdd (BitVec.signExtend 9 a) (BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8)))
                        (congrArg (HAdd.hAdd (BitVec.signExtend 9 a))
                          (BitVec.neg_eq_not_add (BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8))))))
                    (BitVec.msb_eq_getLsbD_last
                      (BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8) + 1#9)))))
                (congrArg (fun x => x.getMsbD 1)
                  (Eq.trans (BitVec.sub_toAdd (BitVec.signExtend 9 a) (BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8)))
                    (congrArg (HAdd.hAdd (BitVec.signExtend 9 a))
                      (BitVec.neg_eq_not_add (BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                ((BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8) + 1#9)).getLsbD 8)
                ((BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8) + 1#9)).getMsbD 1))))
          (true_and
            ((!(BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8) + 1#9)).getLsbD 8 ==
                  (BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8) + 1#9)).getMsbD 1) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.001361] โ๏ธ (?hโ : (True โง
              (BitVec.signExtend (8 + 1) a - BitVec.signExtend (8 + 1) (xโยน >>> 2#8 &&& 13#8)).msb โ
                (BitVec.signExtend (8 + 1) a - BitVec.signExtend (8 + 1) (xโยน >>> 2#8 &&& 13#8)).getMsbD 1) =
            ((!(BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8) + 1#9)).getLsbD 8 ==
                  (BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8) + 1#9)).getMsbD 1) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (congr
                  (congrArg Ne
                    (Eq.trans
                      (congrArg BitVec.msb
                        (Eq.trans (BitVec.sub_toAdd (BitVec.signExtend 9 a) (BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8)))
                          (congrArg (HAdd.hAdd (BitVec.signExtend 9 a))
                            (BitVec.neg_eq_not_add (BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8))))))
                      (BitVec.msb_eq_getLsbD_last
                        (BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8) + 1#9)))))
                  (congrArg (fun x => x.getMsbD 1)
                    (Eq.trans (BitVec.sub_toAdd (BitVec.signExtend 9 a) (BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8)))
                      (congrArg (HAdd.hAdd (BitVec.signExtend 9 a))
                        (BitVec.neg_eq_not_add (BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                  ((BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8) + 1#9)).getLsbD 8)
                  ((BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8) + 1#9)).getMsbD 1))))
            (true_and
              ((!(BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8) + 1#9)).getLsbD 8 ==
                    (BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8) + 1#9)).getMsbD 1) =
                true)) : (True โง
              (BitVec.signExtend 9 a - BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8)).msb โ
                (BitVec.signExtend 9 a - BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8)).getMsbD 1) =
            ((!(BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8) + 1#9)).getLsbD 8 ==
                  (BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8) + 1#9)).getMsbD 1) =
              true))
        [Meta.isDefEq] [0.001357] โ๏ธ (True โง
                (BitVec.signExtend (8 + 1) a - BitVec.signExtend (8 + 1) (xโยน >>> 2#8 &&& 13#8)).msb โ
                  (BitVec.signExtend (8 + 1) a - BitVec.signExtend (8 + 1) (xโยน >>> 2#8 &&& 13#8)).getMsbD 1) =
              ((!(BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8) + 1#9)).getLsbD 8 ==
                    (BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8) + 1#9)).getMsbD 1) =
                true) =?= (True โง
                (BitVec.signExtend 9 a - BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8)).msb โ
                  (BitVec.signExtend 9 a - BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8)).getMsbD 1) =
              ((!(BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8) + 1#9)).getLsbD 8 ==
                    (BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8) + 1#9)).getMsbD 1) =
                true)
          [Meta.isDefEq] [0.001326] โ๏ธ True โง
                (BitVec.signExtend (8 + 1) a - BitVec.signExtend (8 + 1) (xโยน >>> 2#8 &&& 13#8)).msb โ
                  (BitVec.signExtend (8 + 1) a - BitVec.signExtend (8 + 1) (xโยน >>> 2#8 &&& 13#8)).getMsbD
                    1 =?= True โง
                (BitVec.signExtend 9 a - BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8)).msb โ
                  (BitVec.signExtend 9 a - BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8)).getMsbD 1
            [Meta.isDefEq] [0.001303] โ๏ธ (BitVec.signExtend (8 + 1) a -
                      BitVec.signExtend (8 + 1) (xโยน >>> 2#8 &&& 13#8)).msb โ
                  (BitVec.signExtend (8 + 1) a - BitVec.signExtend (8 + 1) (xโยน >>> 2#8 &&& 13#8)).getMsbD
                    1 =?= (BitVec.signExtend 9 a - BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8)).msb โ
                  (BitVec.signExtend 9 a - BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8)).getMsbD 1
              [Meta.isDefEq.delta] [0.001281] โ๏ธ (BitVec.signExtend (8 + 1) a -
                        BitVec.signExtend (8 + 1) (xโยน >>> 2#8 &&& 13#8)).msb โ
                    (BitVec.signExtend (8 + 1) a - BitVec.signExtend (8 + 1) (xโยน >>> 2#8 &&& 13#8)).getMsbD
                      1 =?= (BitVec.signExtend 9 a - BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8)).msb โ
                    (BitVec.signExtend 9 a - BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8)).getMsbD 1
                [Meta.isDefEq] [0.001183] โ๏ธ (BitVec.signExtend (8 + 1) a -
                        BitVec.signExtend (8 + 1)
                          (xโยน >>> 2#8 &&&
                            13#8)).msb =?= (BitVec.signExtend 9 a - BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8)).msb
                  [Meta.isDefEq.delta] [0.001166] โ๏ธ (BitVec.signExtend (8 + 1) a -
                          BitVec.signExtend (8 + 1)
                            (xโยน >>> 2#8 &&&
                              13#8)).msb =?= (BitVec.signExtend 9 a - BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8)).msb
                    [Meta.isDefEq] [0.001131] โ๏ธ BitVec.signExtend (8 + 1) a -
                          BitVec.signExtend (8 + 1)
                            (xโยน >>> 2#8 &&& 13#8) =?= BitVec.signExtend 9 a - BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8)
                      [Meta.isDefEq] [0.001092] โ๏ธ instHSub.1 (BitVec.signExtend (8 + 1) a)
                            (BitVec.signExtend (8 + 1)
                              (xโยน >>> 2#8 &&&
                                13#8)) =?= instHSub.1 (BitVec.signExtend 9 a) (BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8))
                        [Meta.isDefEq] [0.001008] โ๏ธ Sub.sub (BitVec.signExtend (8 + 1) a)
                              (BitVec.signExtend (8 + 1)
                                (xโยน >>> 2#8 &&&
                                  13#8)) =?= Sub.sub (BitVec.signExtend 9 a) (BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      xโยน xโ : BitVec 8
      aโ :
        ยฌ((Option.map (fun div => xโ + (~~~(div * 42#8) + 1#8))
                  (some (if xโ.getLsbD 7 = true then ~~~((~~~xโ + 1#8) / 42#8) + 1#8 else xโ / 42#8))).bind
              fun a => some ((a + (~~~(xโยน >>> 2 &&& 13#8) + 1#8)) <<< 2)) โ
            (Option.map (fun div => xโ + (~~~(div * 42#8) + 1#8))
                  (some (if xโ.getLsbD 7 = true then ~~~((~~~xโ + 1#8) / 42#8) + 1#8 else xโ / 42#8))).bind
              fun a =>
              if
                  (!(BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8) + 1#9)).getLsbD 8 ==
                        (BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (xโยน >>> 2 &&& 13#8) + 1#9)).getMsbD 1) =
                    true then
                none
              else some ((a + (~~~(xโยน >>> 2 &&& 13#8) + 1#8)) <<< 2)
      โข False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:99:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:99:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:92:8: error: (kernel) declaration has metavariables 'lshr_and_and_thm'
[bv] [0.115411] Normalizing goal
  [Meta.synthInstance] [0.002535] โ๏ธ Decidable
        ((if 2#8 โฅ โ8 then none
          else
            (Option.map (fun div => xโยน - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && xโยน == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (xโยน.sdiv 42#8))).bind
              fun x => if 2#8 โฅ โ8 then none else some ((xโ >>> 2#8 &&& 13#8 &&& x) <<< 2#8)) โ
          (Option.map (fun div => xโยน - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโยน == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโยน.sdiv 42#8))).bind
            fun x => if 2#8 โฅ โ8 then none else some (xโ &&& 52#8 &&& x <<< 2#8))
    [Meta.check] [0.001718] โ๏ธ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if 2#8 โฅ โ8 then none
          else
            (Option.map (fun div => xโยน - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && xโยน == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (xโยน.sdiv 42#8))).bind
              fun x => if 2#8 โฅ โ8 then none else some ((xโ >>> 2#8 &&& 13#8 &&& x) <<< 2#8))
          ((Option.map (fun div => xโยน - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโยน == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโยน.sdiv 42#8))).bind
            fun x => if 2#8 โฅ โ8 then none else some (xโ &&& 52#8 &&& x <<< 2#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      xโยน xโ : BitVec 8
      aโ :
        ยฌ(if 2#8 โฅ โ8 then none
            else
              (Option.map (fun div => xโยน - div * 42#8)
                    (if (42#8 == 0 || 8 != 1 && xโยน == BitVec.intMin 8 && 42#8 == -1) = true then none
                    else some (xโยน.sdiv 42#8))).bind
                fun x => if 2#8 โฅ โ8 then none else some ((xโ >>> 2#8 &&& 13#8 &&& x) <<< 2#8)) โ
            (Option.map (fun div => xโยน - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && xโยน == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (xโยน.sdiv 42#8))).bind
              fun x => if 2#8 โฅ โ8 then none else some (xโ &&& 52#8 &&& x <<< 2#8)
      โข False
  [Meta.appBuilder] [0.001997] โ๏ธ f: Complement.complement, xs: [div * 42#8]
    [Meta.synthInstance] [0.001918] โ๏ธ Complement (BitVec 8)
      [Meta.whnf] [0.001648] Non-easy whnf: Complement (BitVec 8)
  [Meta.appBuilder] [0.002863] โ๏ธ f: HAdd.hAdd, xs: [~~~(div * 42#8), 1#8]
    [Meta.synthInstance] [0.002752] โ๏ธ HAdd (BitVec 8) (BitVec 8) (BitVec 8)
      [Meta.synthInstance] [0.002218] โ๏ธ apply @instHAdd to HAdd (BitVec 8) (BitVec 8) (BitVec 8)
        [Meta.synthInstance.tryResolve] [0.002112] โ๏ธ HAdd (BitVec 8) (BitVec 8)
              (BitVec 8) โ HAdd (BitVec 8) (BitVec 8) (BitVec 8)
          [Meta.isDefEq] [0.001945] โ๏ธ ?m.128810 =?= instHAdd
            [Meta.isDefEq.assign] [0.001940] โ๏ธ ?m.128810 := instHAdd
              [Meta.isDefEq.assign.checkTypes] [0.001918] โ๏ธ (?m.128810 : HAdd (BitVec 8) (BitVec 8)
                    (BitVec 8)) := (instHAdd : HAdd (BitVec 8) (BitVec 8) (BitVec 8))
                [Meta.isDefEq] [0.001905] โ๏ธ HAdd (BitVec 8) (BitVec 8)
                      (BitVec 8) =?= HAdd (BitVec 8) (BitVec 8) (BitVec 8)
  [Meta.isDefEq] [0.002285] โ๏ธ ?a + ?a =?= ~~~(div * 42#8) + 1#8
    [Meta.isDefEq] [0.002126] โ๏ธ instHAdd =?= instHAdd
      [Meta.isDefEq] [0.002018] โ๏ธ { hAdd := fun a b => Add.add a b } =?= { hAdd := fun a b => Add.add a b }
  [Meta.appBuilder] [0.003536] โ๏ธ f: eq_false', xs: [fun h => Bool.noConfusion h]
    [Meta.isDefEq] [0.003483] โ๏ธ ?p โ False =?= false = true โ Bool.noConfusionType False false true
      [Meta.isDefEq] [0.003453] โ๏ธ False =?= Bool.noConfusionType False false true
        [Meta.isDefEq] [0.003390] โ๏ธ False =?= Bool.casesOn false (Bool.casesOn true (False โ False) False)
              (Bool.casesOn true False (False โ False))
  [Meta.isDefEq] [0.004518] โ๏ธ ?hf =?= fun a a_1 =>
        ite_cond_eq_false none (some ((xโ >>> 2#8 &&& 13#8 &&& a) <<< 2#8))
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
              (Eq.trans (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))
    [Meta.isDefEq.assign] [0.004514] โ๏ธ ?hf := fun a a_1 =>
          ite_cond_eq_false none (some ((xโ >>> 2#8 &&& 13#8 &&& a) <<< 2#8))
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
                (Eq.trans (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                  Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))
      [Meta.isDefEq.assign.checkTypes] [0.004475] โ๏ธ (?hf : โ
            a โ
              Option.map (fun div => xโยน + (~~~(div * 42#8) + 1#8))
                (some (if xโยน.getLsbD 7 = true then ~~~((~~~xโยน + 1#8) / 42#8) + 1#8 else xโยน / 42#8)),
            (if 2#8 โฅ โ8 then none else some ((xโ >>> 2#8 &&& 13#8 &&& a) <<< 2#8)) =
              some
                ((xโ >>> 2 &&& 13#8 &&& a) <<<
                  2)) := (fun a a_1 =>
            ite_cond_eq_false none (some ((xโ >>> 2#8 &&& 13#8 &&& a) <<< 2#8))
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
                  (Eq.trans
                    (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                    Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))) : โ
            a โ
              Option.map (fun div => xโยน + (~~~(div * 42#8) + 1#8))
                (some (if xโยน.getLsbD 7 = true then ~~~((~~~xโยน + 1#8) / 42#8) + 1#8 else xโยน / 42#8)),
            (if 2#8 โฅ โ8 then none else some ((xโ >>> 2#8 &&& 13#8 &&& a) <<< 2#8)) =
              some ((xโ >>> 2#8 &&& 13#8 &&& a) <<< 2#8))
        [Meta.isDefEq] [0.004470] โ๏ธ โ
              a โ
                Option.map (fun div => xโยน + (~~~(div * 42#8) + 1#8))
                  (some (if xโยน.getLsbD 7 = true then ~~~((~~~xโยน + 1#8) / 42#8) + 1#8 else xโยน / 42#8)),
              (if 2#8 โฅ โ8 then none else some ((xโ >>> 2#8 &&& 13#8 &&& a) <<< 2#8)) =
                some
                  ((xโ >>> 2 &&& 13#8 &&& a) <<<
                    2) =?= โ
              a โ
                Option.map (fun div => xโยน + (~~~(div * 42#8) + 1#8))
                  (some (if xโยน.getLsbD 7 = true then ~~~((~~~xโยน + 1#8) / 42#8) + 1#8 else xโยน / 42#8)),
              (if 2#8 โฅ โ8 then none else some ((xโ >>> 2#8 &&& 13#8 &&& a) <<< 2#8)) =
                some ((xโ >>> 2#8 &&& 13#8 &&& a) <<< 2#8)
          [Meta.isDefEq] [0.004427] โ๏ธ (if 2#8 โฅ โ8 then none else some ((xโ >>> 2#8 &&& 13#8 &&& a) <<< 2#8)) =
                some
                  ((xโ >>> 2 &&& 13#8 &&& a) <<<
                    2) =?= (if 2#8 โฅ โ8 then none else some ((xโ >>> 2#8 &&& 13#8 &&& a) <<< 2#8)) =
                some ((xโ >>> 2#8 &&& 13#8 &&& a) <<< 2#8)
            [Meta.isDefEq] [0.004382] โ๏ธ some
                  ((xโ >>> 2 &&& 13#8 &&& a) <<< 2) =?= some ((xโ >>> 2#8 &&& 13#8 &&& a) <<< 2#8)
              [Meta.isDefEq] [0.004356] โ๏ธ (xโ >>> 2 &&& 13#8 &&& a) <<< 2 =?= (xโ >>> 2#8 &&& 13#8 &&& a) <<< 2#8
                [Meta.isDefEq] [0.004332] โ๏ธ BitVec.instHShiftLeftNat.1 (xโ >>> 2 &&& 13#8 &&& a)
                      2 =?= BitVec.instHShiftLeft.1 (xโ >>> 2#8 &&& 13#8 &&& a) 2#8
                  [Meta.isDefEq] [0.002558] โ๏ธ (xโ >>> 2 &&& 13#8 &&& a).shiftLeft
                        2 =?= (xโ >>> 2#8 &&& 13#8 &&& a) <<< (2#8).toNat
                    [Meta.isDefEq] [0.002525] โ๏ธ (xโ >>> 2 &&& 13#8 &&& a).shiftLeft
                          2 =?= (xโ >>> 2#8 &&& 13#8 &&& a).shiftLeft (2#8).toNat
                      [Meta.isDefEq.delta] [0.002514] โ๏ธ (xโ >>> 2 &&& 13#8 &&& a).shiftLeft
                            2 =?= (xโ >>> 2#8 &&& 13#8 &&& a).shiftLeft (2#8).toNat
                        [Meta.isDefEq] [0.002473] โ๏ธ xโ >>> 2 &&& 13#8 &&& a =?= xโ >>> 2#8 &&& 13#8 &&& a
                          [Meta.isDefEq] [0.002443] โ๏ธ instHAndOfAndOp.1 (xโ >>> 2 &&& 13#8)
                                a =?= instHAndOfAndOp.1 (xโ >>> 2#8 &&& 13#8) a
                            [Meta.isDefEq] [0.002376] โ๏ธ AndOp.and (xโ >>> 2 &&& 13#8)
                                  a =?= AndOp.and (xโ >>> 2#8 &&& 13#8) a
                              [Meta.isDefEq] [0.002352] โ๏ธ BitVec.instAndOp.1 (xโ >>> 2 &&& 13#8)
                                    a =?= BitVec.instAndOp.1 (xโ >>> 2#8 &&& 13#8) a
                                [Meta.isDefEq] [0.002303] โ๏ธ (xโ >>> 2 &&& 13#8).and a =?= (xโ >>> 2#8 &&& 13#8).and a
                                  [Meta.isDefEq.delta] [0.002292] โ๏ธ (xโ >>> 2 &&& 13#8).and
                                        a =?= (xโ >>> 2#8 &&& 13#8).and a
                                    [Meta.isDefEq] [0.002264] โ๏ธ xโ >>> 2 &&& 13#8 =?= xโ >>> 2#8 &&& 13#8
                                      [Meta.isDefEq] [0.002248] โ๏ธ instHAndOfAndOp.1 (xโ >>> 2)
                                            13#8 =?= instHAndOfAndOp.1 (xโ >>> 2#8) 13#8
                                        [Meta.isDefEq] [0.002225] โ๏ธ AndOp.and (xโ >>> 2)
                                              13#8 =?= AndOp.and (xโ >>> 2#8) 13#8
                                          [Meta.isDefEq] [0.002210] โ๏ธ BitVec.instAndOp.1 (xโ >>> 2)
                                                13#8 =?= BitVec.instAndOp.1 (xโ >>> 2#8) 13#8
                                            [Meta.isDefEq] [0.002191] โ๏ธ (xโ >>> 2).and 13#8 =?= (xโ >>> 2#8).and 13#8
                                              [Meta.isDefEq.delta] [0.002176] โ๏ธ (xโ >>> 2).and
                                                    13#8 =?= (xโ >>> 2#8).and 13#8
                                                [Meta.isDefEq] [0.002164] โ๏ธ xโ >>> 2 =?= xโ >>> 2#8
                                                  [Meta.isDefEq] [0.002140] โ๏ธ BitVec.instHShiftRightNat.1 xโ
                                                        2 =?= BitVec.instHShiftRight.1 xโ 2#8
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      xโยน xโ : BitVec 8
      aโ :
        ยฌ((Option.map (fun div => xโยน + (~~~(div * 42#8) + 1#8))
                  (some (if xโยน.getLsbD 7 = true then ~~~((~~~xโยน + 1#8) / 42#8) + 1#8 else xโยน / 42#8))).bind
              fun a => some ((xโ >>> 2 &&& 13#8 &&& a) <<< 2)) โ
            (Option.map (fun div => xโยน + (~~~(div * 42#8) + 1#8))
                  (some (if xโยน.getLsbD 7 = true then ~~~((~~~xโยน + 1#8) / 42#8) + 1#8 else xโยน / 42#8))).bind
              fun a => some (xโ &&& 52#8 &&& a <<< 2)
      โข False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:110:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:103:8: error: (kernel) declaration has metavariables 'lshr_and_or_thm'
[bv] [0.096237] Normalizing goal
  [Meta.synthInstance] [0.006438] โ๏ธ Decidable
        (((Option.map (fun div => xโ - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโ.sdiv 42#8))).bind
            fun x =>
            if 2#8 โฅ โ8 then none else if 2#8 โฅ โ8 then none else some ((x ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8)) โ
          (Option.map (fun div => xโ - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโ.sdiv 42#8))).bind
            fun x => if 2#8 โฅ โ8 then none else some (xโยน &&& 52#8 ||| x <<< 2#8))
    [Meta.synthInstance] [0.004195] โ๏ธ apply @BitVec.Refinement.instDecidableRelOptionOfDecidableEq to Decidable
          (((Option.map (fun div => xโ - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (xโ.sdiv 42#8))).bind
              fun x =>
              if 2#8 โฅ โ8 then none else if 2#8 โฅ โ8 then none else some ((x ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8)) โ
            (Option.map (fun div => xโ - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (xโ.sdiv 42#8))).bind
              fun x => if 2#8 โฅ โ8 then none else some (xโยน &&& 52#8 ||| x <<< 2#8))
      [Meta.whnf] [0.001736] Non-easy whnf: DecidableRel BitVec.Refinement
    [Meta.check] [0.001642] โ๏ธ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          ((Option.map (fun div => xโ - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโ.sdiv 42#8))).bind
            fun x => if 2#8 โฅ โ8 then none else if 2#8 โฅ โ8 then none else some ((x ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8))
          ((Option.map (fun div => xโ - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโ.sdiv 42#8))).bind
            fun x => if 2#8 โฅ โ8 then none else some (xโยน &&& 52#8 ||| x <<< 2#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      xโยน xโ : BitVec 8
      aโ :
        ยฌ((Option.map (fun div => xโ - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (xโ.sdiv 42#8))).bind
              fun x =>
              if 2#8 โฅ โ8 then none else if 2#8 โฅ โ8 then none else some ((x ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8)) โ
            (Option.map (fun div => xโ - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (xโ.sdiv 42#8))).bind
              fun x => if 2#8 โฅ โ8 then none else some (xโยน &&& 52#8 ||| x <<< 2#8)
      โข False
  [Meta.isDefEq] [0.001512] โ๏ธ ?hf =?= fun a a_1 =>
        Eq.trans
          (ite_cond_eq_false none (if 2#8 โฅ โ8 then none else some ((a ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8))
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
                (Eq.trans (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                  Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
          (ite_cond_eq_false none (some ((a ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8))
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
                (Eq.trans (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                  Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
    [Meta.isDefEq.assign] [0.001506] โ๏ธ ?hf := fun a a_1 =>
          Eq.trans
            (ite_cond_eq_false none (if 2#8 โฅ โ8 then none else some ((a ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8))
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
                  (Eq.trans
                    (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                    Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
            (ite_cond_eq_false none (some ((a ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8))
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
                  (Eq.trans
                    (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                    Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
      [Meta.isDefEq.assign.checkTypes] [0.001445] โ๏ธ (?hf : โ
            a โ
              Option.map (fun div => xโ + (~~~(div * 42#8) + 1#8))
                (some (if xโ.getLsbD 7 = true then ~~~((~~~xโ + 1#8) / 42#8) + 1#8 else xโ / 42#8)),
            (if 2#8 โฅ โ8 then none else if 2#8 โฅ โ8 then none else some ((a ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8)) =
              some
                ((a ||| xโยน >>> 2 &&& 13#8) <<<
                  2)) := (fun a a_1 =>
            Eq.trans
              (ite_cond_eq_false none (if 2#8 โฅ โ8 then none else some ((a ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
                    (Eq.trans
                      (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                      Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
              (ite_cond_eq_false none (some ((a ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
                    (Eq.trans
                      (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                      Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))) : โ
            a โ
              Option.map (fun div => xโ + (~~~(div * 42#8) + 1#8))
                (some (if xโ.getLsbD 7 = true then ~~~((~~~xโ + 1#8) / 42#8) + 1#8 else xโ / 42#8)),
            (if 2#8 โฅ โ8 then none else if 2#8 โฅ โ8 then none else some ((a ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8)) =
              some ((a ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8))
        [Meta.isDefEq] [0.001440] โ๏ธ โ
              a โ
                Option.map (fun div => xโ + (~~~(div * 42#8) + 1#8))
                  (some (if xโ.getLsbD 7 = true then ~~~((~~~xโ + 1#8) / 42#8) + 1#8 else xโ / 42#8)),
              (if 2#8 โฅ โ8 then none else if 2#8 โฅ โ8 then none else some ((a ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8)) =
                some
                  ((a ||| xโยน >>> 2 &&& 13#8) <<<
                    2) =?= โ
              a โ
                Option.map (fun div => xโ + (~~~(div * 42#8) + 1#8))
                  (some (if xโ.getLsbD 7 = true then ~~~((~~~xโ + 1#8) / 42#8) + 1#8 else xโ / 42#8)),
              (if 2#8 โฅ โ8 then none else if 2#8 โฅ โ8 then none else some ((a ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8)) =
                some ((a ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8)
          [Meta.isDefEq] [0.001369] โ๏ธ (if 2#8 โฅ โ8 then none
                else if 2#8 โฅ โ8 then none else some ((a ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8)) =
                some
                  ((a ||| xโยน >>> 2 &&& 13#8) <<<
                    2) =?= (if 2#8 โฅ โ8 then none
                else if 2#8 โฅ โ8 then none else some ((a ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8)) =
                some ((a ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8)
            [Meta.isDefEq] [0.001334] โ๏ธ some
                  ((a ||| xโยน >>> 2 &&& 13#8) <<< 2) =?= some ((a ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8)
              [Meta.isDefEq] [0.001299] โ๏ธ (a ||| xโยน >>> 2 &&& 13#8) <<< 2 =?= (a ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8
                [Meta.isDefEq] [0.001264] โ๏ธ BitVec.instHShiftLeftNat.1 (a ||| xโยน >>> 2 &&& 13#8)
                      2 =?= BitVec.instHShiftLeft.1 (a ||| xโยน >>> 2#8 &&& 13#8) 2#8
                  [Meta.isDefEq] [0.001174] โ๏ธ (a ||| xโยน >>> 2 &&& 13#8).shiftLeft
                        2 =?= (a ||| xโยน >>> 2#8 &&& 13#8) <<< (2#8).toNat
                    [Meta.isDefEq] [0.001134] โ๏ธ (a ||| xโยน >>> 2 &&& 13#8).shiftLeft
                          2 =?= (a ||| xโยน >>> 2#8 &&& 13#8).shiftLeft (2#8).toNat
                      [Meta.isDefEq.delta] [0.001118] โ๏ธ (a ||| xโยน >>> 2 &&& 13#8).shiftLeft
                            2 =?= (a ||| xโยน >>> 2#8 &&& 13#8).shiftLeft (2#8).toNat
                        [Meta.isDefEq] [0.001069] โ๏ธ a ||| xโยน >>> 2 &&& 13#8 =?= a ||| xโยน >>> 2#8 &&& 13#8
                          [Meta.isDefEq] [0.001025] โ๏ธ instHOrOfOrOp.1 a
                                (xโยน >>> 2 &&& 13#8) =?= instHOrOfOrOp.1 a (xโยน >>> 2#8 &&& 13#8)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      xโยน xโ : BitVec 8
      aโ :
        ยฌ((Option.map (fun div => xโ + (~~~(div * 42#8) + 1#8))
                  (some (if xโ.getLsbD 7 = true then ~~~((~~~xโ + 1#8) / 42#8) + 1#8 else xโ / 42#8))).bind
              fun a => some ((a ||| xโยน >>> 2 &&& 13#8) <<< 2)) โ
            (Option.map (fun div => xโ + (~~~(div * 42#8) + 1#8))
                  (some (if xโ.getLsbD 7 = true then ~~~((~~~xโ + 1#8) / 42#8) + 1#8 else xโ / 42#8))).bind
              fun a => some (xโยน &&& 52#8 ||| a <<< 2)
      โข False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:121:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:114:8: error: (kernel) declaration has metavariables 'lshr_and_or_disjoint_thm'
[bv] [0.091331] Normalizing goal
  [Meta.synthInstance] [0.002922] โ๏ธ Decidable
        (((Option.map (fun div => xโ - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโ.sdiv 42#8))).bind
            fun x =>
            if 2#8 โฅ โ8 then none else if 2#8 โฅ โ8 then none else some ((x ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8)) โ
          (Option.map (fun div => xโ - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโ.sdiv 42#8))).bind
            fun x => if 2#8 โฅ โ8 then none else some (xโยน &&& 52#8 ||| x <<< 2#8))
    [Meta.check] [0.001891] โ๏ธ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          ((Option.map (fun div => xโ - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโ.sdiv 42#8))).bind
            fun x => if 2#8 โฅ โ8 then none else if 2#8 โฅ โ8 then none else some ((x ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8))
          ((Option.map (fun div => xโ - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโ.sdiv 42#8))).bind
            fun x => if 2#8 โฅ โ8 then none else some (xโยน &&& 52#8 ||| x <<< 2#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      xโยน xโ : BitVec 8
      aโ :
        ยฌ((Option.map (fun div => xโ - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (xโ.sdiv 42#8))).bind
              fun x =>
              if 2#8 โฅ โ8 then none else if 2#8 โฅ โ8 then none else some ((x ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8)) โ
            (Option.map (fun div => xโ - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (xโ.sdiv 42#8))).bind
              fun x => if 2#8 โฅ โ8 then none else some (xโยน &&& 52#8 ||| x <<< 2#8)
      โข False
  [Meta.isDefEq] [0.001573] โ๏ธ ?hf =?= fun a a_1 =>
        Eq.trans
          (ite_cond_eq_false none (if 2#8 โฅ โ8 then none else some ((a ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8))
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
                (Eq.trans (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                  Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
          (ite_cond_eq_false none (some ((a ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8))
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
                (Eq.trans (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                  Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
    [Meta.isDefEq.assign] [0.001568] โ๏ธ ?hf := fun a a_1 =>
          Eq.trans
            (ite_cond_eq_false none (if 2#8 โฅ โ8 then none else some ((a ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8))
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
                  (Eq.trans
                    (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                    Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
            (ite_cond_eq_false none (some ((a ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8))
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
                  (Eq.trans
                    (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                    Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
      [Meta.isDefEq.assign.checkTypes] [0.001506] โ๏ธ (?hf : โ
            a โ
              Option.map (fun div => xโ + (~~~(div * 42#8) + 1#8))
                (some (if xโ.getLsbD 7 = true then ~~~((~~~xโ + 1#8) / 42#8) + 1#8 else xโ / 42#8)),
            (if 2#8 โฅ โ8 then none else if 2#8 โฅ โ8 then none else some ((a ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8)) =
              some
                ((a ||| xโยน >>> 2 &&& 13#8) <<<
                  2)) := (fun a a_1 =>
            Eq.trans
              (ite_cond_eq_false none (if 2#8 โฅ โ8 then none else some ((a ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
                    (Eq.trans
                      (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                      Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
              (ite_cond_eq_false none (some ((a ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
                    (Eq.trans
                      (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                      Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))) : โ
            a โ
              Option.map (fun div => xโ + (~~~(div * 42#8) + 1#8))
                (some (if xโ.getLsbD 7 = true then ~~~((~~~xโ + 1#8) / 42#8) + 1#8 else xโ / 42#8)),
            (if 2#8 โฅ โ8 then none else if 2#8 โฅ โ8 then none else some ((a ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8)) =
              some ((a ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8))
        [Meta.isDefEq] [0.001501] โ๏ธ โ
              a โ
                Option.map (fun div => xโ + (~~~(div * 42#8) + 1#8))
                  (some (if xโ.getLsbD 7 = true then ~~~((~~~xโ + 1#8) / 42#8) + 1#8 else xโ / 42#8)),
              (if 2#8 โฅ โ8 then none else if 2#8 โฅ โ8 then none else some ((a ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8)) =
                some
                  ((a ||| xโยน >>> 2 &&& 13#8) <<<
                    2) =?= โ
              a โ
                Option.map (fun div => xโ + (~~~(div * 42#8) + 1#8))
                  (some (if xโ.getLsbD 7 = true then ~~~((~~~xโ + 1#8) / 42#8) + 1#8 else xโ / 42#8)),
              (if 2#8 โฅ โ8 then none else if 2#8 โฅ โ8 then none else some ((a ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8)) =
                some ((a ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8)
          [Meta.isDefEq] [0.001426] โ๏ธ (if 2#8 โฅ โ8 then none
                else if 2#8 โฅ โ8 then none else some ((a ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8)) =
                some
                  ((a ||| xโยน >>> 2 &&& 13#8) <<<
                    2) =?= (if 2#8 โฅ โ8 then none
                else if 2#8 โฅ โ8 then none else some ((a ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8)) =
                some ((a ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8)
            [Meta.isDefEq] [0.001389] โ๏ธ some
                  ((a ||| xโยน >>> 2 &&& 13#8) <<< 2) =?= some ((a ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8)
              [Meta.isDefEq] [0.001352] โ๏ธ (a ||| xโยน >>> 2 &&& 13#8) <<< 2 =?= (a ||| xโยน >>> 2#8 &&& 13#8) <<< 2#8
                [Meta.isDefEq] [0.001311] โ๏ธ BitVec.instHShiftLeftNat.1 (a ||| xโยน >>> 2 &&& 13#8)
                      2 =?= BitVec.instHShiftLeft.1 (a ||| xโยน >>> 2#8 &&& 13#8) 2#8
                  [Meta.isDefEq] [0.001209] โ๏ธ (a ||| xโยน >>> 2 &&& 13#8).shiftLeft
                        2 =?= (a ||| xโยน >>> 2#8 &&& 13#8) <<< (2#8).toNat
                    [Meta.isDefEq] [0.001166] โ๏ธ (a ||| xโยน >>> 2 &&& 13#8).shiftLeft
                          2 =?= (a ||| xโยน >>> 2#8 &&& 13#8).shiftLeft (2#8).toNat
                      [Meta.isDefEq.delta] [0.001150] โ๏ธ (a ||| xโยน >>> 2 &&& 13#8).shiftLeft
                            2 =?= (a ||| xโยน >>> 2#8 &&& 13#8).shiftLeft (2#8).toNat
                        [Meta.isDefEq] [0.001098] โ๏ธ a ||| xโยน >>> 2 &&& 13#8 =?= a ||| xโยน >>> 2#8 &&& 13#8
                          [Meta.isDefEq] [0.001054] โ๏ธ instHOrOfOrOp.1 a
                                (xโยน >>> 2 &&& 13#8) =?= instHOrOfOrOp.1 a (xโยน >>> 2#8 &&& 13#8)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      xโยน xโ : BitVec 8
      aโ :
        ยฌ((Option.map (fun div => xโ + (~~~(div * 42#8) + 1#8))
                  (some (if xโ.getLsbD 7 = true then ~~~((~~~xโ + 1#8) / 42#8) + 1#8 else xโ / 42#8))).bind
              fun a => some ((a ||| xโยน >>> 2 &&& 13#8) <<< 2)) โ
            (Option.map (fun div => xโ + (~~~(div * 42#8) + 1#8))
                  (some (if xโ.getLsbD 7 = true then ~~~((~~~xโ + 1#8) / 42#8) + 1#8 else xโ / 42#8))).bind
              fun a => some (xโยน &&& 52#8 ||| a <<< 2)
      โข False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:132:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:125:8: error: (kernel) declaration has metavariables 'ashr_and_or_disjoint_thm'
[bv] [0.052954] Normalizing goal
  [Meta.synthInstance] [0.001665] โ๏ธ Decidable
        (((Option.map (fun div => xโ - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโ.sdiv 42#8))).bind
            fun x =>
            if 2#8 โฅ โ8 then none
            else if 2#8 โฅ โ8 then none else some ((x ||| xโยน.sshiftRight (2#8).toNat &&& 13#8) <<< 2#8)) โ
          (Option.map (fun div => xโ - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโ.sdiv 42#8))).bind
            fun x => if 2#8 โฅ โ8 then none else some (xโยน &&& 52#8 ||| x <<< 2#8))
    [Meta.check] [0.001044] โ๏ธ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          ((Option.map (fun div => xโ - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโ.sdiv 42#8))).bind
            fun x =>
            if 2#8 โฅ โ8 then none
            else if 2#8 โฅ โ8 then none else some ((x ||| xโยน.sshiftRight (2#8).toNat &&& 13#8) <<< 2#8))
          ((Option.map (fun div => xโ - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโ.sdiv 42#8))).bind
            fun x => if 2#8 โฅ โ8 then none else some (xโยน &&& 52#8 ||| x <<< 2#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      xโยน xโ : BitVec 8
      aโ :
        ยฌ((Option.map (fun div => xโ - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (xโ.sdiv 42#8))).bind
              fun x =>
              if 2#8 โฅ โ8 then none
              else if 2#8 โฅ โ8 then none else some ((x ||| xโยน.sshiftRight (2#8).toNat &&& 13#8) <<< 2#8)) โ
            (Option.map (fun div => xโ - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && xโ == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (xโ.sdiv 42#8))).bind
              fun x => if 2#8 โฅ โ8 then none else some (xโยน &&& 52#8 ||| x <<< 2#8)
      โข False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      xโยน xโ : BitVec 8
      aโ :
        ยฌ((Option.map (fun div => xโ + (~~~(div * 42#8) + 1#8))
                  (some (if xโ.getLsbD 7 = true then ~~~((~~~xโ + 1#8) / 42#8) + 1#8 else xโ / 42#8))).bind
              fun a => some ((a ||| xโยน.sshiftRight 2 &&& 13#8) <<< 2)) โ
            (Option.map (fun div => xโ + (~~~(div * 42#8) + 1#8))
                  (some (if xโ.getLsbD 7 = true then ~~~((~~~xโ + 1#8) / 42#8) + 1#8 else xโ / 42#8))).bind
              fun a => some (xโยน &&& 52#8 ||| a <<< 2)
      โข False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:143:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:143:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:136:8: error: (kernel) declaration has metavariables 'lshr_and_xor_thm'
[bv] [0.055407] Normalizing goal
  [Meta.synthInstance] [0.001614] โ๏ธ Decidable
        ((if 2#8 โฅ โ8 then none
          else
            (Option.map (fun div => xโยน - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && xโยน == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (xโยน.sdiv 42#8))).bind
              fun x => if 2#8 โฅ โ8 then none else some ((xโ >>> 2#8 &&& 13#8 ^^^ x) <<< 2#8)) โ
          (Option.map (fun div => xโยน - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโยน == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโยน.sdiv 42#8))).bind
            fun x => if 2#8 โฅ โ8 then none else some (xโ &&& 52#8 ^^^ x <<< 2#8))
    [Meta.check] [0.001081] โ๏ธ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if 2#8 โฅ โ8 then none
          else
            (Option.map (fun div => xโยน - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && xโยน == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (xโยน.sdiv 42#8))).bind
              fun x => if 2#8 โฅ โ8 then none else some ((xโ >>> 2#8 &&& 13#8 ^^^ x) <<< 2#8))
          ((Option.map (fun div => xโยน - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && xโยน == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (xโยน.sdiv 42#8))).bind
            fun x => if 2#8 โฅ โ8 then none else some (xโ &&& 52#8 ^^^ x <<< 2#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      xโยน xโ : BitVec 8
      aโ :
        ยฌ(if 2#8 โฅ โ8 then none
            else
              (Option.map (fun div => xโยน - div * 42#8)
                    (if (42#8 == 0 || 8 != 1 && xโยน == BitVec.intMin 8 && 42#8 == -1) = true then none
                    else some (xโยน.sdiv 42#8))).bind
                fun x => if 2#8 โฅ โ8 then none else some ((xโ >>> 2#8 &&& 13#8 ^^^ x) <<< 2#8)) โ
            (Option.map (fun div => xโยน - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && xโยน == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (xโยน.sdiv 42#8))).bind
              fun x => if 2#8 โฅ โ8 then none else some (xโ &&& 52#8 ^^^ x <<< 2#8)
      โข False
  [Meta.isDefEq] [0.001167] โ๏ธ if ?b then ?x
      else
        ?y =?= if xโยน.msb = true then if (42#8).msb = true then -xโยน / -42#8 else -(-xโยน / 42#8)
      else if (42#8).msb = true then -(xโยน / -42#8) else xโยน / 42#8
    [Meta.isDefEq] [0.001045] โ๏ธ ?ฮฑ =?= BitVec 8
      [Meta.isDefEq.assign] [0.001042] โ๏ธ ?ฮฑ := BitVec 8
        [Meta.isDefEq.assign.checkTypes] [0.001038] โ๏ธ (?ฮฑ : Sort ?u.190751) := (BitVec 8 : Type)
          [Meta.isDefEq] [0.001033] โ๏ธ Sort ?u.190751 =?= Type
            [Meta.isLevelDefEq] [0.001028] โ๏ธ ?u.190751 =?= 1
  [Meta.isDefEq] [0.001013] โ๏ธ ?hf =?= fun a a_1 =>
        ite_cond_eq_false none (some ((xโ >>> 2#8 &&& 13#8 ^^^ a) <<< 2#8))
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
              (Eq.trans (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))
    [Meta.isDefEq.assign] [0.001008] โ๏ธ ?hf := fun a a_1 =>
          ite_cond_eq_false none (some ((xโ >>> 2#8 &&& 13#8 ^^^ a) <<< 2#8))
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
                (Eq.trans (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                  Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      xโยน xโ : BitVec 8
      aโ :
        ยฌ((Option.map (fun div => xโยน + (~~~(div * 42#8) + 1#8))
                  (some (if xโยน.getLsbD 7 = true then ~~~((~~~xโยน + 1#8) / 42#8) + 1#8 else xโยน / 42#8))).bind
              fun a => some ((xโ >>> 2 &&& 13#8 ^^^ a) <<< 2)) โ
            (Option.map (fun div => xโยน + (~~~(div * 42#8) + 1#8))
                  (some (if xโยน.getLsbD 7 = true then ~~~((~~~xโยน + 1#8) / 42#8) + 1#8 else xโยน / 42#8))).bind
              fun a => some (xโ &&& 52#8 ^^^ a <<< 2)
      โข False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 0.690420ms, solving context: 0.000000ms
LeanSAT proved the goal after 2.893390ms: rewriting 2.876370ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 79.358729ms, solving context: 0.000000ms
LeanSAT proved the goal after 91.119230ms: rewriting 20.555490ms, bitblasting 0.000000ms, SAT solving 55.346300ms, LRAT trimming 3.258880ms, LRAT checking 7.606350ms
Bitwuzla proved the goal after 0.620050ms, solving context: 0.000000ms
LeanSAT proved the goal after 2.724590ms: rewriting 2.709060ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 0.453100ms, solving context: 0.000000ms
LeanSAT proved the goal after 2.700580ms: rewriting 2.691670ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 0.508370ms, solving context: 0.000000ms
LeanSAT proved the goal after 2.407319ms: rewriting 2.398909ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 77.091309ms, solving context: 0.000000ms
LeanSAT proved the goal after 85.940180ms: rewriting 20.710820ms, bitblasting 0.000000ms, SAT solving 54.431430ms, LRAT trimming 2.869930ms, LRAT checking 6.335180ms
