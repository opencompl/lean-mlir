‚ö† [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
‚ö† [881/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
‚ö† [884/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
‚ö† [887/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
‚ö† [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:18:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:18:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:11:8: error: (kernel) declaration has metavariables 'lshr_add_thm'
[bv] [0.077265] Normalizing goal
  [Meta.synthInstance] [0.002183] ‚úÖÔ∏è Decidable
        ((if 5#8 ‚â• ‚Üë8 then none
          else
            (Option.map (fun div => x‚úù¬π - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && x‚úù¬π == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (x‚úù¬π.sdiv 42#8))).bind
              fun x => if 5#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 5#8 + x) <<< 5#8)) ‚äë
          (Option.map (fun div => x‚úù¬π - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù¬π == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù¬π.sdiv 42#8))).bind
            fun x => if 5#8 ‚â• ‚Üë8 then none else some (x‚úù + x <<< 5#8 &&& 224#8))
    [Meta.check] [0.001399] ‚úÖÔ∏è BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if 5#8 ‚â• ‚Üë8 then none
          else
            (Option.map (fun div => x‚úù¬π - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && x‚úù¬π == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (x‚úù¬π.sdiv 42#8))).bind
              fun x => if 5#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 5#8 + x) <<< 5#8))
          ((Option.map (fun div => x‚úù¬π - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù¬π == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù¬π.sdiv 42#8))).bind
            fun x => if 5#8 ‚â• ‚Üë8 then none else some (x‚úù + x <<< 5#8 &&& 224#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if 5#8 ‚â• ‚Üë8 then none
            else
              (Option.map (fun div => x‚úù¬π - div * 42#8)
                    (if (42#8 == 0 || 8 != 1 && x‚úù¬π == BitVec.intMin 8 && 42#8 == -1) = true then none
                    else some (x‚úù¬π.sdiv 42#8))).bind
                fun x => if 5#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 5#8 + x) <<< 5#8)) ‚äë
            (Option.map (fun div => x‚úù¬π - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && x‚úù¬π == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (x‚úù¬π.sdiv 42#8))).bind
              fun x => if 5#8 ‚â• ‚Üë8 then none else some (x‚úù + x <<< 5#8 &&& 224#8)
      ‚ä¢ False
  [Meta.isDefEq] [0.002560] ‚ùåÔ∏è ?a == ?a =?= 42#8 == 0#8
    [Meta.isDefEq.onFailure] [0.002219] ‚ùåÔ∏è ?a == ?a =?= 42#8 == 0#8
      [Meta.synthInstance] [0.002195] üí•Ô∏è BEq ?Œ±
        [Meta.synthInstance] [0.001276] new goal BEq ?Œ±
  [Meta.appBuilder] [0.001095] ‚úÖÔ∏è f: eq_false', xs: [fun h => Bool.noConfusion h]
    [Meta.isDefEq] [0.001054] ‚úÖÔ∏è ?p ‚Üí False =?= false = true ‚Üí Bool.noConfusionType False false true
      [Meta.isDefEq] [0.001031] ‚úÖÔ∏è False =?= Bool.noConfusionType False false true
  [Meta.isDefEq] [0.002127] ‚úÖÔ∏è ?hf =?= fun a a_1 =>
        ite_cond_eq_false none (some ((x‚úù >>> 5#8 + a) <<< 5#8))
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 5#8)
              (Eq.trans (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 5#8 8#8) (eq_self true)))
                Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))
    [Meta.isDefEq.assign] [0.002123] ‚úÖÔ∏è ?hf := fun a a_1 =>
          ite_cond_eq_false none (some ((x‚úù >>> 5#8 + a) <<< 5#8))
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 5#8)
                (Eq.trans (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 5#8 8#8) (eq_self true)))
                  Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))
      [Meta.isDefEq.assign.checkTypes] [0.002084] ‚úÖÔ∏è (?hf : ‚àÄ
            a ‚àà
              Option.map (fun div => x‚úù¬π + (~~~(div * 42#8) + 1#8))
                (some (if x‚úù¬π.getLsbD 7 = true then ~~~((~~~x‚úù¬π + 1#8) / 42#8) + 1#8 else x‚úù¬π / 42#8)),
            (if 5#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 5#8 + a) <<< 5#8)) =
              some
                ((x‚úù >>> 5 + a) <<<
                  5)) := (fun a a_1 =>
            ite_cond_eq_false none (some ((x‚úù >>> 5#8 + a) <<< 5#8))
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 5#8)
                  (Eq.trans
                    (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 5#8 8#8) (eq_self true)))
                    Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))) : ‚àÄ
            a ‚àà
              Option.map (fun div => x‚úù¬π + (~~~(div * 42#8) + 1#8))
                (some (if x‚úù¬π.getLsbD 7 = true then ~~~((~~~x‚úù¬π + 1#8) / 42#8) + 1#8 else x‚úù¬π / 42#8)),
            (if 5#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 5#8 + a) <<< 5#8)) = some ((x‚úù >>> 5#8 + a) <<< 5#8))
        [Meta.isDefEq] [0.002079] ‚úÖÔ∏è ‚àÄ
              a ‚àà
                Option.map (fun div => x‚úù¬π + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù¬π.getLsbD 7 = true then ~~~((~~~x‚úù¬π + 1#8) / 42#8) + 1#8 else x‚úù¬π / 42#8)),
              (if 5#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 5#8 + a) <<< 5#8)) =
                some
                  ((x‚úù >>> 5 + a) <<<
                    5) =?= ‚àÄ
              a ‚àà
                Option.map (fun div => x‚úù¬π + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù¬π.getLsbD 7 = true then ~~~((~~~x‚úù¬π + 1#8) / 42#8) + 1#8 else x‚úù¬π / 42#8)),
              (if 5#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 5#8 + a) <<< 5#8)) = some ((x‚úù >>> 5#8 + a) <<< 5#8)
          [Meta.isDefEq] [0.002036] ‚úÖÔ∏è (if 5#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 5#8 + a) <<< 5#8)) =
                some
                  ((x‚úù >>> 5 + a) <<<
                    5) =?= (if 5#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 5#8 + a) <<< 5#8)) =
                some ((x‚úù >>> 5#8 + a) <<< 5#8)
            [Meta.isDefEq] [0.001993] ‚úÖÔ∏è some ((x‚úù >>> 5 + a) <<< 5) =?= some ((x‚úù >>> 5#8 + a) <<< 5#8)
              [Meta.isDefEq] [0.001967] ‚úÖÔ∏è (x‚úù >>> 5 + a) <<< 5 =?= (x‚úù >>> 5#8 + a) <<< 5#8
                [Meta.isDefEq] [0.001944] ‚úÖÔ∏è BitVec.instHShiftLeftNat.1 (x‚úù >>> 5 + a)
                      5 =?= BitVec.instHShiftLeft.1 (x‚úù >>> 5#8 + a) 5#8
                  [Meta.isDefEq] [0.001880] ‚úÖÔ∏è (x‚úù >>> 5 + a).shiftLeft 5 =?= (x‚úù >>> 5#8 + a) <<< (5#8).toNat
                    [Meta.isDefEq] [0.001853] ‚úÖÔ∏è (x‚úù >>> 5 + a).shiftLeft 5 =?= (x‚úù >>> 5#8 + a).shiftLeft (5#8).toNat
                      [Meta.isDefEq.delta] [0.001844] ‚úÖÔ∏è (x‚úù >>> 5 + a).shiftLeft
                            5 =?= (x‚úù >>> 5#8 + a).shiftLeft (5#8).toNat
                        [Meta.isDefEq] [0.001812] ‚úÖÔ∏è x‚úù >>> 5 + a =?= x‚úù >>> 5#8 + a
                          [Meta.isDefEq] [0.001694] ‚úÖÔ∏è instHAdd.1 (x‚úù >>> 5) a =?= instHAdd.1 (x‚úù >>> 5#8) a
                            [Meta.isDefEq] [0.001640] ‚úÖÔ∏è Add.add (x‚úù >>> 5) a =?= Add.add (x‚úù >>> 5#8) a
                              [Meta.isDefEq] [0.001124] ‚ùåÔ∏è BitVec.instAdd =?= instAddNat
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨((Option.map (fun div => x‚úù¬π + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù¬π.getLsbD 7 = true then ~~~((~~~x‚úù¬π + 1#8) / 42#8) + 1#8 else x‚úù¬π / 42#8))).bind
              fun a => some ((x‚úù >>> 5 + a) <<< 5)) ‚äë
            (Option.map (fun div => x‚úù¬π + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù¬π.getLsbD 7 = true then ~~~((~~~x‚úù¬π + 1#8) / 42#8) + 1#8 else x‚úù¬π / 42#8))).bind
              fun a => some (x‚úù + a <<< 5 &&& 224#8)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:30:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:22:8: error: (kernel) declaration has metavariables 'lshr_sub_thm'
[bv] [0.124385] Normalizing goal
  [Meta.synthInstance] [0.002689] ‚úÖÔ∏è Decidable
        (((Option.map (fun div => x‚úù - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù.sdiv 42#8))).bind
            fun x => if 3#8 ‚â• ‚Üë8 then none else if 3#8 ‚â• ‚Üë8 then none else some ((x - x‚úù¬π >>> 3#8) <<< 3#8)) ‚äë
          (Option.map (fun div => x‚úù - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù.sdiv 42#8))).bind
            fun x =>
            if 3#8 ‚â• ‚Üë8 then none
            else
              if
                  True ‚àß
                    (BitVec.signExtend (8 + 1) x - BitVec.signExtend (8 + 1) (x‚úù¬π >>> 3#8)).msb ‚â†
                      (BitVec.signExtend (8 + 1) x - BitVec.signExtend (8 + 1) (x‚úù¬π >>> 3#8)).getMsbD 1 then
                none
              else if 3#8 ‚â• ‚Üë8 then none else some ((x - x‚úù¬π >>> 3#8) <<< 3#8))
    [Meta.check] [0.001972] ‚úÖÔ∏è BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          ((Option.map (fun div => x‚úù - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù.sdiv 42#8))).bind
            fun x => if 3#8 ‚â• ‚Üë8 then none else if 3#8 ‚â• ‚Üë8 then none else some ((x - x‚úù¬π >>> 3#8) <<< 3#8))
          ((Option.map (fun div => x‚úù - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù.sdiv 42#8))).bind
            fun x =>
            if 3#8 ‚â• ‚Üë8 then none
            else
              if
                  True ‚àß
                    (BitVec.signExtend (8 + 1) x - BitVec.signExtend (8 + 1) (x‚úù¬π >>> 3#8)).msb ‚â†
                      (BitVec.signExtend (8 + 1) x - BitVec.signExtend (8 + 1) (x‚úù¬π >>> 3#8)).getMsbD 1 then
                none
              else if 3#8 ‚â• ‚Üë8 then none else some ((x - x‚úù¬π >>> 3#8) <<< 3#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨((Option.map (fun div => x‚úù - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (x‚úù.sdiv 42#8))).bind
              fun x => if 3#8 ‚â• ‚Üë8 then none else if 3#8 ‚â• ‚Üë8 then none else some ((x - x‚úù¬π >>> 3#8) <<< 3#8)) ‚äë
            (Option.map (fun div => x‚úù - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (x‚úù.sdiv 42#8))).bind
              fun x =>
              if 3#8 ‚â• ‚Üë8 then none
              else
                if
                    True ‚àß
                      (BitVec.signExtend (8 + 1) x - BitVec.signExtend (8 + 1) (x‚úù¬π >>> 3#8)).msb ‚â†
                        (BitVec.signExtend (8 + 1) x - BitVec.signExtend (8 + 1) (x‚úù¬π >>> 3#8)).getMsbD 1 then
                  none
                else if 3#8 ‚â• ‚Üë8 then none else some ((x - x‚úù¬π >>> 3#8) <<< 3#8)
      ‚ä¢ False
  [Meta.isDefEq] [0.001033] ‚úÖÔ∏è ?h‚ÇÅ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (congr
              (congrArg Ne
                (Eq.trans
                  (congrArg BitVec.msb
                    (Eq.trans (BitVec.sub_toAdd (BitVec.signExtend 9 a) (BitVec.signExtend 9 (x‚úù¬π >>> 3)))
                      (congrArg (HAdd.hAdd (BitVec.signExtend 9 a))
                        (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x‚úù¬π >>> 3))))))
                  (BitVec.msb_eq_getLsbD_last (BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 3) + 1#9)))))
              (congrArg (fun x => x.getMsbD 1)
                (Eq.trans (BitVec.sub_toAdd (BitVec.signExtend 9 a) (BitVec.signExtend 9 (x‚úù¬π >>> 3)))
                  (congrArg (HAdd.hAdd (BitVec.signExtend 9 a))
                    (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x‚úù¬π >>> 3)))))))
            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
              ((BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 3) + 1#9)).getLsbD 8)
              ((BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 3) + 1#9)).getMsbD 1))))
        (true_and
          ((!(BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 3) + 1#9)).getLsbD 8 ==
                (BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 3) + 1#9)).getMsbD 1) =
            true))
    [Meta.isDefEq.assign] [0.001025] ‚úÖÔ∏è ?h‚ÇÅ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (congr
                (congrArg Ne
                  (Eq.trans
                    (congrArg BitVec.msb
                      (Eq.trans (BitVec.sub_toAdd (BitVec.signExtend 9 a) (BitVec.signExtend 9 (x‚úù¬π >>> 3)))
                        (congrArg (HAdd.hAdd (BitVec.signExtend 9 a))
                          (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x‚úù¬π >>> 3))))))
                    (BitVec.msb_eq_getLsbD_last (BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 3) + 1#9)))))
                (congrArg (fun x => x.getMsbD 1)
                  (Eq.trans (BitVec.sub_toAdd (BitVec.signExtend 9 a) (BitVec.signExtend 9 (x‚úù¬π >>> 3)))
                    (congrArg (HAdd.hAdd (BitVec.signExtend 9 a))
                      (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x‚úù¬π >>> 3)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                ((BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 3) + 1#9)).getLsbD 8)
                ((BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 3) + 1#9)).getMsbD 1))))
          (true_and
            ((!(BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 3) + 1#9)).getLsbD 8 ==
                  (BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 3) + 1#9)).getMsbD 1) =
              true))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨((Option.map (fun div => x‚úù + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù.getLsbD 7 = true then ~~~((~~~x‚úù + 1#8) / 42#8) + 1#8 else x‚úù / 42#8))).bind
              fun a => some ((a + (~~~(x‚úù¬π >>> 3) + 1#8)) <<< 3)) ‚äë
            (Option.map (fun div => x‚úù + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù.getLsbD 7 = true then ~~~((~~~x‚úù + 1#8) / 42#8) + 1#8 else x‚úù / 42#8))).bind
              fun a =>
              if
                  (!(BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 3) + 1#9)).getLsbD 8 ==
                        (BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 3) + 1#9)).getMsbD 1) =
                    true then
                none
              else some ((a + (~~~(x‚úù¬π >>> 3) + 1#8)) <<< 3)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:41:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:41:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:34:8: error: (kernel) declaration has metavariables 'lshr_and_thm'
[bv] [0.175357] Normalizing goal
  [Meta.isDefEq] [0.001670] ‚úÖÔ∏è ?p =?= (if 6#8 ‚â• ‚Üë8 then none
        else
          (Option.map (fun div => x‚úù¬π - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù¬π == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù¬π.sdiv 42#8))).bind
            fun x => if 6#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 6#8 &&& x) <<< 6#8)) ‚äë
        (Option.map (fun div => x‚úù¬π - div * 42#8)
              (if (42#8 == 0 || 8 != 1 && x‚úù¬π == BitVec.intMin 8 && 42#8 == -1) = true then none
              else some (x‚úù¬π.sdiv 42#8))).bind
          fun x => if 6#8 ‚â• ‚Üë8 then none else some (x‚úù &&& x <<< 6#8)
    [Meta.isDefEq.assign] [0.001663] ‚úÖÔ∏è ?p := (if 6#8 ‚â• ‚Üë8 then none
          else
            (Option.map (fun div => x‚úù¬π - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && x‚úù¬π == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (x‚úù¬π.sdiv 42#8))).bind
              fun x => if 6#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 6#8 &&& x) <<< 6#8)) ‚äë
          (Option.map (fun div => x‚úù¬π - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù¬π == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù¬π.sdiv 42#8))).bind
            fun x => if 6#8 ‚â• ‚Üë8 then none else some (x‚úù &&& x <<< 6#8)
  [Meta.synthInstance] [0.001673] ‚úÖÔ∏è Decidable
        ((if 6#8 ‚â• ‚Üë8 then none
          else
            (Option.map (fun div => x‚úù¬π - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && x‚úù¬π == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (x‚úù¬π.sdiv 42#8))).bind
              fun x => if 6#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 6#8 &&& x) <<< 6#8)) ‚äë
          (Option.map (fun div => x‚úù¬π - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù¬π == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù¬π.sdiv 42#8))).bind
            fun x => if 6#8 ‚â• ‚Üë8 then none else some (x‚úù &&& x <<< 6#8))
    [Meta.check] [0.001011] ‚úÖÔ∏è BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if 6#8 ‚â• ‚Üë8 then none
          else
            (Option.map (fun div => x‚úù¬π - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && x‚úù¬π == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (x‚úù¬π.sdiv 42#8))).bind
              fun x => if 6#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 6#8 &&& x) <<< 6#8))
          ((Option.map (fun div => x‚úù¬π - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù¬π == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù¬π.sdiv 42#8))).bind
            fun x => if 6#8 ‚â• ‚Üë8 then none else some (x‚úù &&& x <<< 6#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if 6#8 ‚â• ‚Üë8 then none
            else
              (Option.map (fun div => x‚úù¬π - div * 42#8)
                    (if (42#8 == 0 || 8 != 1 && x‚úù¬π == BitVec.intMin 8 && 42#8 == -1) = true then none
                    else some (x‚úù¬π.sdiv 42#8))).bind
                fun x => if 6#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 6#8 &&& x) <<< 6#8)) ‚äë
            (Option.map (fun div => x‚úù¬π - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && x‚úù¬π == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (x‚úù¬π.sdiv 42#8))).bind
              fun x => if 6#8 ‚â• ‚Üë8 then none else some (x‚úù &&& x <<< 6#8)
      ‚ä¢ False
  [Meta.appBuilder] [0.003910] ‚úÖÔ∏è f: Complement.complement, xs: [div * 42#8]
    [Meta.synthInstance] [0.002050] ‚úÖÔ∏è Complement (BitVec 8)
      [Meta.whnf] [0.001789] Non-easy whnf: Complement (BitVec 8)
  [Meta.appBuilder] [0.007561] ‚úÖÔ∏è f: HAdd.hAdd, xs: [~~~(div * 42#8), 1#8]
    [Meta.isDefEq] [0.001839] ‚úÖÔ∏è ?Œ≤ =?= BitVec 8
      [Meta.isDefEq.assign] [0.001833] ‚úÖÔ∏è ?Œ≤ := BitVec 8
    [Meta.synthInstance] [0.005635] ‚úÖÔ∏è HAdd (BitVec 8) (BitVec 8) (BitVec 8)
      [Meta.synthInstance] [0.005243] ‚úÖÔ∏è apply @instHAdd to HAdd (BitVec 8) (BitVec 8) (BitVec 8)
        [Meta.synthInstance.tryResolve] [0.005122] ‚úÖÔ∏è HAdd (BitVec 8) (BitVec 8)
              (BitVec 8) ‚âü HAdd (BitVec 8) (BitVec 8) (BitVec 8)
          [Meta.isDefEq] [0.001341] ‚úÖÔ∏è HAdd (BitVec 8) (BitVec 8) ?m.47578 =?= HAdd ?m.47581 ?m.47581 ?m.47581
          [Meta.isDefEq] [0.001828] ‚úÖÔ∏è ?m.47579 =?= instHAdd
            [Meta.isDefEq.assign] [0.001825] ‚úÖÔ∏è ?m.47579 := instHAdd
              [Meta.isDefEq.assign.checkTypes] [0.001804] ‚úÖÔ∏è (?m.47579 : HAdd (BitVec 8) (BitVec 8)
                    (BitVec 8)) := (instHAdd : HAdd (BitVec 8) (BitVec 8) (BitVec 8))
                [Meta.isDefEq] [0.001797] ‚úÖÔ∏è HAdd (BitVec 8) (BitVec 8)
                      (BitVec 8) =?= HAdd (BitVec 8) (BitVec 8) (BitVec 8)
  [Meta.isDefEq] [0.004194] ‚ùåÔ∏è ?a + ?a =?= ~~~(div * 42#8) + 1#8
    [Meta.isDefEq] [0.002069] ‚ùåÔ∏è instHAdd =?= instHAdd
      [Meta.isDefEq] [0.001974] ‚ùåÔ∏è { hAdd := fun a b => Add.add a b } =?= { hAdd := fun a b => Add.add a b }
        [Meta.isDefEq.onFailure] [0.001846] ‚ùåÔ∏è { hAdd := fun a b => Add.add a b } =?= { hAdd := fun a b => Add.add a b }
    [Meta.isDefEq] [0.001908] ‚ùåÔ∏è ~~~(div * 42#8) =?= 1#8
      [Meta.isDefEq] [0.001896] ‚ùåÔ∏è ~~~(div * 42#8) =?= 1#8
  [Meta.appBuilder] [0.002170] ‚úÖÔ∏è f: funext, xs: [fun div =>
         Eq.trans (BitVec.sub_toAdd x‚úù¬π (div * 42#8)) (congrArg (HAdd.hAdd x‚úù¬π) (BitVec.neg_eq_not_add (div * 42#8)))]
  [Meta.isDefEq] [0.002763] ‚ùåÔ∏è ?a == ?a =?= 42#8 == 0#8
    [Meta.isDefEq] [0.002078] ‚úÖÔ∏è ?inst‚úù =?= instBEqOfDecidableEq
      [Meta.isDefEq.assign] [0.002075] ‚úÖÔ∏è ?inst‚úù := instBEqOfDecidableEq
        [Meta.isDefEq.assign.checkTypes] [0.002068] ‚úÖÔ∏è (?inst‚úù : BEq
              (BitVec 8)) := (instBEqOfDecidableEq : BEq (BitVec 8))
          [Meta.isDefEq] [0.002064] ‚úÖÔ∏è BEq (BitVec 8) =?= BEq (BitVec 8)
  [Meta.appBuilder] [0.002173] ‚úÖÔ∏è f: eq_false', xs: [fun h => Bool.noConfusion h]
    [Meta.isDefEq] [0.002113] ‚úÖÔ∏è ?p ‚Üí False =?= false = true ‚Üí Bool.noConfusionType False false true
      [Meta.isDefEq] [0.002080] ‚úÖÔ∏è False =?= Bool.noConfusionType False false true
  [Meta.appBuilder] [0.002831] ‚úÖÔ∏è f: HAdd.hAdd, xs: [~~~x‚úù¬π, 1#8]
    [Meta.isDefEq] [0.001891] ‚úÖÔ∏è ?Œ≤ =?= BitVec 8
      [Meta.isDefEq.assign] [0.001872] ‚úÖÔ∏è ?Œ≤ := BitVec 8
  [Meta.isDefEq] [0.002317] ‚ùåÔ∏è ~~~?a + ?a =?= ~~~((~~~x‚úù¬π + 1#8) / 42#8) + 1#8
  [Meta.isDefEq] [0.002073] ‚úÖÔ∏è ?hx =?= congr
        (congrArg Option.map
          (funext fun div =>
            Eq.trans (BitVec.sub_toAdd x‚úù¬π (div * 42#8))
              (congrArg (HAdd.hAdd x‚úù¬π) (BitVec.neg_eq_not_add (div * 42#8)))))
        (Eq.trans
          (ite_cond_eq_false none (some (x‚úù¬π.sdiv 42#8))
            (Eq.trans
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Eq.trans
                    (congrArg false.or
                      (Eq.trans (congrArg (fun x => x && false) (Bool.true_and (x‚úù¬π == BitVec.intMin 8)))
                        (Bool.and_false (x‚úù¬π == BitVec.intMin 8))))
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim false false))
                  (Eq.trans
                    (congrArg not
                      (Eq.trans (congr (congrArg Bool.and Bool.not_false) Bool.not_false) (Bool.and_self true)))
                    Bool.not_true)))
              (eq_false' fun h => Bool.noConfusion h)))
          (congrArg some
            (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv x‚úù¬π 42#8)
              (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x‚úù¬π))
                (fun a =>
                  Eq.trans
                    (ite_cond_eq_false (-x‚úù¬π / -42#8) (-(-x‚úù¬π / 42#8))
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#8))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (Eq.trans (congrArg (fun x => -(x / 42#8)) (BitVec.neg_eq_not_add x‚úù¬π))
                      (BitVec.neg_eq_not_add ((~~~x‚úù¬π + 1#8) / 42#8))))
                fun a =>
                ite_cond_eq_false (-(x‚úù¬π / -42#8)) (x‚úù¬π / 42#8)
                  (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#8))
                    (eq_false' fun h => Bool.noConfusion h))))))
    [Meta.isDefEq.assign] [0.002066] ‚úÖÔ∏è ?hx := congr
          (congrArg Option.map
            (funext fun div =>
              Eq.trans (BitVec.sub_toAdd x‚úù¬π (div * 42#8))
                (congrArg (HAdd.hAdd x‚úù¬π) (BitVec.neg_eq_not_add (div * 42#8)))))
          (Eq.trans
            (ite_cond_eq_false none (some (x‚úù¬π.sdiv 42#8))
              (Eq.trans
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Eq.trans
                      (congrArg false.or
                        (Eq.trans (congrArg (fun x => x && false) (Bool.true_and (x‚úù¬π == BitVec.intMin 8)))
                          (Bool.and_false (x‚úù¬π == BitVec.intMin 8))))
                      (Std.Tactic.BVDecide.Normalize.Bool.or_elim false false))
                    (Eq.trans
                      (congrArg not
                        (Eq.trans (congr (congrArg Bool.and Bool.not_false) Bool.not_false) (Bool.and_self true)))
                      Bool.not_true)))
                (eq_false' fun h => Bool.noConfusion h)))
            (congrArg some
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv x‚úù¬π 42#8)
                (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x‚úù¬π))
                  (fun a =>
                    Eq.trans
                      (ite_cond_eq_false (-x‚úù¬π / -42#8) (-(-x‚úù¬π / 42#8))
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#8))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (Eq.trans (congrArg (fun x => -(x / 42#8)) (BitVec.neg_eq_not_add x‚úù¬π))
                        (BitVec.neg_eq_not_add ((~~~x‚úù¬π + 1#8) / 42#8))))
                  fun a =>
                  ite_cond_eq_false (-(x‚úù¬π / -42#8)) (x‚úù¬π / 42#8)
                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#8))
                      (eq_false' fun h => Bool.noConfusion h))))))
  [Meta.isDefEq] [0.019963] ‚úÖÔ∏è ?hf =?= fun a a_1 =>
        ite_cond_eq_false none (some ((x‚úù >>> 6#8 &&& a) <<< 6#8))
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 6#8)
              (Eq.trans (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 6#8 8#8) (eq_self true)))
                Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))
    [Meta.isDefEq.assign] [0.019957] ‚úÖÔ∏è ?hf := fun a a_1 =>
          ite_cond_eq_false none (some ((x‚úù >>> 6#8 &&& a) <<< 6#8))
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 6#8)
                (Eq.trans (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 6#8 8#8) (eq_self true)))
                  Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))
      [Meta.isDefEq.assign.checkTypes] [0.019891] ‚úÖÔ∏è (?hf : ‚àÄ
            a ‚àà
              Option.map (fun div => x‚úù¬π + (~~~(div * 42#8) + 1#8))
                (some (if x‚úù¬π.getLsbD 7 = true then ~~~((~~~x‚úù¬π + 1#8) / 42#8) + 1#8 else x‚úù¬π / 42#8)),
            (if 6#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 6#8 &&& a) <<< 6#8)) =
              some
                ((x‚úù >>> 6 &&& a) <<<
                  6)) := (fun a a_1 =>
            ite_cond_eq_false none (some ((x‚úù >>> 6#8 &&& a) <<< 6#8))
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 6#8)
                  (Eq.trans
                    (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 6#8 8#8) (eq_self true)))
                    Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))) : ‚àÄ
            a ‚àà
              Option.map (fun div => x‚úù¬π + (~~~(div * 42#8) + 1#8))
                (some (if x‚úù¬π.getLsbD 7 = true then ~~~((~~~x‚úù¬π + 1#8) / 42#8) + 1#8 else x‚úù¬π / 42#8)),
            (if 6#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 6#8 &&& a) <<< 6#8)) = some ((x‚úù >>> 6#8 &&& a) <<< 6#8))
        [Meta.isDefEq] [0.019883] ‚úÖÔ∏è ‚àÄ
              a ‚àà
                Option.map (fun div => x‚úù¬π + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù¬π.getLsbD 7 = true then ~~~((~~~x‚úù¬π + 1#8) / 42#8) + 1#8 else x‚úù¬π / 42#8)),
              (if 6#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 6#8 &&& a) <<< 6#8)) =
                some
                  ((x‚úù >>> 6 &&& a) <<<
                    6) =?= ‚àÄ
              a ‚àà
                Option.map (fun div => x‚úù¬π + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù¬π.getLsbD 7 = true then ~~~((~~~x‚úù¬π + 1#8) / 42#8) + 1#8 else x‚úù¬π / 42#8)),
              (if 6#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 6#8 &&& a) <<< 6#8)) = some ((x‚úù >>> 6#8 &&& a) <<< 6#8)
          [Meta.isDefEq] [0.019803] ‚úÖÔ∏è (if 6#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 6#8 &&& a) <<< 6#8)) =
                some
                  ((x‚úù >>> 6 &&& a) <<<
                    6) =?= (if 6#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 6#8 &&& a) <<< 6#8)) =
                some ((x‚úù >>> 6#8 &&& a) <<< 6#8)
            [Meta.isDefEq] [0.017812] ‚úÖÔ∏è some ((x‚úù >>> 6 &&& a) <<< 6) =?= some ((x‚úù >>> 6#8 &&& a) <<< 6#8)
              [Meta.isDefEq] [0.017759] ‚úÖÔ∏è (x‚úù >>> 6 &&& a) <<< 6 =?= (x‚úù >>> 6#8 &&& a) <<< 6#8
                [Meta.isDefEq] [0.017706] ‚úÖÔ∏è BitVec.instHShiftLeftNat.1 (x‚úù >>> 6 &&& a)
                      6 =?= BitVec.instHShiftLeft.1 (x‚úù >>> 6#8 &&& a) 6#8
                  [Meta.isDefEq] [0.017601] ‚úÖÔ∏è (x‚úù >>> 6 &&& a).shiftLeft 6 =?= (x‚úù >>> 6#8 &&& a) <<< (6#8).toNat
                    [Meta.isDefEq] [0.017559] ‚úÖÔ∏è (x‚úù >>> 6 &&& a).shiftLeft
                          6 =?= (x‚úù >>> 6#8 &&& a).shiftLeft (6#8).toNat
                      [Meta.isDefEq.delta] [0.017543] ‚úÖÔ∏è (x‚úù >>> 6 &&& a).shiftLeft
                            6 =?= (x‚úù >>> 6#8 &&& a).shiftLeft (6#8).toNat
                        [Meta.isDefEq] [0.017491] ‚úÖÔ∏è x‚úù >>> 6 &&& a =?= x‚úù >>> 6#8 &&& a
                          [Meta.isDefEq] [0.015517] ‚úÖÔ∏è instHAndOfAndOp.1 (x‚úù >>> 6)
                                a =?= instHAndOfAndOp.1 (x‚úù >>> 6#8) a
                            [Meta.isDefEq] [0.014142] ‚úÖÔ∏è AndOp.and (x‚úù >>> 6) a =?= AndOp.and (x‚úù >>> 6#8) a
                              [Meta.isDefEq] [0.014105] ‚úÖÔ∏è BitVec.instAndOp.1 (x‚úù >>> 6)
                                    a =?= BitVec.instAndOp.1 (x‚úù >>> 6#8) a
                                [Meta.whnf] [0.001847] Non-easy whnf: AndOp (BitVec 8)
                                [Meta.isDefEq] [0.010260] ‚úÖÔ∏è (x‚úù >>> 6).and a =?= (x‚úù >>> 6#8).and a
                                  [Meta.isDefEq.delta] [0.010238] ‚úÖÔ∏è (x‚úù >>> 6).and a =?= (x‚úù >>> 6#8).and a
                                    [Meta.isDefEq] [0.010190] ‚úÖÔ∏è x‚úù >>> 6 =?= x‚úù >>> 6#8
                                      [Meta.isDefEq] [0.010127] ‚úÖÔ∏è BitVec.instHShiftRightNat.1 x‚úù
                                            6 =?= BitVec.instHShiftRight.1 x‚úù 6#8
                                        [Meta.isDefEq] [0.009995] ‚úÖÔ∏è x‚úù.ushiftRight 6 =?= x‚úù >>> (6#8).toNat
                                          [Meta.isDefEq] [0.009944] ‚úÖÔ∏è x‚úù.ushiftRight 6 =?= x‚úù.ushiftRight (6#8).toNat
                                            [Meta.isDefEq.delta] [0.007985] ‚úÖÔ∏è x‚úù.ushiftRight
                                                  6 =?= x‚úù.ushiftRight (6#8).toNat
                                              [Meta.isDefEq] [0.007933] ‚úÖÔ∏è 6 =?= (6#8).toNat
                                                [Meta.whnf] [0.001959] Non-easy whnf: instOfNatNat 6
                                                  [Meta.whnf] [0.001941] Non-easy whnf: { ofNat := 6 }
                                                [Meta.isDefEq] [0.005898] ‚úÖÔ∏è 6 =?= ‚Üë(6#8).toFin
                                                  [Meta.isDefEq] [0.005845] ‚úÖÔ∏è 6 =?= (6#8).toFin.1
                                                    [Meta.whnf] [0.005664] Non-easy whnf: (6#8).toFin
  [Meta.isDefEq] [0.002131] ‚úÖÔ∏è ?x.bind
        ?f =?= (Option.map (fun div => x‚úù¬π + (~~~(div * 42#8) + 1#8))
            (some (if x‚úù¬π.getLsbD 7 = true then ~~~((~~~x‚úù¬π + 1#8) / 42#8) + 1#8 else x‚úù¬π / 42#8))).bind
        fun a => some ((x‚úù >>> 6 &&& a) <<< 6)
    [Meta.isDefEq] [0.001917] ‚úÖÔ∏è ?Œ± =?= BitVec 8
      [Meta.isDefEq.assign] [0.001911] ‚úÖÔ∏è ?Œ± := BitVec 8
        [Meta.isDefEq.assign.checkTypes] [0.001901] ‚úÖÔ∏è (?Œ± : Type ?u.48404) := (BitVec 8 : Type)
  [Meta.isDefEq] [0.003794] ‚úÖÔ∏è ?hx =?= congr
        (congrArg Option.map
          (funext fun div =>
            Eq.trans (BitVec.sub_toAdd x‚úù¬π (div * 42#8))
              (congrArg (HAdd.hAdd x‚úù¬π) (BitVec.neg_eq_not_add (div * 42#8)))))
        (Eq.trans
          (ite_cond_eq_false none (some (x‚úù¬π.sdiv 42#8))
            (Eq.trans
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Eq.trans
                    (congrArg false.or
                      (Eq.trans (congrArg (fun x => x && false) (Bool.true_and (x‚úù¬π == BitVec.intMin 8)))
                        (Bool.and_false (x‚úù¬π == BitVec.intMin 8))))
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim false false))
                  (Eq.trans
                    (congrArg not
                      (Eq.trans (congr (congrArg Bool.and Bool.not_false) Bool.not_false) (Bool.and_self true)))
                    Bool.not_true)))
              (eq_false' fun h => Bool.noConfusion h)))
          (congrArg some
            (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv x‚úù¬π 42#8)
              (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x‚úù¬π))
                (fun a =>
                  Eq.trans
                    (ite_cond_eq_false (-x‚úù¬π / -42#8) (-(-x‚úù¬π / 42#8))
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#8))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (Eq.trans (congrArg (fun x => -(x / 42#8)) (BitVec.neg_eq_not_add x‚úù¬π))
                      (BitVec.neg_eq_not_add ((~~~x‚úù¬π + 1#8) / 42#8))))
                fun a =>
                ite_cond_eq_false (-(x‚úù¬π / -42#8)) (x‚úù¬π / 42#8)
                  (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#8))
                    (eq_false' fun h => Bool.noConfusion h))))))
    [Meta.isDefEq.assign] [0.003788] ‚úÖÔ∏è ?hx := congr
          (congrArg Option.map
            (funext fun div =>
              Eq.trans (BitVec.sub_toAdd x‚úù¬π (div * 42#8))
                (congrArg (HAdd.hAdd x‚úù¬π) (BitVec.neg_eq_not_add (div * 42#8)))))
          (Eq.trans
            (ite_cond_eq_false none (some (x‚úù¬π.sdiv 42#8))
              (Eq.trans
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Eq.trans
                      (congrArg false.or
                        (Eq.trans (congrArg (fun x => x && false) (Bool.true_and (x‚úù¬π == BitVec.intMin 8)))
                          (Bool.and_false (x‚úù¬π == BitVec.intMin 8))))
                      (Std.Tactic.BVDecide.Normalize.Bool.or_elim false false))
                    (Eq.trans
                      (congrArg not
                        (Eq.trans (congr (congrArg Bool.and Bool.not_false) Bool.not_false) (Bool.and_self true)))
                      Bool.not_true)))
                (eq_false' fun h => Bool.noConfusion h)))
            (congrArg some
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv x‚úù¬π 42#8)
                (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x‚úù¬π))
                  (fun a =>
                    Eq.trans
                      (ite_cond_eq_false (-x‚úù¬π / -42#8) (-(-x‚úù¬π / 42#8))
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#8))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (Eq.trans (congrArg (fun x => -(x / 42#8)) (BitVec.neg_eq_not_add x‚úù¬π))
                        (BitVec.neg_eq_not_add ((~~~x‚úù¬π + 1#8) / 42#8))))
                  fun a =>
                  ite_cond_eq_false (-(x‚úù¬π / -42#8)) (x‚úù¬π / 42#8)
                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#8))
                      (eq_false' fun h => Bool.noConfusion h))))))
  [Meta.appBuilder] [0.004588] ‚úÖÔ∏è f: HShiftLeft.hShiftLeft, xs: [a, 6]
    [Meta.synthInstance] [0.004487] ‚úÖÔ∏è HShiftLeft (BitVec 8) ‚Ñï (BitVec 8)
      [Meta.synthInstance] [0.004218] ‚úÖÔ∏è apply @BitVec.instHShiftLeftNat to HShiftLeft (BitVec 8) ‚Ñï (BitVec 8)
        [Meta.synthInstance.tryResolve] [0.004175] ‚úÖÔ∏è HShiftLeft (BitVec 8) ‚Ñï
              (BitVec 8) ‚âü HShiftLeft (BitVec 8) ‚Ñï (BitVec 8)
          [Meta.isDefEq] [0.002127] ‚úÖÔ∏è HShiftLeft (BitVec 8) ‚Ñï
                ?m.48457 =?= HShiftLeft (BitVec ?m.48460) ‚Ñï (BitVec ?m.48460)
  [Meta.isDefEq] [0.002165] ‚ùåÔ∏è ?x &&& ?x =?= x‚úù &&& a <<< 6
    [Meta.isDefEq] [0.002034] ‚úÖÔ∏è ?x =?= x‚úù
      [Meta.isDefEq.assign] [0.002028] ‚úÖÔ∏è ?x := x‚úù
        [Meta.isDefEq.assign.checkTypes] [0.002019] ‚úÖÔ∏è (?x : BitVec ?w) := (x‚úù : BitVec 8)
          [Meta.isDefEq] [0.002013] ‚úÖÔ∏è BitVec ?w =?= BitVec 8
  [Meta.isDefEq] [0.003685] ‚ùåÔ∏è ?x &&& ?x =?= x‚úù &&& a <<< 6
    [Meta.isDefEq] [0.003535] ‚úÖÔ∏è ?x =?= x‚úù
      [Meta.isDefEq.assign] [0.003529] ‚úÖÔ∏è ?x := x‚úù
        [Meta.isDefEq.assign.checkTypes] [0.003521] ‚úÖÔ∏è (?x : BitVec ?w) := (x‚úù : BitVec 8)
          [Meta.isDefEq] [0.003515] ‚úÖÔ∏è BitVec ?w =?= BitVec 8
  [Meta.isDefEq] [0.005739] ‚úÖÔ∏è ?hf =?= fun a a_1 =>
        ite_cond_eq_false none (some (x‚úù &&& a <<< 6#8))
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 6#8)
              (Eq.trans (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 6#8 8#8) (eq_self true)))
                Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))
    [Meta.isDefEq.assign] [0.005734] ‚úÖÔ∏è ?hf := fun a a_1 =>
          ite_cond_eq_false none (some (x‚úù &&& a <<< 6#8))
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 6#8)
                (Eq.trans (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 6#8 8#8) (eq_self true)))
                  Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))
      [Meta.isDefEq.assign.checkTypes] [0.005673] ‚úÖÔ∏è (?hf : ‚àÄ
            a ‚àà
              Option.map (fun div => x‚úù¬π + (~~~(div * 42#8) + 1#8))
                (some (if x‚úù¬π.getLsbD 7 = true then ~~~((~~~x‚úù¬π + 1#8) / 42#8) + 1#8 else x‚úù¬π / 42#8)),
            (if 6#8 ‚â• ‚Üë8 then none else some (x‚úù &&& a <<< 6#8)) =
              some
                (x‚úù &&&
                  a <<<
                    6)) := (fun a a_1 =>
            ite_cond_eq_false none (some (x‚úù &&& a <<< 6#8))
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 6#8)
                  (Eq.trans
                    (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 6#8 8#8) (eq_self true)))
                    Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))) : ‚àÄ
            a ‚àà
              Option.map (fun div => x‚úù¬π + (~~~(div * 42#8) + 1#8))
                (some (if x‚úù¬π.getLsbD 7 = true then ~~~((~~~x‚úù¬π + 1#8) / 42#8) + 1#8 else x‚úù¬π / 42#8)),
            (if 6#8 ‚â• ‚Üë8 then none else some (x‚úù &&& a <<< 6#8)) = some (x‚úù &&& a <<< 6#8))
        [Meta.isDefEq] [0.005667] ‚úÖÔ∏è ‚àÄ
              a ‚àà
                Option.map (fun div => x‚úù¬π + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù¬π.getLsbD 7 = true then ~~~((~~~x‚úù¬π + 1#8) / 42#8) + 1#8 else x‚úù¬π / 42#8)),
              (if 6#8 ‚â• ‚Üë8 then none else some (x‚úù &&& a <<< 6#8)) =
                some
                  (x‚úù &&&
                    a <<<
                      6) =?= ‚àÄ
              a ‚àà
                Option.map (fun div => x‚úù¬π + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù¬π.getLsbD 7 = true then ~~~((~~~x‚úù¬π + 1#8) / 42#8) + 1#8 else x‚úù¬π / 42#8)),
              (if 6#8 ‚â• ‚Üë8 then none else some (x‚úù &&& a <<< 6#8)) = some (x‚úù &&& a <<< 6#8)
          [Meta.isDefEq] [0.005594] ‚úÖÔ∏è (if 6#8 ‚â• ‚Üë8 then none else some (x‚úù &&& a <<< 6#8)) =
                some (x‚úù &&& a <<< 6) =?= (if 6#8 ‚â• ‚Üë8 then none else some (x‚úù &&& a <<< 6#8)) = some (x‚úù &&& a <<< 6#8)
            [Meta.isDefEq] [0.005557] ‚úÖÔ∏è some (x‚úù &&& a <<< 6) =?= some (x‚úù &&& a <<< 6#8)
              [Meta.isDefEq] [0.005531] ‚úÖÔ∏è x‚úù &&& a <<< 6 =?= x‚úù &&& a <<< 6#8
                [Meta.isDefEq] [0.005491] ‚úÖÔ∏è instHAndOfAndOp.1 x‚úù (a <<< 6) =?= instHAndOfAndOp.1 x‚úù (a <<< 6#8)
                  [Meta.isDefEq] [0.005438] ‚úÖÔ∏è AndOp.and x‚úù (a <<< 6) =?= AndOp.and x‚úù (a <<< 6#8)
                    [Meta.isDefEq] [0.005408] ‚úÖÔ∏è BitVec.instAndOp.1 x‚úù (a <<< 6) =?= BitVec.instAndOp.1 x‚úù (a <<< 6#8)
                      [Meta.isDefEq] [0.005362] ‚úÖÔ∏è x‚úù.and (a <<< 6) =?= x‚úù.and (a <<< 6#8)
                        [Meta.isDefEq.delta] [0.005345] ‚úÖÔ∏è x‚úù.and (a <<< 6) =?= x‚úù.and (a <<< 6#8)
                          [Meta.isDefEq] [0.005330] ‚úÖÔ∏è a <<< 6 =?= a <<< 6#8
                            [Meta.isDefEq] [0.005298] ‚úÖÔ∏è BitVec.instHShiftLeftNat.1 a
                                  6 =?= BitVec.instHShiftLeft.1 a 6#8
                              [Meta.whnf] [0.001856] Non-easy whnf: BitVec.instHShiftLeftNat
                              [Meta.isDefEq] [0.003392] ‚úÖÔ∏è a.shiftLeft 6 =?= a <<< (6#8).toNat
                                [Meta.isDefEq] [0.003359] ‚úÖÔ∏è a.shiftLeft 6 =?= a.shiftLeft (6#8).toNat
                                  [Meta.isDefEq.delta] [0.003343] ‚úÖÔ∏è a.shiftLeft 6 =?= a.shiftLeft (6#8).toNat
                                    [Meta.isDefEq] [0.001471] ‚úÖÔ∏è 6 =?= (6#8).toNat
                                      [Meta.isDefEq] [0.001413] ‚úÖÔ∏è 6 =?= ‚Üë(6#8).toFin
                                        [Meta.isDefEq] [0.001376] ‚úÖÔ∏è 6 =?= (6#8).toFin.1
                                          [Meta.isDefEq] [0.001322] ‚úÖÔ∏è 6 =?= 6 % 2 ^ 8
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨((Option.map (fun div => x‚úù¬π + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù¬π.getLsbD 7 = true then ~~~((~~~x‚úù¬π + 1#8) / 42#8) + 1#8 else x‚úù¬π / 42#8))).bind
              fun a => some ((x‚úù >>> 6 &&& a) <<< 6)) ‚äë
            (Option.map (fun div => x‚úù¬π + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù¬π.getLsbD 7 = true then ~~~((~~~x‚úù¬π + 1#8) / 42#8) + 1#8 else x‚úù¬π / 42#8))).bind
              fun a => some (x‚úù &&& a <<< 6)
      ‚ä¢ False
  [Meta.isDefEq] [0.004319] ‚ùåÔ∏è ?a + ?a =?= ~~~x‚úù¬π + 1#8
    [Meta.isDefEq] [0.004098] ‚ùåÔ∏è instHAdd =?= instHAdd
      [Meta.isDefEq] [0.004018] ‚ùåÔ∏è { hAdd := fun a b => Add.add a b } =?= { hAdd := fun a b => Add.add a b }
        [Meta.isDefEq] [0.003957] ‚ùåÔ∏è fun a b => Add.add a b =?= fun a b => Add.add a b
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:52:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:45:8: error: (kernel) declaration has metavariables 'lshr_or_thm'
[bv] [0.063469] Normalizing goal
  [Meta.synthInstance] [0.001703] ‚úÖÔ∏è Decidable
        (((Option.map (fun div => x‚úù - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù.sdiv 42#8))).bind
            fun x => if 4#8 ‚â• ‚Üë8 then none else if 4#8 ‚â• ‚Üë8 then none else some ((x ||| x‚úù¬π >>> 4#8) <<< 4#8)) ‚äë
          (Option.map (fun div => x‚úù - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù.sdiv 42#8))).bind
            fun x => if 4#8 ‚â• ‚Üë8 then none else some (x‚úù¬π &&& 240#8 ||| x <<< 4#8))
    [Meta.check] [0.001057] ‚úÖÔ∏è BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          ((Option.map (fun div => x‚úù - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù.sdiv 42#8))).bind
            fun x => if 4#8 ‚â• ‚Üë8 then none else if 4#8 ‚â• ‚Üë8 then none else some ((x ||| x‚úù¬π >>> 4#8) <<< 4#8))
          ((Option.map (fun div => x‚úù - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù.sdiv 42#8))).bind
            fun x => if 4#8 ‚â• ‚Üë8 then none else some (x‚úù¬π &&& 240#8 ||| x <<< 4#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨((Option.map (fun div => x‚úù - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (x‚úù.sdiv 42#8))).bind
              fun x => if 4#8 ‚â• ‚Üë8 then none else if 4#8 ‚â• ‚Üë8 then none else some ((x ||| x‚úù¬π >>> 4#8) <<< 4#8)) ‚äë
            (Option.map (fun div => x‚úù - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (x‚úù.sdiv 42#8))).bind
              fun x => if 4#8 ‚â• ‚Üë8 then none else some (x‚úù¬π &&& 240#8 ||| x <<< 4#8)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨((Option.map (fun div => x‚úù + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù.getLsbD 7 = true then ~~~((~~~x‚úù + 1#8) / 42#8) + 1#8 else x‚úù / 42#8))).bind
              fun a => some ((a ||| x‚úù¬π >>> 4) <<< 4)) ‚äë
            (Option.map (fun div => x‚úù + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù.getLsbD 7 = true then ~~~((~~~x‚úù + 1#8) / 42#8) + 1#8 else x‚úù / 42#8))).bind
              fun a => some (x‚úù¬π &&& 240#8 ||| a <<< 4)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:63:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:63:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:56:8: error: (kernel) declaration has metavariables 'lshr_xor_thm'
[bv] [0.075965] Normalizing goal
  [Meta.synthInstance] [0.001801] ‚úÖÔ∏è Decidable
        ((if 3#8 ‚â• ‚Üë8 then none
          else
            (Option.map (fun div => x‚úù¬π - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && x‚úù¬π == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (x‚úù¬π.sdiv 42#8))).bind
              fun x => if 3#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 3#8 ^^^ x) <<< 3#8)) ‚äë
          (Option.map (fun div => x‚úù¬π - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù¬π == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù¬π.sdiv 42#8))).bind
            fun x => if 3#8 ‚â• ‚Üë8 then none else some (x‚úù &&& 248#8 ^^^ x <<< 3#8))
    [Meta.check] [0.001229] ‚úÖÔ∏è BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if 3#8 ‚â• ‚Üë8 then none
          else
            (Option.map (fun div => x‚úù¬π - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && x‚úù¬π == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (x‚úù¬π.sdiv 42#8))).bind
              fun x => if 3#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 3#8 ^^^ x) <<< 3#8))
          ((Option.map (fun div => x‚úù¬π - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù¬π == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù¬π.sdiv 42#8))).bind
            fun x => if 3#8 ‚â• ‚Üë8 then none else some (x‚úù &&& 248#8 ^^^ x <<< 3#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if 3#8 ‚â• ‚Üë8 then none
            else
              (Option.map (fun div => x‚úù¬π - div * 42#8)
                    (if (42#8 == 0 || 8 != 1 && x‚úù¬π == BitVec.intMin 8 && 42#8 == -1) = true then none
                    else some (x‚úù¬π.sdiv 42#8))).bind
                fun x => if 3#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 3#8 ^^^ x) <<< 3#8)) ‚äë
            (Option.map (fun div => x‚úù¬π - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && x‚úù¬π == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (x‚úù¬π.sdiv 42#8))).bind
              fun x => if 3#8 ‚â• ‚Üë8 then none else some (x‚úù &&& 248#8 ^^^ x <<< 3#8)
      ‚ä¢ False
  [Meta.appBuilder] [0.002682] ‚úÖÔ∏è f: HAdd.hAdd, xs: [~~~(div * 42#8), 1#8]
    [Meta.synthInstance] [0.002593] ‚úÖÔ∏è HAdd (BitVec 8) (BitVec 8) (BitVec 8)
      [Meta.synthInstance] [0.002130] ‚úÖÔ∏è apply @instHAdd to HAdd (BitVec 8) (BitVec 8) (BitVec 8)
        [Meta.synthInstance.tryResolve] [0.002069] ‚úÖÔ∏è HAdd (BitVec 8) (BitVec 8)
              (BitVec 8) ‚âü HAdd (BitVec 8) (BitVec 8) (BitVec 8)
          [Meta.isDefEq] [0.001994] ‚úÖÔ∏è HAdd (BitVec 8) (BitVec 8) ?m.78537 =?= HAdd ?m.78540 ?m.78540 ?m.78540
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨((Option.map (fun div => x‚úù¬π + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù¬π.getLsbD 7 = true then ~~~((~~~x‚úù¬π + 1#8) / 42#8) + 1#8 else x‚úù¬π / 42#8))).bind
              fun a => some ((x‚úù >>> 3 ^^^ a) <<< 3)) ‚äë
            (Option.map (fun div => x‚úù¬π + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù¬π.getLsbD 7 = true then ~~~((~~~x‚úù¬π + 1#8) / 42#8) + 1#8 else x‚úù¬π / 42#8))).bind
              fun a => some (x‚úù &&& 248#8 ^^^ a <<< 3)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:74:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:67:8: error: (kernel) declaration has metavariables 'lshr_and_add_thm'
[bv] [0.091671] Normalizing goal
  [Meta.synthInstance] [0.001734] ‚úÖÔ∏è Decidable
        (((Option.map (fun div => x‚úù - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù.sdiv 42#8))).bind
            fun x =>
            if 3#8 ‚â• ‚Üë8 then none else if 3#8 ‚â• ‚Üë8 then none else some ((x + (x‚úù¬π >>> 3#8 &&& 12#8)) <<< 3#8)) ‚äë
          (Option.map (fun div => x‚úù - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù.sdiv 42#8))).bind
            fun x => if 3#8 ‚â• ‚Üë8 then none else some ((x‚úù¬π &&& 96#8) + x <<< 3#8))
    [Meta.check] [0.001140] ‚úÖÔ∏è BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          ((Option.map (fun div => x‚úù - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù.sdiv 42#8))).bind
            fun x => if 3#8 ‚â• ‚Üë8 then none else if 3#8 ‚â• ‚Üë8 then none else some ((x + (x‚úù¬π >>> 3#8 &&& 12#8)) <<< 3#8))
          ((Option.map (fun div => x‚úù - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù.sdiv 42#8))).bind
            fun x => if 3#8 ‚â• ‚Üë8 then none else some ((x‚úù¬π &&& 96#8) + x <<< 3#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨((Option.map (fun div => x‚úù - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (x‚úù.sdiv 42#8))).bind
              fun x =>
              if 3#8 ‚â• ‚Üë8 then none else if 3#8 ‚â• ‚Üë8 then none else some ((x + (x‚úù¬π >>> 3#8 &&& 12#8)) <<< 3#8)) ‚äë
            (Option.map (fun div => x‚úù - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (x‚úù.sdiv 42#8))).bind
              fun x => if 3#8 ‚â• ‚Üë8 then none else some ((x‚úù¬π &&& 96#8) + x <<< 3#8)
      ‚ä¢ False
  [Meta.isDefEq] [0.003607] ‚úÖÔ∏è ?hf =?= fun a a_1 =>
        Eq.trans
          (ite_cond_eq_false none (if 3#8 ‚â• ‚Üë8 then none else some ((a + (x‚úù¬π >>> 3#8 &&& 12#8)) <<< 3#8))
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 3#8)
                (Eq.trans (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 3#8 8#8) (eq_self true)))
                  Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
          (ite_cond_eq_false none (some ((a + (x‚úù¬π >>> 3#8 &&& 12#8)) <<< 3#8))
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 3#8)
                (Eq.trans (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 3#8 8#8) (eq_self true)))
                  Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
    [Meta.isDefEq.assign] [0.003602] ‚úÖÔ∏è ?hf := fun a a_1 =>
          Eq.trans
            (ite_cond_eq_false none (if 3#8 ‚â• ‚Üë8 then none else some ((a + (x‚úù¬π >>> 3#8 &&& 12#8)) <<< 3#8))
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 3#8)
                  (Eq.trans
                    (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 3#8 8#8) (eq_self true)))
                    Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
            (ite_cond_eq_false none (some ((a + (x‚úù¬π >>> 3#8 &&& 12#8)) <<< 3#8))
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 3#8)
                  (Eq.trans
                    (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 3#8 8#8) (eq_self true)))
                    Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
      [Meta.isDefEq.assign.checkTypes] [0.003536] ‚úÖÔ∏è (?hf : ‚àÄ
            a ‚àà
              Option.map (fun div => x‚úù + (~~~(div * 42#8) + 1#8))
                (some (if x‚úù.getLsbD 7 = true then ~~~((~~~x‚úù + 1#8) / 42#8) + 1#8 else x‚úù / 42#8)),
            (if 3#8 ‚â• ‚Üë8 then none else if 3#8 ‚â• ‚Üë8 then none else some ((a + (x‚úù¬π >>> 3#8 &&& 12#8)) <<< 3#8)) =
              some
                ((a + (x‚úù¬π >>> 3 &&& 12#8)) <<<
                  3)) := (fun a a_1 =>
            Eq.trans
              (ite_cond_eq_false none (if 3#8 ‚â• ‚Üë8 then none else some ((a + (x‚úù¬π >>> 3#8 &&& 12#8)) <<< 3#8))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 3#8)
                    (Eq.trans
                      (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 3#8 8#8) (eq_self true)))
                      Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
              (ite_cond_eq_false none (some ((a + (x‚úù¬π >>> 3#8 &&& 12#8)) <<< 3#8))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 3#8)
                    (Eq.trans
                      (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 3#8 8#8) (eq_self true)))
                      Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))) : ‚àÄ
            a ‚àà
              Option.map (fun div => x‚úù + (~~~(div * 42#8) + 1#8))
                (some (if x‚úù.getLsbD 7 = true then ~~~((~~~x‚úù + 1#8) / 42#8) + 1#8 else x‚úù / 42#8)),
            (if 3#8 ‚â• ‚Üë8 then none else if 3#8 ‚â• ‚Üë8 then none else some ((a + (x‚úù¬π >>> 3#8 &&& 12#8)) <<< 3#8)) =
              some ((a + (x‚úù¬π >>> 3#8 &&& 12#8)) <<< 3#8))
        [Meta.isDefEq] [0.003531] ‚úÖÔ∏è ‚àÄ
              a ‚àà
                Option.map (fun div => x‚úù + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù.getLsbD 7 = true then ~~~((~~~x‚úù + 1#8) / 42#8) + 1#8 else x‚úù / 42#8)),
              (if 3#8 ‚â• ‚Üë8 then none else if 3#8 ‚â• ‚Üë8 then none else some ((a + (x‚úù¬π >>> 3#8 &&& 12#8)) <<< 3#8)) =
                some
                  ((a + (x‚úù¬π >>> 3 &&& 12#8)) <<<
                    3) =?= ‚àÄ
              a ‚àà
                Option.map (fun div => x‚úù + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù.getLsbD 7 = true then ~~~((~~~x‚úù + 1#8) / 42#8) + 1#8 else x‚úù / 42#8)),
              (if 3#8 ‚â• ‚Üë8 then none else if 3#8 ‚â• ‚Üë8 then none else some ((a + (x‚úù¬π >>> 3#8 &&& 12#8)) <<< 3#8)) =
                some ((a + (x‚úù¬π >>> 3#8 &&& 12#8)) <<< 3#8)
          [Meta.isDefEq] [0.003455] ‚úÖÔ∏è (if 3#8 ‚â• ‚Üë8 then none
                else if 3#8 ‚â• ‚Üë8 then none else some ((a + (x‚úù¬π >>> 3#8 &&& 12#8)) <<< 3#8)) =
                some
                  ((a + (x‚úù¬π >>> 3 &&& 12#8)) <<<
                    3) =?= (if 3#8 ‚â• ‚Üë8 then none
                else if 3#8 ‚â• ‚Üë8 then none else some ((a + (x‚úù¬π >>> 3#8 &&& 12#8)) <<< 3#8)) =
                some ((a + (x‚úù¬π >>> 3#8 &&& 12#8)) <<< 3#8)
            [Meta.isDefEq] [0.003420] ‚úÖÔ∏è some
                  ((a + (x‚úù¬π >>> 3 &&& 12#8)) <<< 3) =?= some ((a + (x‚úù¬π >>> 3#8 &&& 12#8)) <<< 3#8)
              [Meta.isDefEq] [0.003385] ‚úÖÔ∏è (a + (x‚úù¬π >>> 3 &&& 12#8)) <<< 3 =?= (a + (x‚úù¬π >>> 3#8 &&& 12#8)) <<< 3#8
                [Meta.isDefEq] [0.003347] ‚úÖÔ∏è BitVec.instHShiftLeftNat.1 (a + (x‚úù¬π >>> 3 &&& 12#8))
                      3 =?= BitVec.instHShiftLeft.1 (a + (x‚úù¬π >>> 3#8 &&& 12#8)) 3#8
                  [Meta.isDefEq] [0.003267] ‚úÖÔ∏è (a + (x‚úù¬π >>> 3 &&& 12#8)).shiftLeft
                        3 =?= (a + (x‚úù¬π >>> 3#8 &&& 12#8)) <<< (3#8).toNat
                    [Meta.isDefEq] [0.003226] ‚úÖÔ∏è (a + (x‚úù¬π >>> 3 &&& 12#8)).shiftLeft
                          3 =?= (a + (x‚úù¬π >>> 3#8 &&& 12#8)).shiftLeft (3#8).toNat
                      [Meta.isDefEq.delta] [0.003211] ‚úÖÔ∏è (a + (x‚úù¬π >>> 3 &&& 12#8)).shiftLeft
                            3 =?= (a + (x‚úù¬π >>> 3#8 &&& 12#8)).shiftLeft (3#8).toNat
                        [Meta.isDefEq] [0.003171] ‚úÖÔ∏è a + (x‚úù¬π >>> 3 &&& 12#8) =?= a + (x‚úù¬π >>> 3#8 &&& 12#8)
                          [Meta.isDefEq] [0.002975] ‚úÖÔ∏è instHAdd.1 a
                                (x‚úù¬π >>> 3 &&& 12#8) =?= instHAdd.1 a (x‚úù¬π >>> 3#8 &&& 12#8)
                            [Meta.isDefEq] [0.002888] ‚úÖÔ∏è Add.add a
                                  (x‚úù¬π >>> 3 &&& 12#8) =?= Add.add a (x‚úù¬π >>> 3#8 &&& 12#8)
                              [Meta.isDefEq] [0.002234] ‚ùåÔ∏è BitVec.instAdd =?= instAddNat
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨((Option.map (fun div => x‚úù + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù.getLsbD 7 = true then ~~~((~~~x‚úù + 1#8) / 42#8) + 1#8 else x‚úù / 42#8))).bind
              fun a => some ((a + (x‚úù¬π >>> 3 &&& 12#8)) <<< 3)) ‚äë
            (Option.map (fun div => x‚úù + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù.getLsbD 7 = true then ~~~((~~~x‚úù + 1#8) / 42#8) + 1#8 else x‚úù / 42#8))).bind
              fun a => some ((x‚úù¬π &&& 96#8) + a <<< 3)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:88:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:78:8: error: (kernel) declaration has metavariables 'lshr_and_sub_thm'
[bv] [0.135502] Normalizing goal
  [Meta.synthInstance] [0.001964] ‚úÖÔ∏è Decidable
        (((Option.map (fun div => x‚úù - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù.sdiv 42#8))).bind
            fun x =>
            if 2#8 ‚â• ‚Üë8 then none else if 2#8 ‚â• ‚Üë8 then none else some ((x - (x‚úù¬π >>> 2#8 &&& 13#8)) <<< 2#8)) ‚äë
          (Option.map (fun div => x‚úù - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù.sdiv 42#8))).bind
            fun x =>
            if 2#8 ‚â• ‚Üë8 then none
            else
              if
                  True ‚àß
                    (BitVec.signExtend (8 + 1) x - BitVec.signExtend (8 + 1) (x‚úù¬π >>> 2#8 &&& 13#8)).msb ‚â†
                      (BitVec.signExtend (8 + 1) x - BitVec.signExtend (8 + 1) (x‚úù¬π >>> 2#8 &&& 13#8)).getMsbD 1 then
                none
              else if 2#8 ‚â• ‚Üë8 then none else some ((x - (x‚úù¬π >>> 2#8 &&& 13#8)) <<< 2#8))
    [Meta.check] [0.001357] ‚úÖÔ∏è BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          ((Option.map (fun div => x‚úù - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù.sdiv 42#8))).bind
            fun x => if 2#8 ‚â• ‚Üë8 then none else if 2#8 ‚â• ‚Üë8 then none else some ((x - (x‚úù¬π >>> 2#8 &&& 13#8)) <<< 2#8))
          ((Option.map (fun div => x‚úù - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù.sdiv 42#8))).bind
            fun x =>
            if 2#8 ‚â• ‚Üë8 then none
            else
              if
                  True ‚àß
                    (BitVec.signExtend (8 + 1) x - BitVec.signExtend (8 + 1) (x‚úù¬π >>> 2#8 &&& 13#8)).msb ‚â†
                      (BitVec.signExtend (8 + 1) x - BitVec.signExtend (8 + 1) (x‚úù¬π >>> 2#8 &&& 13#8)).getMsbD 1 then
                none
              else if 2#8 ‚â• ‚Üë8 then none else some ((x - (x‚úù¬π >>> 2#8 &&& 13#8)) <<< 2#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨((Option.map (fun div => x‚úù - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (x‚úù.sdiv 42#8))).bind
              fun x =>
              if 2#8 ‚â• ‚Üë8 then none else if 2#8 ‚â• ‚Üë8 then none else some ((x - (x‚úù¬π >>> 2#8 &&& 13#8)) <<< 2#8)) ‚äë
            (Option.map (fun div => x‚úù - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (x‚úù.sdiv 42#8))).bind
              fun x =>
              if 2#8 ‚â• ‚Üë8 then none
              else
                if
                    True ‚àß
                      (BitVec.signExtend (8 + 1) x - BitVec.signExtend (8 + 1) (x‚úù¬π >>> 2#8 &&& 13#8)).msb ‚â†
                        (BitVec.signExtend (8 + 1) x - BitVec.signExtend (8 + 1) (x‚úù¬π >>> 2#8 &&& 13#8)).getMsbD 1 then
                  none
                else if 2#8 ‚â• ‚Üë8 then none else some ((x - (x‚úù¬π >>> 2#8 &&& 13#8)) <<< 2#8)
      ‚ä¢ False
  [Meta.isDefEq] [0.001393] ‚úÖÔ∏è ?h‚ÇÅ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (congr
              (congrArg Ne
                (Eq.trans
                  (congrArg BitVec.msb
                    (Eq.trans (BitVec.sub_toAdd (BitVec.signExtend 9 a) (BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8)))
                      (congrArg (HAdd.hAdd (BitVec.signExtend 9 a))
                        (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8))))))
                  (BitVec.msb_eq_getLsbD_last
                    (BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8) + 1#9)))))
              (congrArg (fun x => x.getMsbD 1)
                (Eq.trans (BitVec.sub_toAdd (BitVec.signExtend 9 a) (BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8)))
                  (congrArg (HAdd.hAdd (BitVec.signExtend 9 a))
                    (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8)))))))
            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
              ((BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8) + 1#9)).getLsbD 8)
              ((BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8) + 1#9)).getMsbD 1))))
        (true_and
          ((!(BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8) + 1#9)).getLsbD 8 ==
                (BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8) + 1#9)).getMsbD 1) =
            true))
    [Meta.isDefEq.assign] [0.001388] ‚úÖÔ∏è ?h‚ÇÅ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (congr
                (congrArg Ne
                  (Eq.trans
                    (congrArg BitVec.msb
                      (Eq.trans (BitVec.sub_toAdd (BitVec.signExtend 9 a) (BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8)))
                        (congrArg (HAdd.hAdd (BitVec.signExtend 9 a))
                          (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8))))))
                    (BitVec.msb_eq_getLsbD_last
                      (BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8) + 1#9)))))
                (congrArg (fun x => x.getMsbD 1)
                  (Eq.trans (BitVec.sub_toAdd (BitVec.signExtend 9 a) (BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8)))
                    (congrArg (HAdd.hAdd (BitVec.signExtend 9 a))
                      (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                ((BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8) + 1#9)).getLsbD 8)
                ((BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8) + 1#9)).getMsbD 1))))
          (true_and
            ((!(BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8) + 1#9)).getLsbD 8 ==
                  (BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8) + 1#9)).getMsbD 1) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.001361] ‚úÖÔ∏è (?h‚ÇÅ : (True ‚àß
              (BitVec.signExtend (8 + 1) a - BitVec.signExtend (8 + 1) (x‚úù¬π >>> 2#8 &&& 13#8)).msb ‚â†
                (BitVec.signExtend (8 + 1) a - BitVec.signExtend (8 + 1) (x‚úù¬π >>> 2#8 &&& 13#8)).getMsbD 1) =
            ((!(BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8) + 1#9)).getLsbD 8 ==
                  (BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8) + 1#9)).getMsbD 1) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (congr
                  (congrArg Ne
                    (Eq.trans
                      (congrArg BitVec.msb
                        (Eq.trans (BitVec.sub_toAdd (BitVec.signExtend 9 a) (BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8)))
                          (congrArg (HAdd.hAdd (BitVec.signExtend 9 a))
                            (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8))))))
                      (BitVec.msb_eq_getLsbD_last
                        (BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8) + 1#9)))))
                  (congrArg (fun x => x.getMsbD 1)
                    (Eq.trans (BitVec.sub_toAdd (BitVec.signExtend 9 a) (BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8)))
                      (congrArg (HAdd.hAdd (BitVec.signExtend 9 a))
                        (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                  ((BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8) + 1#9)).getLsbD 8)
                  ((BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8) + 1#9)).getMsbD 1))))
            (true_and
              ((!(BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8) + 1#9)).getLsbD 8 ==
                    (BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8) + 1#9)).getMsbD 1) =
                true)) : (True ‚àß
              (BitVec.signExtend 9 a - BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8)).msb ‚â†
                (BitVec.signExtend 9 a - BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8)).getMsbD 1) =
            ((!(BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8) + 1#9)).getLsbD 8 ==
                  (BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8) + 1#9)).getMsbD 1) =
              true))
        [Meta.isDefEq] [0.001357] ‚úÖÔ∏è (True ‚àß
                (BitVec.signExtend (8 + 1) a - BitVec.signExtend (8 + 1) (x‚úù¬π >>> 2#8 &&& 13#8)).msb ‚â†
                  (BitVec.signExtend (8 + 1) a - BitVec.signExtend (8 + 1) (x‚úù¬π >>> 2#8 &&& 13#8)).getMsbD 1) =
              ((!(BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8) + 1#9)).getLsbD 8 ==
                    (BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8) + 1#9)).getMsbD 1) =
                true) =?= (True ‚àß
                (BitVec.signExtend 9 a - BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8)).msb ‚â†
                  (BitVec.signExtend 9 a - BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8)).getMsbD 1) =
              ((!(BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8) + 1#9)).getLsbD 8 ==
                    (BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8) + 1#9)).getMsbD 1) =
                true)
          [Meta.isDefEq] [0.001326] ‚úÖÔ∏è True ‚àß
                (BitVec.signExtend (8 + 1) a - BitVec.signExtend (8 + 1) (x‚úù¬π >>> 2#8 &&& 13#8)).msb ‚â†
                  (BitVec.signExtend (8 + 1) a - BitVec.signExtend (8 + 1) (x‚úù¬π >>> 2#8 &&& 13#8)).getMsbD
                    1 =?= True ‚àß
                (BitVec.signExtend 9 a - BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8)).msb ‚â†
                  (BitVec.signExtend 9 a - BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8)).getMsbD 1
            [Meta.isDefEq] [0.001303] ‚úÖÔ∏è (BitVec.signExtend (8 + 1) a -
                      BitVec.signExtend (8 + 1) (x‚úù¬π >>> 2#8 &&& 13#8)).msb ‚â†
                  (BitVec.signExtend (8 + 1) a - BitVec.signExtend (8 + 1) (x‚úù¬π >>> 2#8 &&& 13#8)).getMsbD
                    1 =?= (BitVec.signExtend 9 a - BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8)).msb ‚â†
                  (BitVec.signExtend 9 a - BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8)).getMsbD 1
              [Meta.isDefEq.delta] [0.001281] ‚úÖÔ∏è (BitVec.signExtend (8 + 1) a -
                        BitVec.signExtend (8 + 1) (x‚úù¬π >>> 2#8 &&& 13#8)).msb ‚â†
                    (BitVec.signExtend (8 + 1) a - BitVec.signExtend (8 + 1) (x‚úù¬π >>> 2#8 &&& 13#8)).getMsbD
                      1 =?= (BitVec.signExtend 9 a - BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8)).msb ‚â†
                    (BitVec.signExtend 9 a - BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8)).getMsbD 1
                [Meta.isDefEq] [0.001183] ‚úÖÔ∏è (BitVec.signExtend (8 + 1) a -
                        BitVec.signExtend (8 + 1)
                          (x‚úù¬π >>> 2#8 &&&
                            13#8)).msb =?= (BitVec.signExtend 9 a - BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8)).msb
                  [Meta.isDefEq.delta] [0.001166] ‚úÖÔ∏è (BitVec.signExtend (8 + 1) a -
                          BitVec.signExtend (8 + 1)
                            (x‚úù¬π >>> 2#8 &&&
                              13#8)).msb =?= (BitVec.signExtend 9 a - BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8)).msb
                    [Meta.isDefEq] [0.001131] ‚úÖÔ∏è BitVec.signExtend (8 + 1) a -
                          BitVec.signExtend (8 + 1)
                            (x‚úù¬π >>> 2#8 &&& 13#8) =?= BitVec.signExtend 9 a - BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8)
                      [Meta.isDefEq] [0.001092] ‚úÖÔ∏è instHSub.1 (BitVec.signExtend (8 + 1) a)
                            (BitVec.signExtend (8 + 1)
                              (x‚úù¬π >>> 2#8 &&&
                                13#8)) =?= instHSub.1 (BitVec.signExtend 9 a) (BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8))
                        [Meta.isDefEq] [0.001008] ‚úÖÔ∏è Sub.sub (BitVec.signExtend (8 + 1) a)
                              (BitVec.signExtend (8 + 1)
                                (x‚úù¬π >>> 2#8 &&&
                                  13#8)) =?= Sub.sub (BitVec.signExtend 9 a) (BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨((Option.map (fun div => x‚úù + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù.getLsbD 7 = true then ~~~((~~~x‚úù + 1#8) / 42#8) + 1#8 else x‚úù / 42#8))).bind
              fun a => some ((a + (~~~(x‚úù¬π >>> 2 &&& 13#8) + 1#8)) <<< 2)) ‚äë
            (Option.map (fun div => x‚úù + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù.getLsbD 7 = true then ~~~((~~~x‚úù + 1#8) / 42#8) + 1#8 else x‚úù / 42#8))).bind
              fun a =>
              if
                  (!(BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8) + 1#9)).getLsbD 8 ==
                        (BitVec.signExtend 9 a + (~~~BitVec.signExtend 9 (x‚úù¬π >>> 2 &&& 13#8) + 1#9)).getMsbD 1) =
                    true then
                none
              else some ((a + (~~~(x‚úù¬π >>> 2 &&& 13#8) + 1#8)) <<< 2)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:99:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:99:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:92:8: error: (kernel) declaration has metavariables 'lshr_and_and_thm'
[bv] [0.115411] Normalizing goal
  [Meta.synthInstance] [0.002535] ‚úÖÔ∏è Decidable
        ((if 2#8 ‚â• ‚Üë8 then none
          else
            (Option.map (fun div => x‚úù¬π - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && x‚úù¬π == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (x‚úù¬π.sdiv 42#8))).bind
              fun x => if 2#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 2#8 &&& 13#8 &&& x) <<< 2#8)) ‚äë
          (Option.map (fun div => x‚úù¬π - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù¬π == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù¬π.sdiv 42#8))).bind
            fun x => if 2#8 ‚â• ‚Üë8 then none else some (x‚úù &&& 52#8 &&& x <<< 2#8))
    [Meta.check] [0.001718] ‚úÖÔ∏è BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if 2#8 ‚â• ‚Üë8 then none
          else
            (Option.map (fun div => x‚úù¬π - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && x‚úù¬π == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (x‚úù¬π.sdiv 42#8))).bind
              fun x => if 2#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 2#8 &&& 13#8 &&& x) <<< 2#8))
          ((Option.map (fun div => x‚úù¬π - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù¬π == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù¬π.sdiv 42#8))).bind
            fun x => if 2#8 ‚â• ‚Üë8 then none else some (x‚úù &&& 52#8 &&& x <<< 2#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if 2#8 ‚â• ‚Üë8 then none
            else
              (Option.map (fun div => x‚úù¬π - div * 42#8)
                    (if (42#8 == 0 || 8 != 1 && x‚úù¬π == BitVec.intMin 8 && 42#8 == -1) = true then none
                    else some (x‚úù¬π.sdiv 42#8))).bind
                fun x => if 2#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 2#8 &&& 13#8 &&& x) <<< 2#8)) ‚äë
            (Option.map (fun div => x‚úù¬π - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && x‚úù¬π == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (x‚úù¬π.sdiv 42#8))).bind
              fun x => if 2#8 ‚â• ‚Üë8 then none else some (x‚úù &&& 52#8 &&& x <<< 2#8)
      ‚ä¢ False
  [Meta.appBuilder] [0.001997] ‚úÖÔ∏è f: Complement.complement, xs: [div * 42#8]
    [Meta.synthInstance] [0.001918] ‚úÖÔ∏è Complement (BitVec 8)
      [Meta.whnf] [0.001648] Non-easy whnf: Complement (BitVec 8)
  [Meta.appBuilder] [0.002863] ‚úÖÔ∏è f: HAdd.hAdd, xs: [~~~(div * 42#8), 1#8]
    [Meta.synthInstance] [0.002752] ‚úÖÔ∏è HAdd (BitVec 8) (BitVec 8) (BitVec 8)
      [Meta.synthInstance] [0.002218] ‚úÖÔ∏è apply @instHAdd to HAdd (BitVec 8) (BitVec 8) (BitVec 8)
        [Meta.synthInstance.tryResolve] [0.002112] ‚úÖÔ∏è HAdd (BitVec 8) (BitVec 8)
              (BitVec 8) ‚âü HAdd (BitVec 8) (BitVec 8) (BitVec 8)
          [Meta.isDefEq] [0.001945] ‚úÖÔ∏è ?m.128810 =?= instHAdd
            [Meta.isDefEq.assign] [0.001940] ‚úÖÔ∏è ?m.128810 := instHAdd
              [Meta.isDefEq.assign.checkTypes] [0.001918] ‚úÖÔ∏è (?m.128810 : HAdd (BitVec 8) (BitVec 8)
                    (BitVec 8)) := (instHAdd : HAdd (BitVec 8) (BitVec 8) (BitVec 8))
                [Meta.isDefEq] [0.001905] ‚úÖÔ∏è HAdd (BitVec 8) (BitVec 8)
                      (BitVec 8) =?= HAdd (BitVec 8) (BitVec 8) (BitVec 8)
  [Meta.isDefEq] [0.002285] ‚ùåÔ∏è ?a + ?a =?= ~~~(div * 42#8) + 1#8
    [Meta.isDefEq] [0.002126] ‚ùåÔ∏è instHAdd =?= instHAdd
      [Meta.isDefEq] [0.002018] ‚ùåÔ∏è { hAdd := fun a b => Add.add a b } =?= { hAdd := fun a b => Add.add a b }
  [Meta.appBuilder] [0.003536] ‚úÖÔ∏è f: eq_false', xs: [fun h => Bool.noConfusion h]
    [Meta.isDefEq] [0.003483] ‚úÖÔ∏è ?p ‚Üí False =?= false = true ‚Üí Bool.noConfusionType False false true
      [Meta.isDefEq] [0.003453] ‚úÖÔ∏è False =?= Bool.noConfusionType False false true
        [Meta.isDefEq] [0.003390] ‚úÖÔ∏è False =?= Bool.casesOn false (Bool.casesOn true (False ‚Üí False) False)
              (Bool.casesOn true False (False ‚Üí False))
  [Meta.isDefEq] [0.004518] ‚úÖÔ∏è ?hf =?= fun a a_1 =>
        ite_cond_eq_false none (some ((x‚úù >>> 2#8 &&& 13#8 &&& a) <<< 2#8))
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
              (Eq.trans (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))
    [Meta.isDefEq.assign] [0.004514] ‚úÖÔ∏è ?hf := fun a a_1 =>
          ite_cond_eq_false none (some ((x‚úù >>> 2#8 &&& 13#8 &&& a) <<< 2#8))
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
                (Eq.trans (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                  Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))
      [Meta.isDefEq.assign.checkTypes] [0.004475] ‚úÖÔ∏è (?hf : ‚àÄ
            a ‚àà
              Option.map (fun div => x‚úù¬π + (~~~(div * 42#8) + 1#8))
                (some (if x‚úù¬π.getLsbD 7 = true then ~~~((~~~x‚úù¬π + 1#8) / 42#8) + 1#8 else x‚úù¬π / 42#8)),
            (if 2#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 2#8 &&& 13#8 &&& a) <<< 2#8)) =
              some
                ((x‚úù >>> 2 &&& 13#8 &&& a) <<<
                  2)) := (fun a a_1 =>
            ite_cond_eq_false none (some ((x‚úù >>> 2#8 &&& 13#8 &&& a) <<< 2#8))
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
                  (Eq.trans
                    (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                    Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))) : ‚àÄ
            a ‚àà
              Option.map (fun div => x‚úù¬π + (~~~(div * 42#8) + 1#8))
                (some (if x‚úù¬π.getLsbD 7 = true then ~~~((~~~x‚úù¬π + 1#8) / 42#8) + 1#8 else x‚úù¬π / 42#8)),
            (if 2#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 2#8 &&& 13#8 &&& a) <<< 2#8)) =
              some ((x‚úù >>> 2#8 &&& 13#8 &&& a) <<< 2#8))
        [Meta.isDefEq] [0.004470] ‚úÖÔ∏è ‚àÄ
              a ‚àà
                Option.map (fun div => x‚úù¬π + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù¬π.getLsbD 7 = true then ~~~((~~~x‚úù¬π + 1#8) / 42#8) + 1#8 else x‚úù¬π / 42#8)),
              (if 2#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 2#8 &&& 13#8 &&& a) <<< 2#8)) =
                some
                  ((x‚úù >>> 2 &&& 13#8 &&& a) <<<
                    2) =?= ‚àÄ
              a ‚àà
                Option.map (fun div => x‚úù¬π + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù¬π.getLsbD 7 = true then ~~~((~~~x‚úù¬π + 1#8) / 42#8) + 1#8 else x‚úù¬π / 42#8)),
              (if 2#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 2#8 &&& 13#8 &&& a) <<< 2#8)) =
                some ((x‚úù >>> 2#8 &&& 13#8 &&& a) <<< 2#8)
          [Meta.isDefEq] [0.004427] ‚úÖÔ∏è (if 2#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 2#8 &&& 13#8 &&& a) <<< 2#8)) =
                some
                  ((x‚úù >>> 2 &&& 13#8 &&& a) <<<
                    2) =?= (if 2#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 2#8 &&& 13#8 &&& a) <<< 2#8)) =
                some ((x‚úù >>> 2#8 &&& 13#8 &&& a) <<< 2#8)
            [Meta.isDefEq] [0.004382] ‚úÖÔ∏è some
                  ((x‚úù >>> 2 &&& 13#8 &&& a) <<< 2) =?= some ((x‚úù >>> 2#8 &&& 13#8 &&& a) <<< 2#8)
              [Meta.isDefEq] [0.004356] ‚úÖÔ∏è (x‚úù >>> 2 &&& 13#8 &&& a) <<< 2 =?= (x‚úù >>> 2#8 &&& 13#8 &&& a) <<< 2#8
                [Meta.isDefEq] [0.004332] ‚úÖÔ∏è BitVec.instHShiftLeftNat.1 (x‚úù >>> 2 &&& 13#8 &&& a)
                      2 =?= BitVec.instHShiftLeft.1 (x‚úù >>> 2#8 &&& 13#8 &&& a) 2#8
                  [Meta.isDefEq] [0.002558] ‚úÖÔ∏è (x‚úù >>> 2 &&& 13#8 &&& a).shiftLeft
                        2 =?= (x‚úù >>> 2#8 &&& 13#8 &&& a) <<< (2#8).toNat
                    [Meta.isDefEq] [0.002525] ‚úÖÔ∏è (x‚úù >>> 2 &&& 13#8 &&& a).shiftLeft
                          2 =?= (x‚úù >>> 2#8 &&& 13#8 &&& a).shiftLeft (2#8).toNat
                      [Meta.isDefEq.delta] [0.002514] ‚úÖÔ∏è (x‚úù >>> 2 &&& 13#8 &&& a).shiftLeft
                            2 =?= (x‚úù >>> 2#8 &&& 13#8 &&& a).shiftLeft (2#8).toNat
                        [Meta.isDefEq] [0.002473] ‚úÖÔ∏è x‚úù >>> 2 &&& 13#8 &&& a =?= x‚úù >>> 2#8 &&& 13#8 &&& a
                          [Meta.isDefEq] [0.002443] ‚úÖÔ∏è instHAndOfAndOp.1 (x‚úù >>> 2 &&& 13#8)
                                a =?= instHAndOfAndOp.1 (x‚úù >>> 2#8 &&& 13#8) a
                            [Meta.isDefEq] [0.002376] ‚úÖÔ∏è AndOp.and (x‚úù >>> 2 &&& 13#8)
                                  a =?= AndOp.and (x‚úù >>> 2#8 &&& 13#8) a
                              [Meta.isDefEq] [0.002352] ‚úÖÔ∏è BitVec.instAndOp.1 (x‚úù >>> 2 &&& 13#8)
                                    a =?= BitVec.instAndOp.1 (x‚úù >>> 2#8 &&& 13#8) a
                                [Meta.isDefEq] [0.002303] ‚úÖÔ∏è (x‚úù >>> 2 &&& 13#8).and a =?= (x‚úù >>> 2#8 &&& 13#8).and a
                                  [Meta.isDefEq.delta] [0.002292] ‚úÖÔ∏è (x‚úù >>> 2 &&& 13#8).and
                                        a =?= (x‚úù >>> 2#8 &&& 13#8).and a
                                    [Meta.isDefEq] [0.002264] ‚úÖÔ∏è x‚úù >>> 2 &&& 13#8 =?= x‚úù >>> 2#8 &&& 13#8
                                      [Meta.isDefEq] [0.002248] ‚úÖÔ∏è instHAndOfAndOp.1 (x‚úù >>> 2)
                                            13#8 =?= instHAndOfAndOp.1 (x‚úù >>> 2#8) 13#8
                                        [Meta.isDefEq] [0.002225] ‚úÖÔ∏è AndOp.and (x‚úù >>> 2)
                                              13#8 =?= AndOp.and (x‚úù >>> 2#8) 13#8
                                          [Meta.isDefEq] [0.002210] ‚úÖÔ∏è BitVec.instAndOp.1 (x‚úù >>> 2)
                                                13#8 =?= BitVec.instAndOp.1 (x‚úù >>> 2#8) 13#8
                                            [Meta.isDefEq] [0.002191] ‚úÖÔ∏è (x‚úù >>> 2).and 13#8 =?= (x‚úù >>> 2#8).and 13#8
                                              [Meta.isDefEq.delta] [0.002176] ‚úÖÔ∏è (x‚úù >>> 2).and
                                                    13#8 =?= (x‚úù >>> 2#8).and 13#8
                                                [Meta.isDefEq] [0.002164] ‚úÖÔ∏è x‚úù >>> 2 =?= x‚úù >>> 2#8
                                                  [Meta.isDefEq] [0.002140] ‚úÖÔ∏è BitVec.instHShiftRightNat.1 x‚úù
                                                        2 =?= BitVec.instHShiftRight.1 x‚úù 2#8
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨((Option.map (fun div => x‚úù¬π + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù¬π.getLsbD 7 = true then ~~~((~~~x‚úù¬π + 1#8) / 42#8) + 1#8 else x‚úù¬π / 42#8))).bind
              fun a => some ((x‚úù >>> 2 &&& 13#8 &&& a) <<< 2)) ‚äë
            (Option.map (fun div => x‚úù¬π + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù¬π.getLsbD 7 = true then ~~~((~~~x‚úù¬π + 1#8) / 42#8) + 1#8 else x‚úù¬π / 42#8))).bind
              fun a => some (x‚úù &&& 52#8 &&& a <<< 2)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:110:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:103:8: error: (kernel) declaration has metavariables 'lshr_and_or_thm'
[bv] [0.096237] Normalizing goal
  [Meta.synthInstance] [0.006438] ‚úÖÔ∏è Decidable
        (((Option.map (fun div => x‚úù - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù.sdiv 42#8))).bind
            fun x =>
            if 2#8 ‚â• ‚Üë8 then none else if 2#8 ‚â• ‚Üë8 then none else some ((x ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8)) ‚äë
          (Option.map (fun div => x‚úù - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù.sdiv 42#8))).bind
            fun x => if 2#8 ‚â• ‚Üë8 then none else some (x‚úù¬π &&& 52#8 ||| x <<< 2#8))
    [Meta.synthInstance] [0.004195] ‚úÖÔ∏è apply @BitVec.Refinement.instDecidableRelOptionOfDecidableEq to Decidable
          (((Option.map (fun div => x‚úù - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (x‚úù.sdiv 42#8))).bind
              fun x =>
              if 2#8 ‚â• ‚Üë8 then none else if 2#8 ‚â• ‚Üë8 then none else some ((x ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8)) ‚äë
            (Option.map (fun div => x‚úù - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (x‚úù.sdiv 42#8))).bind
              fun x => if 2#8 ‚â• ‚Üë8 then none else some (x‚úù¬π &&& 52#8 ||| x <<< 2#8))
      [Meta.whnf] [0.001736] Non-easy whnf: DecidableRel BitVec.Refinement
    [Meta.check] [0.001642] ‚úÖÔ∏è BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          ((Option.map (fun div => x‚úù - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù.sdiv 42#8))).bind
            fun x => if 2#8 ‚â• ‚Üë8 then none else if 2#8 ‚â• ‚Üë8 then none else some ((x ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8))
          ((Option.map (fun div => x‚úù - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù.sdiv 42#8))).bind
            fun x => if 2#8 ‚â• ‚Üë8 then none else some (x‚úù¬π &&& 52#8 ||| x <<< 2#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨((Option.map (fun div => x‚úù - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (x‚úù.sdiv 42#8))).bind
              fun x =>
              if 2#8 ‚â• ‚Üë8 then none else if 2#8 ‚â• ‚Üë8 then none else some ((x ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8)) ‚äë
            (Option.map (fun div => x‚úù - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (x‚úù.sdiv 42#8))).bind
              fun x => if 2#8 ‚â• ‚Üë8 then none else some (x‚úù¬π &&& 52#8 ||| x <<< 2#8)
      ‚ä¢ False
  [Meta.isDefEq] [0.001512] ‚úÖÔ∏è ?hf =?= fun a a_1 =>
        Eq.trans
          (ite_cond_eq_false none (if 2#8 ‚â• ‚Üë8 then none else some ((a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8))
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
                (Eq.trans (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                  Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
          (ite_cond_eq_false none (some ((a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8))
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
                (Eq.trans (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                  Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
    [Meta.isDefEq.assign] [0.001506] ‚úÖÔ∏è ?hf := fun a a_1 =>
          Eq.trans
            (ite_cond_eq_false none (if 2#8 ‚â• ‚Üë8 then none else some ((a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8))
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
                  (Eq.trans
                    (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                    Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
            (ite_cond_eq_false none (some ((a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8))
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
                  (Eq.trans
                    (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                    Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
      [Meta.isDefEq.assign.checkTypes] [0.001445] ‚úÖÔ∏è (?hf : ‚àÄ
            a ‚àà
              Option.map (fun div => x‚úù + (~~~(div * 42#8) + 1#8))
                (some (if x‚úù.getLsbD 7 = true then ~~~((~~~x‚úù + 1#8) / 42#8) + 1#8 else x‚úù / 42#8)),
            (if 2#8 ‚â• ‚Üë8 then none else if 2#8 ‚â• ‚Üë8 then none else some ((a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8)) =
              some
                ((a ||| x‚úù¬π >>> 2 &&& 13#8) <<<
                  2)) := (fun a a_1 =>
            Eq.trans
              (ite_cond_eq_false none (if 2#8 ‚â• ‚Üë8 then none else some ((a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
                    (Eq.trans
                      (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                      Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
              (ite_cond_eq_false none (some ((a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
                    (Eq.trans
                      (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                      Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))) : ‚àÄ
            a ‚àà
              Option.map (fun div => x‚úù + (~~~(div * 42#8) + 1#8))
                (some (if x‚úù.getLsbD 7 = true then ~~~((~~~x‚úù + 1#8) / 42#8) + 1#8 else x‚úù / 42#8)),
            (if 2#8 ‚â• ‚Üë8 then none else if 2#8 ‚â• ‚Üë8 then none else some ((a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8)) =
              some ((a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8))
        [Meta.isDefEq] [0.001440] ‚úÖÔ∏è ‚àÄ
              a ‚àà
                Option.map (fun div => x‚úù + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù.getLsbD 7 = true then ~~~((~~~x‚úù + 1#8) / 42#8) + 1#8 else x‚úù / 42#8)),
              (if 2#8 ‚â• ‚Üë8 then none else if 2#8 ‚â• ‚Üë8 then none else some ((a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8)) =
                some
                  ((a ||| x‚úù¬π >>> 2 &&& 13#8) <<<
                    2) =?= ‚àÄ
              a ‚àà
                Option.map (fun div => x‚úù + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù.getLsbD 7 = true then ~~~((~~~x‚úù + 1#8) / 42#8) + 1#8 else x‚úù / 42#8)),
              (if 2#8 ‚â• ‚Üë8 then none else if 2#8 ‚â• ‚Üë8 then none else some ((a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8)) =
                some ((a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8)
          [Meta.isDefEq] [0.001369] ‚úÖÔ∏è (if 2#8 ‚â• ‚Üë8 then none
                else if 2#8 ‚â• ‚Üë8 then none else some ((a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8)) =
                some
                  ((a ||| x‚úù¬π >>> 2 &&& 13#8) <<<
                    2) =?= (if 2#8 ‚â• ‚Üë8 then none
                else if 2#8 ‚â• ‚Üë8 then none else some ((a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8)) =
                some ((a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8)
            [Meta.isDefEq] [0.001334] ‚úÖÔ∏è some
                  ((a ||| x‚úù¬π >>> 2 &&& 13#8) <<< 2) =?= some ((a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8)
              [Meta.isDefEq] [0.001299] ‚úÖÔ∏è (a ||| x‚úù¬π >>> 2 &&& 13#8) <<< 2 =?= (a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8
                [Meta.isDefEq] [0.001264] ‚úÖÔ∏è BitVec.instHShiftLeftNat.1 (a ||| x‚úù¬π >>> 2 &&& 13#8)
                      2 =?= BitVec.instHShiftLeft.1 (a ||| x‚úù¬π >>> 2#8 &&& 13#8) 2#8
                  [Meta.isDefEq] [0.001174] ‚úÖÔ∏è (a ||| x‚úù¬π >>> 2 &&& 13#8).shiftLeft
                        2 =?= (a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< (2#8).toNat
                    [Meta.isDefEq] [0.001134] ‚úÖÔ∏è (a ||| x‚úù¬π >>> 2 &&& 13#8).shiftLeft
                          2 =?= (a ||| x‚úù¬π >>> 2#8 &&& 13#8).shiftLeft (2#8).toNat
                      [Meta.isDefEq.delta] [0.001118] ‚úÖÔ∏è (a ||| x‚úù¬π >>> 2 &&& 13#8).shiftLeft
                            2 =?= (a ||| x‚úù¬π >>> 2#8 &&& 13#8).shiftLeft (2#8).toNat
                        [Meta.isDefEq] [0.001069] ‚úÖÔ∏è a ||| x‚úù¬π >>> 2 &&& 13#8 =?= a ||| x‚úù¬π >>> 2#8 &&& 13#8
                          [Meta.isDefEq] [0.001025] ‚úÖÔ∏è instHOrOfOrOp.1 a
                                (x‚úù¬π >>> 2 &&& 13#8) =?= instHOrOfOrOp.1 a (x‚úù¬π >>> 2#8 &&& 13#8)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨((Option.map (fun div => x‚úù + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù.getLsbD 7 = true then ~~~((~~~x‚úù + 1#8) / 42#8) + 1#8 else x‚úù / 42#8))).bind
              fun a => some ((a ||| x‚úù¬π >>> 2 &&& 13#8) <<< 2)) ‚äë
            (Option.map (fun div => x‚úù + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù.getLsbD 7 = true then ~~~((~~~x‚úù + 1#8) / 42#8) + 1#8 else x‚úù / 42#8))).bind
              fun a => some (x‚úù¬π &&& 52#8 ||| a <<< 2)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:121:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:114:8: error: (kernel) declaration has metavariables 'lshr_and_or_disjoint_thm'
[bv] [0.091331] Normalizing goal
  [Meta.synthInstance] [0.002922] ‚úÖÔ∏è Decidable
        (((Option.map (fun div => x‚úù - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù.sdiv 42#8))).bind
            fun x =>
            if 2#8 ‚â• ‚Üë8 then none else if 2#8 ‚â• ‚Üë8 then none else some ((x ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8)) ‚äë
          (Option.map (fun div => x‚úù - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù.sdiv 42#8))).bind
            fun x => if 2#8 ‚â• ‚Üë8 then none else some (x‚úù¬π &&& 52#8 ||| x <<< 2#8))
    [Meta.check] [0.001891] ‚úÖÔ∏è BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          ((Option.map (fun div => x‚úù - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù.sdiv 42#8))).bind
            fun x => if 2#8 ‚â• ‚Üë8 then none else if 2#8 ‚â• ‚Üë8 then none else some ((x ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8))
          ((Option.map (fun div => x‚úù - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù.sdiv 42#8))).bind
            fun x => if 2#8 ‚â• ‚Üë8 then none else some (x‚úù¬π &&& 52#8 ||| x <<< 2#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨((Option.map (fun div => x‚úù - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (x‚úù.sdiv 42#8))).bind
              fun x =>
              if 2#8 ‚â• ‚Üë8 then none else if 2#8 ‚â• ‚Üë8 then none else some ((x ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8)) ‚äë
            (Option.map (fun div => x‚úù - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (x‚úù.sdiv 42#8))).bind
              fun x => if 2#8 ‚â• ‚Üë8 then none else some (x‚úù¬π &&& 52#8 ||| x <<< 2#8)
      ‚ä¢ False
  [Meta.isDefEq] [0.001573] ‚úÖÔ∏è ?hf =?= fun a a_1 =>
        Eq.trans
          (ite_cond_eq_false none (if 2#8 ‚â• ‚Üë8 then none else some ((a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8))
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
                (Eq.trans (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                  Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
          (ite_cond_eq_false none (some ((a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8))
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
                (Eq.trans (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                  Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
    [Meta.isDefEq.assign] [0.001568] ‚úÖÔ∏è ?hf := fun a a_1 =>
          Eq.trans
            (ite_cond_eq_false none (if 2#8 ‚â• ‚Üë8 then none else some ((a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8))
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
                  (Eq.trans
                    (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                    Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
            (ite_cond_eq_false none (some ((a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8))
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
                  (Eq.trans
                    (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                    Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
      [Meta.isDefEq.assign.checkTypes] [0.001506] ‚úÖÔ∏è (?hf : ‚àÄ
            a ‚àà
              Option.map (fun div => x‚úù + (~~~(div * 42#8) + 1#8))
                (some (if x‚úù.getLsbD 7 = true then ~~~((~~~x‚úù + 1#8) / 42#8) + 1#8 else x‚úù / 42#8)),
            (if 2#8 ‚â• ‚Üë8 then none else if 2#8 ‚â• ‚Üë8 then none else some ((a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8)) =
              some
                ((a ||| x‚úù¬π >>> 2 &&& 13#8) <<<
                  2)) := (fun a a_1 =>
            Eq.trans
              (ite_cond_eq_false none (if 2#8 ‚â• ‚Üë8 then none else some ((a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
                    (Eq.trans
                      (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                      Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
              (ite_cond_eq_false none (some ((a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
                    (Eq.trans
                      (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                      Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))) : ‚àÄ
            a ‚àà
              Option.map (fun div => x‚úù + (~~~(div * 42#8) + 1#8))
                (some (if x‚úù.getLsbD 7 = true then ~~~((~~~x‚úù + 1#8) / 42#8) + 1#8 else x‚úù / 42#8)),
            (if 2#8 ‚â• ‚Üë8 then none else if 2#8 ‚â• ‚Üë8 then none else some ((a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8)) =
              some ((a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8))
        [Meta.isDefEq] [0.001501] ‚úÖÔ∏è ‚àÄ
              a ‚àà
                Option.map (fun div => x‚úù + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù.getLsbD 7 = true then ~~~((~~~x‚úù + 1#8) / 42#8) + 1#8 else x‚úù / 42#8)),
              (if 2#8 ‚â• ‚Üë8 then none else if 2#8 ‚â• ‚Üë8 then none else some ((a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8)) =
                some
                  ((a ||| x‚úù¬π >>> 2 &&& 13#8) <<<
                    2) =?= ‚àÄ
              a ‚àà
                Option.map (fun div => x‚úù + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù.getLsbD 7 = true then ~~~((~~~x‚úù + 1#8) / 42#8) + 1#8 else x‚úù / 42#8)),
              (if 2#8 ‚â• ‚Üë8 then none else if 2#8 ‚â• ‚Üë8 then none else some ((a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8)) =
                some ((a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8)
          [Meta.isDefEq] [0.001426] ‚úÖÔ∏è (if 2#8 ‚â• ‚Üë8 then none
                else if 2#8 ‚â• ‚Üë8 then none else some ((a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8)) =
                some
                  ((a ||| x‚úù¬π >>> 2 &&& 13#8) <<<
                    2) =?= (if 2#8 ‚â• ‚Üë8 then none
                else if 2#8 ‚â• ‚Üë8 then none else some ((a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8)) =
                some ((a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8)
            [Meta.isDefEq] [0.001389] ‚úÖÔ∏è some
                  ((a ||| x‚úù¬π >>> 2 &&& 13#8) <<< 2) =?= some ((a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8)
              [Meta.isDefEq] [0.001352] ‚úÖÔ∏è (a ||| x‚úù¬π >>> 2 &&& 13#8) <<< 2 =?= (a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< 2#8
                [Meta.isDefEq] [0.001311] ‚úÖÔ∏è BitVec.instHShiftLeftNat.1 (a ||| x‚úù¬π >>> 2 &&& 13#8)
                      2 =?= BitVec.instHShiftLeft.1 (a ||| x‚úù¬π >>> 2#8 &&& 13#8) 2#8
                  [Meta.isDefEq] [0.001209] ‚úÖÔ∏è (a ||| x‚úù¬π >>> 2 &&& 13#8).shiftLeft
                        2 =?= (a ||| x‚úù¬π >>> 2#8 &&& 13#8) <<< (2#8).toNat
                    [Meta.isDefEq] [0.001166] ‚úÖÔ∏è (a ||| x‚úù¬π >>> 2 &&& 13#8).shiftLeft
                          2 =?= (a ||| x‚úù¬π >>> 2#8 &&& 13#8).shiftLeft (2#8).toNat
                      [Meta.isDefEq.delta] [0.001150] ‚úÖÔ∏è (a ||| x‚úù¬π >>> 2 &&& 13#8).shiftLeft
                            2 =?= (a ||| x‚úù¬π >>> 2#8 &&& 13#8).shiftLeft (2#8).toNat
                        [Meta.isDefEq] [0.001098] ‚úÖÔ∏è a ||| x‚úù¬π >>> 2 &&& 13#8 =?= a ||| x‚úù¬π >>> 2#8 &&& 13#8
                          [Meta.isDefEq] [0.001054] ‚úÖÔ∏è instHOrOfOrOp.1 a
                                (x‚úù¬π >>> 2 &&& 13#8) =?= instHOrOfOrOp.1 a (x‚úù¬π >>> 2#8 &&& 13#8)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨((Option.map (fun div => x‚úù + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù.getLsbD 7 = true then ~~~((~~~x‚úù + 1#8) / 42#8) + 1#8 else x‚úù / 42#8))).bind
              fun a => some ((a ||| x‚úù¬π >>> 2 &&& 13#8) <<< 2)) ‚äë
            (Option.map (fun div => x‚úù + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù.getLsbD 7 = true then ~~~((~~~x‚úù + 1#8) / 42#8) + 1#8 else x‚úù / 42#8))).bind
              fun a => some (x‚úù¬π &&& 52#8 ||| a <<< 2)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:132:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:125:8: error: (kernel) declaration has metavariables 'ashr_and_or_disjoint_thm'
[bv] [0.052954] Normalizing goal
  [Meta.synthInstance] [0.001665] ‚úÖÔ∏è Decidable
        (((Option.map (fun div => x‚úù - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù.sdiv 42#8))).bind
            fun x =>
            if 2#8 ‚â• ‚Üë8 then none
            else if 2#8 ‚â• ‚Üë8 then none else some ((x ||| x‚úù¬π.sshiftRight (2#8).toNat &&& 13#8) <<< 2#8)) ‚äë
          (Option.map (fun div => x‚úù - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù.sdiv 42#8))).bind
            fun x => if 2#8 ‚â• ‚Üë8 then none else some (x‚úù¬π &&& 52#8 ||| x <<< 2#8))
    [Meta.check] [0.001044] ‚úÖÔ∏è BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          ((Option.map (fun div => x‚úù - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù.sdiv 42#8))).bind
            fun x =>
            if 2#8 ‚â• ‚Üë8 then none
            else if 2#8 ‚â• ‚Üë8 then none else some ((x ||| x‚úù¬π.sshiftRight (2#8).toNat &&& 13#8) <<< 2#8))
          ((Option.map (fun div => x‚úù - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù.sdiv 42#8))).bind
            fun x => if 2#8 ‚â• ‚Üë8 then none else some (x‚úù¬π &&& 52#8 ||| x <<< 2#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨((Option.map (fun div => x‚úù - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (x‚úù.sdiv 42#8))).bind
              fun x =>
              if 2#8 ‚â• ‚Üë8 then none
              else if 2#8 ‚â• ‚Üë8 then none else some ((x ||| x‚úù¬π.sshiftRight (2#8).toNat &&& 13#8) <<< 2#8)) ‚äë
            (Option.map (fun div => x‚úù - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (x‚úù.sdiv 42#8))).bind
              fun x => if 2#8 ‚â• ‚Üë8 then none else some (x‚úù¬π &&& 52#8 ||| x <<< 2#8)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨((Option.map (fun div => x‚úù + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù.getLsbD 7 = true then ~~~((~~~x‚úù + 1#8) / 42#8) + 1#8 else x‚úù / 42#8))).bind
              fun a => some ((a ||| x‚úù¬π.sshiftRight 2 &&& 13#8) <<< 2)) ‚äë
            (Option.map (fun div => x‚úù + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù.getLsbD 7 = true then ~~~((~~~x‚úù + 1#8) / 42#8) + 1#8 else x‚úù / 42#8))).bind
              fun a => some (x‚úù¬π &&& 52#8 ||| a <<< 2)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:143:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:143:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhbo_proof.lean:136:8: error: (kernel) declaration has metavariables 'lshr_and_xor_thm'
[bv] [0.055407] Normalizing goal
  [Meta.synthInstance] [0.001614] ‚úÖÔ∏è Decidable
        ((if 2#8 ‚â• ‚Üë8 then none
          else
            (Option.map (fun div => x‚úù¬π - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && x‚úù¬π == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (x‚úù¬π.sdiv 42#8))).bind
              fun x => if 2#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 2#8 &&& 13#8 ^^^ x) <<< 2#8)) ‚äë
          (Option.map (fun div => x‚úù¬π - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù¬π == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù¬π.sdiv 42#8))).bind
            fun x => if 2#8 ‚â• ‚Üë8 then none else some (x‚úù &&& 52#8 ^^^ x <<< 2#8))
    [Meta.check] [0.001081] ‚úÖÔ∏è BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if 2#8 ‚â• ‚Üë8 then none
          else
            (Option.map (fun div => x‚úù¬π - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && x‚úù¬π == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (x‚úù¬π.sdiv 42#8))).bind
              fun x => if 2#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 2#8 &&& 13#8 ^^^ x) <<< 2#8))
          ((Option.map (fun div => x‚úù¬π - div * 42#8)
                (if (42#8 == 0 || 8 != 1 && x‚úù¬π == BitVec.intMin 8 && 42#8 == -1) = true then none
                else some (x‚úù¬π.sdiv 42#8))).bind
            fun x => if 2#8 ‚â• ‚Üë8 then none else some (x‚úù &&& 52#8 ^^^ x <<< 2#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if 2#8 ‚â• ‚Üë8 then none
            else
              (Option.map (fun div => x‚úù¬π - div * 42#8)
                    (if (42#8 == 0 || 8 != 1 && x‚úù¬π == BitVec.intMin 8 && 42#8 == -1) = true then none
                    else some (x‚úù¬π.sdiv 42#8))).bind
                fun x => if 2#8 ‚â• ‚Üë8 then none else some ((x‚úù >>> 2#8 &&& 13#8 ^^^ x) <<< 2#8)) ‚äë
            (Option.map (fun div => x‚úù¬π - div * 42#8)
                  (if (42#8 == 0 || 8 != 1 && x‚úù¬π == BitVec.intMin 8 && 42#8 == -1) = true then none
                  else some (x‚úù¬π.sdiv 42#8))).bind
              fun x => if 2#8 ‚â• ‚Üë8 then none else some (x‚úù &&& 52#8 ^^^ x <<< 2#8)
      ‚ä¢ False
  [Meta.isDefEq] [0.001167] ‚úÖÔ∏è if ?b then ?x
      else
        ?y =?= if x‚úù¬π.msb = true then if (42#8).msb = true then -x‚úù¬π / -42#8 else -(-x‚úù¬π / 42#8)
      else if (42#8).msb = true then -(x‚úù¬π / -42#8) else x‚úù¬π / 42#8
    [Meta.isDefEq] [0.001045] ‚úÖÔ∏è ?Œ± =?= BitVec 8
      [Meta.isDefEq.assign] [0.001042] ‚úÖÔ∏è ?Œ± := BitVec 8
        [Meta.isDefEq.assign.checkTypes] [0.001038] ‚úÖÔ∏è (?Œ± : Sort ?u.190751) := (BitVec 8 : Type)
          [Meta.isDefEq] [0.001033] ‚úÖÔ∏è Sort ?u.190751 =?= Type
            [Meta.isLevelDefEq] [0.001028] ‚úÖÔ∏è ?u.190751 =?= 1
  [Meta.isDefEq] [0.001013] ‚úÖÔ∏è ?hf =?= fun a a_1 =>
        ite_cond_eq_false none (some ((x‚úù >>> 2#8 &&& 13#8 ^^^ a) <<< 2#8))
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
              (Eq.trans (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))
    [Meta.isDefEq.assign] [0.001008] ‚úÖÔ∏è ?hf := fun a a_1 =>
          ite_cond_eq_false none (some ((x‚úù >>> 2#8 &&& 13#8 ^^^ a) <<< 2#8))
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
                (Eq.trans (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                  Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨((Option.map (fun div => x‚úù¬π + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù¬π.getLsbD 7 = true then ~~~((~~~x‚úù¬π + 1#8) / 42#8) + 1#8 else x‚úù¬π / 42#8))).bind
              fun a => some ((x‚úù >>> 2 &&& 13#8 ^^^ a) <<< 2)) ‚äë
            (Option.map (fun div => x‚úù¬π + (~~~(div * 42#8) + 1#8))
                  (some (if x‚úù¬π.getLsbD 7 = true then ~~~((~~~x‚úù¬π + 1#8) / 42#8) + 1#8 else x‚úù¬π / 42#8))).bind
              fun a => some (x‚úù &&& 52#8 ^^^ a <<< 2)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 0.690420ms, solving context: 0.000000ms
LeanSAT proved the goal after 2.893390ms: rewriting 2.876370ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 79.358729ms, solving context: 0.000000ms
LeanSAT proved the goal after 91.119230ms: rewriting 20.555490ms, bitblasting 0.000000ms, SAT solving 55.346300ms, LRAT trimming 3.258880ms, LRAT checking 7.606350ms
Bitwuzla proved the goal after 0.620050ms, solving context: 0.000000ms
LeanSAT proved the goal after 2.724590ms: rewriting 2.709060ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 0.453100ms, solving context: 0.000000ms
LeanSAT proved the goal after 2.700580ms: rewriting 2.691670ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 0.508370ms, solving context: 0.000000ms
LeanSAT proved the goal after 2.407319ms: rewriting 2.398909ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 77.091309ms, solving context: 0.000000ms
LeanSAT proved the goal after 85.940180ms: rewriting 20.710820ms, bitblasting 0.000000ms, SAT solving 54.431430ms, LRAT trimming 2.869930ms, LRAT checking 6.335180ms
