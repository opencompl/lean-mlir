⚠ [872/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
⚠ [878/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
⚠ [884/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [887/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
⚠ [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:18:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:11:8: error: (kernel) declaration has metavariables 'reassoc_add_nuw_thm'
[bv] [0.059984] Normalizing goal
  [Meta.synthInstance] [0.001951] ✅️ Decidable
        ((if True ∧ (x✝ + 4#32 < x✝ ∨ x✝ + 4#32 < 4#32) then none
          else
            if True ∧ (x✝ + 4#32 + 64#32 < x✝ + 4#32 ∨ x✝ + 4#32 + 64#32 < 64#32) then none
            else some (x✝ + 4#32 + 64#32)) ⊑
          if True ∧ (x✝ + 68#32 < x✝ ∨ x✝ + 68#32 < 68#32) then none else some (x✝ + 68#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if True ∧ (x✝ + 4#32 < x✝ ∨ x✝ + 4#32 < 4#32) then none
            else
              if True ∧ (x✝ + 4#32 + 64#32 < x✝ + 4#32 ∨ x✝ + 4#32 + 64#32 < 64#32) then none
              else some (x✝ + 4#32 + 64#32)) ⊑
            if True ∧ (x✝ + 68#32 < x✝ ∨ x✝ + 68#32 < 68#32) then none else some (x✝ + 68#32)
      ⊢ False
  [Meta.isDefEq] [0.001510] ✅️ ?h₃ =?= fun a =>
        congrArg some (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right' x✝ 4#32 64#32)
    [Meta.isDefEq.assign] [0.001506] ✅️ ?h₃ := fun a =>
          congrArg some (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right' x✝ 4#32 64#32)
      [Meta.isDefEq.assign.checkTypes] [0.001459] ✅️ (?h₃ : ¬(!((!x✝ + 4#32 >ᵤ 68#32 + x✝) && !64#32 >ᵤ 68#32 + x✝)) =
                true →
            some (x✝ + 4#32 + 64#32) =
              some
                (68#32 +
                  x✝)) := (fun a =>
            congrArg some
              (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right' x✝ 4#32
                64#32) : ¬(!((!x✝ + 4#32 >ᵤ 68#32 + x✝) && !64#32 >ᵤ 68#32 + x✝)) = true →
            some (x✝ + 4#32 + 64#32) = some (4#32 + 64#32 + x✝))
        [Meta.isDefEq] [0.001454] ✅️ ¬(!((!x✝ + 4#32 >ᵤ 68#32 + x✝) && !64#32 >ᵤ 68#32 + x✝)) = true →
              some (x✝ + 4#32 + 64#32) =
                some
                  (68#32 +
                    x✝) =?= ¬(!((!x✝ + 4#32 >ᵤ 68#32 + x✝) && !64#32 >ᵤ 68#32 + x✝)) = true →
              some (x✝ + 4#32 + 64#32) = some (4#32 + 64#32 + x✝)
          [Meta.isDefEq] [0.001398] ✅️ some (x✝ + 4#32 + 64#32) =
                some (68#32 + x✝) =?= some (x✝ + 4#32 + 64#32) = some (4#32 + 64#32 + x✝)
            [Meta.isDefEq] [0.001363] ✅️ some (68#32 + x✝) =?= some (4#32 + 64#32 + x✝)
              [Meta.isDefEq] [0.001328] ✅️ 68#32 + x✝ =?= 4#32 + 64#32 + x✝
                [Meta.isDefEq] [0.001128] ✅️ instHAdd.1 (68#32) x✝ =?= instHAdd.1 (4#32 + 64#32) x✝
                  [Meta.isDefEq] [0.001053] ✅️ Add.add (68#32) x✝ =?= Add.add (4#32 + 64#32) x✝
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if (!((!x✝ >ᵤ x✝ + 4#32) && !4#32 >ᵤ x✝ + 4#32)) = true then none
            else if (!((!x✝ + 4#32 >ᵤ 68#32 + x✝) && !64#32 >ᵤ 68#32 + x✝)) = true then none else some (68#32 + x✝)) ⊑
            if (!((!x✝ >ᵤ x✝ + 68#32) && !68#32 >ᵤ x✝ + 68#32)) = true then none else some (x✝ + 68#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:29:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:22:8: error: (kernel) declaration has metavariables 'reassoc_sub_nuw_thm'
[bv] [0.036786] Normalizing goal
  [Meta.synthInstance] [0.001376] ✅️ Decidable
        ((if True ∧ x✝ < 4#32 then none else if True ∧ x✝ - 4#32 < 64#32 then none else some (x✝ - 4#32 - 64#32)) ⊑
          some (x✝ + 4294967228#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if True ∧ x✝ < 4#32 then none else if True ∧ x✝ - 4#32 < 64#32 then none else some (x✝ - 4#32 - 64#32)) ⊑
            some (x✝ + 4294967228#32)
      ⊢ False
  [Meta.isDefEq] [0.001839] ✅️ ?h₃ =?= fun a =>
        congrArg some
          (Eq.trans
            (Eq.trans (congrArg (fun x => x - 64#32) (BitVec.sub_toAdd x✝ 4#32))
              (BitVec.sub_toAdd (x✝ + 4294967292#32) 64#32))
            (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right' x✝ 4294967292#32 4294967232#32))
    [Meta.isDefEq.assign] [0.001834] ✅️ ?h₃ := fun a =>
          congrArg some
            (Eq.trans
              (Eq.trans (congrArg (fun x => x - 64#32) (BitVec.sub_toAdd x✝ 4#32))
                (BitVec.sub_toAdd (x✝ + 4294967292#32) 64#32))
              (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right' x✝ 4294967292#32 4294967232#32))
      [Meta.isDefEq.assign.checkTypes] [0.001764] ✅️ (?h₃ : ¬(64#32 >ᵤ x✝ + 4294967292#32) = true →
            some (x✝ - 4#32 - 64#32) =
              some
                (4294967228#32 +
                  x✝)) := (fun a =>
            congrArg some
              (Eq.trans
                (Eq.trans (congrArg (fun x => x - 64#32) (BitVec.sub_toAdd x✝ 4#32))
                  (BitVec.sub_toAdd (x✝ + 4294967292#32) 64#32))
                (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right' x✝ 4294967292#32
                  4294967232#32)) : ¬(64#32 >ᵤ x✝ + 4294967292#32) = true →
            some (x✝ - 4#32 - 64#32) = some (4294967292#32 + 4294967232#32 + x✝))
        [Meta.isDefEq] [0.001758] ✅️ ¬(64#32 >ᵤ x✝ + 4294967292#32) = true →
              some (x✝ - 4#32 - 64#32) =
                some
                  (4294967228#32 +
                    x✝) =?= ¬(64#32 >ᵤ x✝ + 4294967292#32) = true →
              some (x✝ - 4#32 - 64#32) = some (4294967292#32 + 4294967232#32 + x✝)
          [Meta.isDefEq] [0.001706] ✅️ some (x✝ - 4#32 - 64#32) =
                some (4294967228#32 + x✝) =?= some (x✝ - 4#32 - 64#32) = some (4294967292#32 + 4294967232#32 + x✝)
            [Meta.isDefEq] [0.001673] ✅️ some (4294967228#32 + x✝) =?= some (4294967292#32 + 4294967232#32 + x✝)
              [Meta.isDefEq] [0.001639] ✅️ 4294967228#32 + x✝ =?= 4294967292#32 + 4294967232#32 + x✝
                [Meta.isDefEq] [0.001467] ✅️ instHAdd.1 (4294967228#32)
                      x✝ =?= instHAdd.1 (4294967292#32 + 4294967232#32) x✝
                  [Meta.isDefEq] [0.001405] ✅️ Add.add (4294967228#32) x✝ =?= Add.add (4294967292#32 + 4294967232#32) x✝
                    [Meta.isDefEq] [0.001209] ✅️ BitVec.instAdd.1 (4294967228#32)
                          x✝ =?= BitVec.instAdd.1 (4294967292#32 + 4294967232#32) x✝
                      [Meta.isDefEq] [0.001161] ✅️ (4294967228#32).add x✝ =?= (4294967292#32 + 4294967232#32).add x✝
                        [Meta.isDefEq.delta] [0.001145] ✅️ (4294967228#32).add
                              x✝ =?= (4294967292#32 + 4294967232#32).add x✝
                          [Meta.isDefEq] [0.001106] ✅️ 4294967228#32 =?= 4294967292#32 + 4294967232#32
                            [Meta.isDefEq] [0.001041] ✅️ {
                                  toFin := Fin.ofNat' (2 ^ 32) 4294967228 } =?= 4294967292#32 + 4294967232#32
                              [Meta.isDefEq] [0.001019] ✅️ {
                                    toFin := Fin.ofNat' (2 ^ 32) 4294967228 } =?= instHAdd.1 4294967292#32 4294967232#32
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if (4#32 >ᵤ x✝) = true then none
            else if (64#32 >ᵤ x✝ + 4294967292#32) = true then none else some (4294967228#32 + x✝)) ⊑
            some (x✝ + 4294967228#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:40:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:33:8: error: (kernel) declaration has metavariables 'reassoc_mul_nuw_thm'
[bv] [0.057023] Normalizing goal
  [Meta.synthInstance] [0.001432] ✅️ Decidable
        ((if
              True ∧
                BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 4#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
            none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 32) (x✝ * 4#32) * BitVec.zeroExtend (2 * 32) 65#32 ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else some (x✝ * 4#32 * 65#32)) ⊑
          if
              True ∧
                BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 260#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
            none
          else some (x✝ * 260#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if
                True ∧
                  BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 4#32 ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 32) (x✝ * 4#32) * BitVec.zeroExtend (2 * 32) 65#32 ≥
                      BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                none
              else some (x✝ * 4#32 * 65#32)) ⊑
            if
                True ∧
                  BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 260#32 ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else some (x✝ * 260#32)
      ⊢ False
  [Meta.isDefEq] [0.001097] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1) (BitVec.zeroExtend 64 x✝ * 4#64))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 x✝ * 4#64)
                      (BitVec.twoPow 64 31 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 4#64) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 4#64)))))))
        (true_and ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 4#64) = true))
    [Meta.isDefEq.assign] [0.001095] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                  (BitVec.zeroExtend 64 x✝ * 4#64))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 x✝ * 4#64)
                        (BitVec.twoPow 64 31 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 4#64) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 4#64)))))))
          (true_and ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 4#64) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001081] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 4#32 ≥ BitVec.twoPow (2 * 32) (32 - 1) <<< 1) =
            ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 4#64) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                    (BitVec.zeroExtend 64 x✝ * 4#64))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 x✝ * 4#64)
                          (BitVec.twoPow 64 31 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 4#64) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 4#64)))))))
            (true_and
              ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 4#64) =
                true)) : (True ∧ BitVec.zeroExtend 64 x✝ * 4#64 ≥ BitVec.twoPow 64 31 <<< 1) =
            ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 4#64) = true))
        [Meta.isDefEq] [0.001078] ✅️ (True ∧
                BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 4#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1) =
              ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 4#64) =
                true) =?= (True ∧ BitVec.zeroExtend 64 x✝ * 4#64 ≥ BitVec.twoPow 64 31 <<< 1) =
              ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 4#64) = true)
          [Meta.isDefEq] [0.001057] ✅️ True ∧
                BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 4#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 64 x✝ * 4#64 ≥ BitVec.twoPow 64 31 <<< 1
            [Meta.isDefEq] [0.001042] ✅️ BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 4#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1 =?= BitVec.zeroExtend 64 x✝ * 4#64 ≥ BitVec.twoPow 64 31 <<< 1
              [Meta.isDefEq.delta] [0.001021] ✅️ BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 4#32 ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 =?= BitVec.zeroExtend 64 x✝ * 4#64 ≥ BitVec.twoPow 64 31 <<< 1
  [Meta.synthInstance] [0.004600] ✅️ Decidable ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 4#64) = true)
    [Meta.check] [0.004437] ✅️ instDecidableEqBool (!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 4#64) true
  [Meta.isDefEq] [0.001277] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                (BitVec.zeroExtend 64 x✝ * 260#64))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 x✝ * 260#64)
                      (BitVec.twoPow 64 31 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 260#64) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 260#64)))))))
        (true_and ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 260#64) = true))
    [Meta.isDefEq.assign] [0.001273] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                  (BitVec.zeroExtend 64 x✝ * 260#64))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 x✝ * 260#64)
                        (BitVec.twoPow 64 31 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 260#64) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 260#64)))))))
          (true_and ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 260#64) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001253] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 260#32 ≥
                BitVec.twoPow (2 * 32) (32 - 1) <<< 1) =
            ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 260#64) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                    (BitVec.zeroExtend 64 x✝ * 260#64))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 x✝ * 260#64)
                          (BitVec.twoPow 64 31 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 260#64) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 260#64)))))))
            (true_and
              ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 260#64) =
                true)) : (True ∧ BitVec.zeroExtend 64 x✝ * 260#64 ≥ BitVec.twoPow 64 31 <<< 1) =
            ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 260#64) = true))
        [Meta.isDefEq] [0.001248] ✅️ (True ∧
                BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 260#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1) =
              ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 260#64) =
                true) =?= (True ∧ BitVec.zeroExtend 64 x✝ * 260#64 ≥ BitVec.twoPow 64 31 <<< 1) =
              ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 260#64) = true)
          [Meta.isDefEq] [0.001216] ✅️ True ∧
                BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 260#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 64 x✝ * 260#64 ≥ BitVec.twoPow 64 31 <<< 1
            [Meta.isDefEq] [0.001199] ✅️ BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 260#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1 =?= BitVec.zeroExtend 64 x✝ * 260#64 ≥ BitVec.twoPow 64 31 <<< 1
              [Meta.isDefEq.delta] [0.001168] ✅️ BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 260#32 ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<<
                      1 =?= BitVec.zeroExtend 64 x✝ * 260#64 ≥ BitVec.twoPow 64 31 <<< 1
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if (!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 4#64) = true then none
            else
              if (!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 (x✝ * 4#32) * 65#64) = true then none
              else some (x✝ * 4#32 * 65#32)) ⊑
            if (!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 260#64) = true then none else some (x✝ * 260#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:50:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:44:8: error: (kernel) declaration has metavariables 'no_reassoc_add_nuw_none_thm'
[bv] [0.030115] Normalizing goal
  [Meta.synthInstance] [0.001568] ✅️ Decidable
        ((if True ∧ (x✝ + 4#32 + 64#32 < x✝ + 4#32 ∨ x✝ + 4#32 + 64#32 < 64#32) then none
          else some (x✝ + 4#32 + 64#32)) ⊑
          some (x✝ + 68#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if True ∧ (x✝ + 4#32 + 64#32 < x✝ + 4#32 ∨ x✝ + 4#32 + 64#32 < 64#32) then none
            else some (x✝ + 4#32 + 64#32)) ⊑
            some (x✝ + 68#32)
      ⊢ False
  [Meta.isDefEq] [0.001778] ✅️ ?h₃ =?= fun a =>
        congrArg some (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right' x✝ 4#32 64#32)
    [Meta.isDefEq.assign] [0.001774] ✅️ ?h₃ := fun a =>
          congrArg some (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right' x✝ 4#32 64#32)
      [Meta.isDefEq.assign.checkTypes] [0.001729] ✅️ (?h₃ : ¬(!((!x✝ + 4#32 >ᵤ 68#32 + x✝) && !64#32 >ᵤ 68#32 + x✝)) =
                true →
            some (x✝ + 4#32 + 64#32) =
              some
                (68#32 +
                  x✝)) := (fun a =>
            congrArg some
              (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right' x✝ 4#32
                64#32) : ¬(!((!x✝ + 4#32 >ᵤ 68#32 + x✝) && !64#32 >ᵤ 68#32 + x✝)) = true →
            some (x✝ + 4#32 + 64#32) = some (4#32 + 64#32 + x✝))
        [Meta.isDefEq] [0.001723] ✅️ ¬(!((!x✝ + 4#32 >ᵤ 68#32 + x✝) && !64#32 >ᵤ 68#32 + x✝)) = true →
              some (x✝ + 4#32 + 64#32) =
                some
                  (68#32 +
                    x✝) =?= ¬(!((!x✝ + 4#32 >ᵤ 68#32 + x✝) && !64#32 >ᵤ 68#32 + x✝)) = true →
              some (x✝ + 4#32 + 64#32) = some (4#32 + 64#32 + x✝)
          [Meta.isDefEq] [0.001669] ✅️ some (x✝ + 4#32 + 64#32) =
                some (68#32 + x✝) =?= some (x✝ + 4#32 + 64#32) = some (4#32 + 64#32 + x✝)
            [Meta.isDefEq] [0.001634] ✅️ some (68#32 + x✝) =?= some (4#32 + 64#32 + x✝)
              [Meta.isDefEq] [0.001601] ✅️ 68#32 + x✝ =?= 4#32 + 64#32 + x✝
                [Meta.isDefEq] [0.001398] ✅️ instHAdd.1 (68#32) x✝ =?= instHAdd.1 (4#32 + 64#32) x✝
                  [Meta.isDefEq] [0.001330] ✅️ Add.add (68#32) x✝ =?= Add.add (4#32 + 64#32) x✝
                    [Meta.isDefEq] [0.001122] ✅️ BitVec.instAdd.1 (68#32) x✝ =?= BitVec.instAdd.1 (4#32 + 64#32) x✝
                      [Meta.isDefEq] [0.001070] ✅️ (68#32).add x✝ =?= (4#32 + 64#32).add x✝
                        [Meta.isDefEq.delta] [0.001028] ✅️ (68#32).add x✝ =?= (4#32 + 64#32).add x✝
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if (!((!x✝ + 4#32 >ᵤ 68#32 + x✝) && !64#32 >ᵤ 68#32 + x✝)) = true then none else some (68#32 + x✝)) ⊑
            some (x✝ + 68#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:60:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:54:8: error: (kernel) declaration has metavariables 'no_reassoc_add_none_nuw_thm'
[bv] [0.028626] Normalizing goal
  [Meta.synthInstance] [0.001494] ✅️ Decidable
        ((if True ∧ (x✝ + 4#32 < x✝ ∨ x✝ + 4#32 < 4#32) then none else some (x✝ + 4#32 + 64#32)) ⊑ some (x✝ + 68#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ : ¬(if True ∧ (x✝ + 4#32 < x✝ ∨ x✝ + 4#32 < 4#32) then none else some (x✝ + 4#32 + 64#32)) ⊑ some (x✝ + 68#32)
      ⊢ False
  [Meta.isDefEq] [0.001721] ✅️ ?h₃ =?= fun a =>
        congrArg some (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right' x✝ 4#32 64#32)
    [Meta.isDefEq.assign] [0.001716] ✅️ ?h₃ := fun a =>
          congrArg some (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right' x✝ 4#32 64#32)
      [Meta.isDefEq.assign.checkTypes] [0.001674] ✅️ (?h₃ : ¬(!((!x✝ >ᵤ x✝ + 4#32) && !4#32 >ᵤ x✝ + 4#32)) = true →
            some (x✝ + 4#32 + 64#32) =
              some
                (68#32 +
                  x✝)) := (fun a =>
            congrArg some
              (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right' x✝ 4#32
                64#32) : ¬(!((!x✝ >ᵤ x✝ + 4#32) && !4#32 >ᵤ x✝ + 4#32)) = true →
            some (x✝ + 4#32 + 64#32) = some (4#32 + 64#32 + x✝))
        [Meta.isDefEq] [0.001669] ✅️ ¬(!((!x✝ >ᵤ x✝ + 4#32) && !4#32 >ᵤ x✝ + 4#32)) = true →
              some (x✝ + 4#32 + 64#32) =
                some
                  (68#32 +
                    x✝) =?= ¬(!((!x✝ >ᵤ x✝ + 4#32) && !4#32 >ᵤ x✝ + 4#32)) = true →
              some (x✝ + 4#32 + 64#32) = some (4#32 + 64#32 + x✝)
          [Meta.isDefEq] [0.001627] ✅️ some (x✝ + 4#32 + 64#32) =
                some (68#32 + x✝) =?= some (x✝ + 4#32 + 64#32) = some (4#32 + 64#32 + x✝)
            [Meta.isDefEq] [0.001574] ✅️ some (68#32 + x✝) =?= some (4#32 + 64#32 + x✝)
              [Meta.isDefEq] [0.001544] ✅️ 68#32 + x✝ =?= 4#32 + 64#32 + x✝
                [Meta.isDefEq] [0.001384] ✅️ instHAdd.1 (68#32) x✝ =?= instHAdd.1 (4#32 + 64#32) x✝
                  [Meta.isDefEq] [0.001318] ✅️ Add.add (68#32) x✝ =?= Add.add (4#32 + 64#32) x✝
                    [Meta.isDefEq] [0.001117] ✅️ BitVec.instAdd.1 (68#32) x✝ =?= BitVec.instAdd.1 (4#32 + 64#32) x✝
                      [Meta.isDefEq] [0.001063] ✅️ (68#32).add x✝ =?= (4#32 + 64#32).add x✝
                        [Meta.isDefEq.delta] [0.001043] ✅️ (68#32).add x✝ =?= (4#32 + 64#32).add x✝
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if (!((!x✝ >ᵤ x✝ + 4#32) && !4#32 >ᵤ x✝ + 4#32)) = true then none else some (68#32 + x✝)) ⊑ some (x✝ + 68#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:72:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:72:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:64:8: error: (kernel) declaration has metavariables 'reassoc_x2_add_nuw_thm'
[bv] [0.050184] Normalizing goal
  [Meta.synthInstance] [0.001294] ✅️ Decidable
        ((if True ∧ (x✝ + 4#32 < x✝ ∨ x✝ + 4#32 < 4#32) then none
          else
            if True ∧ (x✝¹ + 8#32 < x✝¹ ∨ x✝¹ + 8#32 < 8#32) then none
            else
              if True ∧ (x✝ + 4#32 + (x✝¹ + 8#32) < x✝ + 4#32 ∨ x✝ + 4#32 + (x✝¹ + 8#32) < x✝¹ + 8#32) then none
              else some (x✝ + 4#32 + (x✝¹ + 8#32))) ⊑
          if True ∧ (x✝ + x✝¹ < x✝ ∨ x✝ + x✝¹ < x✝¹) then none
          else
            if True ∧ (x✝ + x✝¹ + 12#32 < x✝ + x✝¹ ∨ x✝ + x✝¹ + 12#32 < 12#32) then none else some (x✝ + x✝¹ + 12#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if True ∧ (x✝ + 4#32 < x✝ ∨ x✝ + 4#32 < 4#32) then none
            else
              if True ∧ (x✝¹ + 8#32 < x✝¹ ∨ x✝¹ + 8#32 < 8#32) then none
              else
                if True ∧ (x✝ + 4#32 + (x✝¹ + 8#32) < x✝ + 4#32 ∨ x✝ + 4#32 + (x✝¹ + 8#32) < x✝¹ + 8#32) then none
                else some (x✝ + 4#32 + (x✝¹ + 8#32))) ⊑
            if True ∧ (x✝ + x✝¹ < x✝ ∨ x✝ + x✝¹ < x✝¹) then none
            else
              if True ∧ (x✝ + x✝¹ + 12#32 < x✝ + x✝¹ ∨ x✝ + x✝¹ + 12#32 < 12#32) then none else some (x✝ + x✝¹ + 12#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!((!x✝ >ᵤ x✝ + 4#32) && !4#32 >ᵤ x✝ + 4#32)) = true then none
            else
              if (!((!x✝¹ >ᵤ x✝¹ + 8#32) && !8#32 >ᵤ x✝¹ + 8#32)) = true then none
              else
                if (!((!x✝ + 4#32 >ᵤ x✝ + 4#32 + (x✝¹ + 8#32)) && !x✝¹ + 8#32 >ᵤ x✝ + 4#32 + (x✝¹ + 8#32))) = true then
                  none
                else some (x✝ + 4#32 + (x✝¹ + 8#32))) ⊑
            if (!((!x✝ >ᵤ x✝ + x✝¹) && !x✝¹ >ᵤ x✝ + x✝¹)) = true then none
            else
              if (!((!x✝ + x✝¹ >ᵤ x✝ + x✝¹ + 12#32) && !12#32 >ᵤ x✝ + x✝¹ + 12#32)) = true then none
              else some (x✝ + x✝¹ + 12#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:84:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:84:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:76:8: error: (kernel) declaration has metavariables 'reassoc_x2_mul_nuw_thm'
[bv] [0.055548] Normalizing goal
  [Meta.synthInstance] [0.001503] ✅️ Decidable
        ((if
              True ∧
                BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 5#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
            none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 32) x✝¹ * BitVec.zeroExtend (2 * 32) 9#32 ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 32) (x✝ * 5#32) * BitVec.zeroExtend (2 * 32) (x✝¹ * 9#32) ≥
                      BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                none
              else some (x✝ * 5#32 * (x✝¹ * 9#32))) ⊑
          if
              True ∧
                BitVec.zeroExtend (2 * 32) (x✝ * x✝¹) * BitVec.zeroExtend (2 * 32) 45#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
            none
          else some (x✝ * x✝¹ * 45#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if
                True ∧
                  BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 5#32 ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 32) x✝¹ * BitVec.zeroExtend (2 * 32) 9#32 ≥
                      BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                none
              else
                if
                    True ∧
                      BitVec.zeroExtend (2 * 32) (x✝ * 5#32) * BitVec.zeroExtend (2 * 32) (x✝¹ * 9#32) ≥
                        BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                  none
                else some (x✝ * 5#32 * (x✝¹ * 9#32))) ⊑
            if
                True ∧
                  BitVec.zeroExtend (2 * 32) (x✝ * x✝¹) * BitVec.zeroExtend (2 * 32) 45#32 ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else some (x✝ * x✝¹ * 45#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 5#64) = true then none
            else
              if (!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 9#64) = true then none
              else
                if
                    (!BitVec.twoPow 64 31 <<< 1 >ᵤ
                          BitVec.zeroExtend 64 (x✝ * 5#32) * BitVec.zeroExtend 64 (x✝¹ * 9#32)) =
                      true then
                  none
                else some (x✝ * 5#32 * (x✝¹ * 9#32))) ⊑
            if (!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 (x✝ * x✝¹) * 45#64) = true then none
            else some (x✝ * x✝¹ * 45#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:96:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:96:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:88:8: error: (kernel) declaration has metavariables 'reassoc_x2_sub_nuw_thm'
[bv] [0.040233] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if True ∧ x✝ < 4#32 then none
            else
              if True ∧ x✝¹ < 8#32 then none
              else if True ∧ x✝ - 4#32 < x✝¹ - 8#32 then none else some (x✝ - 4#32 - (x✝¹ - 8#32))) ⊑
            some (x✝ - x✝¹ + 4#32)
      ⊢ False
  [Meta.isDefEq] [0.002078] ❌️ ?a = ?a =?= (x✝¹ + 4294967288#32 >ᵤ x✝ + 4294967292#32) = true
    [Meta.isDefEq] [0.001988] ✅️ ?a =?= x✝¹ + 4294967288#32 >ᵤ x✝ + 4294967292#32
      [Meta.isDefEq.assign] [0.001985] ✅️ ?a := x✝¹ + 4294967288#32 >ᵤ x✝ + 4294967292#32
        [Meta.isDefEq.assign.checkTypes] [0.001975] ✅️ (?a : Bool) := (x✝¹ + 4294967288#32 >ᵤ x✝ + 4294967292#32 : Bool)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (4#32 >ᵤ x✝) = true then none
            else
              if (8#32 >ᵤ x✝¹) = true then none
              else
                if (x✝¹ + 4294967288#32 >ᵤ x✝ + 4294967292#32) = true then none
                else some (x✝ + 4294967292#32 + (~~~(x✝¹ + 4294967288#32) + 1#32))) ⊑
            some (x✝ + (~~~x✝¹ + 1#32) + 4#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:107:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:100:8: error: (kernel) declaration has metavariables 'tryFactorization_add_nuw_mul_nuw_thm'
[bv] [0.044198] Normalizing goal
  [Meta.synthInstance] [0.001769] ✅️ Decidable
        ((if
              True ∧
                BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 3#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
            none
          else if True ∧ (x✝ * 3#32 + x✝ < x✝ * 3#32 ∨ x✝ * 3#32 + x✝ < x✝) then none else some (x✝ * 3#32 + x✝)) ⊑
          if True ∧ x✝ <<< 2#32 >>> 2#32 = x✝ then none else if 2#32 ≥ ↑32 then none else some (x✝ <<< 2#32))
    [Meta.check] [0.001145] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if
              True ∧
                BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 3#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
            none
          else if True ∧ (x✝ * 3#32 + x✝ < x✝ * 3#32 ∨ x✝ * 3#32 + x✝ < x✝) then none else some (x✝ * 3#32 + x✝))
          (if True ∧ x✝ <<< 2#32 >>> 2#32 = x✝ then none else if 2#32 ≥ ↑32 then none else some (x✝ <<< 2#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if
                True ∧
                  BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 3#32 ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else if True ∧ (x✝ * 3#32 + x✝ < x✝ * 3#32 ∨ x✝ * 3#32 + x✝ < x✝) then none else some (x✝ * 3#32 + x✝)) ⊑
            if True ∧ x✝ <<< 2#32 >>> 2#32 = x✝ then none else if 2#32 ≥ ↑32 then none else some (x✝ <<< 2#32)
      ⊢ False
  [Meta.isDefEq] [0.001777] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1) (BitVec.zeroExtend 64 x✝ * 3#64))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 x✝ * 3#64)
                      (BitVec.twoPow 64 31 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 3#64) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 3#64)))))))
        (true_and ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 3#64) = true))
    [Meta.isDefEq.assign] [0.001775] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                  (BitVec.zeroExtend 64 x✝ * 3#64))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 x✝ * 3#64)
                        (BitVec.twoPow 64 31 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 3#64) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 3#64)))))))
          (true_and ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 3#64) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001761] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 3#32 ≥ BitVec.twoPow (2 * 32) (32 - 1) <<< 1) =
            ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 3#64) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                    (BitVec.zeroExtend 64 x✝ * 3#64))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 x✝ * 3#64)
                          (BitVec.twoPow 64 31 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 3#64) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 3#64)))))))
            (true_and
              ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 3#64) =
                true)) : (True ∧ BitVec.zeroExtend 64 x✝ * 3#64 ≥ BitVec.twoPow 64 31 <<< 1) =
            ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 3#64) = true))
        [Meta.isDefEq] [0.001756] ✅️ (True ∧
                BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 3#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1) =
              ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 3#64) =
                true) =?= (True ∧ BitVec.zeroExtend 64 x✝ * 3#64 ≥ BitVec.twoPow 64 31 <<< 1) =
              ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 3#64) = true)
          [Meta.isDefEq] [0.001734] ✅️ True ∧
                BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 3#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 64 x✝ * 3#64 ≥ BitVec.twoPow 64 31 <<< 1
            [Meta.isDefEq] [0.001718] ✅️ BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 3#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1 =?= BitVec.zeroExtend 64 x✝ * 3#64 ≥ BitVec.twoPow 64 31 <<< 1
              [Meta.isDefEq.delta] [0.001693] ✅️ BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 3#32 ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 =?= BitVec.zeroExtend 64 x✝ * 3#64 ≥ BitVec.twoPow 64 31 <<< 1
                [Meta.isDefEq] [0.001128] ✅️ BitVec.zeroExtend (2 * 32) x✝ *
                      BitVec.zeroExtend (2 * 32) 3#32 =?= BitVec.zeroExtend 64 x✝ * 3#64
                  [Meta.isDefEq] [0.001102] ✅️ instHMul.1 (BitVec.zeroExtend (2 * 32) x✝)
                        (BitVec.zeroExtend (2 * 32) 3#32) =?= instHMul.1 (BitVec.zeroExtend 64 x✝) 3#64
                    [Meta.isDefEq] [0.001033] ✅️ Mul.mul (BitVec.zeroExtend (2 * 32) x✝)
                          (BitVec.zeroExtend (2 * 32) 3#32) =?= Mul.mul (BitVec.zeroExtend 64 x✝) 3#64
                      [Meta.isDefEq] [0.001008] ✅️ BitVec.instMul.1 (BitVec.zeroExtend (2 * 32) x✝)
                            (BitVec.zeroExtend (2 * 32) 3#32) =?= BitVec.instMul.1 (BitVec.zeroExtend 64 x✝) 3#64
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if (!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 3#64) = true then none
            else
              if (!((!x✝ * 3#32 >ᵤ x✝ * 3#32 + x✝) && !x✝ >ᵤ x✝ * 3#32 + x✝)) = true then none
              else some (x✝ * 3#32 + x✝)) ⊑
            if (x✝ <<< 2 >>> 2 == x✝) = true then none else some (x✝ <<< 2)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:118:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:111:8: error: (kernel) declaration has metavariables 'tryFactorization_add_nuw_mul_nuw_int_max_thm'
[bv] [0.042988] Normalizing goal
  [Meta.synthInstance] [0.001762] ✅️ Decidable
        ((if
              True ∧
                BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 2147483647#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
            none
          else
            if True ∧ (x✝ * 2147483647#32 + x✝ < x✝ * 2147483647#32 ∨ x✝ * 2147483647#32 + x✝ < x✝) then none
            else some (x✝ * 2147483647#32 + x✝)) ⊑
          if True ∧ x✝ <<< 31#32 >>> 31#32 = x✝ then none else if 31#32 ≥ ↑32 then none else some (x✝ <<< 31#32))
    [Meta.check] [0.001112] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if
              True ∧
                BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 2147483647#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
            none
          else
            if True ∧ (x✝ * 2147483647#32 + x✝ < x✝ * 2147483647#32 ∨ x✝ * 2147483647#32 + x✝ < x✝) then none
            else some (x✝ * 2147483647#32 + x✝))
          (if True ∧ x✝ <<< 31#32 >>> 31#32 = x✝ then none else if 31#32 ≥ ↑32 then none else some (x✝ <<< 31#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if
                True ∧
                  BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 2147483647#32 ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else
              if True ∧ (x✝ * 2147483647#32 + x✝ < x✝ * 2147483647#32 ∨ x✝ * 2147483647#32 + x✝ < x✝) then none
              else some (x✝ * 2147483647#32 + x✝)) ⊑
            if True ∧ x✝ <<< 31#32 >>> 31#32 = x✝ then none else if 31#32 ≥ ↑32 then none else some (x✝ <<< 31#32)
      ⊢ False
  [Meta.isDefEq] [0.001348] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                (BitVec.zeroExtend 64 x✝ * 2147483647#64))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 x✝ * 2147483647#64)
                      (BitVec.twoPow 64 31 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 2147483647#64) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 2147483647#64)))))))
        (true_and ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 2147483647#64) = true))
    [Meta.isDefEq.assign] [0.001346] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                  (BitVec.zeroExtend 64 x✝ * 2147483647#64))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 x✝ * 2147483647#64)
                        (BitVec.twoPow 64 31 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 2147483647#64) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 2147483647#64)))))))
          (true_and ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 2147483647#64) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001333] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 2147483647#32 ≥
                BitVec.twoPow (2 * 32) (32 - 1) <<< 1) =
            ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 2147483647#64) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                    (BitVec.zeroExtend 64 x✝ * 2147483647#64))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 x✝ * 2147483647#64)
                          (BitVec.twoPow 64 31 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 2147483647#64) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 2147483647#64)))))))
            (true_and
              ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 2147483647#64) =
                true)) : (True ∧ BitVec.zeroExtend 64 x✝ * 2147483647#64 ≥ BitVec.twoPow 64 31 <<< 1) =
            ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 2147483647#64) = true))
        [Meta.isDefEq] [0.001329] ✅️ (True ∧
                BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 2147483647#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1) =
              ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 2147483647#64) =
                true) =?= (True ∧ BitVec.zeroExtend 64 x✝ * 2147483647#64 ≥ BitVec.twoPow 64 31 <<< 1) =
              ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 2147483647#64) = true)
          [Meta.isDefEq] [0.001310] ✅️ True ∧
                BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 2147483647#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 64 x✝ * 2147483647#64 ≥ BitVec.twoPow 64 31 <<< 1
            [Meta.isDefEq] [0.001294] ✅️ BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 2147483647#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<<
                    1 =?= BitVec.zeroExtend 64 x✝ * 2147483647#64 ≥ BitVec.twoPow 64 31 <<< 1
              [Meta.isDefEq.delta] [0.001272] ✅️ BitVec.zeroExtend (2 * 32) x✝ *
                      BitVec.zeroExtend (2 * 32) 2147483647#32 ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<<
                      1 =?= BitVec.zeroExtend 64 x✝ * 2147483647#64 ≥ BitVec.twoPow 64 31 <<< 1
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if (!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 2147483647#64) = true then none
            else
              if (!((!x✝ * 2147483647#32 >ᵤ x✝ * 2147483647#32 + x✝) && !x✝ >ᵤ x✝ * 2147483647#32 + x✝)) = true then
                none
              else some (x✝ * 2147483647#32 + x✝)) ⊑
            if (x✝ <<< 31 >>> 31 == x✝) = true then none else some (x✝ <<< 31)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:128:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:122:8: error: (kernel) declaration has metavariables 'tryFactorization_add_mul_nuw_thm'
[bv] [0.019001] Normalizing goal
  [Meta.synthInstance] [0.001211] ✅️ Decidable
        ((if True ∧ (x✝ * 3#32 + x✝ < x✝ * 3#32 ∨ x✝ * 3#32 + x✝ < x✝) then none else some (x✝ * 3#32 + x✝)) ⊑
          if 2#32 ≥ ↑32 then none else some (x✝ <<< 2#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if True ∧ (x✝ * 3#32 + x✝ < x✝ * 3#32 ∨ x✝ * 3#32 + x✝ < x✝) then none else some (x✝ * 3#32 + x✝)) ⊑
            if 2#32 ≥ ↑32 then none else some (x✝ <<< 2#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if (!((!x✝ * 3#32 >ᵤ x✝ * 3#32 + x✝) && !x✝ >ᵤ x✝ * 3#32 + x✝)) = true then none else some (x✝ * 3#32 + x✝)) ⊑
            some (x✝ <<< 2)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:138:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:132:8: error: (kernel) declaration has metavariables 'tryFactorization_add_nuw_mul_thm'
[bv] [0.026323] Normalizing goal
  [Meta.synthInstance] [0.001476] ✅️ Decidable
        ((if
              True ∧
                BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 3#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
            none
          else some (x✝ * 3#32 + x✝)) ⊑
          if 2#32 ≥ ↑32 then none else some (x✝ <<< 2#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if
                True ∧
                  BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 3#32 ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else some (x✝ * 3#32 + x✝)) ⊑
            if 2#32 ≥ ↑32 then none else some (x✝ <<< 2#32)
      ⊢ False
  [Meta.isDefEq] [0.001365] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1) (BitVec.zeroExtend 64 x✝ * 3#64))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 x✝ * 3#64)
                      (BitVec.twoPow 64 31 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 3#64) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 3#64)))))))
        (true_and ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 3#64) = true))
    [Meta.isDefEq.assign] [0.001362] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                  (BitVec.zeroExtend 64 x✝ * 3#64))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 x✝ * 3#64)
                        (BitVec.twoPow 64 31 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 3#64) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 3#64)))))))
          (true_and ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 3#64) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001348] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 3#32 ≥ BitVec.twoPow (2 * 32) (32 - 1) <<< 1) =
            ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 3#64) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                    (BitVec.zeroExtend 64 x✝ * 3#64))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 x✝ * 3#64)
                          (BitVec.twoPow 64 31 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 3#64) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 3#64)))))))
            (true_and
              ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 3#64) =
                true)) : (True ∧ BitVec.zeroExtend 64 x✝ * 3#64 ≥ BitVec.twoPow 64 31 <<< 1) =
            ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 3#64) = true))
        [Meta.isDefEq] [0.001345] ✅️ (True ∧
                BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 3#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1) =
              ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 3#64) =
                true) =?= (True ∧ BitVec.zeroExtend 64 x✝ * 3#64 ≥ BitVec.twoPow 64 31 <<< 1) =
              ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 3#64) = true)
          [Meta.isDefEq] [0.001324] ✅️ True ∧
                BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 3#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 64 x✝ * 3#64 ≥ BitVec.twoPow 64 31 <<< 1
            [Meta.isDefEq] [0.001309] ✅️ BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 3#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1 =?= BitVec.zeroExtend 64 x✝ * 3#64 ≥ BitVec.twoPow 64 31 <<< 1
              [Meta.isDefEq.delta] [0.001289] ✅️ BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 3#32 ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 =?= BitVec.zeroExtend 64 x✝ * 3#64 ≥ BitVec.twoPow 64 31 <<< 1
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if (!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 3#64) = true then none
            else some (x✝ * 3#32 + x✝)) ⊑
            some (x✝ <<< 2)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:150:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:150:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:142:8: error: (kernel) declaration has metavariables 'tryFactorization_add_nuw_mul_nuw_mul_nuw_var_thm'
[bv] [0.052821] Normalizing goal
  [Meta.synthInstance] [0.001421] ✅️ Decidable
        ((if
              True ∧
                BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) x✝¹ ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
            none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) x✝² ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else
              if True ∧ (x✝ * x✝¹ + x✝ * x✝² < x✝ * x✝¹ ∨ x✝ * x✝¹ + x✝ * x✝² < x✝ * x✝²) then none
              else some (x✝ * x✝¹ + x✝ * x✝²)) ⊑
          if
              True ∧
                BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) (x✝¹ + x✝²) ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
            none
          else some (x✝ * (x✝¹ + x✝²)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if
                True ∧
                  BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) x✝¹ ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) x✝² ≥
                      BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                none
              else
                if True ∧ (x✝ * x✝¹ + x✝ * x✝² < x✝ * x✝¹ ∨ x✝ * x✝¹ + x✝ * x✝² < x✝ * x✝²) then none
                else some (x✝ * x✝¹ + x✝ * x✝²)) ⊑
            if
                True ∧
                  BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) (x✝¹ + x✝²) ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else some (x✝ * (x✝¹ + x✝²))
      ⊢ False
  [Meta.isDefEq] [0.001780] ✅️ ?c =?= (!((!x✝ * x✝¹ >ᵤ x✝ * x✝¹ + x✝ * x✝²) && !x✝ * x✝² >ᵤ x✝ * x✝¹ + x✝ * x✝²)) = true
    [Meta.isDefEq.assign] [0.001777] ✅️ ?c := (!((!x✝ * x✝¹ >ᵤ x✝ * x✝¹ + x✝ * x✝²) &&
              !x✝ * x✝² >ᵤ x✝ * x✝¹ + x✝ * x✝²)) =
          true
      [Meta.isDefEq.assign.checkTypes] [0.001769] ✅️ (?c : Prop) := ((!((!x✝ * x✝¹ >ᵤ x✝ * x✝¹ + x✝ * x✝²) &&
                !x✝ * x✝² >ᵤ x✝ * x✝¹ + x✝ * x✝²)) =
            true : Prop)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * BitVec.zeroExtend 64 x✝¹) = true then none
            else
              if (!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * BitVec.zeroExtend 64 x✝²) = true then none
              else
                if (!((!x✝ * x✝¹ >ᵤ x✝ * x✝¹ + x✝ * x✝²) && !x✝ * x✝² >ᵤ x✝ * x✝¹ + x✝ * x✝²)) = true then none
                else some (x✝ * x✝¹ + x✝ * x✝²)) ⊑
            if (!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * BitVec.zeroExtend 64 (x✝¹ + x✝²)) = true then
              none
            else some (x✝ * (x✝¹ + x✝²))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:161:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:154:8: error: (kernel) declaration has metavariables 'tryFactorization_add_nuw_mul_mul_nuw_var_thm'
[bv] [0.045633] Normalizing goal
  [Meta.synthInstance] [0.002107] ✅️ Decidable
        ((if
              True ∧
                BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) x✝² ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
            none
          else
            if True ∧ (x✝ * x✝¹ + x✝ * x✝² < x✝ * x✝¹ ∨ x✝ * x✝¹ + x✝ * x✝² < x✝ * x✝²) then none
            else some (x✝ * x✝¹ + x✝ * x✝²)) ⊑
          some (x✝ * (x✝¹ + x✝²)))
    [Meta.check] [0.001202] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if
              True ∧
                BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) x✝² ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
            none
          else
            if True ∧ (x✝ * x✝¹ + x✝ * x✝² < x✝ * x✝¹ ∨ x✝ * x✝¹ + x✝ * x✝² < x✝ * x✝²) then none
            else some (x✝ * x✝¹ + x✝ * x✝²))
          (some (x✝ * (x✝¹ + x✝²)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if
                True ∧
                  BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) x✝² ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else
              if True ∧ (x✝ * x✝¹ + x✝ * x✝² < x✝ * x✝¹ ∨ x✝ * x✝¹ + x✝ * x✝² < x✝ * x✝²) then none
              else some (x✝ * x✝¹ + x✝ * x✝²)) ⊑
            some (x✝ * (x✝¹ + x✝²))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * BitVec.zeroExtend 64 x✝²) = true then none
            else
              if (!((!x✝ * x✝¹ >ᵤ x✝ * x✝¹ + x✝ * x✝²) && !x✝ * x✝² >ᵤ x✝ * x✝¹ + x✝ * x✝²)) = true then none
              else some (x✝ * x✝¹ + x✝ * x✝²)) ⊑
            some (x✝ * (x✝¹ + x✝²))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:172:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:172:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:165:8: error: (kernel) declaration has metavariables 'tryFactorization_add_nuw_mul_nuw_mul_var_thm'
[bv] [0.055794] Normalizing goal
  [Meta.synthInstance] [0.002420] ✅️ Decidable
        ((if
              True ∧
                BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) x✝¹ ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
            none
          else
            if True ∧ (x✝ * x✝¹ + x✝ * x✝² < x✝ * x✝¹ ∨ x✝ * x✝¹ + x✝ * x✝² < x✝ * x✝²) then none
            else some (x✝ * x✝¹ + x✝ * x✝²)) ⊑
          some (x✝ * (x✝¹ + x✝²)))
    [Meta.check] [0.001339] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if
              True ∧
                BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) x✝¹ ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
            none
          else
            if True ∧ (x✝ * x✝¹ + x✝ * x✝² < x✝ * x✝¹ ∨ x✝ * x✝¹ + x✝ * x✝² < x✝ * x✝²) then none
            else some (x✝ * x✝¹ + x✝ * x✝²))
          (some (x✝ * (x✝¹ + x✝²)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if
                True ∧
                  BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) x✝¹ ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else
              if True ∧ (x✝ * x✝¹ + x✝ * x✝² < x✝ * x✝¹ ∨ x✝ * x✝¹ + x✝ * x✝² < x✝ * x✝²) then none
              else some (x✝ * x✝¹ + x✝ * x✝²)) ⊑
            some (x✝ * (x✝¹ + x✝²))
      ⊢ False
  [Meta.isDefEq] [0.001009] ❌️ ?a ==
        ?a =?= (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * BitVec.zeroExtend 64 x✝¹) == true
  [Meta.isDefEq] [0.001096] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                (BitVec.zeroExtend 64 x✝ * BitVec.zeroExtend 64 x✝¹))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 x✝ * BitVec.zeroExtend 64 x✝¹)
                      (BitVec.twoPow 64 31 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * BitVec.zeroExtend 64 x✝¹) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * BitVec.zeroExtend 64 x✝¹)))))))
        (true_and ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * BitVec.zeroExtend 64 x✝¹) = true))
    [Meta.isDefEq.assign] [0.001092] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                  (BitVec.zeroExtend 64 x✝ * BitVec.zeroExtend 64 x✝¹))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 x✝ * BitVec.zeroExtend 64 x✝¹)
                        (BitVec.twoPow 64 31 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * BitVec.zeroExtend 64 x✝¹) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * BitVec.zeroExtend 64 x✝¹)))))))
          (true_and ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * BitVec.zeroExtend 64 x✝¹) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001070] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) x✝¹ ≥ BitVec.twoPow (2 * 32) (32 - 1) <<< 1) =
            ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * BitVec.zeroExtend 64 x✝¹) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                    (BitVec.zeroExtend 64 x✝ * BitVec.zeroExtend 64 x✝¹))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                          (BitVec.zeroExtend 64 x✝ * BitVec.zeroExtend 64 x✝¹) (BitVec.twoPow 64 31 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * BitVec.zeroExtend 64 x✝¹) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * BitVec.zeroExtend 64 x✝¹)))))))
            (true_and
              ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * BitVec.zeroExtend 64 x✝¹) =
                true)) : (True ∧ BitVec.zeroExtend 64 x✝ * BitVec.zeroExtend 64 x✝¹ ≥ BitVec.twoPow 64 31 <<< 1) =
            ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * BitVec.zeroExtend 64 x✝¹) = true))
        [Meta.isDefEq] [0.001065] ✅️ (True ∧
                BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) x✝¹ ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1) =
              ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * BitVec.zeroExtend 64 x✝¹) =
                true) =?= (True ∧ BitVec.zeroExtend 64 x✝ * BitVec.zeroExtend 64 x✝¹ ≥ BitVec.twoPow 64 31 <<< 1) =
              ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * BitVec.zeroExtend 64 x✝¹) = true)
          [Meta.isDefEq] [0.001029] ✅️ True ∧
                BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) x✝¹ ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 64 x✝ * BitVec.zeroExtend 64 x✝¹ ≥ BitVec.twoPow 64 31 <<< 1
            [Meta.isDefEq] [0.001010] ✅️ BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) x✝¹ ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<<
                    1 =?= BitVec.zeroExtend 64 x✝ * BitVec.zeroExtend 64 x✝¹ ≥ BitVec.twoPow 64 31 <<< 1
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * BitVec.zeroExtend 64 x✝¹) = true then none
            else
              if (!((!x✝ * x✝¹ >ᵤ x✝ * x✝¹ + x✝ * x✝²) && !x✝ * x✝² >ᵤ x✝ * x✝¹ + x✝ * x✝²)) = true then none
              else some (x✝ * x✝¹ + x✝ * x✝²)) ⊑
            some (x✝ * (x✝¹ + x✝²))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:183:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:183:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/greassociatehnuw_proof.lean:176:8: error: (kernel) declaration has metavariables 'tryFactorization_add_mul_nuw_mul_var_thm'
[bv] [0.051457] Normalizing goal
  [Meta.synthInstance] [0.001802] ✅️ Decidable
        ((if
              True ∧
                BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) x✝¹ ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
            none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) x✝² ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else some (x✝ * x✝¹ + x✝ * x✝²)) ⊑
          some (x✝ * (x✝¹ + x✝²)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if
                True ∧
                  BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) x✝¹ ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) x✝² ≥
                      BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                none
              else some (x✝ * x✝¹ + x✝ * x✝²)) ⊑
            some (x✝ * (x✝¹ + x✝²))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * BitVec.zeroExtend 64 x✝¹) = true then none
            else
              if (!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * BitVec.zeroExtend 64 x✝²) = true then none
              else some (x✝ * x✝¹ + x✝ * x✝²)) ⊑
            some (x✝ * (x✝¹ + x✝²))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
