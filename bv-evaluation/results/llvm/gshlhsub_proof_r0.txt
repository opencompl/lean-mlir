‚ö† [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
‚ö† [880/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
‚ö† [884/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
‚ö† [887/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
‚ö† [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhsub_proof.lean:16:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhsub_proof.lean:11:8: error: (kernel) declaration has metavariables 'shl_sub_i32_thm'
[bv] [0.058825] Normalizing goal
  [Meta.synthInstance] [0.001237] ‚úÖÔ∏è Decidable
        ((if 31#32 - x‚úù ‚â• ‚Üë32 then none else some (1#32 <<< (31#32 - x‚úù))) ‚äë
          if x‚úù ‚â• ‚Üë32 then none else some (2147483648#32 >>> x‚úù))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if 31#32 - x‚úù ‚â• ‚Üë32 then none else some (1#32 <<< (31#32 - x‚úù))) ‚äë
            if x‚úù ‚â• ‚Üë32 then none else some (2147483648#32 >>> x‚úù)
      ‚ä¢ False
  [Meta.isDefEq] [0.003751] ‚ùåÔ∏è ?a == ?a =?= (32#32 >·µ§ 32#32 + ~~~x‚úù) == true
    [Meta.isDefEq.onFailure] [0.003496] ‚ùåÔ∏è ?a == ?a =?= (32#32 >·µ§ 32#32 + ~~~x‚úù) == true
      [Meta.synthInstance] [0.003474] üí•Ô∏è BEq ?Œ±
        [Meta.synthInstance] [0.003387] new goal BEq ?Œ±
  [Meta.isDefEq] [0.001231] ‚úÖÔ∏è ?h‚ÇÉ =?= fun a =>
        congrArg (fun x => some (1#32 <<< x))
          (Eq.trans (BitVec.sub_toAdd (31#32) x‚úù)
            (Eq.trans (congrArg (HAdd.hAdd 31#32) (BitVec.neg_eq_not_add x‚úù))
              (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (31#32) (~~~x‚úù) 1#32)))
    [Meta.isDefEq.assign] [0.001228] ‚úÖÔ∏è ?h‚ÇÉ := fun a =>
          congrArg (fun x => some (1#32 <<< x))
            (Eq.trans (BitVec.sub_toAdd (31#32) x‚úù)
              (Eq.trans (congrArg (HAdd.hAdd 31#32) (BitVec.neg_eq_not_add x‚úù))
                (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (31#32) (~~~x‚úù) 1#32)))
      [Meta.isDefEq.assign.checkTypes] [0.001200] ‚úÖÔ∏è (?h‚ÇÉ : ¬¨(!32#32 >·µ§ 32#32 + ~~~x‚úù) = true ‚Üí
            some (1#32 <<< (31#32 - x‚úù)) =
              some
                (1#32 <<<
                  (32#32 +
                    ~~~x‚úù))) := (fun a =>
            congrArg (fun x => some (1#32 <<< x))
              (Eq.trans (BitVec.sub_toAdd (31#32) x‚úù)
                (Eq.trans (congrArg (HAdd.hAdd 31#32) (BitVec.neg_eq_not_add x‚úù))
                  (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (31#32) (~~~x‚úù)
                    1#32))) : ¬¨(!32#32 >·µ§ 32#32 + ~~~x‚úù) = true ‚Üí
            some (1#32 <<< (31#32 - x‚úù)) = some (1#32 <<< (31#32 + 1#32 + ~~~x‚úù)))
        [Meta.isDefEq] [0.001197] ‚úÖÔ∏è ¬¨(!32#32 >·µ§ 32#32 + ~~~x‚úù) = true ‚Üí
              some (1#32 <<< (31#32 - x‚úù)) =
                some
                  (1#32 <<<
                    (32#32 +
                      ~~~x‚úù)) =?= ¬¨(!32#32 >·µ§ 32#32 + ~~~x‚úù) = true ‚Üí
              some (1#32 <<< (31#32 - x‚úù)) = some (1#32 <<< (31#32 + 1#32 + ~~~x‚úù))
          [Meta.isDefEq] [0.001165] ‚úÖÔ∏è some (1#32 <<< (31#32 - x‚úù)) =
                some
                  (1#32 <<< (32#32 + ~~~x‚úù)) =?= some (1#32 <<< (31#32 - x‚úù)) = some (1#32 <<< (31#32 + 1#32 + ~~~x‚úù))
            [Meta.isDefEq] [0.001130] ‚úÖÔ∏è some (1#32 <<< (32#32 + ~~~x‚úù)) =?= some (1#32 <<< (31#32 + 1#32 + ~~~x‚úù))
              [Meta.isDefEq] [0.001116] ‚úÖÔ∏è 1#32 <<< (32#32 + ~~~x‚úù) =?= 1#32 <<< (31#32 + 1#32 + ~~~x‚úù)
                [Meta.isDefEq] [0.001089] ‚úÖÔ∏è BitVec.instHShiftLeft.1 (1#32)
                      (32#32 + ~~~x‚úù) =?= BitVec.instHShiftLeft.1 (1#32) (31#32 + 1#32 + ~~~x‚úù)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if (!32#32 >·µ§ 32#32 + ~~~x‚úù) = true then none else some (1#32 <<< (32#32 + ~~~x‚úù))) ‚äë
            if (!32#32 >·µ§ x‚úù) = true then none else some (2147483648#32 >>> x‚úù)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhsub_proof.lean:25:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhsub_proof.lean:20:8: error: (kernel) declaration has metavariables 'shl_sub_i8_thm'
[bv] [0.034064] Normalizing goal
  [Meta.synthInstance] [0.001317] ‚úÖÔ∏è Decidable
        ((if 7#8 - x‚úù ‚â• ‚Üë8 then none else some (1#8 <<< (7#8 - x‚úù))) ‚äë if x‚úù ‚â• ‚Üë8 then none else some (128#8 >>> x‚úù))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x‚úù : BitVec 8
      a‚úù : ¬¨(if 7#8 - x‚úù ‚â• ‚Üë8 then none else some (1#8 <<< (7#8 - x‚úù))) ‚äë if x‚úù ‚â• ‚Üë8 then none else some (128#8 >>> x‚úù)
      ‚ä¢ False
  [Meta.isDefEq] [0.001276] ‚úÖÔ∏è ?h‚ÇÉ =?= fun a =>
        congrArg (fun x => some (1#8 <<< x))
          (Eq.trans (BitVec.sub_toAdd (7#8) x‚úù)
            (Eq.trans (congrArg (HAdd.hAdd 7#8) (BitVec.neg_eq_not_add x‚úù))
              (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (7#8) (~~~x‚úù) 1#8)))
    [Meta.isDefEq.assign] [0.001272] ‚úÖÔ∏è ?h‚ÇÉ := fun a =>
          congrArg (fun x => some (1#8 <<< x))
            (Eq.trans (BitVec.sub_toAdd (7#8) x‚úù)
              (Eq.trans (congrArg (HAdd.hAdd 7#8) (BitVec.neg_eq_not_add x‚úù))
                (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (7#8) (~~~x‚úù) 1#8)))
      [Meta.isDefEq.assign.checkTypes] [0.001236] ‚úÖÔ∏è (?h‚ÇÉ : ¬¨(!8#8 >·µ§ 8#8 + ~~~x‚úù) = true ‚Üí
            some (1#8 <<< (7#8 - x‚úù)) =
              some
                (1#8 <<<
                  (8#8 +
                    ~~~x‚úù))) := (fun a =>
            congrArg (fun x => some (1#8 <<< x))
              (Eq.trans (BitVec.sub_toAdd (7#8) x‚úù)
                (Eq.trans (congrArg (HAdd.hAdd 7#8) (BitVec.neg_eq_not_add x‚úù))
                  (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (7#8) (~~~x‚úù)
                    1#8))) : ¬¨(!8#8 >·µ§ 8#8 + ~~~x‚úù) = true ‚Üí
            some (1#8 <<< (7#8 - x‚úù)) = some (1#8 <<< (7#8 + 1#8 + ~~~x‚úù)))
        [Meta.isDefEq] [0.001231] ‚úÖÔ∏è ¬¨(!8#8 >·µ§ 8#8 + ~~~x‚úù) = true ‚Üí
              some (1#8 <<< (7#8 - x‚úù)) =
                some
                  (1#8 <<<
                    (8#8 +
                      ~~~x‚úù)) =?= ¬¨(!8#8 >·µ§ 8#8 + ~~~x‚úù) = true ‚Üí
              some (1#8 <<< (7#8 - x‚úù)) = some (1#8 <<< (7#8 + 1#8 + ~~~x‚úù))
          [Meta.isDefEq] [0.001198] ‚úÖÔ∏è some (1#8 <<< (7#8 - x‚úù)) =
                some (1#8 <<< (8#8 + ~~~x‚úù)) =?= some (1#8 <<< (7#8 - x‚úù)) = some (1#8 <<< (7#8 + 1#8 + ~~~x‚úù))
            [Meta.isDefEq] [0.001147] ‚úÖÔ∏è some (1#8 <<< (8#8 + ~~~x‚úù)) =?= some (1#8 <<< (7#8 + 1#8 + ~~~x‚úù))
              [Meta.isDefEq] [0.001127] ‚úÖÔ∏è 1#8 <<< (8#8 + ~~~x‚úù) =?= 1#8 <<< (7#8 + 1#8 + ~~~x‚úù)
                [Meta.isDefEq] [0.001098] ‚úÖÔ∏è BitVec.instHShiftLeft.1 (1#8)
                      (8#8 + ~~~x‚úù) =?= BitVec.instHShiftLeft.1 (1#8) (7#8 + 1#8 + ~~~x‚úù)
                  [Meta.isDefEq] [0.001037] ‚úÖÔ∏è 1#8 <<< (8#8 + ~~~x‚úù).toNat =?= 1#8 <<< (7#8 + 1#8 + ~~~x‚úù).toNat
                    [Meta.isDefEq] [0.001016] ‚úÖÔ∏è BitVec.instHShiftLeftNat.1 (1#8)
                          (8#8 + ~~~x‚úù).toNat =?= BitVec.instHShiftLeftNat.1 (1#8) (7#8 + 1#8 + ~~~x‚úù).toNat
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x‚úù : BitVec 8
      a‚úù :
        ¬¨(if (!8#8 >·µ§ 8#8 + ~~~x‚úù) = true then none else some (1#8 <<< (8#8 + ~~~x‚úù))) ‚äë
            if (!8#8 >·µ§ x‚úù) = true then none else some (128#8 >>> x‚úù)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhsub_proof.lean:35:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhsub_proof.lean:29:8: error: (kernel) declaration has metavariables 'shl_sub_i64_thm'
[bv] [0.037921] Normalizing goal
  [Meta.synthInstance] [0.001286] ‚úÖÔ∏è Decidable
        ((if 63#64 - x‚úù ‚â• ‚Üë64 then none else some (1#64 <<< (63#64 - x‚úù))) ‚äë
          if x‚úù ‚â• ‚Üë64 then none else some (9223372036854775808#64 >>> x‚úù))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      x‚úù : BitVec 64
      a‚úù :
        ¬¨(if 63#64 - x‚úù ‚â• ‚Üë64 then none else some (1#64 <<< (63#64 - x‚úù))) ‚äë
            if x‚úù ‚â• ‚Üë64 then none else some (9223372036854775808#64 >>> x‚úù)
      ‚ä¢ False
  [Meta.isDefEq] [0.001197] ‚úÖÔ∏è ?h‚ÇÉ =?= fun a =>
        congrArg (fun x => some (1#64 <<< x))
          (Eq.trans (BitVec.sub_toAdd (63#64) x‚úù)
            (Eq.trans (congrArg (HAdd.hAdd 63#64) (BitVec.neg_eq_not_add x‚úù))
              (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (63#64) (~~~x‚úù) 1#64)))
    [Meta.isDefEq.assign] [0.001194] ‚úÖÔ∏è ?h‚ÇÉ := fun a =>
          congrArg (fun x => some (1#64 <<< x))
            (Eq.trans (BitVec.sub_toAdd (63#64) x‚úù)
              (Eq.trans (congrArg (HAdd.hAdd 63#64) (BitVec.neg_eq_not_add x‚úù))
                (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (63#64) (~~~x‚úù) 1#64)))
      [Meta.isDefEq.assign.checkTypes] [0.001164] ‚úÖÔ∏è (?h‚ÇÉ : ¬¨(!64#64 >·µ§ 64#64 + ~~~x‚úù) = true ‚Üí
            some (1#64 <<< (63#64 - x‚úù)) =
              some
                (1#64 <<<
                  (64#64 +
                    ~~~x‚úù))) := (fun a =>
            congrArg (fun x => some (1#64 <<< x))
              (Eq.trans (BitVec.sub_toAdd (63#64) x‚úù)
                (Eq.trans (congrArg (HAdd.hAdd 63#64) (BitVec.neg_eq_not_add x‚úù))
                  (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (63#64) (~~~x‚úù)
                    1#64))) : ¬¨(!64#64 >·µ§ 64#64 + ~~~x‚úù) = true ‚Üí
            some (1#64 <<< (63#64 - x‚úù)) = some (1#64 <<< (63#64 + 1#64 + ~~~x‚úù)))
        [Meta.isDefEq] [0.001161] ‚úÖÔ∏è ¬¨(!64#64 >·µ§ 64#64 + ~~~x‚úù) = true ‚Üí
              some (1#64 <<< (63#64 - x‚úù)) =
                some
                  (1#64 <<<
                    (64#64 +
                      ~~~x‚úù)) =?= ¬¨(!64#64 >·µ§ 64#64 + ~~~x‚úù) = true ‚Üí
              some (1#64 <<< (63#64 - x‚úù)) = some (1#64 <<< (63#64 + 1#64 + ~~~x‚úù))
          [Meta.isDefEq] [0.001130] ‚úÖÔ∏è some (1#64 <<< (63#64 - x‚úù)) =
                some
                  (1#64 <<< (64#64 + ~~~x‚úù)) =?= some (1#64 <<< (63#64 - x‚úù)) = some (1#64 <<< (63#64 + 1#64 + ~~~x‚úù))
            [Meta.isDefEq] [0.001095] ‚úÖÔ∏è some (1#64 <<< (64#64 + ~~~x‚úù)) =?= some (1#64 <<< (63#64 + 1#64 + ~~~x‚úù))
              [Meta.isDefEq] [0.001078] ‚úÖÔ∏è 1#64 <<< (64#64 + ~~~x‚úù) =?= 1#64 <<< (63#64 + 1#64 + ~~~x‚úù)
                [Meta.isDefEq] [0.001049] ‚úÖÔ∏è BitVec.instHShiftLeft.1 (1#64)
                      (64#64 + ~~~x‚úù) =?= BitVec.instHShiftLeft.1 (1#64) (63#64 + 1#64 + ~~~x‚úù)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      x‚úù : BitVec 64
      a‚úù :
        ¬¨(if (!64#64 >·µ§ 64#64 + ~~~x‚úù) = true then none else some (1#64 <<< (64#64 + ~~~x‚úù))) ‚äë
            if (!64#64 >·µ§ x‚úù) = true then none else some (9223372036854775808#64 >>> x‚úù)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhsub_proof.lean:46:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhsub_proof.lean:39:8: error: (kernel) declaration has metavariables 'shl_bad_sub_i32_thm'
[bv] [0.035995] Normalizing goal
  [Meta.synthInstance] [0.001263] ‚úÖÔ∏è Decidable
        ((if 32#32 - x‚úù ‚â• ‚Üë32 then none else some (1#32 <<< (32#32 - x‚úù))) ‚äë
          if True ‚àß 1#32 <<< (32#32 - x‚úù) >>> (32#32 - x‚úù) = 1#32 then none
          else if 32#32 - x‚úù ‚â• ‚Üë32 then none else some (1#32 <<< (32#32 - x‚úù)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if 32#32 - x‚úù ‚â• ‚Üë32 then none else some (1#32 <<< (32#32 - x‚úù))) ‚äë
            if True ‚àß 1#32 <<< (32#32 - x‚úù) >>> (32#32 - x‚úù) = 1#32 then none
            else if 32#32 - x‚úù ‚â• ‚Üë32 then none else some (1#32 <<< (32#32 - x‚úù))
      ‚ä¢ False
  [Meta.isDefEq] [0.004737] ‚úÖÔ∏è ?h‚ÇÉ =?= fun a =>
        congrArg (fun x => some (1#32 <<< x))
          (Eq.trans (BitVec.sub_toAdd (32#32) x‚úù)
            (Eq.trans (congrArg (HAdd.hAdd 32#32) (BitVec.neg_eq_not_add x‚úù))
              (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (32#32) (~~~x‚úù) 1#32)))
    [Meta.isDefEq.assign] [0.004734] ‚úÖÔ∏è ?h‚ÇÉ := fun a =>
          congrArg (fun x => some (1#32 <<< x))
            (Eq.trans (BitVec.sub_toAdd (32#32) x‚úù)
              (Eq.trans (congrArg (HAdd.hAdd 32#32) (BitVec.neg_eq_not_add x‚úù))
                (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (32#32) (~~~x‚úù) 1#32)))
      [Meta.isDefEq.assign.checkTypes] [0.004703] ‚úÖÔ∏è (?h‚ÇÉ : ¬¨(!32#32 >·µ§ 33#32 + ~~~x‚úù) = true ‚Üí
            some (1#32 <<< (32#32 - x‚úù)) =
              some
                (1#32 <<<
                  (33#32 +
                    ~~~x‚úù))) := (fun a =>
            congrArg (fun x => some (1#32 <<< x))
              (Eq.trans (BitVec.sub_toAdd (32#32) x‚úù)
                (Eq.trans (congrArg (HAdd.hAdd 32#32) (BitVec.neg_eq_not_add x‚úù))
                  (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (32#32) (~~~x‚úù)
                    1#32))) : ¬¨(!32#32 >·µ§ 33#32 + ~~~x‚úù) = true ‚Üí
            some (1#32 <<< (32#32 - x‚úù)) = some (1#32 <<< (32#32 + 1#32 + ~~~x‚úù)))
        [Meta.isDefEq] [0.004700] ‚úÖÔ∏è ¬¨(!32#32 >·µ§ 33#32 + ~~~x‚úù) = true ‚Üí
              some (1#32 <<< (32#32 - x‚úù)) =
                some
                  (1#32 <<<
                    (33#32 +
                      ~~~x‚úù)) =?= ¬¨(!32#32 >·µ§ 33#32 + ~~~x‚úù) = true ‚Üí
              some (1#32 <<< (32#32 - x‚úù)) = some (1#32 <<< (32#32 + 1#32 + ~~~x‚úù))
          [Meta.isDefEq] [0.004665] ‚úÖÔ∏è some (1#32 <<< (32#32 - x‚úù)) =
                some
                  (1#32 <<< (33#32 + ~~~x‚úù)) =?= some (1#32 <<< (32#32 - x‚úù)) = some (1#32 <<< (32#32 + 1#32 + ~~~x‚úù))
            [Meta.isDefEq] [0.004616] ‚úÖÔ∏è some (1#32 <<< (33#32 + ~~~x‚úù)) =?= some (1#32 <<< (32#32 + 1#32 + ~~~x‚úù))
              [Meta.isDefEq] [0.004587] ‚úÖÔ∏è 1#32 <<< (33#32 + ~~~x‚úù) =?= 1#32 <<< (32#32 + 1#32 + ~~~x‚úù)
                [Meta.isDefEq] [0.004550] ‚úÖÔ∏è BitVec.instHShiftLeft.1 (1#32)
                      (33#32 + ~~~x‚úù) =?= BitVec.instHShiftLeft.1 (1#32) (32#32 + 1#32 + ~~~x‚úù)
                  [Meta.isDefEq] [0.004485] ‚úÖÔ∏è 1#32 <<< (33#32 + ~~~x‚úù).toNat =?= 1#32 <<< (32#32 + 1#32 + ~~~x‚úù).toNat
                    [Meta.isDefEq] [0.001364] ‚úÖÔ∏è BitVec.instHShiftLeftNat.1 (1#32)
                          (33#32 + ~~~x‚úù).toNat =?= BitVec.instHShiftLeftNat.1 (1#32) (32#32 + 1#32 + ~~~x‚úù).toNat
                      [Meta.isDefEq] [0.001320] ‚úÖÔ∏è (1#32).shiftLeft
                            (33#32 + ~~~x‚úù).toNat =?= (1#32).shiftLeft (32#32 + 1#32 + ~~~x‚úù).toNat
                        [Meta.isDefEq.delta] [0.001307] ‚úÖÔ∏è (1#32).shiftLeft
                              (33#32 + ~~~x‚úù).toNat =?= (1#32).shiftLeft (32#32 + 1#32 + ~~~x‚úù).toNat
                          [Meta.isDefEq] [0.001279] ‚úÖÔ∏è (33#32 + ~~~x‚úù).toNat =?= (32#32 + 1#32 + ~~~x‚úù).toNat
                            [Meta.isDefEq.delta] [0.001262] ‚úÖÔ∏è (33#32 + ~~~x‚úù).toNat =?= (32#32 + 1#32 + ~~~x‚úù).toNat
                              [Meta.isDefEq] [0.001243] ‚úÖÔ∏è 33#32 + ~~~x‚úù =?= 32#32 + 1#32 + ~~~x‚úù
                                [Meta.isDefEq] [0.001105] ‚úÖÔ∏è instHAdd.1 (33#32)
                                      (~~~x‚úù) =?= instHAdd.1 (32#32 + 1#32) (~~~x‚úù)
                                  [Meta.isDefEq] [0.001060] ‚úÖÔ∏è Add.add (33#32)
                                        (~~~x‚úù) =?= Add.add (32#32 + 1#32) (~~~x‚úù)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if (!32#32 >·µ§ 33#32 + ~~~x‚úù) = true then none else some (1#32 <<< (33#32 + ~~~x‚úù))) ‚äë
            if (1#32 <<< (33#32 + ~~~x‚úù) >>> (33#32 + ~~~x‚úù) == 1#32) = true then none
            else if (!32#32 >·µ§ 33#32 + ~~~x‚úù) = true then none else some (1#32 <<< (33#32 + ~~~x‚úù))
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhsub_proof.lean:57:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhsub_proof.lean:50:8: error: (kernel) declaration has metavariables 'shl_bad_sub2_i32_thm'
[bv] [0.030335] Normalizing goal
  [Meta.synthInstance] [0.001291] ‚úÖÔ∏è Decidable
        ((if x‚úù - 31#32 ‚â• ‚Üë32 then none else some (1#32 <<< (x‚úù - 31#32))) ‚äë
          if True ‚àß 1#32 <<< (x‚úù + 4294967265#32) >>> (x‚úù + 4294967265#32) = 1#32 then none
          else if x‚úù + 4294967265#32 ‚â• ‚Üë32 then none else some (1#32 <<< (x‚úù + 4294967265#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if x‚úù - 31#32 ‚â• ‚Üë32 then none else some (1#32 <<< (x‚úù - 31#32))) ‚äë
            if True ‚àß 1#32 <<< (x‚úù + 4294967265#32) >>> (x‚úù + 4294967265#32) = 1#32 then none
            else if x‚úù + 4294967265#32 ‚â• ‚Üë32 then none else some (1#32 <<< (x‚úù + 4294967265#32))
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if (!32#32 >·µ§ x‚úù + 4294967265#32) = true then none else some (1#32 <<< (x‚úù + 4294967265#32))) ‚äë
            if (1#32 <<< (x‚úù + 4294967265#32) >>> (x‚úù + 4294967265#32) == 1#32) = true then none
            else if (!32#32 >·µ§ x‚úù + 4294967265#32) = true then none else some (1#32 <<< (x‚úù + 4294967265#32))
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhsub_proof.lean:68:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhsub_proof.lean:61:8: error: (kernel) declaration has metavariables 'bad_shl2_sub_i32_thm'
[bv] [0.032213] Normalizing goal
  [Meta.synthInstance] [0.001349] ‚úÖÔ∏è Decidable
        ((if x‚úù - 31#32 ‚â• ‚Üë32 then none else some (1#32 <<< (x‚úù - 31#32))) ‚äë
          if True ‚àß 1#32 <<< (x‚úù + 4294967265#32) >>> (x‚úù + 4294967265#32) = 1#32 then none
          else if x‚úù + 4294967265#32 ‚â• ‚Üë32 then none else some (1#32 <<< (x‚úù + 4294967265#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if x‚úù - 31#32 ‚â• ‚Üë32 then none else some (1#32 <<< (x‚úù - 31#32))) ‚äë
            if True ‚àß 1#32 <<< (x‚úù + 4294967265#32) >>> (x‚úù + 4294967265#32) = 1#32 then none
            else if x‚úù + 4294967265#32 ‚â• ‚Üë32 then none else some (1#32 <<< (x‚úù + 4294967265#32))
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if (!32#32 >·µ§ x‚úù + 4294967265#32) = true then none else some (1#32 <<< (x‚úù + 4294967265#32))) ‚äë
            if (1#32 <<< (x‚úù + 4294967265#32) >>> (x‚úù + 4294967265#32) == 1#32) = true then none
            else if (!32#32 >·µ§ x‚úù + 4294967265#32) = true then none else some (1#32 <<< (x‚úù + 4294967265#32))
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhsub_proof.lean:79:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhsub_proof.lean:72:8: error: (kernel) declaration has metavariables 'shl_bad_sub_i8_thm'
[bv] [0.034122] Normalizing goal
  [Meta.synthInstance] [0.001254] ‚úÖÔ∏è Decidable
        ((if 4#8 - x‚úù ‚â• ‚Üë8 then none else some (1#8 <<< (4#8 - x‚úù))) ‚äë
          if True ‚àß 1#8 <<< (4#8 - x‚úù) >>> (4#8 - x‚úù) = 1#8 then none
          else if 4#8 - x‚úù ‚â• ‚Üë8 then none else some (1#8 <<< (4#8 - x‚úù)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x‚úù : BitVec 8
      a‚úù :
        ¬¨(if 4#8 - x‚úù ‚â• ‚Üë8 then none else some (1#8 <<< (4#8 - x‚úù))) ‚äë
            if True ‚àß 1#8 <<< (4#8 - x‚úù) >>> (4#8 - x‚úù) = 1#8 then none
            else if 4#8 - x‚úù ‚â• ‚Üë8 then none else some (1#8 <<< (4#8 - x‚úù))
      ‚ä¢ False
  [Meta.isDefEq] [0.001334] ‚úÖÔ∏è ?h‚ÇÉ =?= fun a =>
        congrArg (fun x => some (1#8 <<< x))
          (Eq.trans (BitVec.sub_toAdd (4#8) x‚úù)
            (Eq.trans (congrArg (HAdd.hAdd 4#8) (BitVec.neg_eq_not_add x‚úù))
              (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (4#8) (~~~x‚úù) 1#8)))
    [Meta.isDefEq.assign] [0.001331] ‚úÖÔ∏è ?h‚ÇÉ := fun a =>
          congrArg (fun x => some (1#8 <<< x))
            (Eq.trans (BitVec.sub_toAdd (4#8) x‚úù)
              (Eq.trans (congrArg (HAdd.hAdd 4#8) (BitVec.neg_eq_not_add x‚úù))
                (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (4#8) (~~~x‚úù) 1#8)))
      [Meta.isDefEq.assign.checkTypes] [0.001277] ‚úÖÔ∏è (?h‚ÇÉ : ¬¨(!8#8 >·µ§ 5#8 + ~~~x‚úù) = true ‚Üí
            some (1#8 <<< (4#8 - x‚úù)) =
              some
                (1#8 <<<
                  (5#8 +
                    ~~~x‚úù))) := (fun a =>
            congrArg (fun x => some (1#8 <<< x))
              (Eq.trans (BitVec.sub_toAdd (4#8) x‚úù)
                (Eq.trans (congrArg (HAdd.hAdd 4#8) (BitVec.neg_eq_not_add x‚úù))
                  (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (4#8) (~~~x‚úù)
                    1#8))) : ¬¨(!8#8 >·µ§ 5#8 + ~~~x‚úù) = true ‚Üí
            some (1#8 <<< (4#8 - x‚úù)) = some (1#8 <<< (4#8 + 1#8 + ~~~x‚úù)))
        [Meta.isDefEq] [0.001274] ‚úÖÔ∏è ¬¨(!8#8 >·µ§ 5#8 + ~~~x‚úù) = true ‚Üí
              some (1#8 <<< (4#8 - x‚úù)) =
                some
                  (1#8 <<<
                    (5#8 +
                      ~~~x‚úù)) =?= ¬¨(!8#8 >·µ§ 5#8 + ~~~x‚úù) = true ‚Üí
              some (1#8 <<< (4#8 - x‚úù)) = some (1#8 <<< (4#8 + 1#8 + ~~~x‚úù))
          [Meta.isDefEq] [0.001241] ‚úÖÔ∏è some (1#8 <<< (4#8 - x‚úù)) =
                some (1#8 <<< (5#8 + ~~~x‚úù)) =?= some (1#8 <<< (4#8 - x‚úù)) = some (1#8 <<< (4#8 + 1#8 + ~~~x‚úù))
            [Meta.isDefEq] [0.001206] ‚úÖÔ∏è some (1#8 <<< (5#8 + ~~~x‚úù)) =?= some (1#8 <<< (4#8 + 1#8 + ~~~x‚úù))
              [Meta.isDefEq] [0.001184] ‚úÖÔ∏è 1#8 <<< (5#8 + ~~~x‚úù) =?= 1#8 <<< (4#8 + 1#8 + ~~~x‚úù)
                [Meta.isDefEq] [0.001159] ‚úÖÔ∏è BitVec.instHShiftLeft.1 (1#8)
                      (5#8 + ~~~x‚úù) =?= BitVec.instHShiftLeft.1 (1#8) (4#8 + 1#8 + ~~~x‚úù)
                  [Meta.isDefEq] [0.001102] ‚úÖÔ∏è 1#8 <<< (5#8 + ~~~x‚úù).toNat =?= 1#8 <<< (4#8 + 1#8 + ~~~x‚úù).toNat
                    [Meta.isDefEq] [0.001080] ‚úÖÔ∏è BitVec.instHShiftLeftNat.1 (1#8)
                          (5#8 + ~~~x‚úù).toNat =?= BitVec.instHShiftLeftNat.1 (1#8) (4#8 + 1#8 + ~~~x‚úù).toNat
                      [Meta.isDefEq] [0.001036] ‚úÖÔ∏è (1#8).shiftLeft
                            (5#8 + ~~~x‚úù).toNat =?= (1#8).shiftLeft (4#8 + 1#8 + ~~~x‚úù).toNat
                        [Meta.isDefEq.delta] [0.001026] ‚úÖÔ∏è (1#8).shiftLeft
                              (5#8 + ~~~x‚úù).toNat =?= (1#8).shiftLeft (4#8 + 1#8 + ~~~x‚úù).toNat
                          [Meta.isDefEq] [0.001001] ‚úÖÔ∏è (5#8 + ~~~x‚úù).toNat =?= (4#8 + 1#8 + ~~~x‚úù).toNat
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x‚úù : BitVec 8
      a‚úù :
        ¬¨(if (!8#8 >·µ§ 5#8 + ~~~x‚úù) = true then none else some (1#8 <<< (5#8 + ~~~x‚úù))) ‚äë
            if (1#8 <<< (5#8 + ~~~x‚úù) >>> (5#8 + ~~~x‚úù) == 1#8) = true then none
            else if (!8#8 >·µ§ 5#8 + ~~~x‚úù) = true then none else some (1#8 <<< (5#8 + ~~~x‚úù))
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhsub_proof.lean:90:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhsub_proof.lean:83:8: error: (kernel) declaration has metavariables 'shl_bad_sub_i64_thm'
[bv] [0.049521] Normalizing goal
  [Meta.synthInstance] [0.001884] ‚úÖÔ∏è Decidable
        ((if 67#64 - x‚úù ‚â• ‚Üë64 then none else some (1#64 <<< (67#64 - x‚úù))) ‚äë
          if True ‚àß 1#64 <<< (67#64 - x‚úù) >>> (67#64 - x‚úù) = 1#64 then none
          else if 67#64 - x‚úù ‚â• ‚Üë64 then none else some (1#64 <<< (67#64 - x‚úù)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      x‚úù : BitVec 64
      a‚úù :
        ¬¨(if 67#64 - x‚úù ‚â• ‚Üë64 then none else some (1#64 <<< (67#64 - x‚úù))) ‚äë
            if True ‚àß 1#64 <<< (67#64 - x‚úù) >>> (67#64 - x‚úù) = 1#64 then none
            else if 67#64 - x‚úù ‚â• ‚Üë64 then none else some (1#64 <<< (67#64 - x‚úù))
      ‚ä¢ False
  [Meta.isDefEq] [0.002094] ‚úÖÔ∏è ?h‚ÇÉ =?= fun a =>
        congrArg (fun x => some (1#64 <<< x))
          (Eq.trans (BitVec.sub_toAdd (67#64) x‚úù)
            (Eq.trans (congrArg (HAdd.hAdd 67#64) (BitVec.neg_eq_not_add x‚úù))
              (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (67#64) (~~~x‚úù) 1#64)))
    [Meta.isDefEq.assign] [0.002089] ‚úÖÔ∏è ?h‚ÇÉ := fun a =>
          congrArg (fun x => some (1#64 <<< x))
            (Eq.trans (BitVec.sub_toAdd (67#64) x‚úù)
              (Eq.trans (congrArg (HAdd.hAdd 67#64) (BitVec.neg_eq_not_add x‚úù))
                (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (67#64) (~~~x‚úù) 1#64)))
      [Meta.isDefEq.assign.checkTypes] [0.002046] ‚úÖÔ∏è (?h‚ÇÉ : ¬¨(!64#64 >·µ§ 68#64 + ~~~x‚úù) = true ‚Üí
            some (1#64 <<< (67#64 - x‚úù)) =
              some
                (1#64 <<<
                  (68#64 +
                    ~~~x‚úù))) := (fun a =>
            congrArg (fun x => some (1#64 <<< x))
              (Eq.trans (BitVec.sub_toAdd (67#64) x‚úù)
                (Eq.trans (congrArg (HAdd.hAdd 67#64) (BitVec.neg_eq_not_add x‚úù))
                  (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (67#64) (~~~x‚úù)
                    1#64))) : ¬¨(!64#64 >·µ§ 68#64 + ~~~x‚úù) = true ‚Üí
            some (1#64 <<< (67#64 - x‚úù)) = some (1#64 <<< (67#64 + 1#64 + ~~~x‚úù)))
        [Meta.isDefEq] [0.002041] ‚úÖÔ∏è ¬¨(!64#64 >·µ§ 68#64 + ~~~x‚úù) = true ‚Üí
              some (1#64 <<< (67#64 - x‚úù)) =
                some
                  (1#64 <<<
                    (68#64 +
                      ~~~x‚úù)) =?= ¬¨(!64#64 >·µ§ 68#64 + ~~~x‚úù) = true ‚Üí
              some (1#64 <<< (67#64 - x‚úù)) = some (1#64 <<< (67#64 + 1#64 + ~~~x‚úù))
          [Meta.isDefEq] [0.001991] ‚úÖÔ∏è some (1#64 <<< (67#64 - x‚úù)) =
                some
                  (1#64 <<< (68#64 + ~~~x‚úù)) =?= some (1#64 <<< (67#64 - x‚úù)) = some (1#64 <<< (67#64 + 1#64 + ~~~x‚úù))
            [Meta.isDefEq] [0.001933] ‚úÖÔ∏è some (1#64 <<< (68#64 + ~~~x‚úù)) =?= some (1#64 <<< (67#64 + 1#64 + ~~~x‚úù))
              [Meta.isDefEq] [0.001901] ‚úÖÔ∏è 1#64 <<< (68#64 + ~~~x‚úù) =?= 1#64 <<< (67#64 + 1#64 + ~~~x‚úù)
                [Meta.isDefEq] [0.001859] ‚úÖÔ∏è BitVec.instHShiftLeft.1 (1#64)
                      (68#64 + ~~~x‚úù) =?= BitVec.instHShiftLeft.1 (1#64) (67#64 + 1#64 + ~~~x‚úù)
                  [Meta.isDefEq] [0.001773] ‚úÖÔ∏è 1#64 <<< (68#64 + ~~~x‚úù).toNat =?= 1#64 <<< (67#64 + 1#64 + ~~~x‚úù).toNat
                    [Meta.isDefEq] [0.001742] ‚úÖÔ∏è BitVec.instHShiftLeftNat.1 (1#64)
                          (68#64 + ~~~x‚úù).toNat =?= BitVec.instHShiftLeftNat.1 (1#64) (67#64 + 1#64 + ~~~x‚úù).toNat
                      [Meta.isDefEq] [0.001687] ‚úÖÔ∏è (1#64).shiftLeft
                            (68#64 + ~~~x‚úù).toNat =?= (1#64).shiftLeft (67#64 + 1#64 + ~~~x‚úù).toNat
                        [Meta.isDefEq.delta] [0.001671] ‚úÖÔ∏è (1#64).shiftLeft
                              (68#64 + ~~~x‚úù).toNat =?= (1#64).shiftLeft (67#64 + 1#64 + ~~~x‚úù).toNat
                          [Meta.isDefEq] [0.001520] ‚úÖÔ∏è (68#64 + ~~~x‚úù).toNat =?= (67#64 + 1#64 + ~~~x‚úù).toNat
                            [Meta.isDefEq.delta] [0.001497] ‚úÖÔ∏è (68#64 + ~~~x‚úù).toNat =?= (67#64 + 1#64 + ~~~x‚úù).toNat
                              [Meta.isDefEq] [0.001475] ‚úÖÔ∏è 68#64 + ~~~x‚úù =?= 67#64 + 1#64 + ~~~x‚úù
                                [Meta.isDefEq] [0.001305] ‚úÖÔ∏è instHAdd.1 (68#64)
                                      (~~~x‚úù) =?= instHAdd.1 (67#64 + 1#64) (~~~x‚úù)
                                  [Meta.isDefEq] [0.001228] ‚úÖÔ∏è Add.add (68#64)
                                        (~~~x‚úù) =?= Add.add (67#64 + 1#64) (~~~x‚úù)
                                    [Meta.isDefEq] [0.001037] ‚úÖÔ∏è BitVec.instAdd.1 (68#64)
                                          (~~~x‚úù) =?= BitVec.instAdd.1 (67#64 + 1#64) (~~~x‚úù)
  [Meta.isDefEq] [0.001666] ‚ùåÔ∏è ?a == ?a =?= 1#64 <<< (68#64 + ~~~x‚úù) >>> (68#64 + ~~~x‚úù) == 1#64
    [Meta.isDefEq] [0.001432] ‚úÖÔ∏è ?Œ± =?= BitVec 64
      [Meta.isDefEq.assign] [0.001425] ‚úÖÔ∏è ?Œ± := BitVec 64
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      x‚úù : BitVec 64
      a‚úù :
        ¬¨(if (!64#64 >·µ§ 68#64 + ~~~x‚úù) = true then none else some (1#64 <<< (68#64 + ~~~x‚úù))) ‚äë
            if (1#64 <<< (68#64 + ~~~x‚úù) >>> (68#64 + ~~~x‚úù) == 1#64) = true then none
            else if (!64#64 >·µ§ 68#64 + ~~~x‚úù) = true then none else some (1#64 <<< (68#64 + ~~~x‚úù))
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 0.611650ms, solving context: 0.000000ms
LeanSAT proved the goal after 2.896310ms: rewriting 2.879000ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 84.519870ms, solving context: 2.000000ms
LeanSAT proved the goal after 112.857431ms: rewriting 25.515870ms, bitblasting 0.000000ms, SAT solving 56.402830ms, LRAT trimming 9.338930ms, LRAT checking 5.118011ms
