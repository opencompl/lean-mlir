âš  [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
âš  [880/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
âš  [884/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
âš  [887/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
âš  [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhsub_proof.lean:16:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhsub_proof.lean:11:8: error: (kernel) declaration has metavariables 'shl_sub_i32_thm'
[bv] [0.058825] Normalizing goal
  [Meta.synthInstance] [0.001237] âœ…ï¸ Decidable
        ((if 31#32 - xâœ â‰¥ â†‘32 then none else some (1#32 <<< (31#32 - xâœ))) âŠ‘
          if xâœ â‰¥ â†‘32 then none else some (2147483648#32 >>> xâœ))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(if 31#32 - xâœ â‰¥ â†‘32 then none else some (1#32 <<< (31#32 - xâœ))) âŠ‘
            if xâœ â‰¥ â†‘32 then none else some (2147483648#32 >>> xâœ)
      âŠ¢ False
  [Meta.isDefEq] [0.003751] âŒï¸ ?a == ?a =?= (32#32 >áµ¤ 32#32 + ~~~xâœ) == true
    [Meta.isDefEq.onFailure] [0.003496] âŒï¸ ?a == ?a =?= (32#32 >áµ¤ 32#32 + ~~~xâœ) == true
      [Meta.synthInstance] [0.003474] ğŸ’¥ï¸ BEq ?Î±
        [Meta.synthInstance] [0.003387] new goal BEq ?Î±
  [Meta.isDefEq] [0.001231] âœ…ï¸ ?hâ‚ƒ =?= fun a =>
        congrArg (fun x => some (1#32 <<< x))
          (Eq.trans (BitVec.sub_toAdd (31#32) xâœ)
            (Eq.trans (congrArg (HAdd.hAdd 31#32) (BitVec.neg_eq_not_add xâœ))
              (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (31#32) (~~~xâœ) 1#32)))
    [Meta.isDefEq.assign] [0.001228] âœ…ï¸ ?hâ‚ƒ := fun a =>
          congrArg (fun x => some (1#32 <<< x))
            (Eq.trans (BitVec.sub_toAdd (31#32) xâœ)
              (Eq.trans (congrArg (HAdd.hAdd 31#32) (BitVec.neg_eq_not_add xâœ))
                (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (31#32) (~~~xâœ) 1#32)))
      [Meta.isDefEq.assign.checkTypes] [0.001200] âœ…ï¸ (?hâ‚ƒ : Â¬(!32#32 >áµ¤ 32#32 + ~~~xâœ) = true â†’
            some (1#32 <<< (31#32 - xâœ)) =
              some
                (1#32 <<<
                  (32#32 +
                    ~~~xâœ))) := (fun a =>
            congrArg (fun x => some (1#32 <<< x))
              (Eq.trans (BitVec.sub_toAdd (31#32) xâœ)
                (Eq.trans (congrArg (HAdd.hAdd 31#32) (BitVec.neg_eq_not_add xâœ))
                  (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (31#32) (~~~xâœ)
                    1#32))) : Â¬(!32#32 >áµ¤ 32#32 + ~~~xâœ) = true â†’
            some (1#32 <<< (31#32 - xâœ)) = some (1#32 <<< (31#32 + 1#32 + ~~~xâœ)))
        [Meta.isDefEq] [0.001197] âœ…ï¸ Â¬(!32#32 >áµ¤ 32#32 + ~~~xâœ) = true â†’
              some (1#32 <<< (31#32 - xâœ)) =
                some
                  (1#32 <<<
                    (32#32 +
                      ~~~xâœ)) =?= Â¬(!32#32 >áµ¤ 32#32 + ~~~xâœ) = true â†’
              some (1#32 <<< (31#32 - xâœ)) = some (1#32 <<< (31#32 + 1#32 + ~~~xâœ))
          [Meta.isDefEq] [0.001165] âœ…ï¸ some (1#32 <<< (31#32 - xâœ)) =
                some
                  (1#32 <<< (32#32 + ~~~xâœ)) =?= some (1#32 <<< (31#32 - xâœ)) = some (1#32 <<< (31#32 + 1#32 + ~~~xâœ))
            [Meta.isDefEq] [0.001130] âœ…ï¸ some (1#32 <<< (32#32 + ~~~xâœ)) =?= some (1#32 <<< (31#32 + 1#32 + ~~~xâœ))
              [Meta.isDefEq] [0.001116] âœ…ï¸ 1#32 <<< (32#32 + ~~~xâœ) =?= 1#32 <<< (31#32 + 1#32 + ~~~xâœ)
                [Meta.isDefEq] [0.001089] âœ…ï¸ BitVec.instHShiftLeft.1 (1#32)
                      (32#32 + ~~~xâœ) =?= BitVec.instHShiftLeft.1 (1#32) (31#32 + 1#32 + ~~~xâœ)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(if (!32#32 >áµ¤ 32#32 + ~~~xâœ) = true then none else some (1#32 <<< (32#32 + ~~~xâœ))) âŠ‘
            if (!32#32 >áµ¤ xâœ) = true then none else some (2147483648#32 >>> xâœ)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhsub_proof.lean:25:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhsub_proof.lean:20:8: error: (kernel) declaration has metavariables 'shl_sub_i8_thm'
[bv] [0.034064] Normalizing goal
  [Meta.synthInstance] [0.001317] âœ…ï¸ Decidable
        ((if 7#8 - xâœ â‰¥ â†‘8 then none else some (1#8 <<< (7#8 - xâœ))) âŠ‘ if xâœ â‰¥ â†‘8 then none else some (128#8 >>> xâœ))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      xâœ : BitVec 8
      aâœ : Â¬(if 7#8 - xâœ â‰¥ â†‘8 then none else some (1#8 <<< (7#8 - xâœ))) âŠ‘ if xâœ â‰¥ â†‘8 then none else some (128#8 >>> xâœ)
      âŠ¢ False
  [Meta.isDefEq] [0.001276] âœ…ï¸ ?hâ‚ƒ =?= fun a =>
        congrArg (fun x => some (1#8 <<< x))
          (Eq.trans (BitVec.sub_toAdd (7#8) xâœ)
            (Eq.trans (congrArg (HAdd.hAdd 7#8) (BitVec.neg_eq_not_add xâœ))
              (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (7#8) (~~~xâœ) 1#8)))
    [Meta.isDefEq.assign] [0.001272] âœ…ï¸ ?hâ‚ƒ := fun a =>
          congrArg (fun x => some (1#8 <<< x))
            (Eq.trans (BitVec.sub_toAdd (7#8) xâœ)
              (Eq.trans (congrArg (HAdd.hAdd 7#8) (BitVec.neg_eq_not_add xâœ))
                (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (7#8) (~~~xâœ) 1#8)))
      [Meta.isDefEq.assign.checkTypes] [0.001236] âœ…ï¸ (?hâ‚ƒ : Â¬(!8#8 >áµ¤ 8#8 + ~~~xâœ) = true â†’
            some (1#8 <<< (7#8 - xâœ)) =
              some
                (1#8 <<<
                  (8#8 +
                    ~~~xâœ))) := (fun a =>
            congrArg (fun x => some (1#8 <<< x))
              (Eq.trans (BitVec.sub_toAdd (7#8) xâœ)
                (Eq.trans (congrArg (HAdd.hAdd 7#8) (BitVec.neg_eq_not_add xâœ))
                  (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (7#8) (~~~xâœ)
                    1#8))) : Â¬(!8#8 >áµ¤ 8#8 + ~~~xâœ) = true â†’
            some (1#8 <<< (7#8 - xâœ)) = some (1#8 <<< (7#8 + 1#8 + ~~~xâœ)))
        [Meta.isDefEq] [0.001231] âœ…ï¸ Â¬(!8#8 >áµ¤ 8#8 + ~~~xâœ) = true â†’
              some (1#8 <<< (7#8 - xâœ)) =
                some
                  (1#8 <<<
                    (8#8 +
                      ~~~xâœ)) =?= Â¬(!8#8 >áµ¤ 8#8 + ~~~xâœ) = true â†’
              some (1#8 <<< (7#8 - xâœ)) = some (1#8 <<< (7#8 + 1#8 + ~~~xâœ))
          [Meta.isDefEq] [0.001198] âœ…ï¸ some (1#8 <<< (7#8 - xâœ)) =
                some (1#8 <<< (8#8 + ~~~xâœ)) =?= some (1#8 <<< (7#8 - xâœ)) = some (1#8 <<< (7#8 + 1#8 + ~~~xâœ))
            [Meta.isDefEq] [0.001147] âœ…ï¸ some (1#8 <<< (8#8 + ~~~xâœ)) =?= some (1#8 <<< (7#8 + 1#8 + ~~~xâœ))
              [Meta.isDefEq] [0.001127] âœ…ï¸ 1#8 <<< (8#8 + ~~~xâœ) =?= 1#8 <<< (7#8 + 1#8 + ~~~xâœ)
                [Meta.isDefEq] [0.001098] âœ…ï¸ BitVec.instHShiftLeft.1 (1#8)
                      (8#8 + ~~~xâœ) =?= BitVec.instHShiftLeft.1 (1#8) (7#8 + 1#8 + ~~~xâœ)
                  [Meta.isDefEq] [0.001037] âœ…ï¸ 1#8 <<< (8#8 + ~~~xâœ).toNat =?= 1#8 <<< (7#8 + 1#8 + ~~~xâœ).toNat
                    [Meta.isDefEq] [0.001016] âœ…ï¸ BitVec.instHShiftLeftNat.1 (1#8)
                          (8#8 + ~~~xâœ).toNat =?= BitVec.instHShiftLeftNat.1 (1#8) (7#8 + 1#8 + ~~~xâœ).toNat
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      xâœ : BitVec 8
      aâœ :
        Â¬(if (!8#8 >áµ¤ 8#8 + ~~~xâœ) = true then none else some (1#8 <<< (8#8 + ~~~xâœ))) âŠ‘
            if (!8#8 >áµ¤ xâœ) = true then none else some (128#8 >>> xâœ)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhsub_proof.lean:35:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhsub_proof.lean:29:8: error: (kernel) declaration has metavariables 'shl_sub_i64_thm'
[bv] [0.037921] Normalizing goal
  [Meta.synthInstance] [0.001286] âœ…ï¸ Decidable
        ((if 63#64 - xâœ â‰¥ â†‘64 then none else some (1#64 <<< (63#64 - xâœ))) âŠ‘
          if xâœ â‰¥ â†‘64 then none else some (9223372036854775808#64 >>> xâœ))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      xâœ : BitVec 64
      aâœ :
        Â¬(if 63#64 - xâœ â‰¥ â†‘64 then none else some (1#64 <<< (63#64 - xâœ))) âŠ‘
            if xâœ â‰¥ â†‘64 then none else some (9223372036854775808#64 >>> xâœ)
      âŠ¢ False
  [Meta.isDefEq] [0.001197] âœ…ï¸ ?hâ‚ƒ =?= fun a =>
        congrArg (fun x => some (1#64 <<< x))
          (Eq.trans (BitVec.sub_toAdd (63#64) xâœ)
            (Eq.trans (congrArg (HAdd.hAdd 63#64) (BitVec.neg_eq_not_add xâœ))
              (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (63#64) (~~~xâœ) 1#64)))
    [Meta.isDefEq.assign] [0.001194] âœ…ï¸ ?hâ‚ƒ := fun a =>
          congrArg (fun x => some (1#64 <<< x))
            (Eq.trans (BitVec.sub_toAdd (63#64) xâœ)
              (Eq.trans (congrArg (HAdd.hAdd 63#64) (BitVec.neg_eq_not_add xâœ))
                (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (63#64) (~~~xâœ) 1#64)))
      [Meta.isDefEq.assign.checkTypes] [0.001164] âœ…ï¸ (?hâ‚ƒ : Â¬(!64#64 >áµ¤ 64#64 + ~~~xâœ) = true â†’
            some (1#64 <<< (63#64 - xâœ)) =
              some
                (1#64 <<<
                  (64#64 +
                    ~~~xâœ))) := (fun a =>
            congrArg (fun x => some (1#64 <<< x))
              (Eq.trans (BitVec.sub_toAdd (63#64) xâœ)
                (Eq.trans (congrArg (HAdd.hAdd 63#64) (BitVec.neg_eq_not_add xâœ))
                  (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (63#64) (~~~xâœ)
                    1#64))) : Â¬(!64#64 >áµ¤ 64#64 + ~~~xâœ) = true â†’
            some (1#64 <<< (63#64 - xâœ)) = some (1#64 <<< (63#64 + 1#64 + ~~~xâœ)))
        [Meta.isDefEq] [0.001161] âœ…ï¸ Â¬(!64#64 >áµ¤ 64#64 + ~~~xâœ) = true â†’
              some (1#64 <<< (63#64 - xâœ)) =
                some
                  (1#64 <<<
                    (64#64 +
                      ~~~xâœ)) =?= Â¬(!64#64 >áµ¤ 64#64 + ~~~xâœ) = true â†’
              some (1#64 <<< (63#64 - xâœ)) = some (1#64 <<< (63#64 + 1#64 + ~~~xâœ))
          [Meta.isDefEq] [0.001130] âœ…ï¸ some (1#64 <<< (63#64 - xâœ)) =
                some
                  (1#64 <<< (64#64 + ~~~xâœ)) =?= some (1#64 <<< (63#64 - xâœ)) = some (1#64 <<< (63#64 + 1#64 + ~~~xâœ))
            [Meta.isDefEq] [0.001095] âœ…ï¸ some (1#64 <<< (64#64 + ~~~xâœ)) =?= some (1#64 <<< (63#64 + 1#64 + ~~~xâœ))
              [Meta.isDefEq] [0.001078] âœ…ï¸ 1#64 <<< (64#64 + ~~~xâœ) =?= 1#64 <<< (63#64 + 1#64 + ~~~xâœ)
                [Meta.isDefEq] [0.001049] âœ…ï¸ BitVec.instHShiftLeft.1 (1#64)
                      (64#64 + ~~~xâœ) =?= BitVec.instHShiftLeft.1 (1#64) (63#64 + 1#64 + ~~~xâœ)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      xâœ : BitVec 64
      aâœ :
        Â¬(if (!64#64 >áµ¤ 64#64 + ~~~xâœ) = true then none else some (1#64 <<< (64#64 + ~~~xâœ))) âŠ‘
            if (!64#64 >áµ¤ xâœ) = true then none else some (9223372036854775808#64 >>> xâœ)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhsub_proof.lean:46:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhsub_proof.lean:39:8: error: (kernel) declaration has metavariables 'shl_bad_sub_i32_thm'
[bv] [0.035995] Normalizing goal
  [Meta.synthInstance] [0.001263] âœ…ï¸ Decidable
        ((if 32#32 - xâœ â‰¥ â†‘32 then none else some (1#32 <<< (32#32 - xâœ))) âŠ‘
          if True âˆ§ 1#32 <<< (32#32 - xâœ) >>> (32#32 - xâœ) = 1#32 then none
          else if 32#32 - xâœ â‰¥ â†‘32 then none else some (1#32 <<< (32#32 - xâœ)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(if 32#32 - xâœ â‰¥ â†‘32 then none else some (1#32 <<< (32#32 - xâœ))) âŠ‘
            if True âˆ§ 1#32 <<< (32#32 - xâœ) >>> (32#32 - xâœ) = 1#32 then none
            else if 32#32 - xâœ â‰¥ â†‘32 then none else some (1#32 <<< (32#32 - xâœ))
      âŠ¢ False
  [Meta.isDefEq] [0.004737] âœ…ï¸ ?hâ‚ƒ =?= fun a =>
        congrArg (fun x => some (1#32 <<< x))
          (Eq.trans (BitVec.sub_toAdd (32#32) xâœ)
            (Eq.trans (congrArg (HAdd.hAdd 32#32) (BitVec.neg_eq_not_add xâœ))
              (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (32#32) (~~~xâœ) 1#32)))
    [Meta.isDefEq.assign] [0.004734] âœ…ï¸ ?hâ‚ƒ := fun a =>
          congrArg (fun x => some (1#32 <<< x))
            (Eq.trans (BitVec.sub_toAdd (32#32) xâœ)
              (Eq.trans (congrArg (HAdd.hAdd 32#32) (BitVec.neg_eq_not_add xâœ))
                (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (32#32) (~~~xâœ) 1#32)))
      [Meta.isDefEq.assign.checkTypes] [0.004703] âœ…ï¸ (?hâ‚ƒ : Â¬(!32#32 >áµ¤ 33#32 + ~~~xâœ) = true â†’
            some (1#32 <<< (32#32 - xâœ)) =
              some
                (1#32 <<<
                  (33#32 +
                    ~~~xâœ))) := (fun a =>
            congrArg (fun x => some (1#32 <<< x))
              (Eq.trans (BitVec.sub_toAdd (32#32) xâœ)
                (Eq.trans (congrArg (HAdd.hAdd 32#32) (BitVec.neg_eq_not_add xâœ))
                  (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (32#32) (~~~xâœ)
                    1#32))) : Â¬(!32#32 >áµ¤ 33#32 + ~~~xâœ) = true â†’
            some (1#32 <<< (32#32 - xâœ)) = some (1#32 <<< (32#32 + 1#32 + ~~~xâœ)))
        [Meta.isDefEq] [0.004700] âœ…ï¸ Â¬(!32#32 >áµ¤ 33#32 + ~~~xâœ) = true â†’
              some (1#32 <<< (32#32 - xâœ)) =
                some
                  (1#32 <<<
                    (33#32 +
                      ~~~xâœ)) =?= Â¬(!32#32 >áµ¤ 33#32 + ~~~xâœ) = true â†’
              some (1#32 <<< (32#32 - xâœ)) = some (1#32 <<< (32#32 + 1#32 + ~~~xâœ))
          [Meta.isDefEq] [0.004665] âœ…ï¸ some (1#32 <<< (32#32 - xâœ)) =
                some
                  (1#32 <<< (33#32 + ~~~xâœ)) =?= some (1#32 <<< (32#32 - xâœ)) = some (1#32 <<< (32#32 + 1#32 + ~~~xâœ))
            [Meta.isDefEq] [0.004616] âœ…ï¸ some (1#32 <<< (33#32 + ~~~xâœ)) =?= some (1#32 <<< (32#32 + 1#32 + ~~~xâœ))
              [Meta.isDefEq] [0.004587] âœ…ï¸ 1#32 <<< (33#32 + ~~~xâœ) =?= 1#32 <<< (32#32 + 1#32 + ~~~xâœ)
                [Meta.isDefEq] [0.004550] âœ…ï¸ BitVec.instHShiftLeft.1 (1#32)
                      (33#32 + ~~~xâœ) =?= BitVec.instHShiftLeft.1 (1#32) (32#32 + 1#32 + ~~~xâœ)
                  [Meta.isDefEq] [0.004485] âœ…ï¸ 1#32 <<< (33#32 + ~~~xâœ).toNat =?= 1#32 <<< (32#32 + 1#32 + ~~~xâœ).toNat
                    [Meta.isDefEq] [0.001364] âœ…ï¸ BitVec.instHShiftLeftNat.1 (1#32)
                          (33#32 + ~~~xâœ).toNat =?= BitVec.instHShiftLeftNat.1 (1#32) (32#32 + 1#32 + ~~~xâœ).toNat
                      [Meta.isDefEq] [0.001320] âœ…ï¸ (1#32).shiftLeft
                            (33#32 + ~~~xâœ).toNat =?= (1#32).shiftLeft (32#32 + 1#32 + ~~~xâœ).toNat
                        [Meta.isDefEq.delta] [0.001307] âœ…ï¸ (1#32).shiftLeft
                              (33#32 + ~~~xâœ).toNat =?= (1#32).shiftLeft (32#32 + 1#32 + ~~~xâœ).toNat
                          [Meta.isDefEq] [0.001279] âœ…ï¸ (33#32 + ~~~xâœ).toNat =?= (32#32 + 1#32 + ~~~xâœ).toNat
                            [Meta.isDefEq.delta] [0.001262] âœ…ï¸ (33#32 + ~~~xâœ).toNat =?= (32#32 + 1#32 + ~~~xâœ).toNat
                              [Meta.isDefEq] [0.001243] âœ…ï¸ 33#32 + ~~~xâœ =?= 32#32 + 1#32 + ~~~xâœ
                                [Meta.isDefEq] [0.001105] âœ…ï¸ instHAdd.1 (33#32)
                                      (~~~xâœ) =?= instHAdd.1 (32#32 + 1#32) (~~~xâœ)
                                  [Meta.isDefEq] [0.001060] âœ…ï¸ Add.add (33#32)
                                        (~~~xâœ) =?= Add.add (32#32 + 1#32) (~~~xâœ)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(if (!32#32 >áµ¤ 33#32 + ~~~xâœ) = true then none else some (1#32 <<< (33#32 + ~~~xâœ))) âŠ‘
            if (1#32 <<< (33#32 + ~~~xâœ) >>> (33#32 + ~~~xâœ) == 1#32) = true then none
            else if (!32#32 >áµ¤ 33#32 + ~~~xâœ) = true then none else some (1#32 <<< (33#32 + ~~~xâœ))
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhsub_proof.lean:57:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhsub_proof.lean:50:8: error: (kernel) declaration has metavariables 'shl_bad_sub2_i32_thm'
[bv] [0.030335] Normalizing goal
  [Meta.synthInstance] [0.001291] âœ…ï¸ Decidable
        ((if xâœ - 31#32 â‰¥ â†‘32 then none else some (1#32 <<< (xâœ - 31#32))) âŠ‘
          if True âˆ§ 1#32 <<< (xâœ + 4294967265#32) >>> (xâœ + 4294967265#32) = 1#32 then none
          else if xâœ + 4294967265#32 â‰¥ â†‘32 then none else some (1#32 <<< (xâœ + 4294967265#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(if xâœ - 31#32 â‰¥ â†‘32 then none else some (1#32 <<< (xâœ - 31#32))) âŠ‘
            if True âˆ§ 1#32 <<< (xâœ + 4294967265#32) >>> (xâœ + 4294967265#32) = 1#32 then none
            else if xâœ + 4294967265#32 â‰¥ â†‘32 then none else some (1#32 <<< (xâœ + 4294967265#32))
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(if (!32#32 >áµ¤ xâœ + 4294967265#32) = true then none else some (1#32 <<< (xâœ + 4294967265#32))) âŠ‘
            if (1#32 <<< (xâœ + 4294967265#32) >>> (xâœ + 4294967265#32) == 1#32) = true then none
            else if (!32#32 >áµ¤ xâœ + 4294967265#32) = true then none else some (1#32 <<< (xâœ + 4294967265#32))
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhsub_proof.lean:68:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhsub_proof.lean:61:8: error: (kernel) declaration has metavariables 'bad_shl2_sub_i32_thm'
[bv] [0.032213] Normalizing goal
  [Meta.synthInstance] [0.001349] âœ…ï¸ Decidable
        ((if xâœ - 31#32 â‰¥ â†‘32 then none else some (1#32 <<< (xâœ - 31#32))) âŠ‘
          if True âˆ§ 1#32 <<< (xâœ + 4294967265#32) >>> (xâœ + 4294967265#32) = 1#32 then none
          else if xâœ + 4294967265#32 â‰¥ â†‘32 then none else some (1#32 <<< (xâœ + 4294967265#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(if xâœ - 31#32 â‰¥ â†‘32 then none else some (1#32 <<< (xâœ - 31#32))) âŠ‘
            if True âˆ§ 1#32 <<< (xâœ + 4294967265#32) >>> (xâœ + 4294967265#32) = 1#32 then none
            else if xâœ + 4294967265#32 â‰¥ â†‘32 then none else some (1#32 <<< (xâœ + 4294967265#32))
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(if (!32#32 >áµ¤ xâœ + 4294967265#32) = true then none else some (1#32 <<< (xâœ + 4294967265#32))) âŠ‘
            if (1#32 <<< (xâœ + 4294967265#32) >>> (xâœ + 4294967265#32) == 1#32) = true then none
            else if (!32#32 >áµ¤ xâœ + 4294967265#32) = true then none else some (1#32 <<< (xâœ + 4294967265#32))
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhsub_proof.lean:79:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhsub_proof.lean:72:8: error: (kernel) declaration has metavariables 'shl_bad_sub_i8_thm'
[bv] [0.034122] Normalizing goal
  [Meta.synthInstance] [0.001254] âœ…ï¸ Decidable
        ((if 4#8 - xâœ â‰¥ â†‘8 then none else some (1#8 <<< (4#8 - xâœ))) âŠ‘
          if True âˆ§ 1#8 <<< (4#8 - xâœ) >>> (4#8 - xâœ) = 1#8 then none
          else if 4#8 - xâœ â‰¥ â†‘8 then none else some (1#8 <<< (4#8 - xâœ)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      xâœ : BitVec 8
      aâœ :
        Â¬(if 4#8 - xâœ â‰¥ â†‘8 then none else some (1#8 <<< (4#8 - xâœ))) âŠ‘
            if True âˆ§ 1#8 <<< (4#8 - xâœ) >>> (4#8 - xâœ) = 1#8 then none
            else if 4#8 - xâœ â‰¥ â†‘8 then none else some (1#8 <<< (4#8 - xâœ))
      âŠ¢ False
  [Meta.isDefEq] [0.001334] âœ…ï¸ ?hâ‚ƒ =?= fun a =>
        congrArg (fun x => some (1#8 <<< x))
          (Eq.trans (BitVec.sub_toAdd (4#8) xâœ)
            (Eq.trans (congrArg (HAdd.hAdd 4#8) (BitVec.neg_eq_not_add xâœ))
              (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (4#8) (~~~xâœ) 1#8)))
    [Meta.isDefEq.assign] [0.001331] âœ…ï¸ ?hâ‚ƒ := fun a =>
          congrArg (fun x => some (1#8 <<< x))
            (Eq.trans (BitVec.sub_toAdd (4#8) xâœ)
              (Eq.trans (congrArg (HAdd.hAdd 4#8) (BitVec.neg_eq_not_add xâœ))
                (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (4#8) (~~~xâœ) 1#8)))
      [Meta.isDefEq.assign.checkTypes] [0.001277] âœ…ï¸ (?hâ‚ƒ : Â¬(!8#8 >áµ¤ 5#8 + ~~~xâœ) = true â†’
            some (1#8 <<< (4#8 - xâœ)) =
              some
                (1#8 <<<
                  (5#8 +
                    ~~~xâœ))) := (fun a =>
            congrArg (fun x => some (1#8 <<< x))
              (Eq.trans (BitVec.sub_toAdd (4#8) xâœ)
                (Eq.trans (congrArg (HAdd.hAdd 4#8) (BitVec.neg_eq_not_add xâœ))
                  (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (4#8) (~~~xâœ)
                    1#8))) : Â¬(!8#8 >áµ¤ 5#8 + ~~~xâœ) = true â†’
            some (1#8 <<< (4#8 - xâœ)) = some (1#8 <<< (4#8 + 1#8 + ~~~xâœ)))
        [Meta.isDefEq] [0.001274] âœ…ï¸ Â¬(!8#8 >áµ¤ 5#8 + ~~~xâœ) = true â†’
              some (1#8 <<< (4#8 - xâœ)) =
                some
                  (1#8 <<<
                    (5#8 +
                      ~~~xâœ)) =?= Â¬(!8#8 >áµ¤ 5#8 + ~~~xâœ) = true â†’
              some (1#8 <<< (4#8 - xâœ)) = some (1#8 <<< (4#8 + 1#8 + ~~~xâœ))
          [Meta.isDefEq] [0.001241] âœ…ï¸ some (1#8 <<< (4#8 - xâœ)) =
                some (1#8 <<< (5#8 + ~~~xâœ)) =?= some (1#8 <<< (4#8 - xâœ)) = some (1#8 <<< (4#8 + 1#8 + ~~~xâœ))
            [Meta.isDefEq] [0.001206] âœ…ï¸ some (1#8 <<< (5#8 + ~~~xâœ)) =?= some (1#8 <<< (4#8 + 1#8 + ~~~xâœ))
              [Meta.isDefEq] [0.001184] âœ…ï¸ 1#8 <<< (5#8 + ~~~xâœ) =?= 1#8 <<< (4#8 + 1#8 + ~~~xâœ)
                [Meta.isDefEq] [0.001159] âœ…ï¸ BitVec.instHShiftLeft.1 (1#8)
                      (5#8 + ~~~xâœ) =?= BitVec.instHShiftLeft.1 (1#8) (4#8 + 1#8 + ~~~xâœ)
                  [Meta.isDefEq] [0.001102] âœ…ï¸ 1#8 <<< (5#8 + ~~~xâœ).toNat =?= 1#8 <<< (4#8 + 1#8 + ~~~xâœ).toNat
                    [Meta.isDefEq] [0.001080] âœ…ï¸ BitVec.instHShiftLeftNat.1 (1#8)
                          (5#8 + ~~~xâœ).toNat =?= BitVec.instHShiftLeftNat.1 (1#8) (4#8 + 1#8 + ~~~xâœ).toNat
                      [Meta.isDefEq] [0.001036] âœ…ï¸ (1#8).shiftLeft
                            (5#8 + ~~~xâœ).toNat =?= (1#8).shiftLeft (4#8 + 1#8 + ~~~xâœ).toNat
                        [Meta.isDefEq.delta] [0.001026] âœ…ï¸ (1#8).shiftLeft
                              (5#8 + ~~~xâœ).toNat =?= (1#8).shiftLeft (4#8 + 1#8 + ~~~xâœ).toNat
                          [Meta.isDefEq] [0.001001] âœ…ï¸ (5#8 + ~~~xâœ).toNat =?= (4#8 + 1#8 + ~~~xâœ).toNat
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      xâœ : BitVec 8
      aâœ :
        Â¬(if (!8#8 >áµ¤ 5#8 + ~~~xâœ) = true then none else some (1#8 <<< (5#8 + ~~~xâœ))) âŠ‘
            if (1#8 <<< (5#8 + ~~~xâœ) >>> (5#8 + ~~~xâœ) == 1#8) = true then none
            else if (!8#8 >áµ¤ 5#8 + ~~~xâœ) = true then none else some (1#8 <<< (5#8 + ~~~xâœ))
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhsub_proof.lean:90:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhsub_proof.lean:83:8: error: (kernel) declaration has metavariables 'shl_bad_sub_i64_thm'
[bv] [0.049521] Normalizing goal
  [Meta.synthInstance] [0.001884] âœ…ï¸ Decidable
        ((if 67#64 - xâœ â‰¥ â†‘64 then none else some (1#64 <<< (67#64 - xâœ))) âŠ‘
          if True âˆ§ 1#64 <<< (67#64 - xâœ) >>> (67#64 - xâœ) = 1#64 then none
          else if 67#64 - xâœ â‰¥ â†‘64 then none else some (1#64 <<< (67#64 - xâœ)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      xâœ : BitVec 64
      aâœ :
        Â¬(if 67#64 - xâœ â‰¥ â†‘64 then none else some (1#64 <<< (67#64 - xâœ))) âŠ‘
            if True âˆ§ 1#64 <<< (67#64 - xâœ) >>> (67#64 - xâœ) = 1#64 then none
            else if 67#64 - xâœ â‰¥ â†‘64 then none else some (1#64 <<< (67#64 - xâœ))
      âŠ¢ False
  [Meta.isDefEq] [0.002094] âœ…ï¸ ?hâ‚ƒ =?= fun a =>
        congrArg (fun x => some (1#64 <<< x))
          (Eq.trans (BitVec.sub_toAdd (67#64) xâœ)
            (Eq.trans (congrArg (HAdd.hAdd 67#64) (BitVec.neg_eq_not_add xâœ))
              (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (67#64) (~~~xâœ) 1#64)))
    [Meta.isDefEq.assign] [0.002089] âœ…ï¸ ?hâ‚ƒ := fun a =>
          congrArg (fun x => some (1#64 <<< x))
            (Eq.trans (BitVec.sub_toAdd (67#64) xâœ)
              (Eq.trans (congrArg (HAdd.hAdd 67#64) (BitVec.neg_eq_not_add xâœ))
                (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (67#64) (~~~xâœ) 1#64)))
      [Meta.isDefEq.assign.checkTypes] [0.002046] âœ…ï¸ (?hâ‚ƒ : Â¬(!64#64 >áµ¤ 68#64 + ~~~xâœ) = true â†’
            some (1#64 <<< (67#64 - xâœ)) =
              some
                (1#64 <<<
                  (68#64 +
                    ~~~xâœ))) := (fun a =>
            congrArg (fun x => some (1#64 <<< x))
              (Eq.trans (BitVec.sub_toAdd (67#64) xâœ)
                (Eq.trans (congrArg (HAdd.hAdd 67#64) (BitVec.neg_eq_not_add xâœ))
                  (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (67#64) (~~~xâœ)
                    1#64))) : Â¬(!64#64 >áµ¤ 68#64 + ~~~xâœ) = true â†’
            some (1#64 <<< (67#64 - xâœ)) = some (1#64 <<< (67#64 + 1#64 + ~~~xâœ)))
        [Meta.isDefEq] [0.002041] âœ…ï¸ Â¬(!64#64 >áµ¤ 68#64 + ~~~xâœ) = true â†’
              some (1#64 <<< (67#64 - xâœ)) =
                some
                  (1#64 <<<
                    (68#64 +
                      ~~~xâœ)) =?= Â¬(!64#64 >áµ¤ 68#64 + ~~~xâœ) = true â†’
              some (1#64 <<< (67#64 - xâœ)) = some (1#64 <<< (67#64 + 1#64 + ~~~xâœ))
          [Meta.isDefEq] [0.001991] âœ…ï¸ some (1#64 <<< (67#64 - xâœ)) =
                some
                  (1#64 <<< (68#64 + ~~~xâœ)) =?= some (1#64 <<< (67#64 - xâœ)) = some (1#64 <<< (67#64 + 1#64 + ~~~xâœ))
            [Meta.isDefEq] [0.001933] âœ…ï¸ some (1#64 <<< (68#64 + ~~~xâœ)) =?= some (1#64 <<< (67#64 + 1#64 + ~~~xâœ))
              [Meta.isDefEq] [0.001901] âœ…ï¸ 1#64 <<< (68#64 + ~~~xâœ) =?= 1#64 <<< (67#64 + 1#64 + ~~~xâœ)
                [Meta.isDefEq] [0.001859] âœ…ï¸ BitVec.instHShiftLeft.1 (1#64)
                      (68#64 + ~~~xâœ) =?= BitVec.instHShiftLeft.1 (1#64) (67#64 + 1#64 + ~~~xâœ)
                  [Meta.isDefEq] [0.001773] âœ…ï¸ 1#64 <<< (68#64 + ~~~xâœ).toNat =?= 1#64 <<< (67#64 + 1#64 + ~~~xâœ).toNat
                    [Meta.isDefEq] [0.001742] âœ…ï¸ BitVec.instHShiftLeftNat.1 (1#64)
                          (68#64 + ~~~xâœ).toNat =?= BitVec.instHShiftLeftNat.1 (1#64) (67#64 + 1#64 + ~~~xâœ).toNat
                      [Meta.isDefEq] [0.001687] âœ…ï¸ (1#64).shiftLeft
                            (68#64 + ~~~xâœ).toNat =?= (1#64).shiftLeft (67#64 + 1#64 + ~~~xâœ).toNat
                        [Meta.isDefEq.delta] [0.001671] âœ…ï¸ (1#64).shiftLeft
                              (68#64 + ~~~xâœ).toNat =?= (1#64).shiftLeft (67#64 + 1#64 + ~~~xâœ).toNat
                          [Meta.isDefEq] [0.001520] âœ…ï¸ (68#64 + ~~~xâœ).toNat =?= (67#64 + 1#64 + ~~~xâœ).toNat
                            [Meta.isDefEq.delta] [0.001497] âœ…ï¸ (68#64 + ~~~xâœ).toNat =?= (67#64 + 1#64 + ~~~xâœ).toNat
                              [Meta.isDefEq] [0.001475] âœ…ï¸ 68#64 + ~~~xâœ =?= 67#64 + 1#64 + ~~~xâœ
                                [Meta.isDefEq] [0.001305] âœ…ï¸ instHAdd.1 (68#64)
                                      (~~~xâœ) =?= instHAdd.1 (67#64 + 1#64) (~~~xâœ)
                                  [Meta.isDefEq] [0.001228] âœ…ï¸ Add.add (68#64)
                                        (~~~xâœ) =?= Add.add (67#64 + 1#64) (~~~xâœ)
                                    [Meta.isDefEq] [0.001037] âœ…ï¸ BitVec.instAdd.1 (68#64)
                                          (~~~xâœ) =?= BitVec.instAdd.1 (67#64 + 1#64) (~~~xâœ)
  [Meta.isDefEq] [0.001666] âŒï¸ ?a == ?a =?= 1#64 <<< (68#64 + ~~~xâœ) >>> (68#64 + ~~~xâœ) == 1#64
    [Meta.isDefEq] [0.001432] âœ…ï¸ ?Î± =?= BitVec 64
      [Meta.isDefEq.assign] [0.001425] âœ…ï¸ ?Î± := BitVec 64
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      xâœ : BitVec 64
      aâœ :
        Â¬(if (!64#64 >áµ¤ 68#64 + ~~~xâœ) = true then none else some (1#64 <<< (68#64 + ~~~xâœ))) âŠ‘
            if (1#64 <<< (68#64 + ~~~xâœ) >>> (68#64 + ~~~xâœ) == 1#64) = true then none
            else if (!64#64 >áµ¤ 68#64 + ~~~xâœ) = true then none else some (1#64 <<< (68#64 + ~~~xâœ))
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 0.611650ms, solving context: 0.000000ms
LeanSAT proved the goal after 2.896310ms: rewriting 2.879000ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 84.519870ms, solving context: 2.000000ms
LeanSAT proved the goal after 112.857431ms: rewriting 25.515870ms, bitblasting 0.000000ms, SAT solving 56.402830ms, LRAT trimming 9.338930ms, LRAT checking 5.118011ms
