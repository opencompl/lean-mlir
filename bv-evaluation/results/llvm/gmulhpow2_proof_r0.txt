⚠ [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
⚠ [864/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
⚠ [884/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [887/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
⚠ [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gmulhpow2_proof.lean:17:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gmulhpow2_proof.lean:11:8: error: (kernel) declaration has metavariables 'mul_selectp2_x_thm'
[bv] [0.081776] Normalizing goal
  [Meta.synthInstance] [0.002242] ✅️ Decidable
        ((Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 2#8
            | some { toFin := ⟨0, ⋯⟩ } => some 4#8)
            fun x' => some (x' * x✝¹)) ⊑
          Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 1#8
            | some { toFin := ⟨0, ⋯⟩ } => some 2#8)
            fun y' => if y' ≥ ↑8 then none else some (x✝¹ <<< y'))
    [Meta.check] [0.001295] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 2#8
            | some { toFin := ⟨0, ⋯⟩ } => some 4#8)
            fun x' => some (x' * x✝¹))
          (Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 1#8
            | some { toFin := ⟨0, ⋯⟩ } => some 2#8)
            fun y' => if y' ≥ ↑8 then none else some (x✝¹ <<< y'))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 1
      x✝¹ : BitVec 8
      x✝ : BitVec 1
      a✝ :
        ¬(Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 2#8
              | some { toFin := ⟨0, ⋯⟩ } => some 4#8)
              fun x' => some (x' * x✝¹)) ⊑
            Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 1#8
              | some { toFin := ⟨0, ⋯⟩ } => some 2#8)
              fun y' => if y' ≥ ↑8 then none else some (x✝¹ <<< y')
      ⊢ False
  [Meta.isDefEq] [0.001090] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 2#8
      | some { toFin := ⟨0, ⋯⟩ } => some 4#8
  [Meta.isDefEq] [0.001044] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 2#8
      | some { toFin := ⟨0, ⋯⟩ } => some 4#8
  [Meta.isDefEq] [0.001069] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#8
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.isDefEq] [0.001044] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#8
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.isDefEq] [0.001068] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 2#8
      | some { toFin := ⟨0, ⋯⟩ } => some 4#8
  [Meta.isDefEq] [0.001227] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 2#8
      | some { toFin := ⟨0, ⋯⟩ } => some 4#8
  [Meta.isDefEq] [0.001174] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 2#8
      | some { toFin := ⟨0, ⋯⟩ } => some 4#8
  [Meta.isDefEq] [0.001083] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#8
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.isDefEq] [0.001183] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#8
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.isDefEq] [0.001186] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#8
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 1
      x✝¹ : BitVec 8
      x✝ : BitVec 1
      a✝ :
        ¬(Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 2#8
              | some { toFin := ⟨0, ⋯⟩ } => some 4#8)
              fun x' => some (x' * x✝¹)) ⊑
            Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 1#8
              | some { toFin := ⟨0, ⋯⟩ } => some 2#8)
              fun a => if (!8#8 >ᵤ a) = true then none else some (x✝¹ <<< a)
      ⊢ False
  [Meta.isDefEq] [0.001057] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 2#8
      | some { toFin := ⟨0, ⋯⟩ } => some 4#8
  [Meta.isDefEq] [0.001100] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#8
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.isDefEq] [0.001108] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#8
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.isDefEq] [0.001051] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 2#8
      | some { toFin := ⟨0, ⋯⟩ } => some 4#8
  [Meta.isDefEq] [0.001080] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#8
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.isDefEq] [0.001110] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#8
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gmulhpow2_proof.lean:28:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gmulhpow2_proof.lean:21:8: error: (kernel) declaration has metavariables 'mul_selectp2_x_propegate_nuw_thm'
[bv] [0.191327] Normalizing goal
  [Meta.synthInstance] [0.003966] ✅️ Decidable
        ((Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 2#8
            | some { toFin := ⟨0, ⋯⟩ } => some 4#8)
            fun x' =>
            if
                True ∧
                  (BitVec.signExtend (2 * 8) x' * BitVec.signExtend (2 * 8) x✝¹ <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x' * BitVec.signExtend (2 * 8) x✝¹ ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 8) x' * BitVec.zeroExtend (2 * 8) x✝¹ ≥
                      BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
                none
              else some (x' * x✝¹)) ⊑
          Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 1#8
            | some { toFin := ⟨0, ⋯⟩ } => some 2#8)
            fun y' => if True ∧ x✝¹ <<< y' >>> y' = x✝¹ then none else if y' ≥ ↑8 then none else some (x✝¹ <<< y'))
    [Meta.check] [0.002914] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 2#8
            | some { toFin := ⟨0, ⋯⟩ } => some 4#8)
            fun x' =>
            if
                True ∧
                  (BitVec.signExtend (2 * 8) x' * BitVec.signExtend (2 * 8) x✝¹ <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x' * BitVec.signExtend (2 * 8) x✝¹ ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 8) x' * BitVec.zeroExtend (2 * 8) x✝¹ ≥
                      BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
                none
              else some (x' * x✝¹))
          (Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 1#8
            | some { toFin := ⟨0, ⋯⟩ } => some 2#8)
            fun y' => if True ∧ x✝¹ <<< y' >>> y' = x✝¹ then none else if y' ≥ ↑8 then none else some (x✝¹ <<< y'))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 1
      x✝¹ : BitVec 8
      x✝ : BitVec 1
      a✝ :
        ¬(Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 2#8
              | some { toFin := ⟨0, ⋯⟩ } => some 4#8)
              fun x' =>
              if
                  True ∧
                    (BitVec.signExtend (2 * 8) x' * BitVec.signExtend (2 * 8) x✝¹ <
                        BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                      BitVec.signExtend (2 * 8) x' * BitVec.signExtend (2 * 8) x✝¹ ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
                none
              else
                if
                    True ∧
                      BitVec.zeroExtend (2 * 8) x' * BitVec.zeroExtend (2 * 8) x✝¹ ≥
                        BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
                  none
                else some (x' * x✝¹)) ⊑
            Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 1#8
              | some { toFin := ⟨0, ⋯⟩ } => some 2#8)
              fun y' => if True ∧ x✝¹ <<< y' >>> y' = x✝¹ then none else if y' ≥ ↑8 then none else some (x✝¹ <<< y')
      ⊢ False
  [Meta.isDefEq] [0.001125] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 2#8
      | some { toFin := ⟨0, ⋯⟩ } => some 4#8
  [Meta.isDefEq] [0.001233] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 2#8
      | some { toFin := ⟨0, ⋯⟩ } => some 4#8
  [Meta.isDefEq] [0.001191] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 2#8
      | some { toFin := ⟨0, ⋯⟩ } => some 4#8
  [Meta.isDefEq] [0.001153] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹)
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                      (BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                            (BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹) (BitVec.twoPow 16 7)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹) true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹)
                !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹)
                (congrArg
                  (fun x =>
                    !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ
                            BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹) &&
                        x))
                  (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹)))))))
        (true_and
          ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹) &&
                BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹)) =
            true))
    [Meta.isDefEq.assign] [0.001149] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                        (BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                              (BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹) (BitVec.twoPow 16 7)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹) true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹)
                  (congrArg
                    (fun x =>
                      !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ
                              BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹) &&
                          x))
                    (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹)))))))
          (true_and
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.001110] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 8) a * BitVec.signExtend (2 * 8) x✝¹ <
                  BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                BitVec.signExtend (2 * 8) a * BitVec.signExtend (2 * 8) x✝¹ ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹)
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                          (BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                                (BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹) (BitVec.twoPow 16 7)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹) true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹)
                      !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹)
                    (congrArg
                      (fun x =>
                        !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ
                                BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹) &&
                            x))
                      (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹)))))))
            (true_and
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹)) =
                true)) : (True ∧
              (BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹ < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹ ≥ BitVec.twoPow 16 7)) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹)) =
              true))
        [Meta.isDefEq] [0.001105] ✅️ (True ∧
                (BitVec.signExtend (2 * 8) a * BitVec.signExtend (2 * 8) x✝¹ <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) a * BitVec.signExtend (2 * 8) x✝¹ ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹)) =
                true) =?= (True ∧
                (BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹ < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹ ≥ BitVec.twoPow 16 7)) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹)) =
                true)
          [Meta.isDefEq] [0.001063] ✅️ True ∧
                (BitVec.signExtend (2 * 8) a * BitVec.signExtend (2 * 8) x✝¹ <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) a * BitVec.signExtend (2 * 8) x✝¹ ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1)) =?= True ∧
                (BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹ < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹ ≥ BitVec.twoPow 16 7)
            [Meta.isDefEq] [0.001034] ✅️ BitVec.signExtend (2 * 8) a * BitVec.signExtend (2 * 8) x✝¹ <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) a * BitVec.signExtend (2 * 8) x✝¹ ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1) =?= BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹ <
                    BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹ ≥ BitVec.twoPow 16 7
  [Meta.isDefEq] [0.001277] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                (BitVec.zeroExtend 16 a * BitVec.zeroExtend 16 x✝¹))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 a * BitVec.zeroExtend 16 x✝¹)
                      (BitVec.twoPow 16 7 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 a * BitVec.zeroExtend 16 x✝¹) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 a * BitVec.zeroExtend 16 x✝¹)))))))
        (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 a * BitVec.zeroExtend 16 x✝¹) = true))
    [Meta.isDefEq.assign] [0.001273] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                  (BitVec.zeroExtend 16 a * BitVec.zeroExtend 16 x✝¹))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 a * BitVec.zeroExtend 16 x✝¹)
                        (BitVec.twoPow 16 7 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 a * BitVec.zeroExtend 16 x✝¹) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 a * BitVec.zeroExtend 16 x✝¹)))))))
          (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 a * BitVec.zeroExtend 16 x✝¹) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001251] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 8) a * BitVec.zeroExtend (2 * 8) x✝¹ ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 a * BitVec.zeroExtend 16 x✝¹) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                    (BitVec.zeroExtend 16 a * BitVec.zeroExtend 16 x✝¹))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 a * BitVec.zeroExtend 16 x✝¹)
                          (BitVec.twoPow 16 7 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 a * BitVec.zeroExtend 16 x✝¹) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 a * BitVec.zeroExtend 16 x✝¹)))))))
            (true_and
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 a * BitVec.zeroExtend 16 x✝¹) =
                true)) : (True ∧ BitVec.zeroExtend 16 a * BitVec.zeroExtend 16 x✝¹ ≥ BitVec.twoPow 16 7 <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 a * BitVec.zeroExtend 16 x✝¹) = true))
        [Meta.isDefEq] [0.001246] ✅️ (True ∧
                BitVec.zeroExtend (2 * 8) a * BitVec.zeroExtend (2 * 8) x✝¹ ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 a * BitVec.zeroExtend 16 x✝¹) =
                true) =?= (True ∧ BitVec.zeroExtend 16 a * BitVec.zeroExtend 16 x✝¹ ≥ BitVec.twoPow 16 7 <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 a * BitVec.zeroExtend 16 x✝¹) = true)
          [Meta.isDefEq] [0.001209] ✅️ True ∧
                BitVec.zeroExtend (2 * 8) a * BitVec.zeroExtend (2 * 8) x✝¹ ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 16 a * BitVec.zeroExtend 16 x✝¹ ≥ BitVec.twoPow 16 7 <<< 1
            [Meta.isDefEq] [0.001190] ✅️ BitVec.zeroExtend (2 * 8) a * BitVec.zeroExtend (2 * 8) x✝¹ ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<<
                    1 =?= BitVec.zeroExtend 16 a * BitVec.zeroExtend 16 x✝¹ ≥ BitVec.twoPow 16 7 <<< 1
              [Meta.isDefEq.delta] [0.001138] ✅️ BitVec.zeroExtend (2 * 8) a * BitVec.zeroExtend (2 * 8) x✝¹ ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<<
                      1 =?= BitVec.zeroExtend 16 a * BitVec.zeroExtend 16 x✝¹ ≥ BitVec.twoPow 16 7 <<< 1
  [Meta.isDefEq] [0.001145] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#8
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.isDefEq] [0.001228] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#8
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.isDefEq] [0.001193] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#8
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.isDefEq] [0.001120] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 2#8
      | some { toFin := ⟨0, ⋯⟩ } => some 4#8
  [Meta.isDefEq] [0.001260] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 2#8
      | some { toFin := ⟨0, ⋯⟩ } => some 4#8
  [Meta.isDefEq] [0.001215] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 2#8
      | some { toFin := ⟨0, ⋯⟩ } => some 4#8
  [Meta.isDefEq] [0.001044] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#8
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.isDefEq] [0.001156] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#8
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.isDefEq] [0.001183] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#8
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 1
      x✝¹ : BitVec 8
      x✝ : BitVec 1
      a✝ :
        ¬(Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 2#8
              | some { toFin := ⟨0, ⋯⟩ } => some 4#8)
              fun a =>
              if
                  (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹) &&
                        BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 a * BitVec.signExtend 16 x✝¹)) =
                    true then
                none
              else
                if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 a * BitVec.zeroExtend 16 x✝¹) = true then none
                else some (a * x✝¹)) ⊑
            Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 1#8
              | some { toFin := ⟨0, ⋯⟩ } => some 2#8)
              fun a =>
              if (x✝¹ <<< a >>> a == x✝¹) = true then none else if (!8#8 >ᵤ a) = true then none else some (x✝¹ <<< a)
      ⊢ False
  [Meta.isDefEq] [0.001046] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 2#8
      | some { toFin := ⟨0, ⋯⟩ } => some 4#8
  [Meta.isDefEq] [0.001150] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 2#8
      | some { toFin := ⟨0, ⋯⟩ } => some 4#8
  [Meta.isDefEq] [0.001141] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 2#8
      | some { toFin := ⟨0, ⋯⟩ } => some 4#8
  [Meta.isDefEq] [0.001103] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#8
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.isDefEq] [0.001201] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#8
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.isDefEq] [0.001179] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#8
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.isDefEq] [0.001062] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 2#8
      | some { toFin := ⟨0, ⋯⟩ } => some 4#8
  [Meta.isDefEq] [0.001186] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 2#8
      | some { toFin := ⟨0, ⋯⟩ } => some 4#8
  [Meta.isDefEq] [0.001153] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 2#8
      | some { toFin := ⟨0, ⋯⟩ } => some 4#8
  [Meta.isDefEq] [0.001113] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#8
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.isDefEq] [0.001190] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#8
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.isDefEq] [0.001127] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#8
      | some { toFin := ⟨0, ⋯⟩ } => some 2#8
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gmulhpow2_proof.lean:38:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gmulhpow2_proof.lean:38:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gmulhpow2_proof.lean:32:8: error: (kernel) declaration has metavariables 'mul_selectp2_x_non_const_thm'
[bv] [0.091486] Normalizing goal
  [Meta.synthInstance] [0.001632] ✅️ Decidable
        ((Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 2#8
            | some { toFin := ⟨0, ⋯⟩ } => if x✝¹ ≥ ↑8 then none else some (1#8 <<< x✝¹))
            fun x' => some (x' * x✝²)) ⊑
          Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 1#8
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
            fun y' => if y' ≥ ↑8 then none else some (x✝² <<< y'))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      e_2 : LLVM.IntW 1
      x✝² x✝¹ : BitVec 8
      x✝ : BitVec 1
      a✝ :
        ¬(Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 2#8
              | some { toFin := ⟨0, ⋯⟩ } => if x✝¹ ≥ ↑8 then none else some (1#8 <<< x✝¹))
              fun x' => some (x' * x✝²)) ⊑
            Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 1#8
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun y' => if y' ≥ ↑8 then none else some (x✝² <<< y')
      ⊢ False
  [Meta.isDefEq] [0.001009] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 2#8
      | some { toFin := ⟨0, ⋯⟩ } => if x✝¹ ≥ ↑8 then none else some (1#8 <<< x✝¹)
  [Meta.appBuilder] [0.002005] ✅️ f: funext, xs: [fun _ =>
         ite_congr
           (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
             (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (8#8) x✝¹)
               (Eq.trans
                 (Eq.trans (congrArg Not (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult x✝¹ 8#8))
                   (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq (8#8 >ᵤ x✝¹) true))
                 (congrArg (fun x => (!x) = true) (beq_true (8#8 >ᵤ x✝¹))))))
           (fun a => Eq.refl none) fun a => Eq.refl (some (1#8 <<< x✝¹))]
    [Meta.isDefEq] [0.001946] ✅️ ∀ (x : ?α),
          ?f x =
            ?g
              x =?= Unit →
          (if x✝¹ ≥ ↑8 then none else some (1#8 <<< x✝¹)) = if (!8#8 >ᵤ x✝¹) = true then none else some (1#8 <<< x✝¹)
  [Meta.isDefEq] [0.001065] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#8
      | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
  [Meta.isDefEq] [0.001079] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#8
      | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
  [Meta.isDefEq] [0.001187] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 2#8
      | some { toFin := ⟨0, ⋯⟩ } => if (!8#8 >ᵤ x✝¹) = true then none else some (1#8 <<< x✝¹)
  [Meta.isDefEq] [0.001183] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#8
      | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
  [Meta.isDefEq] [0.001179] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#8
      | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      e_2 : LLVM.IntW 1
      x✝² x✝¹ : BitVec 8
      x✝ : BitVec 1
      a✝ :
        ¬(Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 2#8
              | some { toFin := ⟨0, ⋯⟩ } => if (!8#8 >ᵤ x✝¹) = true then none else some (1#8 <<< x✝¹))
              fun a => some (a * x✝²)) ⊑
            Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 1#8
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun a => if (!8#8 >ᵤ a) = true then none else some (x✝² <<< a)
      ⊢ False
  [Meta.isDefEq] [0.001040] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 2#8
      | some { toFin := ⟨0, ⋯⟩ } => if (!8#8 >ᵤ x✝¹) = true then none else some (1#8 <<< x✝¹)
  [Meta.isDefEq] [0.001231] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 2#8
      | some { toFin := ⟨0, ⋯⟩ } => if (!8#8 >ᵤ x✝¹) = true then none else some (1#8 <<< x✝¹)
  [Meta.isDefEq] [0.001154] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 2#8
      | some { toFin := ⟨0, ⋯⟩ } => if (!8#8 >ᵤ x✝¹) = true then none else some (1#8 <<< x✝¹)
  [Meta.isDefEq] [0.001120] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 2#8
      | some { toFin := ⟨0, ⋯⟩ } => if (!8#8 >ᵤ x✝¹) = true then none else some (1#8 <<< x✝¹)
  [Meta.isDefEq] [0.001128] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 2#8
      | some { toFin := ⟨0, ⋯⟩ } => if (!8#8 >ᵤ x✝¹) = true then none else some (1#8 <<< x✝¹)
  [Meta.appBuilder] [0.001925] ✅️ f: Subsingleton.elim, xs: [h✝, h]
    [Meta.synthInstance] [0.001856] ✅️ Subsingleton (Decidable c✝)
      [Meta.synthInstance] [0.001767] ✅️ apply instSubsingletonDecidable to Subsingleton (Decidable c✝)
        [Meta.synthInstance.tryResolve] [0.001734] ✅️ Subsingleton (Decidable c✝) ≟ Subsingleton (Decidable c✝)
          [Meta.isDefEq] [0.001651] ✅️ ?m.40294 =?= instSubsingletonDecidable c✝
            [Meta.isDefEq.assign] [0.001647] ✅️ ?m.40294 := instSubsingletonDecidable c✝
              [Meta.isDefEq.assign.checkTypes] [0.001633] ✅️ (?m.40294 : Subsingleton
                    (Decidable c✝)) := (instSubsingletonDecidable c✝ : Subsingleton (Decidable c✝))
  [Meta.isDefEq] [0.001081] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#8
      | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gmulhpow2_proof.lean:49:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gmulhpow2_proof.lean:42:8: error: (kernel) declaration has metavariables 'mul_x_selectp2_thm'
[bv] [0.056251] Normalizing goal
  [Meta.synthInstance] [0.001521] ✅️ Decidable
        ((Option.bind
            (match some x✝¹ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 8#8
            | some { toFin := ⟨0, ⋯⟩ } => some 1#8)
            fun y' => some (x✝ * x✝ * y')) ⊑
          Option.bind
            (match some x✝¹ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 3#8
            | some { toFin := ⟨0, ⋯⟩ } => some 0#8)
            fun y' => if y' ≥ ↑8 then none else some ((x✝ * x✝) <<< y'))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 1
      e_1 : LLVM.IntW 8
      x✝¹ : BitVec 1
      x✝ : BitVec 8
      a✝ :
        ¬(Option.bind
              (match some x✝¹ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 8#8
              | some { toFin := ⟨0, ⋯⟩ } => some 1#8)
              fun y' => some (x✝ * x✝ * y')) ⊑
            Option.bind
              (match some x✝¹ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 3#8
              | some { toFin := ⟨0, ⋯⟩ } => some 0#8)
              fun y' => if y' ≥ ↑8 then none else some ((x✝ * x✝) <<< y')
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 1
      e_1 : LLVM.IntW 8
      x✝¹ : BitVec 1
      x✝ : BitVec 8
      a✝ :
        ¬(Option.bind
              (match some x✝¹ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 8#8
              | some { toFin := ⟨0, ⋯⟩ } => some 1#8)
              fun y' => some (x✝ * x✝ * y')) ⊑
            Option.bind
              (match some x✝¹ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 3#8
              | some { toFin := ⟨0, ⋯⟩ } => some 0#8)
              fun a => if (!8#8 >ᵤ a) = true then none else some ((x✝ * x✝) <<< a)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gmulhpow2_proof.lean:59:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gmulhpow2_proof.lean:53:8: error: (kernel) declaration has metavariables 'shl_add_log_may_cause_poison_pr62175_with_nuw_thm'
[bv] [0.052378] Normalizing goal
  [Meta.synthInstance] [0.002158] ✅️ Decidable
        ((if True ∧ 4#8 <<< x✝¹ >>> x✝¹ = 4#8 then none else if x✝¹ ≥ ↑8 then none else some (x✝ * 4#8 <<< x✝¹)) ⊑
          if x✝¹ + 2#8 ≥ ↑8 then none else some (x✝ <<< (x✝¹ + 2#8)))
    [Meta.check] [0.001182] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if True ∧ 4#8 <<< x✝¹ >>> x✝¹ = 4#8 then none else if x✝¹ ≥ ↑8 then none else some (x✝ * 4#8 <<< x✝¹))
          (if x✝¹ + 2#8 ≥ ↑8 then none else some (x✝ <<< (x✝¹ + 2#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if True ∧ 4#8 <<< x✝¹ >>> x✝¹ = 4#8 then none else if x✝¹ ≥ ↑8 then none else some (x✝ * 4#8 <<< x✝¹)) ⊑
            if x✝¹ + 2#8 ≥ ↑8 then none else some (x✝ <<< (x✝¹ + 2#8))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if (4#8 <<< x✝¹ >>> x✝¹ == 4#8) = true then none
            else if (!8#8 >ᵤ x✝¹) = true then none else some (x✝ * 4#8 <<< x✝¹)) ⊑
            if (!8#8 >ᵤ x✝¹ + 2#8) = true then none else some (x✝ <<< (x✝¹ + 2#8))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gmulhpow2_proof.lean:69:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gmulhpow2_proof.lean:63:8: error: (kernel) declaration has metavariables 'shl_add_log_may_cause_poison_pr62175_with_nsw_thm'
[bv] [0.055273] Normalizing goal
  [Meta.synthInstance] [0.002136] ✅️ Decidable
        ((if True ∧ (4#8 <<< x✝¹).sshiftRight x✝¹.toNat = 4#8 then none
          else if x✝¹ ≥ ↑8 then none else some (x✝ * 4#8 <<< x✝¹)) ⊑
          if x✝¹ + 2#8 ≥ ↑8 then none else some (x✝ <<< (x✝¹ + 2#8)))
    [Meta.check] [0.001122] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if True ∧ (4#8 <<< x✝¹).sshiftRight x✝¹.toNat = 4#8 then none
          else if x✝¹ ≥ ↑8 then none else some (x✝ * 4#8 <<< x✝¹))
          (if x✝¹ + 2#8 ≥ ↑8 then none else some (x✝ <<< (x✝¹ + 2#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if True ∧ (4#8 <<< x✝¹).sshiftRight x✝¹.toNat = 4#8 then none
            else if x✝¹ ≥ ↑8 then none else some (x✝ * 4#8 <<< x✝¹)) ⊑
            if x✝¹ + 2#8 ≥ ↑8 then none else some (x✝ <<< (x✝¹ + 2#8))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if ((4#8 <<< x✝¹).sshiftRight x✝¹.toNat == 4#8) = true then none
            else if (!8#8 >ᵤ x✝¹) = true then none else some (x✝ * 4#8 <<< x✝¹)) ⊑
            if (!8#8 >ᵤ x✝¹ + 2#8) = true then none else some (x✝ <<< (x✝¹ + 2#8))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
