⚠ [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
⚠ [875/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
⚠ [884/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [887/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
⚠ [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
Bitwuzla proved the goal after 75.567410ms, solving context: 2.000000ms
LeanSAT proved the goal after 121.844099ms: rewriting 17.557470ms, bitblasting 1.823140ms, SAT solving 57.605210ms, LRAT trimming 13.961290ms, LRAT checking 27.083909ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhxor_proof.lean:28:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhxor_proof.lean:21:8: error: (kernel) declaration has metavariables 'arbitrary_mask_sub_i8_thm'
[bv] [0.067901] Normalizing goal
  [Meta.synthInstance] [0.003520] ✅️ Decidable
        (some (11#8 - (x✝ &&& 10#8)) ⊑
          if
              True ∧
                (BitVec.signExtend (8 + 1) 11#8 - BitVec.signExtend (8 + 1) (x✝ &&& 10#8)).msb ≠
                  (BitVec.signExtend (8 + 1) 11#8 - BitVec.signExtend (8 + 1) (x✝ &&& 10#8)).getMsbD 1 then
            none
          else if True ∧ 11#8 < x✝ &&& 10#8 then none else some (11#8 - (x✝ &&& 10#8)))
    [Meta.synthInstance] [0.002437] ✅️ apply @BitVec.Refinement.instDecidableRelOptionOfDecidableEq to Decidable
          (some (11#8 - (x✝ &&& 10#8)) ⊑
            if
                True ∧
                  (BitVec.signExtend (8 + 1) 11#8 - BitVec.signExtend (8 + 1) (x✝ &&& 10#8)).msb ≠
                    (BitVec.signExtend (8 + 1) 11#8 - BitVec.signExtend (8 + 1) (x✝ &&& 10#8)).getMsbD 1 then
              none
            else if True ∧ 11#8 < x✝ &&& 10#8 then none else some (11#8 - (x✝ &&& 10#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬some (11#8 - (x✝ &&& 10#8)) ⊑
            if
                True ∧
                  (BitVec.signExtend (8 + 1) 11#8 - BitVec.signExtend (8 + 1) (x✝ &&& 10#8)).msb ≠
                    (BitVec.signExtend (8 + 1) 11#8 - BitVec.signExtend (8 + 1) (x✝ &&& 10#8)).getMsbD 1 then
              none
            else if True ∧ 11#8 < x✝ &&& 10#8 then none else some (11#8 - (x✝ &&& 10#8))
      ⊢ False
  [Meta.isDefEq] [0.011086] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (congr
              (congrArg Ne
                (Eq.trans
                  (congrArg BitVec.msb
                    (Eq.trans (BitVec.sub_toAdd (11#9) (BitVec.signExtend 9 (x✝ &&& 10#8)))
                      (Eq.trans (congrArg (HAdd.hAdd 11#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝ &&& 10#8))))
                        (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (11#9)
                          (~~~BitVec.signExtend 9 (x✝ &&& 10#8)) 1#9))))
                  (BitVec.msb_eq_getLsbD_last (12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 10#8)))))
              (congrArg (fun x => x.getMsbD 1)
                (Eq.trans (BitVec.sub_toAdd (11#9) (BitVec.signExtend 9 (x✝ &&& 10#8)))
                  (Eq.trans (congrArg (HAdd.hAdd 11#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝ &&& 10#8))))
                    (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (11#9) (~~~BitVec.signExtend 9 (x✝ &&& 10#8))
                      1#9)))))
            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq ((12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 10#8)).getLsbD 8)
              ((12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 10#8)).getMsbD 1))))
        (true_and
          ((!(12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 10#8)).getLsbD 8 ==
                (12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 10#8)).getMsbD 1) =
            true))
    [Meta.isDefEq.assign] [0.011084] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (congr
                (congrArg Ne
                  (Eq.trans
                    (congrArg BitVec.msb
                      (Eq.trans (BitVec.sub_toAdd (11#9) (BitVec.signExtend 9 (x✝ &&& 10#8)))
                        (Eq.trans
                          (congrArg (HAdd.hAdd 11#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝ &&& 10#8))))
                          (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (11#9)
                            (~~~BitVec.signExtend 9 (x✝ &&& 10#8)) 1#9))))
                    (BitVec.msb_eq_getLsbD_last (12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 10#8)))))
                (congrArg (fun x => x.getMsbD 1)
                  (Eq.trans (BitVec.sub_toAdd (11#9) (BitVec.signExtend 9 (x✝ &&& 10#8)))
                    (Eq.trans (congrArg (HAdd.hAdd 11#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝ &&& 10#8))))
                      (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (11#9)
                        (~~~BitVec.signExtend 9 (x✝ &&& 10#8)) 1#9)))))
              (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq ((12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 10#8)).getLsbD 8)
                ((12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 10#8)).getMsbD 1))))
          (true_and
            ((!(12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 10#8)).getLsbD 8 ==
                  (12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 10#8)).getMsbD 1) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.011063] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (8 + 1) 11#8 - BitVec.signExtend (8 + 1) (x✝ &&& 10#8)).msb ≠
                (BitVec.signExtend (8 + 1) 11#8 - BitVec.signExtend (8 + 1) (x✝ &&& 10#8)).getMsbD 1) =
            ((!(12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 10#8)).getLsbD 8 ==
                  (12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 10#8)).getMsbD 1) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (congr
                  (congrArg Ne
                    (Eq.trans
                      (congrArg BitVec.msb
                        (Eq.trans (BitVec.sub_toAdd (11#9) (BitVec.signExtend 9 (x✝ &&& 10#8)))
                          (Eq.trans
                            (congrArg (HAdd.hAdd 11#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝ &&& 10#8))))
                            (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (11#9)
                              (~~~BitVec.signExtend 9 (x✝ &&& 10#8)) 1#9))))
                      (BitVec.msb_eq_getLsbD_last (12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 10#8)))))
                  (congrArg (fun x => x.getMsbD 1)
                    (Eq.trans (BitVec.sub_toAdd (11#9) (BitVec.signExtend 9 (x✝ &&& 10#8)))
                      (Eq.trans (congrArg (HAdd.hAdd 11#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝ &&& 10#8))))
                        (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (11#9)
                          (~~~BitVec.signExtend 9 (x✝ &&& 10#8)) 1#9)))))
                (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq ((12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 10#8)).getLsbD 8)
                  ((12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 10#8)).getMsbD 1))))
            (true_and
              ((!(12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 10#8)).getLsbD 8 ==
                    (12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 10#8)).getMsbD 1) =
                true)) : (True ∧
              (11#9 - BitVec.signExtend 9 (x✝ &&& 10#8)).msb ≠ (11#9 - BitVec.signExtend 9 (x✝ &&& 10#8)).getMsbD 1) =
            ((!(12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 10#8)).getLsbD 8 ==
                  (12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 10#8)).getMsbD 1) =
              true))
        [Meta.isDefEq] [0.011060] ✅️ (True ∧
                (BitVec.signExtend (8 + 1) 11#8 - BitVec.signExtend (8 + 1) (x✝ &&& 10#8)).msb ≠
                  (BitVec.signExtend (8 + 1) 11#8 - BitVec.signExtend (8 + 1) (x✝ &&& 10#8)).getMsbD 1) =
              ((!(12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 10#8)).getLsbD 8 ==
                    (12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 10#8)).getMsbD 1) =
                true) =?= (True ∧
                (11#9 - BitVec.signExtend 9 (x✝ &&& 10#8)).msb ≠ (11#9 - BitVec.signExtend 9 (x✝ &&& 10#8)).getMsbD 1) =
              ((!(12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 10#8)).getLsbD 8 ==
                    (12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 10#8)).getMsbD 1) =
                true)
          [Meta.isDefEq] [0.011040] ✅️ True ∧
                (BitVec.signExtend (8 + 1) 11#8 - BitVec.signExtend (8 + 1) (x✝ &&& 10#8)).msb ≠
                  (BitVec.signExtend (8 + 1) 11#8 - BitVec.signExtend (8 + 1) (x✝ &&& 10#8)).getMsbD
                    1 =?= True ∧
                (11#9 - BitVec.signExtend 9 (x✝ &&& 10#8)).msb ≠ (11#9 - BitVec.signExtend 9 (x✝ &&& 10#8)).getMsbD 1
            [Meta.isDefEq] [0.011025] ✅️ (BitVec.signExtend (8 + 1) 11#8 -
                      BitVec.signExtend (8 + 1) (x✝ &&& 10#8)).msb ≠
                  (BitVec.signExtend (8 + 1) 11#8 - BitVec.signExtend (8 + 1) (x✝ &&& 10#8)).getMsbD
                    1 =?= (11#9 - BitVec.signExtend 9 (x✝ &&& 10#8)).msb ≠
                  (11#9 - BitVec.signExtend 9 (x✝ &&& 10#8)).getMsbD 1
              [Meta.isDefEq.delta] [0.011010] ✅️ (BitVec.signExtend (8 + 1) 11#8 -
                        BitVec.signExtend (8 + 1) (x✝ &&& 10#8)).msb ≠
                    (BitVec.signExtend (8 + 1) 11#8 - BitVec.signExtend (8 + 1) (x✝ &&& 10#8)).getMsbD
                      1 =?= (11#9 - BitVec.signExtend 9 (x✝ &&& 10#8)).msb ≠
                    (11#9 - BitVec.signExtend 9 (x✝ &&& 10#8)).getMsbD 1
                [Meta.isDefEq] [0.010956] ✅️ (BitVec.signExtend (8 + 1) 11#8 -
                        BitVec.signExtend (8 + 1) (x✝ &&& 10#8)).msb =?= (11#9 - BitVec.signExtend 9 (x✝ &&& 10#8)).msb
                  [Meta.isDefEq.delta] [0.010945] ✅️ (BitVec.signExtend (8 + 1) 11#8 -
                          BitVec.signExtend (8 + 1)
                            (x✝ &&& 10#8)).msb =?= (11#9 - BitVec.signExtend 9 (x✝ &&& 10#8)).msb
                    [Meta.isDefEq] [0.010925] ✅️ BitVec.signExtend (8 + 1) 11#8 -
                          BitVec.signExtend (8 + 1) (x✝ &&& 10#8) =?= 11#9 - BitVec.signExtend 9 (x✝ &&& 10#8)
                      [Meta.isDefEq] [0.010899] ✅️ instHSub.1 (BitVec.signExtend (8 + 1) 11#8)
                            (BitVec.signExtend (8 + 1)
                              (x✝ &&& 10#8)) =?= instHSub.1 (11#9) (BitVec.signExtend 9 (x✝ &&& 10#8))
                        [Meta.isDefEq] [0.009539] ✅️ Sub.sub (BitVec.signExtend (8 + 1) 11#8)
                              (BitVec.signExtend (8 + 1)
                                (x✝ &&& 10#8)) =?= Sub.sub (11#9) (BitVec.signExtend 9 (x✝ &&& 10#8))
                          [Meta.isDefEq] [0.009514] ✅️ BitVec.instSub.1 (BitVec.signExtend (8 + 1) 11#8)
                                (BitVec.signExtend (8 + 1)
                                  (x✝ &&& 10#8)) =?= BitVec.instSub.1 (11#9) (BitVec.signExtend 9 (x✝ &&& 10#8))
                            [Meta.isDefEq] [0.009468] ✅️ (BitVec.signExtend (8 + 1) 11#8).sub
                                  (BitVec.signExtend (8 + 1)
                                    (x✝ &&& 10#8)) =?= (11#9).sub (BitVec.signExtend 9 (x✝ &&& 10#8))
                              [Meta.isDefEq.delta] [0.009458] ✅️ (BitVec.signExtend (8 + 1) 11#8).sub
                                    (BitVec.signExtend (8 + 1)
                                      (x✝ &&& 10#8)) =?= (11#9).sub (BitVec.signExtend 9 (x✝ &&& 10#8))
                                [Meta.isDefEq] [0.009383] ✅️ BitVec.signExtend (8 + 1) 11#8 =?= 11#9
                                  [Meta.isDefEq] [0.009364] ✅️ BitVec.ofInt (8 + 1) (11#8).toInt =?= 11#9
                                    [Meta.isDefEq] [0.009346] ✅️ ((11#8).toInt %
                                              Int.ofNat (2 ^ (8 + 1))).toNat#'⋯ =?= 11#9
                                      [Meta.isDefEq] [0.009328] ✅️ ((11#8).toInt %
                                                Int.ofNat (2 ^ (8 + 1))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 9) 11 }
                                        [Meta.isDefEq] [0.009305] ✅️ {
                                              toFin :=
                                                ⟨((11#8).toInt % Int.ofNat (2 ^ (8 + 1))).toNat,
                                                  ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 9) 11 }
                                          [Meta.isDefEq] [0.009253] ✅️ ⟨((11#8).toInt % Int.ofNat (2 ^ (8 + 1))).toNat,
                                                ⋯⟩ =?= Fin.ofNat' (2 ^ 9) 11
                                            [Meta.isDefEq] [0.009234] ✅️ ⟨((11#8).toInt %
                                                      Int.ofNat (2 ^ (8 + 1))).toNat,
                                                  ⋯⟩ =?= ⟨11 % 2 ^ 9, ⋯⟩
                                              [Meta.isDefEq] [0.009096] ✅️ ((11#8).toInt %
                                                      Int.ofNat (2 ^ (8 + 1))).toNat =?= 11 % 2 ^ 9
                                                [Meta.isDefEq] [0.009005] ✅️ match
                                                      (11#8).toInt % Int.ofNat (2 ^ (8 + 1)) with
                                                    | Int.ofNat n => n
                                                    | Int.negSucc a => 0 =?= 11 % 2 ^ 9
                                                  [Meta.whnf] [0.008562] Non-easy whnf: (fun motive x h_1 h_2 =>
                                                          Int.casesOn x (fun a => h_1 a) fun a => h_2 a)
                                                        (fun x => ℕ) ((11#8).toInt % Int.ofNat (2 ^ (8 + 1))) h_1 h_2
                                                    [Meta.whnf] [0.008541] Non-easy whnf: (11#8).toInt %
                                                          Int.ofNat (2 ^ (8 + 1))
                                                      [Meta.whnf] [0.008535] Non-easy whnf: instHMod.1 (11#8).toInt
                                                            (Int.ofNat (2 ^ (8 + 1)))
                                                        [Meta.whnf] [0.008519] Non-easy whnf: Int.instMod.1 (11#8).toInt
                                                              (Int.ofNat (2 ^ (8 + 1)))
                                                          [Meta.whnf] [0.008501] Non-easy whnf: match (11#8).toInt,
                                                                Int.ofNat (2 ^ (8 + 1)) with
                                                              | Int.ofNat m, n => Int.ofNat (m % n.natAbs)
                                                              | Int.negSucc m, n =>
                                                                Int.subNatNat n.natAbs (m % n.natAbs).succ
                                                            [Meta.whnf] [0.008456] Non-easy whnf: (fun motive x x_1 h_1
                                                                      h_2 =>
                                                                    Int.casesOn x (fun a => h_1 a x_1) fun a =>
                                                                      h_2 a x_1)
                                                                  (fun x x => ℤ) (11#8).toInt (Int.ofNat (2 ^ (8 + 1)))
                                                                  h_1 h_2
                                                              [Meta.whnf] [0.008439] Non-easy whnf: (11#8).toInt
                                                                [Meta.whnf] [0.008416] Non-easy whnf: if
                                                                        2 * (11#8).toNat < 2 ^ 8 then ↑(11#8).toNat
                                                                    else ↑(11#8).toNat - ↑(2 ^ 8)
                                                                  [Meta.whnf] [0.008402] Non-easy whnf: Decidable.casesOn
                                                                        ((2 * (11#8).toNat).decLt (2 ^ 8))
                                                                        (fun x => ↑(11#8).toNat - ↑(2 ^ 8)) fun x =>
                                                                        ↑(11#8).toNat
                                                                    [Meta.whnf] [0.008326] Non-easy whnf: (2 *
                                                                              (11#8).toNat).decLt
                                                                          (2 ^ 8)
                                                                      [Meta.whnf] [0.006444] Non-easy whnf: (2 *
                                                                                  (11#8).toNat).succ.decLe
                                                                            (2 ^ 8)
                                                                        [Meta.whnf] [0.004440] Non-easy whnf: if h :
                                                                                (2 * (11#8).toNat).succ.ble (2 ^ 8) =
                                                                                  true then
                                                                              isTrue ⋯
                                                                            else isFalse ⋯
                                                                          [Meta.whnf] [0.004420] Non-easy whnf: Decidable.casesOn
                                                                                (instDecidableEqBool
                                                                                  ((2 * (11#8).toNat).succ.ble (2 ^ 8))
                                                                                  true)
                                                                                (fun h => isFalse ⋯) fun h => isTrue ⋯
                                                                            [Meta.whnf] [0.004399] Non-easy whnf: instDecidableEqBool
                                                                                  ((2 * (11#8).toNat).succ.ble (2 ^ 8))
                                                                                  true
                                                                              [Meta.whnf] [0.004391] Non-easy whnf: ((2 *
                                                                                              (11#8).toNat).succ.ble
                                                                                        (2 ^ 8)).decEq
                                                                                    true
                                                                                [Meta.whnf] [0.004374] Non-easy whnf: match
                                                                                      (2 * (11#8).toNat).succ.ble
                                                                                        (2 ^ 8),
                                                                                      true with
                                                                                    | false, false => isTrue ⋯
                                                                                    | false, true => isFalse ⋯
                                                                                    | true, false => isFalse ⋯
                                                                                    | true, true => isTrue ⋯
                                                                                  [Meta.whnf] [0.004295] Non-easy whnf: (fun
                                                                                            motive a b h_1 h_2 h_3
                                                                                            h_4 =>
                                                                                          Bool.casesOn a
                                                                                            (Bool.casesOn b (h_1 ())
                                                                                              (h_2 ()))
                                                                                            (Bool.casesOn b (h_3 ())
                                                                                              (h_4 ())))
                                                                                        (fun a b => Decidable (a = b))
                                                                                        ((2 * (11#8).toNat).succ.ble
                                                                                          (2 ^ 8))
                                                                                        true h_1 h_2 h_3 h_4
                                                                                    [Meta.whnf] [0.004261] Non-easy whnf: (2 *
                                                                                                (11#8).toNat).succ.ble
                                                                                          (2 ^ 8)
                                                                                      [Meta.whnf] [0.004245] Non-easy whnf: (2 *
                                                                                              (11#8).toNat).succ
                                                                                        [Meta.whnf] [0.004239] Non-easy whnf: 2 *
                                                                                              (11#8).toNat
                                                                                          [Meta.whnf] [0.004219] Non-easy whnf: instHMul.1
                                                                                                2 (11#8).toNat
                                                                                            [Meta.whnf] [0.004182] Non-easy whnf: instMulNat.1
                                                                                                  2 (11#8).toNat
                                                                                              [Meta.whnf] [0.001918] Non-easy whnf: instMulNat
                                                                                              [Meta.whnf] [0.002223] Non-easy whnf: (11#8).toNat
                                                                                                [Meta.whnf] [0.002214] Non-easy whnf: ↑(11#8).toFin
                                                                                                  [Meta.whnf] [0.002204] Non-easy whnf: (11#8).toFin.1
                                                                                                    [Meta.whnf] [0.002153] Non-easy whnf: instHMod.1
                                                                                                          11 (2 ^ 8)
                                                                                                      [Meta.whnf] [0.002144] Non-easy whnf: Nat.instMod.1
                                                                                                            11 (2 ^ 8)
                                                                                                        [Meta.whnf] [0.002118] Non-easy whnf: 2 ^
                                                                                                              8
                                                                                                          [Meta.whnf] [0.002107] Non-easy whnf: instHPow.1
                                                                                                                2 8
                                                                                                            [Meta.whnf] [0.002012] Non-easy whnf: instHPow
  [Meta.isDefEq] [0.002061] ✅️ ?x > ?y =?= 11#8 < x✝ &&& 10#8
  [Meta.isDefEq] [0.002160] ✅️ ?h₃ =?= fun a =>
        congrArg some
          (Eq.trans (BitVec.sub_toAdd (11#8) (x✝ &&& 10#8))
            (Eq.trans (congrArg (HAdd.hAdd 11#8) (BitVec.neg_eq_not_add (x✝ &&& 10#8)))
              (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (11#8) (~~~(x✝ &&& 10#8)) 1#8)))
    [Meta.isDefEq.assign] [0.002158] ✅️ ?h₃ := fun a =>
          congrArg some
            (Eq.trans (BitVec.sub_toAdd (11#8) (x✝ &&& 10#8))
              (Eq.trans (congrArg (HAdd.hAdd 11#8) (BitVec.neg_eq_not_add (x✝ &&& 10#8)))
                (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (11#8) (~~~(x✝ &&& 10#8)) 1#8)))
      [Meta.isDefEq.assign.checkTypes] [0.002134] ✅️ (?h₃ : ¬(x✝ &&& 10#8 >ᵤ 11#8) = true →
            some (11#8 - (x✝ &&& 10#8)) =
              some
                (12#8 +
                  ~~~(x✝ &&&
                      10#8))) := (fun a =>
            congrArg some
              (Eq.trans (BitVec.sub_toAdd (11#8) (x✝ &&& 10#8))
                (Eq.trans (congrArg (HAdd.hAdd 11#8) (BitVec.neg_eq_not_add (x✝ &&& 10#8)))
                  (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (11#8) (~~~(x✝ &&& 10#8))
                    1#8))) : ¬(x✝ &&& 10#8 >ᵤ 11#8) = true →
            some (11#8 - (x✝ &&& 10#8)) = some (11#8 + 1#8 + ~~~(x✝ &&& 10#8)))
        [Meta.isDefEq] [0.002131] ✅️ ¬(x✝ &&& 10#8 >ᵤ 11#8) = true →
              some (11#8 - (x✝ &&& 10#8)) =
                some
                  (12#8 +
                    ~~~(x✝ &&&
                        10#8)) =?= ¬(x✝ &&& 10#8 >ᵤ 11#8) = true →
              some (11#8 - (x✝ &&& 10#8)) = some (11#8 + 1#8 + ~~~(x✝ &&& 10#8))
          [Meta.isDefEq] [0.002103] ✅️ some (11#8 - (x✝ &&& 10#8)) =
                some (12#8 + ~~~(x✝ &&& 10#8)) =?= some (11#8 - (x✝ &&& 10#8)) = some (11#8 + 1#8 + ~~~(x✝ &&& 10#8))
            [Meta.isDefEq] [0.002085] ✅️ some (12#8 + ~~~(x✝ &&& 10#8)) =?= some (11#8 + 1#8 + ~~~(x✝ &&& 10#8))
              [Meta.isDefEq] [0.002066] ✅️ 12#8 + ~~~(x✝ &&& 10#8) =?= 11#8 + 1#8 + ~~~(x✝ &&& 10#8)
                [Meta.isDefEq] [0.001951] ✅️ instHAdd.1 (12#8)
                      (~~~(x✝ &&& 10#8)) =?= instHAdd.1 (11#8 + 1#8) (~~~(x✝ &&& 10#8))
                  [Meta.isDefEq] [0.001912] ✅️ Add.add (12#8)
                        (~~~(x✝ &&& 10#8)) =?= Add.add (11#8 + 1#8) (~~~(x✝ &&& 10#8))
                    [Meta.isDefEq] [0.001396] ❌️ BitVec.instAdd =?= instAddNat
                      [Meta.isDefEq] [0.001374] ❌️ { add := BitVec.add } =?= instAddNat
                        [Meta.isDefEq] [0.001354] ❌️ { add := BitVec.add } =?= { add := Nat.add }
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬some (12#8 + ~~~(x✝ &&& 10#8)) ⊑
            if
                (!(12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 10#8)).getLsbD 8 ==
                      (12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 10#8)).getMsbD 1) =
                  true then
              none
            else if (x✝ &&& 10#8 >ᵤ 11#8) = true then none else some (12#8 + ~~~(x✝ &&& 10#8))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhxor_proof.lean:39:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhxor_proof.lean:32:8: error: (kernel) declaration has metavariables 'not_masked_sub_i8_thm'
[bv] [0.038713] Normalizing goal
  [Meta.synthInstance] [0.001425] ✅️ Decidable
        (some (11#8 - (x✝ &&& 7#8)) ⊑
          if
              True ∧
                (BitVec.signExtend (8 + 1) 11#8 - BitVec.signExtend (8 + 1) (x✝ &&& 7#8)).msb ≠
                  (BitVec.signExtend (8 + 1) 11#8 - BitVec.signExtend (8 + 1) (x✝ &&& 7#8)).getMsbD 1 then
            none
          else if True ∧ 11#8 < x✝ &&& 7#8 then none else some (11#8 - (x✝ &&& 7#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬some (11#8 - (x✝ &&& 7#8)) ⊑
            if
                True ∧
                  (BitVec.signExtend (8 + 1) 11#8 - BitVec.signExtend (8 + 1) (x✝ &&& 7#8)).msb ≠
                    (BitVec.signExtend (8 + 1) 11#8 - BitVec.signExtend (8 + 1) (x✝ &&& 7#8)).getMsbD 1 then
              none
            else if True ∧ 11#8 < x✝ &&& 7#8 then none else some (11#8 - (x✝ &&& 7#8))
      ⊢ False
  [Meta.isDefEq] [0.001910] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (congr
              (congrArg Ne
                (Eq.trans
                  (congrArg BitVec.msb
                    (Eq.trans (BitVec.sub_toAdd (11#9) (BitVec.signExtend 9 (x✝ &&& 7#8)))
                      (Eq.trans (congrArg (HAdd.hAdd 11#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝ &&& 7#8))))
                        (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (11#9)
                          (~~~BitVec.signExtend 9 (x✝ &&& 7#8)) 1#9))))
                  (BitVec.msb_eq_getLsbD_last (12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 7#8)))))
              (congrArg (fun x => x.getMsbD 1)
                (Eq.trans (BitVec.sub_toAdd (11#9) (BitVec.signExtend 9 (x✝ &&& 7#8)))
                  (Eq.trans (congrArg (HAdd.hAdd 11#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝ &&& 7#8))))
                    (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (11#9) (~~~BitVec.signExtend 9 (x✝ &&& 7#8))
                      1#9)))))
            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq ((12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 7#8)).getLsbD 8)
              ((12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 7#8)).getMsbD 1))))
        (true_and
          ((!(12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 7#8)).getLsbD 8 ==
                (12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 7#8)).getMsbD 1) =
            true))
    [Meta.isDefEq.assign] [0.001906] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (congr
                (congrArg Ne
                  (Eq.trans
                    (congrArg BitVec.msb
                      (Eq.trans (BitVec.sub_toAdd (11#9) (BitVec.signExtend 9 (x✝ &&& 7#8)))
                        (Eq.trans (congrArg (HAdd.hAdd 11#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝ &&& 7#8))))
                          (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (11#9)
                            (~~~BitVec.signExtend 9 (x✝ &&& 7#8)) 1#9))))
                    (BitVec.msb_eq_getLsbD_last (12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 7#8)))))
                (congrArg (fun x => x.getMsbD 1)
                  (Eq.trans (BitVec.sub_toAdd (11#9) (BitVec.signExtend 9 (x✝ &&& 7#8)))
                    (Eq.trans (congrArg (HAdd.hAdd 11#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝ &&& 7#8))))
                      (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (11#9) (~~~BitVec.signExtend 9 (x✝ &&& 7#8))
                        1#9)))))
              (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq ((12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 7#8)).getLsbD 8)
                ((12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 7#8)).getMsbD 1))))
          (true_and
            ((!(12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 7#8)).getLsbD 8 ==
                  (12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 7#8)).getMsbD 1) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.001885] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (8 + 1) 11#8 - BitVec.signExtend (8 + 1) (x✝ &&& 7#8)).msb ≠
                (BitVec.signExtend (8 + 1) 11#8 - BitVec.signExtend (8 + 1) (x✝ &&& 7#8)).getMsbD 1) =
            ((!(12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 7#8)).getLsbD 8 ==
                  (12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 7#8)).getMsbD 1) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (congr
                  (congrArg Ne
                    (Eq.trans
                      (congrArg BitVec.msb
                        (Eq.trans (BitVec.sub_toAdd (11#9) (BitVec.signExtend 9 (x✝ &&& 7#8)))
                          (Eq.trans
                            (congrArg (HAdd.hAdd 11#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝ &&& 7#8))))
                            (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (11#9)
                              (~~~BitVec.signExtend 9 (x✝ &&& 7#8)) 1#9))))
                      (BitVec.msb_eq_getLsbD_last (12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 7#8)))))
                  (congrArg (fun x => x.getMsbD 1)
                    (Eq.trans (BitVec.sub_toAdd (11#9) (BitVec.signExtend 9 (x✝ &&& 7#8)))
                      (Eq.trans (congrArg (HAdd.hAdd 11#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝ &&& 7#8))))
                        (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (11#9)
                          (~~~BitVec.signExtend 9 (x✝ &&& 7#8)) 1#9)))))
                (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq ((12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 7#8)).getLsbD 8)
                  ((12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 7#8)).getMsbD 1))))
            (true_and
              ((!(12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 7#8)).getLsbD 8 ==
                    (12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 7#8)).getMsbD 1) =
                true)) : (True ∧
              (11#9 - BitVec.signExtend 9 (x✝ &&& 7#8)).msb ≠ (11#9 - BitVec.signExtend 9 (x✝ &&& 7#8)).getMsbD 1) =
            ((!(12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 7#8)).getLsbD 8 ==
                  (12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 7#8)).getMsbD 1) =
              true))
        [Meta.isDefEq] [0.001882] ✅️ (True ∧
                (BitVec.signExtend (8 + 1) 11#8 - BitVec.signExtend (8 + 1) (x✝ &&& 7#8)).msb ≠
                  (BitVec.signExtend (8 + 1) 11#8 - BitVec.signExtend (8 + 1) (x✝ &&& 7#8)).getMsbD 1) =
              ((!(12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 7#8)).getLsbD 8 ==
                    (12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 7#8)).getMsbD 1) =
                true) =?= (True ∧
                (11#9 - BitVec.signExtend 9 (x✝ &&& 7#8)).msb ≠ (11#9 - BitVec.signExtend 9 (x✝ &&& 7#8)).getMsbD 1) =
              ((!(12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 7#8)).getLsbD 8 ==
                    (12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 7#8)).getMsbD 1) =
                true)
          [Meta.isDefEq] [0.001858] ✅️ True ∧
                (BitVec.signExtend (8 + 1) 11#8 - BitVec.signExtend (8 + 1) (x✝ &&& 7#8)).msb ≠
                  (BitVec.signExtend (8 + 1) 11#8 - BitVec.signExtend (8 + 1) (x✝ &&& 7#8)).getMsbD
                    1 =?= True ∧
                (11#9 - BitVec.signExtend 9 (x✝ &&& 7#8)).msb ≠ (11#9 - BitVec.signExtend 9 (x✝ &&& 7#8)).getMsbD 1
            [Meta.isDefEq] [0.001843] ✅️ (BitVec.signExtend (8 + 1) 11#8 - BitVec.signExtend (8 + 1) (x✝ &&& 7#8)).msb ≠
                  (BitVec.signExtend (8 + 1) 11#8 - BitVec.signExtend (8 + 1) (x✝ &&& 7#8)).getMsbD
                    1 =?= (11#9 - BitVec.signExtend 9 (x✝ &&& 7#8)).msb ≠
                  (11#9 - BitVec.signExtend 9 (x✝ &&& 7#8)).getMsbD 1
              [Meta.isDefEq.delta] [0.001826] ✅️ (BitVec.signExtend (8 + 1) 11#8 -
                        BitVec.signExtend (8 + 1) (x✝ &&& 7#8)).msb ≠
                    (BitVec.signExtend (8 + 1) 11#8 - BitVec.signExtend (8 + 1) (x✝ &&& 7#8)).getMsbD
                      1 =?= (11#9 - BitVec.signExtend 9 (x✝ &&& 7#8)).msb ≠
                    (11#9 - BitVec.signExtend 9 (x✝ &&& 7#8)).getMsbD 1
                [Meta.isDefEq] [0.001759] ✅️ (BitVec.signExtend (8 + 1) 11#8 -
                        BitVec.signExtend (8 + 1) (x✝ &&& 7#8)).msb =?= (11#9 - BitVec.signExtend 9 (x✝ &&& 7#8)).msb
                  [Meta.isDefEq.delta] [0.001747] ✅️ (BitVec.signExtend (8 + 1) 11#8 -
                          BitVec.signExtend (8 + 1) (x✝ &&& 7#8)).msb =?= (11#9 - BitVec.signExtend 9 (x✝ &&& 7#8)).msb
                    [Meta.isDefEq] [0.001725] ✅️ BitVec.signExtend (8 + 1) 11#8 -
                          BitVec.signExtend (8 + 1) (x✝ &&& 7#8) =?= 11#9 - BitVec.signExtend 9 (x✝ &&& 7#8)
                      [Meta.isDefEq] [0.001698] ✅️ instHSub.1 (BitVec.signExtend (8 + 1) 11#8)
                            (BitVec.signExtend (8 + 1)
                              (x✝ &&& 7#8)) =?= instHSub.1 (11#9) (BitVec.signExtend 9 (x✝ &&& 7#8))
                        [Meta.isDefEq] [0.001640] ✅️ Sub.sub (BitVec.signExtend (8 + 1) 11#8)
                              (BitVec.signExtend (8 + 1)
                                (x✝ &&& 7#8)) =?= Sub.sub (11#9) (BitVec.signExtend 9 (x✝ &&& 7#8))
                          [Meta.isDefEq] [0.001615] ✅️ BitVec.instSub.1 (BitVec.signExtend (8 + 1) 11#8)
                                (BitVec.signExtend (8 + 1)
                                  (x✝ &&& 7#8)) =?= BitVec.instSub.1 (11#9) (BitVec.signExtend 9 (x✝ &&& 7#8))
                            [Meta.isDefEq] [0.001569] ✅️ (BitVec.signExtend (8 + 1) 11#8).sub
                                  (BitVec.signExtend (8 + 1)
                                    (x✝ &&& 7#8)) =?= (11#9).sub (BitVec.signExtend 9 (x✝ &&& 7#8))
                              [Meta.isDefEq.delta] [0.001557] ✅️ (BitVec.signExtend (8 + 1) 11#8).sub
                                    (BitVec.signExtend (8 + 1)
                                      (x✝ &&& 7#8)) =?= (11#9).sub (BitVec.signExtend 9 (x✝ &&& 7#8))
                                [Meta.isDefEq] [0.001481] ✅️ BitVec.signExtend (8 + 1) 11#8 =?= 11#9
                                  [Meta.isDefEq] [0.001462] ✅️ BitVec.ofInt (8 + 1) (11#8).toInt =?= 11#9
                                    [Meta.isDefEq] [0.001437] ✅️ ((11#8).toInt %
                                              Int.ofNat (2 ^ (8 + 1))).toNat#'⋯ =?= 11#9
                                      [Meta.isDefEq] [0.001413] ✅️ ((11#8).toInt %
                                                Int.ofNat (2 ^ (8 + 1))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 9) 11 }
                                        [Meta.isDefEq] [0.001397] ✅️ {
                                              toFin :=
                                                ⟨((11#8).toInt % Int.ofNat (2 ^ (8 + 1))).toNat,
                                                  ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 9) 11 }
                                          [Meta.isDefEq] [0.001343] ✅️ ⟨((11#8).toInt % Int.ofNat (2 ^ (8 + 1))).toNat,
                                                ⋯⟩ =?= Fin.ofNat' (2 ^ 9) 11
                                            [Meta.isDefEq] [0.001320] ✅️ ⟨((11#8).toInt %
                                                      Int.ofNat (2 ^ (8 + 1))).toNat,
                                                  ⋯⟩ =?= ⟨11 % 2 ^ 9, ⋯⟩
                                              [Meta.isDefEq] [0.001185] ✅️ ((11#8).toInt %
                                                      Int.ofNat (2 ^ (8 + 1))).toNat =?= 11 % 2 ^ 9
                                                [Meta.isDefEq] [0.001097] ✅️ match
                                                      (11#8).toInt % Int.ofNat (2 ^ (8 + 1)) with
                                                    | Int.ofNat n => n
                                                    | Int.negSucc a => 0 =?= 11 % 2 ^ 9
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬some (12#8 + ~~~(x✝ &&& 7#8)) ⊑
            if
                (!(12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 7#8)).getLsbD 8 ==
                      (12#9 + ~~~BitVec.signExtend 9 (x✝ &&& 7#8)).getMsbD 1) =
                  true then
              none
            else if (x✝ &&& 7#8 >ᵤ 11#8) = true then none else some (12#8 + ~~~(x✝ &&& 7#8))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhxor_proof.lean:50:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhxor_proof.lean:43:8: error: (kernel) declaration has metavariables 'xor_add_thm'
[bv] [0.042946] Normalizing goal
  [Meta.synthInstance] [0.001434] ✅️ Decidable
        (some ((x✝ &&& 31#32 ^^^ 31#32) + 42#32) ⊑
          if
              True ∧
                (BitVec.signExtend (32 + 1) 73#32 - BitVec.signExtend (32 + 1) (x✝ &&& 31#32)).msb ≠
                  (BitVec.signExtend (32 + 1) 73#32 - BitVec.signExtend (32 + 1) (x✝ &&& 31#32)).getMsbD 1 then
            none
          else if True ∧ 73#32 < x✝ &&& 31#32 then none else some (73#32 - (x✝ &&& 31#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬some ((x✝ &&& 31#32 ^^^ 31#32) + 42#32) ⊑
            if
                True ∧
                  (BitVec.signExtend (32 + 1) 73#32 - BitVec.signExtend (32 + 1) (x✝ &&& 31#32)).msb ≠
                    (BitVec.signExtend (32 + 1) 73#32 - BitVec.signExtend (32 + 1) (x✝ &&& 31#32)).getMsbD 1 then
              none
            else if True ∧ 73#32 < x✝ &&& 31#32 then none else some (73#32 - (x✝ &&& 31#32))
      ⊢ False
  [Meta.isDefEq] [0.001761] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (congr
              (congrArg Ne
                (Eq.trans
                  (congrArg BitVec.msb
                    (Eq.trans (BitVec.sub_toAdd (73#33) (BitVec.signExtend 33 (x✝ &&& 31#32)))
                      (Eq.trans
                        (congrArg (HAdd.hAdd 73#33) (BitVec.neg_eq_not_add (BitVec.signExtend 33 (x✝ &&& 31#32))))
                        (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (73#33)
                          (~~~BitVec.signExtend 33 (x✝ &&& 31#32)) 1#33))))
                  (BitVec.msb_eq_getLsbD_last (74#33 + ~~~BitVec.signExtend 33 (x✝ &&& 31#32)))))
              (congrArg (fun x => x.getMsbD 1)
                (Eq.trans (BitVec.sub_toAdd (73#33) (BitVec.signExtend 33 (x✝ &&& 31#32)))
                  (Eq.trans (congrArg (HAdd.hAdd 73#33) (BitVec.neg_eq_not_add (BitVec.signExtend 33 (x✝ &&& 31#32))))
                    (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (73#33)
                      (~~~BitVec.signExtend 33 (x✝ &&& 31#32)) 1#33)))))
            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq ((74#33 + ~~~BitVec.signExtend 33 (x✝ &&& 31#32)).getLsbD 32)
              ((74#33 + ~~~BitVec.signExtend 33 (x✝ &&& 31#32)).getMsbD 1))))
        (true_and
          ((!(74#33 + ~~~BitVec.signExtend 33 (x✝ &&& 31#32)).getLsbD 32 ==
                (74#33 + ~~~BitVec.signExtend 33 (x✝ &&& 31#32)).getMsbD 1) =
            true))
    [Meta.isDefEq.assign] [0.001758] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (congr
                (congrArg Ne
                  (Eq.trans
                    (congrArg BitVec.msb
                      (Eq.trans (BitVec.sub_toAdd (73#33) (BitVec.signExtend 33 (x✝ &&& 31#32)))
                        (Eq.trans
                          (congrArg (HAdd.hAdd 73#33) (BitVec.neg_eq_not_add (BitVec.signExtend 33 (x✝ &&& 31#32))))
                          (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (73#33)
                            (~~~BitVec.signExtend 33 (x✝ &&& 31#32)) 1#33))))
                    (BitVec.msb_eq_getLsbD_last (74#33 + ~~~BitVec.signExtend 33 (x✝ &&& 31#32)))))
                (congrArg (fun x => x.getMsbD 1)
                  (Eq.trans (BitVec.sub_toAdd (73#33) (BitVec.signExtend 33 (x✝ &&& 31#32)))
                    (Eq.trans (congrArg (HAdd.hAdd 73#33) (BitVec.neg_eq_not_add (BitVec.signExtend 33 (x✝ &&& 31#32))))
                      (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (73#33)
                        (~~~BitVec.signExtend 33 (x✝ &&& 31#32)) 1#33)))))
              (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                ((74#33 + ~~~BitVec.signExtend 33 (x✝ &&& 31#32)).getLsbD 32)
                ((74#33 + ~~~BitVec.signExtend 33 (x✝ &&& 31#32)).getMsbD 1))))
          (true_and
            ((!(74#33 + ~~~BitVec.signExtend 33 (x✝ &&& 31#32)).getLsbD 32 ==
                  (74#33 + ~~~BitVec.signExtend 33 (x✝ &&& 31#32)).getMsbD 1) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.001741] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (32 + 1) 73#32 - BitVec.signExtend (32 + 1) (x✝ &&& 31#32)).msb ≠
                (BitVec.signExtend (32 + 1) 73#32 - BitVec.signExtend (32 + 1) (x✝ &&& 31#32)).getMsbD 1) =
            ((!(74#33 + ~~~BitVec.signExtend 33 (x✝ &&& 31#32)).getLsbD 32 ==
                  (74#33 + ~~~BitVec.signExtend 33 (x✝ &&& 31#32)).getMsbD 1) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (congr
                  (congrArg Ne
                    (Eq.trans
                      (congrArg BitVec.msb
                        (Eq.trans (BitVec.sub_toAdd (73#33) (BitVec.signExtend 33 (x✝ &&& 31#32)))
                          (Eq.trans
                            (congrArg (HAdd.hAdd 73#33) (BitVec.neg_eq_not_add (BitVec.signExtend 33 (x✝ &&& 31#32))))
                            (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (73#33)
                              (~~~BitVec.signExtend 33 (x✝ &&& 31#32)) 1#33))))
                      (BitVec.msb_eq_getLsbD_last (74#33 + ~~~BitVec.signExtend 33 (x✝ &&& 31#32)))))
                  (congrArg (fun x => x.getMsbD 1)
                    (Eq.trans (BitVec.sub_toAdd (73#33) (BitVec.signExtend 33 (x✝ &&& 31#32)))
                      (Eq.trans
                        (congrArg (HAdd.hAdd 73#33) (BitVec.neg_eq_not_add (BitVec.signExtend 33 (x✝ &&& 31#32))))
                        (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (73#33)
                          (~~~BitVec.signExtend 33 (x✝ &&& 31#32)) 1#33)))))
                (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                  ((74#33 + ~~~BitVec.signExtend 33 (x✝ &&& 31#32)).getLsbD 32)
                  ((74#33 + ~~~BitVec.signExtend 33 (x✝ &&& 31#32)).getMsbD 1))))
            (true_and
              ((!(74#33 + ~~~BitVec.signExtend 33 (x✝ &&& 31#32)).getLsbD 32 ==
                    (74#33 + ~~~BitVec.signExtend 33 (x✝ &&& 31#32)).getMsbD 1) =
                true)) : (True ∧
              (73#33 - BitVec.signExtend 33 (x✝ &&& 31#32)).msb ≠
                (73#33 - BitVec.signExtend 33 (x✝ &&& 31#32)).getMsbD 1) =
            ((!(74#33 + ~~~BitVec.signExtend 33 (x✝ &&& 31#32)).getLsbD 32 ==
                  (74#33 + ~~~BitVec.signExtend 33 (x✝ &&& 31#32)).getMsbD 1) =
              true))
        [Meta.isDefEq] [0.001738] ✅️ (True ∧
                (BitVec.signExtend (32 + 1) 73#32 - BitVec.signExtend (32 + 1) (x✝ &&& 31#32)).msb ≠
                  (BitVec.signExtend (32 + 1) 73#32 - BitVec.signExtend (32 + 1) (x✝ &&& 31#32)).getMsbD 1) =
              ((!(74#33 + ~~~BitVec.signExtend 33 (x✝ &&& 31#32)).getLsbD 32 ==
                    (74#33 + ~~~BitVec.signExtend 33 (x✝ &&& 31#32)).getMsbD 1) =
                true) =?= (True ∧
                (73#33 - BitVec.signExtend 33 (x✝ &&& 31#32)).msb ≠
                  (73#33 - BitVec.signExtend 33 (x✝ &&& 31#32)).getMsbD 1) =
              ((!(74#33 + ~~~BitVec.signExtend 33 (x✝ &&& 31#32)).getLsbD 32 ==
                    (74#33 + ~~~BitVec.signExtend 33 (x✝ &&& 31#32)).getMsbD 1) =
                true)
          [Meta.isDefEq] [0.001718] ✅️ True ∧
                (BitVec.signExtend (32 + 1) 73#32 - BitVec.signExtend (32 + 1) (x✝ &&& 31#32)).msb ≠
                  (BitVec.signExtend (32 + 1) 73#32 - BitVec.signExtend (32 + 1) (x✝ &&& 31#32)).getMsbD
                    1 =?= True ∧
                (73#33 - BitVec.signExtend 33 (x✝ &&& 31#32)).msb ≠
                  (73#33 - BitVec.signExtend 33 (x✝ &&& 31#32)).getMsbD 1
            [Meta.isDefEq] [0.001703] ✅️ (BitVec.signExtend (32 + 1) 73#32 -
                      BitVec.signExtend (32 + 1) (x✝ &&& 31#32)).msb ≠
                  (BitVec.signExtend (32 + 1) 73#32 - BitVec.signExtend (32 + 1) (x✝ &&& 31#32)).getMsbD
                    1 =?= (73#33 - BitVec.signExtend 33 (x✝ &&& 31#32)).msb ≠
                  (73#33 - BitVec.signExtend 33 (x✝ &&& 31#32)).getMsbD 1
              [Meta.isDefEq.delta] [0.001688] ✅️ (BitVec.signExtend (32 + 1) 73#32 -
                        BitVec.signExtend (32 + 1) (x✝ &&& 31#32)).msb ≠
                    (BitVec.signExtend (32 + 1) 73#32 - BitVec.signExtend (32 + 1) (x✝ &&& 31#32)).getMsbD
                      1 =?= (73#33 - BitVec.signExtend 33 (x✝ &&& 31#32)).msb ≠
                    (73#33 - BitVec.signExtend 33 (x✝ &&& 31#32)).getMsbD 1
                [Meta.isDefEq] [0.001619] ✅️ (BitVec.signExtend (32 + 1) 73#32 -
                        BitVec.signExtend (32 + 1)
                          (x✝ &&& 31#32)).msb =?= (73#33 - BitVec.signExtend 33 (x✝ &&& 31#32)).msb
                  [Meta.isDefEq.delta] [0.001608] ✅️ (BitVec.signExtend (32 + 1) 73#32 -
                          BitVec.signExtend (32 + 1)
                            (x✝ &&& 31#32)).msb =?= (73#33 - BitVec.signExtend 33 (x✝ &&& 31#32)).msb
                    [Meta.isDefEq] [0.001583] ✅️ BitVec.signExtend (32 + 1) 73#32 -
                          BitVec.signExtend (32 + 1) (x✝ &&& 31#32) =?= 73#33 - BitVec.signExtend 33 (x✝ &&& 31#32)
                      [Meta.isDefEq] [0.001556] ✅️ instHSub.1 (BitVec.signExtend (32 + 1) 73#32)
                            (BitVec.signExtend (32 + 1)
                              (x✝ &&& 31#32)) =?= instHSub.1 (73#33) (BitVec.signExtend 33 (x✝ &&& 31#32))
                        [Meta.isDefEq] [0.001500] ✅️ Sub.sub (BitVec.signExtend (32 + 1) 73#32)
                              (BitVec.signExtend (32 + 1)
                                (x✝ &&& 31#32)) =?= Sub.sub (73#33) (BitVec.signExtend 33 (x✝ &&& 31#32))
                          [Meta.isDefEq] [0.001479] ✅️ BitVec.instSub.1 (BitVec.signExtend (32 + 1) 73#32)
                                (BitVec.signExtend (32 + 1)
                                  (x✝ &&& 31#32)) =?= BitVec.instSub.1 (73#33) (BitVec.signExtend 33 (x✝ &&& 31#32))
                            [Meta.isDefEq] [0.001437] ✅️ (BitVec.signExtend (32 + 1) 73#32).sub
                                  (BitVec.signExtend (32 + 1)
                                    (x✝ &&& 31#32)) =?= (73#33).sub (BitVec.signExtend 33 (x✝ &&& 31#32))
                              [Meta.isDefEq.delta] [0.001427] ✅️ (BitVec.signExtend (32 + 1) 73#32).sub
                                    (BitVec.signExtend (32 + 1)
                                      (x✝ &&& 31#32)) =?= (73#33).sub (BitVec.signExtend 33 (x✝ &&& 31#32))
                                [Meta.isDefEq] [0.001328] ✅️ BitVec.signExtend (32 + 1) 73#32 =?= 73#33
                                  [Meta.isDefEq] [0.001312] ✅️ BitVec.ofInt (32 + 1) (73#32).toInt =?= 73#33
                                    [Meta.isDefEq] [0.001298] ✅️ ((73#32).toInt %
                                              Int.ofNat (2 ^ (32 + 1))).toNat#'⋯ =?= 73#33
                                      [Meta.isDefEq] [0.001278] ✅️ ((73#32).toInt %
                                                Int.ofNat
                                                  (2 ^ (32 + 1))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 33) 73 }
                                        [Meta.isDefEq] [0.001265] ✅️ {
                                              toFin :=
                                                ⟨((73#32).toInt % Int.ofNat (2 ^ (32 + 1))).toNat,
                                                  ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 33) 73 }
                                          [Meta.isDefEq] [0.001216] ✅️ ⟨((73#32).toInt %
                                                    Int.ofNat (2 ^ (32 + 1))).toNat,
                                                ⋯⟩ =?= Fin.ofNat' (2 ^ 33) 73
                                            [Meta.isDefEq] [0.001196] ✅️ ⟨((73#32).toInt %
                                                      Int.ofNat (2 ^ (32 + 1))).toNat,
                                                  ⋯⟩ =?= ⟨73 % 2 ^ 33, ⋯⟩
                                              [Meta.isDefEq] [0.001101] ✅️ ((73#32).toInt %
                                                      Int.ofNat (2 ^ (32 + 1))).toNat =?= 73 % 2 ^ 33
                                                [Meta.isDefEq] [0.001024] ✅️ match
                                                      (73#32).toInt % Int.ofNat (2 ^ (32 + 1)) with
                                                    | Int.ofNat n => n
                                                    | Int.negSucc a => 0 =?= 73 % 2 ^ 33
  [Meta.appBuilder] [0.001706] ✅️ f: Subsingleton.elim, xs: [h✝, h]
    [Meta.synthInstance] [0.001652] ✅️ Subsingleton (Decidable c✝)
      [Meta.synthInstance] [0.001598] ✅️ apply instSubsingletonDecidable to Subsingleton (Decidable c✝)
        [Meta.synthInstance.tryResolve] [0.001576] ✅️ Subsingleton (Decidable c✝) ≟ Subsingleton (Decidable c✝)
          [Meta.isDefEq] [0.001555] ✅️ Subsingleton (Decidable c✝) =?= Subsingleton (Decidable ?m.15863)
            [Meta.isDefEq] [0.001538] ✅️ Decidable c✝ =?= Decidable ?m.15863
              [Meta.isDefEq] [0.001525] ✅️ c✝ =?= ?m.15863
                [Meta.isDefEq.assign] [0.001522] ✅️ ?m.15863 := c✝
                  [Meta.isDefEq.assign.checkTypes] [0.001516] ✅️ (?m.15863 : Prop) := (c✝ : Prop)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬some ((x✝ &&& 31#32 ^^^ 31#32) + 42#32) ⊑
            if
                (!(74#33 + ~~~BitVec.signExtend 33 (x✝ &&& 31#32)).getLsbD 32 ==
                      (74#33 + ~~~BitVec.signExtend 33 (x✝ &&& 31#32)).getMsbD 1) =
                  true then
              none
            else if (x✝ &&& 31#32 >ᵤ 73#32) = true then none else some (74#32 + ~~~(x✝ &&& 31#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
