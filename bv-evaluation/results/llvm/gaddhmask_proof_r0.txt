⚠ [782/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
⚠ [878/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [881/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
⚠ [887/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
⚠ [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddhmask_proof.lean:18:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddhmask_proof.lean:11:8: error: (kernel) declaration has metavariables 'add_mask_sign_i32_thm'
[bv] [0.062743] Normalizing goal
  [Meta.synthInstance] [0.002813] ✅️ Decidable
        ((if 31#32 ≥ ↑32 then none
          else
            if 31#32 ≥ ↑32 then none
            else some ((x✝.sshiftRight (31#32).toNat &&& 8#32) + x✝.sshiftRight (31#32).toNat)) ⊑
          match some (BitVec.ofBool (0#32 >ₛ x✝)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some 7#32
          | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
    [Meta.check] [0.001371] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if 31#32 ≥ ↑32 then none
          else
            if 31#32 ≥ ↑32 then none else some ((x✝.sshiftRight (31#32).toNat &&& 8#32) + x✝.sshiftRight (31#32).toNat))
          (match some (BitVec.ofBool (0#32 >ₛ x✝)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some 7#32
          | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if 31#32 ≥ ↑32 then none
            else
              if 31#32 ≥ ↑32 then none
              else some ((x✝.sshiftRight (31#32).toNat &&& 8#32) + x✝.sshiftRight (31#32).toNat)) ⊑
            match some (BitVec.ofBool (0#32 >ₛ x✝)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 7#32
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32
      ⊢ False
  [Meta.isDefEq] [0.001203] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } =>
        ?h_3 () =?= match some (if (!x✝.getLsbD 31 == (0#32 >ᵤ x✝)) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 7#32
      | some { toFin := ⟨0, ⋯⟩ } => some 0#32
  [Meta.isDefEq] [0.001318] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } =>
        ?h_3 () =?= match some (if (!x✝.getLsbD 31 == (0#32 >ᵤ x✝)) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 7#32
      | some { toFin := ⟨0, ⋯⟩ } => some 0#32
  [Meta.isDefEq] [0.001331] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } =>
        ?h_3 () =?= match some (if (!x✝.getLsbD 31 == (0#32 >ᵤ x✝)) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 7#32
      | some { toFin := ⟨0, ⋯⟩ } => some 0#32
  [Meta.isDefEq] [0.001214] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } =>
        ?h_3 () =?= match some (if (!x✝.getLsbD 31 == (0#32 >ᵤ x✝)) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 7#32
      | some { toFin := ⟨0, ⋯⟩ } => some 0#32
  [Meta.isDefEq] [0.001352] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } =>
        ?h_3 () =?= match some (if (!x✝.getLsbD 31 == (0#32 >ᵤ x✝)) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 7#32
      | some { toFin := ⟨0, ⋯⟩ } => some 0#32
  [Meta.isDefEq] [0.001266] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } =>
        ?h_3 () =?= match some (if (!x✝.getLsbD 31 == (0#32 >ᵤ x✝)) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 7#32
      | some { toFin := ⟨0, ⋯⟩ } => some 0#32
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬some ((x✝.sshiftRight 31 &&& 8#32) + x✝.sshiftRight 31) ⊑
            match some (if (!x✝.getLsbD 31 == (0#32 >ᵤ x✝)) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 7#32
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32
      ⊢ False
  [Meta.isDefEq] [0.001206] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } =>
        ?h_3 () =?= match some (if (!x✝.getLsbD 31 == (0#32 >ᵤ x✝)) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 7#32
      | some { toFin := ⟨0, ⋯⟩ } => some 0#32
  [Meta.isDefEq] [0.001292] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } =>
        ?h_3 () =?= match some (if (!x✝.getLsbD 31 == (0#32 >ᵤ x✝)) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 7#32
      | some { toFin := ⟨0, ⋯⟩ } => some 0#32
  [Meta.isDefEq] [0.001276] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } =>
        ?h_3 () =?= match some (if (!x✝.getLsbD 31 == (0#32 >ᵤ x✝)) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 7#32
      | some { toFin := ⟨0, ⋯⟩ } => some 0#32
  [Meta.isDefEq] [0.001024] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } =>
        ?h_3 () =?= match some (if (!x✝.getLsbD 31 == (0#32 >ᵤ x✝)) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 7#32
      | some { toFin := ⟨0, ⋯⟩ } => some 0#32
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddhmask_proof.lean:29:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddhmask_proof.lean:22:8: error: (kernel) declaration has metavariables 'add_mask_sign_commute_i32_thm'
[bv] [0.040576] Normalizing goal
  [Meta.synthInstance] [0.001758] ✅️ Decidable
        ((if 31#32 ≥ ↑32 then none
          else
            if 31#32 ≥ ↑32 then none
            else some (x✝.sshiftRight (31#32).toNat + (x✝.sshiftRight (31#32).toNat &&& 8#32))) ⊑
          match some (BitVec.ofBool (0#32 >ₛ x✝)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some 7#32
          | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if 31#32 ≥ ↑32 then none
            else
              if 31#32 ≥ ↑32 then none
              else some (x✝.sshiftRight (31#32).toNat + (x✝.sshiftRight (31#32).toNat &&& 8#32))) ⊑
            match some (BitVec.ofBool (0#32 >ₛ x✝)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 7#32
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬some (x✝.sshiftRight 31 + (x✝.sshiftRight 31 &&& 8#32)) ⊑
            match some (if (!x✝.getLsbD 31 == (0#32 >ᵤ x✝)) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 7#32
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 0.699750ms, solving context: 0.000000ms
LeanSAT proved the goal after 2.936780ms: rewriting 2.919120ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 89.044710ms, solving context: 0.000000ms
LeanSAT proved the goal after 125.242239ms: rewriting 17.823529ms, bitblasting 1.260790ms, SAT solving 58.441370ms, LRAT trimming 6.802860ms, LRAT checking 32.005220ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddhmask_proof.lean:52:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddhmask_proof.lean:44:8: error: (kernel) declaration has metavariables 'add_mask_ashr28_non_pow2_i32_thm'
[bv] [0.046812] Normalizing goal
  [Meta.synthInstance] [0.002078] ✅️ Decidable
        ((if 28#32 ≥ ↑32 then none
          else
            if 28#32 ≥ ↑32 then none
            else some ((x✝.sshiftRight (28#32).toNat &&& 9#32) + x✝.sshiftRight (28#32).toNat)) ⊑
          if 28#32 ≥ ↑32 then none
          else
            if 28#32 ≥ ↑32 then none
            else
              if
                  True ∧
                    (x✝.sshiftRight (28#32).toNat &&& 9#32).msb = (x✝.sshiftRight (28#32).toNat).msb ∧
                      ((x✝.sshiftRight (28#32).toNat &&& 9#32) + x✝.sshiftRight (28#32).toNat).msb ≠
                        (x✝.sshiftRight (28#32).toNat &&& 9#32).msb then
                none
              else some ((x✝.sshiftRight (28#32).toNat &&& 9#32) + x✝.sshiftRight (28#32).toNat))
    [Meta.check] [0.001070] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if 28#32 ≥ ↑32 then none
          else
            if 28#32 ≥ ↑32 then none else some ((x✝.sshiftRight (28#32).toNat &&& 9#32) + x✝.sshiftRight (28#32).toNat))
          (if 28#32 ≥ ↑32 then none
          else
            if 28#32 ≥ ↑32 then none
            else
              if
                  True ∧
                    (x✝.sshiftRight (28#32).toNat &&& 9#32).msb = (x✝.sshiftRight (28#32).toNat).msb ∧
                      ((x✝.sshiftRight (28#32).toNat &&& 9#32) + x✝.sshiftRight (28#32).toNat).msb ≠
                        (x✝.sshiftRight (28#32).toNat &&& 9#32).msb then
                none
              else some ((x✝.sshiftRight (28#32).toNat &&& 9#32) + x✝.sshiftRight (28#32).toNat))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if 28#32 ≥ ↑32 then none
            else
              if 28#32 ≥ ↑32 then none
              else some ((x✝.sshiftRight (28#32).toNat &&& 9#32) + x✝.sshiftRight (28#32).toNat)) ⊑
            if 28#32 ≥ ↑32 then none
            else
              if 28#32 ≥ ↑32 then none
              else
                if
                    True ∧
                      (x✝.sshiftRight (28#32).toNat &&& 9#32).msb = (x✝.sshiftRight (28#32).toNat).msb ∧
                        ((x✝.sshiftRight (28#32).toNat &&& 9#32) + x✝.sshiftRight (28#32).toNat).msb ≠
                          (x✝.sshiftRight (28#32).toNat &&& 9#32).msb then
                  none
                else some ((x✝.sshiftRight (28#32).toNat &&& 9#32) + x✝.sshiftRight (28#32).toNat)
      ⊢ False
  [Meta.isDefEq] [0.001124] ❌️ ?a ==
        ?a =?= ((x✝.sshiftRight 28 &&& 9#32) + x✝.sshiftRight 28).getLsbD 31 == (x✝.sshiftRight 28 &&& 9#32).getLsbD 31
  [Meta.isDefEq] [0.003628] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (congr
              (congrArg And
                (Eq.trans
                  (congr (congrArg Eq (BitVec.msb_eq_getLsbD_last (x✝.sshiftRight 28 &&& 9#32)))
                    (BitVec.msb_eq_getLsbD_last (x✝.sshiftRight 28)))
                  (Std.Tactic.BVDecide.Normalize.Bool.eq_to_beq ((x✝.sshiftRight 28 &&& 9#32).getLsbD 31)
                    ((x✝.sshiftRight 28).getLsbD 31))))
              (Eq.trans
                (congr (congrArg Ne (BitVec.msb_eq_getLsbD_last ((x✝.sshiftRight 28 &&& 9#32) + x✝.sshiftRight 28)))
                  (BitVec.msb_eq_getLsbD_last (x✝.sshiftRight 28 &&& 9#32)))
                (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                  (((x✝.sshiftRight 28 &&& 9#32) + x✝.sshiftRight 28).getLsbD 31)
                  ((x✝.sshiftRight 28 &&& 9#32).getLsbD 31))))
            (Std.Tactic.BVDecide.Normalize.Bool.and_to_and
              ((x✝.sshiftRight 28 &&& 9#32).getLsbD 31 == (x✝.sshiftRight 28).getLsbD 31)
              !((x✝.sshiftRight 28 &&& 9#32) + x✝.sshiftRight 28).getLsbD 31 ==
                  (x✝.sshiftRight 28 &&& 9#32).getLsbD 31)))
        (true_and
          (((x✝.sshiftRight 28 &&& 9#32).getLsbD 31 == (x✝.sshiftRight 28).getLsbD 31 &&
              !((x✝.sshiftRight 28 &&& 9#32) + x✝.sshiftRight 28).getLsbD 31 ==
                  (x✝.sshiftRight 28 &&& 9#32).getLsbD 31) =
            true))
    [Meta.isDefEq.assign] [0.003624] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (congr
                (congrArg And
                  (Eq.trans
                    (congr (congrArg Eq (BitVec.msb_eq_getLsbD_last (x✝.sshiftRight 28 &&& 9#32)))
                      (BitVec.msb_eq_getLsbD_last (x✝.sshiftRight 28)))
                    (Std.Tactic.BVDecide.Normalize.Bool.eq_to_beq ((x✝.sshiftRight 28 &&& 9#32).getLsbD 31)
                      ((x✝.sshiftRight 28).getLsbD 31))))
                (Eq.trans
                  (congr (congrArg Ne (BitVec.msb_eq_getLsbD_last ((x✝.sshiftRight 28 &&& 9#32) + x✝.sshiftRight 28)))
                    (BitVec.msb_eq_getLsbD_last (x✝.sshiftRight 28 &&& 9#32)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (((x✝.sshiftRight 28 &&& 9#32) + x✝.sshiftRight 28).getLsbD 31)
                    ((x✝.sshiftRight 28 &&& 9#32).getLsbD 31))))
              (Std.Tactic.BVDecide.Normalize.Bool.and_to_and
                ((x✝.sshiftRight 28 &&& 9#32).getLsbD 31 == (x✝.sshiftRight 28).getLsbD 31)
                !((x✝.sshiftRight 28 &&& 9#32) + x✝.sshiftRight 28).getLsbD 31 ==
                    (x✝.sshiftRight 28 &&& 9#32).getLsbD 31)))
          (true_and
            (((x✝.sshiftRight 28 &&& 9#32).getLsbD 31 == (x✝.sshiftRight 28).getLsbD 31 &&
                !((x✝.sshiftRight 28 &&& 9#32) + x✝.sshiftRight 28).getLsbD 31 ==
                    (x✝.sshiftRight 28 &&& 9#32).getLsbD 31) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.003594] ✅️ (?h₁ : (True ∧
              (x✝.sshiftRight (28#32).toNat &&& 9#32).msb = (x✝.sshiftRight (28#32).toNat).msb ∧
                ((x✝.sshiftRight (28#32).toNat &&& 9#32) + x✝.sshiftRight (28#32).toNat).msb ≠
                  (x✝.sshiftRight (28#32).toNat &&& 9#32).msb) =
            (((x✝.sshiftRight 28 &&& 9#32).getLsbD 31 == (x✝.sshiftRight 28).getLsbD 31 &&
                !((x✝.sshiftRight 28 &&& 9#32) + x✝.sshiftRight 28).getLsbD 31 ==
                    (x✝.sshiftRight 28 &&& 9#32).getLsbD 31) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (congr
                  (congrArg And
                    (Eq.trans
                      (congr (congrArg Eq (BitVec.msb_eq_getLsbD_last (x✝.sshiftRight 28 &&& 9#32)))
                        (BitVec.msb_eq_getLsbD_last (x✝.sshiftRight 28)))
                      (Std.Tactic.BVDecide.Normalize.Bool.eq_to_beq ((x✝.sshiftRight 28 &&& 9#32).getLsbD 31)
                        ((x✝.sshiftRight 28).getLsbD 31))))
                  (Eq.trans
                    (congr (congrArg Ne (BitVec.msb_eq_getLsbD_last ((x✝.sshiftRight 28 &&& 9#32) + x✝.sshiftRight 28)))
                      (BitVec.msb_eq_getLsbD_last (x✝.sshiftRight 28 &&& 9#32)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (((x✝.sshiftRight 28 &&& 9#32) + x✝.sshiftRight 28).getLsbD 31)
                      ((x✝.sshiftRight 28 &&& 9#32).getLsbD 31))))
                (Std.Tactic.BVDecide.Normalize.Bool.and_to_and
                  ((x✝.sshiftRight 28 &&& 9#32).getLsbD 31 == (x✝.sshiftRight 28).getLsbD 31)
                  !((x✝.sshiftRight 28 &&& 9#32) + x✝.sshiftRight 28).getLsbD 31 ==
                      (x✝.sshiftRight 28 &&& 9#32).getLsbD 31)))
            (true_and
              (((x✝.sshiftRight 28 &&& 9#32).getLsbD 31 == (x✝.sshiftRight 28).getLsbD 31 &&
                  !((x✝.sshiftRight 28 &&& 9#32) + x✝.sshiftRight 28).getLsbD 31 ==
                      (x✝.sshiftRight 28 &&& 9#32).getLsbD 31) =
                true)) : (True ∧
              (x✝.sshiftRight 28 &&& 9#32).msb = (x✝.sshiftRight 28).msb ∧
                ((x✝.sshiftRight 28 &&& 9#32) + x✝.sshiftRight 28).msb ≠ (x✝.sshiftRight 28 &&& 9#32).msb) =
            (((x✝.sshiftRight 28 &&& 9#32).getLsbD 31 == (x✝.sshiftRight 28).getLsbD 31 &&
                !((x✝.sshiftRight 28 &&& 9#32) + x✝.sshiftRight 28).getLsbD 31 ==
                    (x✝.sshiftRight 28 &&& 9#32).getLsbD 31) =
              true))
        [Meta.isDefEq] [0.003589] ✅️ (True ∧
                (x✝.sshiftRight (28#32).toNat &&& 9#32).msb = (x✝.sshiftRight (28#32).toNat).msb ∧
                  ((x✝.sshiftRight (28#32).toNat &&& 9#32) + x✝.sshiftRight (28#32).toNat).msb ≠
                    (x✝.sshiftRight (28#32).toNat &&& 9#32).msb) =
              (((x✝.sshiftRight 28 &&& 9#32).getLsbD 31 == (x✝.sshiftRight 28).getLsbD 31 &&
                  !((x✝.sshiftRight 28 &&& 9#32) + x✝.sshiftRight 28).getLsbD 31 ==
                      (x✝.sshiftRight 28 &&& 9#32).getLsbD 31) =
                true) =?= (True ∧
                (x✝.sshiftRight 28 &&& 9#32).msb = (x✝.sshiftRight 28).msb ∧
                  ((x✝.sshiftRight 28 &&& 9#32) + x✝.sshiftRight 28).msb ≠ (x✝.sshiftRight 28 &&& 9#32).msb) =
              (((x✝.sshiftRight 28 &&& 9#32).getLsbD 31 == (x✝.sshiftRight 28).getLsbD 31 &&
                  !((x✝.sshiftRight 28 &&& 9#32) + x✝.sshiftRight 28).getLsbD 31 ==
                      (x✝.sshiftRight 28 &&& 9#32).getLsbD 31) =
                true)
          [Meta.isDefEq] [0.003555] ✅️ True ∧
                (x✝.sshiftRight (28#32).toNat &&& 9#32).msb = (x✝.sshiftRight (28#32).toNat).msb ∧
                  ((x✝.sshiftRight (28#32).toNat &&& 9#32) + x✝.sshiftRight (28#32).toNat).msb ≠
                    (x✝.sshiftRight (28#32).toNat &&&
                        9#32).msb =?= True ∧
                (x✝.sshiftRight 28 &&& 9#32).msb = (x✝.sshiftRight 28).msb ∧
                  ((x✝.sshiftRight 28 &&& 9#32) + x✝.sshiftRight 28).msb ≠ (x✝.sshiftRight 28 &&& 9#32).msb
            [Meta.isDefEq] [0.003529] ✅️ (x✝.sshiftRight (28#32).toNat &&& 9#32).msb =
                    (x✝.sshiftRight (28#32).toNat).msb ∧
                  ((x✝.sshiftRight (28#32).toNat &&& 9#32) + x✝.sshiftRight (28#32).toNat).msb ≠
                    (x✝.sshiftRight (28#32).toNat &&&
                        9#32).msb =?= (x✝.sshiftRight 28 &&& 9#32).msb = (x✝.sshiftRight 28).msb ∧
                  ((x✝.sshiftRight 28 &&& 9#32) + x✝.sshiftRight 28).msb ≠ (x✝.sshiftRight 28 &&& 9#32).msb
              [Meta.isDefEq] [0.002390] ✅️ (x✝.sshiftRight (28#32).toNat &&& 9#32).msb =
                    (x✝.sshiftRight (28#32).toNat).msb =?= (x✝.sshiftRight 28 &&& 9#32).msb = (x✝.sshiftRight 28).msb
                [Meta.isDefEq] [0.002323] ✅️ (x✝.sshiftRight (28#32).toNat &&&
                        9#32).msb =?= (x✝.sshiftRight 28 &&& 9#32).msb
                  [Meta.isDefEq.delta] [0.002304] ✅️ (x✝.sshiftRight (28#32).toNat &&&
                          9#32).msb =?= (x✝.sshiftRight 28 &&& 9#32).msb
                    [Meta.isDefEq] [0.002277] ✅️ x✝.sshiftRight (28#32).toNat &&& 9#32 =?= x✝.sshiftRight 28 &&& 9#32
                      [Meta.isDefEq] [0.002243] ✅️ instHAndOfAndOp.1 (x✝.sshiftRight (28#32).toNat)
                            9#32 =?= instHAndOfAndOp.1 (x✝.sshiftRight 28) 9#32
                        [Meta.isDefEq] [0.002152] ✅️ AndOp.and (x✝.sshiftRight (28#32).toNat)
                              9#32 =?= AndOp.and (x✝.sshiftRight 28) 9#32
                          [Meta.isDefEq] [0.002117] ✅️ BitVec.instAndOp.1 (x✝.sshiftRight (28#32).toNat)
                                9#32 =?= BitVec.instAndOp.1 (x✝.sshiftRight 28) 9#32
                            [Meta.isDefEq] [0.002045] ✅️ (x✝.sshiftRight (28#32).toNat).and
                                  9#32 =?= (x✝.sshiftRight 28).and 9#32
                              [Meta.isDefEq.delta] [0.002027] ✅️ (x✝.sshiftRight (28#32).toNat).and
                                    9#32 =?= (x✝.sshiftRight 28).and 9#32
                                [Meta.isDefEq] [0.001986] ✅️ x✝.sshiftRight (28#32).toNat =?= x✝.sshiftRight 28
                                  [Meta.isDefEq.delta] [0.001969] ✅️ x✝.sshiftRight (28#32).toNat =?= x✝.sshiftRight 28
                                    [Meta.isDefEq] [0.001936] ✅️ (28#32).toNat =?= 28
                                      [Meta.isDefEq] [0.001900] ✅️ ↑(28#32).toFin =?= 28
                                        [Meta.isDefEq] [0.001865] ✅️ (28#32).toFin.1 =?= 28
                                          [Meta.whnf] [0.001717] Non-easy whnf: Fin (2 ^ 32)
              [Meta.isDefEq] [0.001122] ✅️ ((x✝.sshiftRight (28#32).toNat &&& 9#32) +
                        x✝.sshiftRight (28#32).toNat).msb ≠
                    (x✝.sshiftRight (28#32).toNat &&&
                        9#32).msb =?= ((x✝.sshiftRight 28 &&& 9#32) + x✝.sshiftRight 28).msb ≠
                    (x✝.sshiftRight 28 &&& 9#32).msb
                [Meta.isDefEq.delta] [0.001099] ✅️ ((x✝.sshiftRight (28#32).toNat &&& 9#32) +
                          x✝.sshiftRight (28#32).toNat).msb ≠
                      (x✝.sshiftRight (28#32).toNat &&&
                          9#32).msb =?= ((x✝.sshiftRight 28 &&& 9#32) + x✝.sshiftRight 28).msb ≠
                      (x✝.sshiftRight 28 &&& 9#32).msb
                  [Meta.isDefEq] [0.001027] ✅️ ((x✝.sshiftRight (28#32).toNat &&& 9#32) +
                          x✝.sshiftRight (28#32).toNat).msb =?= ((x✝.sshiftRight 28 &&& 9#32) + x✝.sshiftRight 28).msb
                    [Meta.isDefEq.delta] [0.001009] ✅️ ((x✝.sshiftRight (28#32).toNat &&& 9#32) +
                            x✝.sshiftRight (28#32).toNat).msb =?= ((x✝.sshiftRight 28 &&& 9#32) + x✝.sshiftRight 28).msb
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬some ((x✝.sshiftRight 28 &&& 9#32) + x✝.sshiftRight 28) ⊑
            if
                ((x✝.sshiftRight 28 &&& 9#32).getLsbD 31 == (x✝.sshiftRight 28).getLsbD 31 &&
                    !((x✝.sshiftRight 28 &&& 9#32) + x✝.sshiftRight 28).getLsbD 31 ==
                        (x✝.sshiftRight 28 &&& 9#32).getLsbD 31) =
                  true then
              none
            else some ((x✝.sshiftRight 28 &&& 9#32) + x✝.sshiftRight 28)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddhmask_proof.lean:64:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddhmask_proof.lean:56:8: error: (kernel) declaration has metavariables 'add_mask_ashr27_i32_thm'
[bv] [0.037046] Normalizing goal
  [Meta.synthInstance] [0.001288] ✅️ Decidable
        ((if 27#32 ≥ ↑32 then none
          else
            if 27#32 ≥ ↑32 then none
            else some ((x✝.sshiftRight (27#32).toNat &&& 8#32) + x✝.sshiftRight (27#32).toNat)) ⊑
          if 27#32 ≥ ↑32 then none
          else
            if 27#32 ≥ ↑32 then none
            else
              if
                  True ∧
                    (x✝.sshiftRight (27#32).toNat &&& 8#32).msb = (x✝.sshiftRight (27#32).toNat).msb ∧
                      ((x✝.sshiftRight (27#32).toNat &&& 8#32) + x✝.sshiftRight (27#32).toNat).msb ≠
                        (x✝.sshiftRight (27#32).toNat &&& 8#32).msb then
                none
              else some ((x✝.sshiftRight (27#32).toNat &&& 8#32) + x✝.sshiftRight (27#32).toNat))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if 27#32 ≥ ↑32 then none
            else
              if 27#32 ≥ ↑32 then none
              else some ((x✝.sshiftRight (27#32).toNat &&& 8#32) + x✝.sshiftRight (27#32).toNat)) ⊑
            if 27#32 ≥ ↑32 then none
            else
              if 27#32 ≥ ↑32 then none
              else
                if
                    True ∧
                      (x✝.sshiftRight (27#32).toNat &&& 8#32).msb = (x✝.sshiftRight (27#32).toNat).msb ∧
                        ((x✝.sshiftRight (27#32).toNat &&& 8#32) + x✝.sshiftRight (27#32).toNat).msb ≠
                          (x✝.sshiftRight (27#32).toNat &&& 8#32).msb then
                  none
                else some ((x✝.sshiftRight (27#32).toNat &&& 8#32) + x✝.sshiftRight (27#32).toNat)
      ⊢ False
  [Meta.isDefEq] [0.001278] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (congr
              (congrArg And
                (Eq.trans
                  (congr (congrArg Eq (BitVec.msb_eq_getLsbD_last (x✝.sshiftRight 27 &&& 8#32)))
                    (BitVec.msb_eq_getLsbD_last (x✝.sshiftRight 27)))
                  (Std.Tactic.BVDecide.Normalize.Bool.eq_to_beq ((x✝.sshiftRight 27 &&& 8#32).getLsbD 31)
                    ((x✝.sshiftRight 27).getLsbD 31))))
              (Eq.trans
                (congr (congrArg Ne (BitVec.msb_eq_getLsbD_last ((x✝.sshiftRight 27 &&& 8#32) + x✝.sshiftRight 27)))
                  (BitVec.msb_eq_getLsbD_last (x✝.sshiftRight 27 &&& 8#32)))
                (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                  (((x✝.sshiftRight 27 &&& 8#32) + x✝.sshiftRight 27).getLsbD 31)
                  ((x✝.sshiftRight 27 &&& 8#32).getLsbD 31))))
            (Std.Tactic.BVDecide.Normalize.Bool.and_to_and
              ((x✝.sshiftRight 27 &&& 8#32).getLsbD 31 == (x✝.sshiftRight 27).getLsbD 31)
              !((x✝.sshiftRight 27 &&& 8#32) + x✝.sshiftRight 27).getLsbD 31 ==
                  (x✝.sshiftRight 27 &&& 8#32).getLsbD 31)))
        (true_and
          (((x✝.sshiftRight 27 &&& 8#32).getLsbD 31 == (x✝.sshiftRight 27).getLsbD 31 &&
              !((x✝.sshiftRight 27 &&& 8#32) + x✝.sshiftRight 27).getLsbD 31 ==
                  (x✝.sshiftRight 27 &&& 8#32).getLsbD 31) =
            true))
    [Meta.isDefEq.assign] [0.001257] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (congr
                (congrArg And
                  (Eq.trans
                    (congr (congrArg Eq (BitVec.msb_eq_getLsbD_last (x✝.sshiftRight 27 &&& 8#32)))
                      (BitVec.msb_eq_getLsbD_last (x✝.sshiftRight 27)))
                    (Std.Tactic.BVDecide.Normalize.Bool.eq_to_beq ((x✝.sshiftRight 27 &&& 8#32).getLsbD 31)
                      ((x✝.sshiftRight 27).getLsbD 31))))
                (Eq.trans
                  (congr (congrArg Ne (BitVec.msb_eq_getLsbD_last ((x✝.sshiftRight 27 &&& 8#32) + x✝.sshiftRight 27)))
                    (BitVec.msb_eq_getLsbD_last (x✝.sshiftRight 27 &&& 8#32)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (((x✝.sshiftRight 27 &&& 8#32) + x✝.sshiftRight 27).getLsbD 31)
                    ((x✝.sshiftRight 27 &&& 8#32).getLsbD 31))))
              (Std.Tactic.BVDecide.Normalize.Bool.and_to_and
                ((x✝.sshiftRight 27 &&& 8#32).getLsbD 31 == (x✝.sshiftRight 27).getLsbD 31)
                !((x✝.sshiftRight 27 &&& 8#32) + x✝.sshiftRight 27).getLsbD 31 ==
                    (x✝.sshiftRight 27 &&& 8#32).getLsbD 31)))
          (true_and
            (((x✝.sshiftRight 27 &&& 8#32).getLsbD 31 == (x✝.sshiftRight 27).getLsbD 31 &&
                !((x✝.sshiftRight 27 &&& 8#32) + x✝.sshiftRight 27).getLsbD 31 ==
                    (x✝.sshiftRight 27 &&& 8#32).getLsbD 31) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.001235] ✅️ (?h₁ : (True ∧
              (x✝.sshiftRight (27#32).toNat &&& 8#32).msb = (x✝.sshiftRight (27#32).toNat).msb ∧
                ((x✝.sshiftRight (27#32).toNat &&& 8#32) + x✝.sshiftRight (27#32).toNat).msb ≠
                  (x✝.sshiftRight (27#32).toNat &&& 8#32).msb) =
            (((x✝.sshiftRight 27 &&& 8#32).getLsbD 31 == (x✝.sshiftRight 27).getLsbD 31 &&
                !((x✝.sshiftRight 27 &&& 8#32) + x✝.sshiftRight 27).getLsbD 31 ==
                    (x✝.sshiftRight 27 &&& 8#32).getLsbD 31) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (congr
                  (congrArg And
                    (Eq.trans
                      (congr (congrArg Eq (BitVec.msb_eq_getLsbD_last (x✝.sshiftRight 27 &&& 8#32)))
                        (BitVec.msb_eq_getLsbD_last (x✝.sshiftRight 27)))
                      (Std.Tactic.BVDecide.Normalize.Bool.eq_to_beq ((x✝.sshiftRight 27 &&& 8#32).getLsbD 31)
                        ((x✝.sshiftRight 27).getLsbD 31))))
                  (Eq.trans
                    (congr (congrArg Ne (BitVec.msb_eq_getLsbD_last ((x✝.sshiftRight 27 &&& 8#32) + x✝.sshiftRight 27)))
                      (BitVec.msb_eq_getLsbD_last (x✝.sshiftRight 27 &&& 8#32)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (((x✝.sshiftRight 27 &&& 8#32) + x✝.sshiftRight 27).getLsbD 31)
                      ((x✝.sshiftRight 27 &&& 8#32).getLsbD 31))))
                (Std.Tactic.BVDecide.Normalize.Bool.and_to_and
                  ((x✝.sshiftRight 27 &&& 8#32).getLsbD 31 == (x✝.sshiftRight 27).getLsbD 31)
                  !((x✝.sshiftRight 27 &&& 8#32) + x✝.sshiftRight 27).getLsbD 31 ==
                      (x✝.sshiftRight 27 &&& 8#32).getLsbD 31)))
            (true_and
              (((x✝.sshiftRight 27 &&& 8#32).getLsbD 31 == (x✝.sshiftRight 27).getLsbD 31 &&
                  !((x✝.sshiftRight 27 &&& 8#32) + x✝.sshiftRight 27).getLsbD 31 ==
                      (x✝.sshiftRight 27 &&& 8#32).getLsbD 31) =
                true)) : (True ∧
              (x✝.sshiftRight 27 &&& 8#32).msb = (x✝.sshiftRight 27).msb ∧
                ((x✝.sshiftRight 27 &&& 8#32) + x✝.sshiftRight 27).msb ≠ (x✝.sshiftRight 27 &&& 8#32).msb) =
            (((x✝.sshiftRight 27 &&& 8#32).getLsbD 31 == (x✝.sshiftRight 27).getLsbD 31 &&
                !((x✝.sshiftRight 27 &&& 8#32) + x✝.sshiftRight 27).getLsbD 31 ==
                    (x✝.sshiftRight 27 &&& 8#32).getLsbD 31) =
              true))
        [Meta.isDefEq] [0.001231] ✅️ (True ∧
                (x✝.sshiftRight (27#32).toNat &&& 8#32).msb = (x✝.sshiftRight (27#32).toNat).msb ∧
                  ((x✝.sshiftRight (27#32).toNat &&& 8#32) + x✝.sshiftRight (27#32).toNat).msb ≠
                    (x✝.sshiftRight (27#32).toNat &&& 8#32).msb) =
              (((x✝.sshiftRight 27 &&& 8#32).getLsbD 31 == (x✝.sshiftRight 27).getLsbD 31 &&
                  !((x✝.sshiftRight 27 &&& 8#32) + x✝.sshiftRight 27).getLsbD 31 ==
                      (x✝.sshiftRight 27 &&& 8#32).getLsbD 31) =
                true) =?= (True ∧
                (x✝.sshiftRight 27 &&& 8#32).msb = (x✝.sshiftRight 27).msb ∧
                  ((x✝.sshiftRight 27 &&& 8#32) + x✝.sshiftRight 27).msb ≠ (x✝.sshiftRight 27 &&& 8#32).msb) =
              (((x✝.sshiftRight 27 &&& 8#32).getLsbD 31 == (x✝.sshiftRight 27).getLsbD 31 &&
                  !((x✝.sshiftRight 27 &&& 8#32) + x✝.sshiftRight 27).getLsbD 31 ==
                      (x✝.sshiftRight 27 &&& 8#32).getLsbD 31) =
                true)
          [Meta.isDefEq] [0.001206] ✅️ True ∧
                (x✝.sshiftRight (27#32).toNat &&& 8#32).msb = (x✝.sshiftRight (27#32).toNat).msb ∧
                  ((x✝.sshiftRight (27#32).toNat &&& 8#32) + x✝.sshiftRight (27#32).toNat).msb ≠
                    (x✝.sshiftRight (27#32).toNat &&&
                        8#32).msb =?= True ∧
                (x✝.sshiftRight 27 &&& 8#32).msb = (x✝.sshiftRight 27).msb ∧
                  ((x✝.sshiftRight 27 &&& 8#32) + x✝.sshiftRight 27).msb ≠ (x✝.sshiftRight 27 &&& 8#32).msb
            [Meta.isDefEq] [0.001188] ✅️ (x✝.sshiftRight (27#32).toNat &&& 8#32).msb =
                    (x✝.sshiftRight (27#32).toNat).msb ∧
                  ((x✝.sshiftRight (27#32).toNat &&& 8#32) + x✝.sshiftRight (27#32).toNat).msb ≠
                    (x✝.sshiftRight (27#32).toNat &&&
                        8#32).msb =?= (x✝.sshiftRight 27 &&& 8#32).msb = (x✝.sshiftRight 27).msb ∧
                  ((x✝.sshiftRight 27 &&& 8#32) + x✝.sshiftRight 27).msb ≠ (x✝.sshiftRight 27 &&& 8#32).msb
  [Meta.appBuilder] [0.002199] ✅️ f: Subsingleton.elim, xs: [h✝, h]
    [Meta.synthInstance] [0.002125] ✅️ Subsingleton (Decidable c✝)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬some ((x✝.sshiftRight 27 &&& 8#32) + x✝.sshiftRight 27) ⊑
            if
                ((x✝.sshiftRight 27 &&& 8#32).getLsbD 31 == (x✝.sshiftRight 27).getLsbD 31 &&
                    !((x✝.sshiftRight 27 &&& 8#32) + x✝.sshiftRight 27).getLsbD 31 ==
                        (x✝.sshiftRight 27 &&& 8#32).getLsbD 31) =
                  true then
              none
            else some ((x✝.sshiftRight 27 &&& 8#32) + x✝.sshiftRight 27)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
