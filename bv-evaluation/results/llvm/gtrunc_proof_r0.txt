⚠ [667/887] Replayed SSA.Core.ErasedContext
warning: ././././SSA/Core/ErasedContext.lean:325:14: unused variable `t`
note: this linter can be disabled with `set_option linter.unusedVariables false`
⚠ [674/887] Replayed SSA.Core.Framework
warning: ././././SSA/Core/Framework.lean:1826:9: unused variable `inst`
note: this linter can be disabled with `set_option linter.unusedVariables false`
warning: ././././SSA/Core/Framework.lean:1833:75: unused variable `inst`
note: this linter can be disabled with `set_option linter.unusedVariables false`
warning: ././././SSA/Core/Framework.lean:2083:31: unused variable `x`
note: this linter can be disabled with `set_option linter.unusedVariables false`
warning: ././././SSA/Core/Framework.lean:2084:33: unused variable `x`
note: this linter can be disabled with `set_option linter.unusedVariables false`
⚠ [687/887] Replayed SSA.Core.MLIRSyntax.AST
warning: ././././SSA/Core/MLIRSyntax/AST.lean:40:4: The namespace 'SSAVal' is duplicated in the declaration 'MLIR.AST.SSAVal.SSAVal'
note: this linter can be disabled with `set_option linter.dupNamespace false`
⚠ [869/887] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [873/887] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
⚠ [874/887] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
⚠ [880/887] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
⚠ [881/887] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
✖ [887/887] Building SSA.Projects.InstCombine.tests.proofs.gtrunc_proof
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/LeanSearchClient/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/packages/leanwuzla/.lake/build/lib:././.lake/build/lib DYLD_LIBRARY_PATH= /Users/luisa/.elan/toolchains/leanprover--lean4---nightly-2024-10-25/bin/lean ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean -R ./././. -o ././.lake/build/lib/SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.olean -i ././.lake/build/lib/SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.ilean -c ././.lake/build/ir/SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.c --json
error: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:7:89: The external prover produced unexpected output, stdout:
stderr:
[error] /var/folders/mw/4wzj975d1_s2cxywvdfyyh000000gn/T/tmp.kf4OUzib:3:202: expected terms of same sort at indices 0 and 1 as argument to '='
info: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:7:89: [Meta.Tactic.bv] Running preprocessing pipeline on:
    case h
    x : BitVec 32
    a✝ : ¬BitVec.setWidth 32 (BitVec.setWidth 128 x >>> 16) = x >>> 16
    ⊢ False
[Meta.Tactic.bv] Rerunning pipeline on:
    case h
    x : BitVec 32
    a✝ : (!BitVec.zeroExtend 32 (BitVec.zeroExtend 128 x >>> 16) == x >>> 16) = true
    ⊢ False
[Meta.Tactic.bv] Pipeline reached a fixpoint
[Meta.Tactic.bv] New atom of width 32: x
[Meta.Tactic.bv] Reflected bv logical expression: !((zext 32 (>> 16 (zext 128 var0))) == (>> 16 var0))
[bv] [0.065212] Preparing LRAT reflection term
  [Meta.Tactic.bv] Encoded as SMT: (set-logic QF_BV)
      (declare-const x_0 (_ BitVec 32))
      (assert (not (= ((_ zero_extend 0) (bvlshr ((_ zero_extend 96) x_0) #b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000)) (bvlshr x_0 #b00000000000000000000000000010000))))
      (check-sat)
      (exit)
      
  [bv] [0.062492] Proving with bitwuzla
error: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:9:103: The external prover produced unexpected output, stdout:
stderr:
[error] /var/folders/mw/4wzj975d1_s2cxywvdfyyh000000gn/T/tmp.EAZKjnKR:3:202: expected terms of same sort at indices 0 and 1 as argument to '='
info: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:9:103: [bv] [0.011071] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      x : BitVec 64
      a✝ : ¬BitVec.setWidth 32 (BitVec.setWidth 128 x >>> 32) = BitVec.setWidth 32 (x >>> 32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      x : BitVec 64
      a✝ : (!BitVec.zeroExtend 32 (BitVec.zeroExtend 128 x >>> 32) == BitVec.zeroExtend 32 (x >>> 32)) = true
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
[Meta.Tactic.bv] New atom of width 64: x
[Meta.Tactic.bv] Reflected bv logical expression: !((zext 32 (>> 32 (zext 128 var0))) == (zext 32 (>> 32 var0)))
[bv] [0.064348] Preparing LRAT reflection term
  [Meta.Tactic.bv] Encoded as SMT: (set-logic QF_BV)
      (declare-const x_0 (_ BitVec 64))
      (assert (not (= ((_ zero_extend 0) (bvlshr ((_ zero_extend 64) x_0) #b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000)) ((_ zero_extend 0) (bvlshr x_0 #b0000000000000000000000000000000000000000000000000000000000100000)))))
      (check-sat)
      (exit)
      
  [bv] [0.062012] Proving with bitwuzla
error: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:18:46: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
info: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:18:46: [bv] [0.016997] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      x x_1 : BitVec 8
      a✝ :
        ¬some (BitVec.setWidth 16 ((BitVec.signExtend 32 x_1 * BitVec.signExtend 32 x).sshiftRight 3)) ⊑
            (if
                    BitVec.signExtend 32 (BitVec.signExtend 16 x_1) * BitVec.signExtend 32 (BitVec.signExtend 16 x) <
                        BitVec.signExtend 32 (BitVec.twoPow 16 15) ∨
                      BitVec.twoPow 32 15 ≤
                        BitVec.signExtend 32 (BitVec.signExtend 16 x_1) *
                          BitVec.signExtend 32 (BitVec.signExtend 16 x) then
                  none
                else some (BitVec.signExtend 16 x_1 * BitVec.signExtend 16 x)).bind
              fun x' => some (x'.sshiftRight 3)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      x x_1 : BitVec 8
      a✝ :
        ¬some (BitVec.zeroExtend 16 ((BitVec.signExtend 32 x_1 * BitVec.signExtend 32 x).sshiftRight 3)) ⊑
            (if
                    (!((!BitVec.signExtend 32 (BitVec.twoPow 16 15) >ᵤ
                              BitVec.signExtend 32 (BitVec.signExtend 16 x_1) *
                                BitVec.signExtend 32 (BitVec.signExtend 16 x)) &&
                          BitVec.twoPow 32 15 >ᵤ
                            BitVec.signExtend 32 (BitVec.signExtend 16 x_1) *
                              BitVec.signExtend 32 (BitVec.signExtend 16 x))) =
                      true then
                  none
                else some (BitVec.signExtend 16 x_1 * BitVec.signExtend 16 x)).bind
              fun a => some (a.sshiftRight 3)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
error: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:27:46: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
info: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:27:46: [bv] [0.017615] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      x x_1 : BitVec 8
      a✝ :
        ¬some (BitVec.setWidth 16 ((BitVec.signExtend 20 x_1 * BitVec.signExtend 20 x).sshiftRight 8)) ⊑
            (if
                    BitVec.signExtend 32 (BitVec.signExtend 16 x_1) * BitVec.signExtend 32 (BitVec.signExtend 16 x) <
                        BitVec.signExtend 32 (BitVec.twoPow 16 15) ∨
                      BitVec.twoPow 32 15 ≤
                        BitVec.signExtend 32 (BitVec.signExtend 16 x_1) *
                          BitVec.signExtend 32 (BitVec.signExtend 16 x) then
                  none
                else some (BitVec.signExtend 16 x_1 * BitVec.signExtend 16 x)).bind
              fun x' => some (x'.sshiftRight 8)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      x x_1 : BitVec 8
      a✝ :
        ¬some (BitVec.zeroExtend 16 ((BitVec.signExtend 20 x_1 * BitVec.signExtend 20 x).sshiftRight 8)) ⊑
            (if
                    (!((!BitVec.signExtend 32 (BitVec.twoPow 16 15) >ᵤ
                              BitVec.signExtend 32 (BitVec.signExtend 16 x_1) *
                                BitVec.signExtend 32 (BitVec.signExtend 16 x)) &&
                          BitVec.twoPow 32 15 >ᵤ
                            BitVec.signExtend 32 (BitVec.signExtend 16 x_1) *
                              BitVec.signExtend 32 (BitVec.signExtend 16 x))) =
                      true then
                  none
                else some (BitVec.signExtend 16 x_1 * BitVec.signExtend 16 x)).bind
              fun a => some (a.sshiftRight 8)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
error: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:30:99: The external prover produced unexpected output, stdout:
stderr:
[error] /var/folders/mw/4wzj975d1_s2cxywvdfyyh000000gn/T/tmp.iih7ChT2:3:155: expected terms of same sort at indices 0 and 1 as argument to '='
info: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:30:99: [bv] [0.010474] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      x : BitVec 32
      a✝ : ¬BitVec.setWidth 32 ((BitVec.setWidth 36 x ||| 66571993088#36).sshiftRight 8) = x >>> 8 ||| 4286578688#32
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      x : BitVec 32
      a✝ :
        (!BitVec.zeroExtend 32 ((BitVec.zeroExtend 36 x ||| 66571993088#36).sshiftRight 8) ==
              x >>> 8 ||| 4286578688#32) =
          true
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
[Meta.Tactic.bv] New atom of width 32: x
[Meta.Tactic.bv] Reflected bv logical expression: !((zext 32 (>>a 8 ((zext 36 var0) || 0xf80000000#36))) == ((>> 8 var0) || 0xff800000#32))
[bv] [0.062171] Preparing LRAT reflection term
  [Meta.Tactic.bv] Encoded as SMT: (set-logic QF_BV)
      (declare-const x_0 (_ BitVec 32))
      (assert (not (= ((_ zero_extend 0) (bvashr (bvor ((_ zero_extend 4) x_0) #b111110000000000000000000000000000000) #b000000000000000000000000000000001000)) (bvor (bvlshr x_0 #b00000000000000000000000000001000) #b11111111100000000000000000000000))))
      (check-sat)
      (exit)
      
  [bv] [0.059377] Proving with bitwuzla
error: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:32:103: The external prover produced unexpected output, stdout:
stderr:
[error] /var/folders/mw/4wzj975d1_s2cxywvdfyyh000000gn/T/tmp.DbaBmS9E:3:202: expected terms of same sort at indices 0 and 1 as argument to '='
info: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:32:103: [bv] [0.010215] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      x : BitVec 64
      a✝ : ¬BitVec.setWidth 92 (BitVec.setWidth 128 x >>> 32) = BitVec.setWidth 92 (x >>> 32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      x : BitVec 64
      a✝ : (!BitVec.zeroExtend 92 (BitVec.zeroExtend 128 x >>> 32) == BitVec.zeroExtend 92 (x >>> 32)) = true
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
[Meta.Tactic.bv] New atom of width 64: x
[Meta.Tactic.bv] Reflected bv logical expression: !((zext 92 (>> 32 (zext 128 var0))) == (zext 92 (>> 32 var0)))
[bv] [0.059920] Preparing LRAT reflection term
  [Meta.Tactic.bv] Encoded as SMT: (set-logic QF_BV)
      (declare-const x_0 (_ BitVec 64))
      (assert (not (= ((_ zero_extend 0) (bvlshr ((_ zero_extend 64) x_0) #b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000)) ((_ zero_extend 28) (bvlshr x_0 #b0000000000000000000000000000000000000000000000000000000000100000)))))
      (check-sat)
      (exit)
      
  [bv] [0.057552] Proving with bitwuzla
error: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:37:39: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
info: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:37:39: [bv] [0.018621] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      x x_1 : BitVec 32
      a✝ :
        ¬some (BitVec.setWidth 64 (BitVec.setWidth 128 x_1 <<< 32) ||| BitVec.setWidth 64 x) ⊑
            (if BitVec.setWidth 64 x_1 <<< 32 >>> 32 = BitVec.setWidth 64 x_1 then none
                else some (BitVec.setWidth 64 x_1 <<< 32)).bind
              fun a => some (a ||| BitVec.setWidth 64 x)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      x x_1 : BitVec 32
      a✝ :
        ¬some (BitVec.zeroExtend 64 (BitVec.zeroExtend 128 x_1 <<< 32) ||| BitVec.zeroExtend 64 x) ⊑
            (if (BitVec.zeroExtend 64 x_1 <<< 32 >>> 32 == BitVec.zeroExtend 64 x_1) = true then none
                else some (BitVec.zeroExtend 64 x_1 <<< 32)).bind
              fun a => some (a ||| BitVec.zeroExtend 64 x)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
error: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:56:88: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
info: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:56:88: [bv] [0.032767] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      x x_1 : BitVec 32
      a✝ :
        ¬((if 128#128 ≤ BitVec.setWidth 128 x &&& 31#128 then none
                else some (BitVec.setWidth 128 x_1 <<< (x.toNat % 340282366920938463463374607431768211456 &&& 31))).bind
              fun x' => some (BitVec.setWidth 64 x')) ⊑
            if
                (BitVec.setWidth 64 x_1 <<< ((x.toNat &&& 31) % 18446744073709551616)).sshiftRight
                    ((x.toNat &&& 31) % 18446744073709551616) =
                  BitVec.setWidth 64 x_1 then
              none
            else
              if
                  BitVec.setWidth 64 x_1 <<< ((x.toNat &&& 31) % 18446744073709551616) >>>
                      ((x.toNat &&& 31) % 18446744073709551616) =
                    BitVec.setWidth 64 x_1 then
                none
              else
                if 64#64 ≤ BitVec.setWidth 64 x &&& 31#64 then none
                else some (BitVec.setWidth 64 x_1 <<< ((x.toNat &&& 31) % 18446744073709551616))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      x x_1 : BitVec 32
      a✝ :
        ¬((if (!128#128 >ᵤ BitVec.zeroExtend 128 x &&& 31#128) = true then none
                else
                  some (BitVec.zeroExtend 128 x_1 <<< (x.toNat % 340282366920938463463374607431768211456 &&& 31))).bind
              fun a => some (BitVec.zeroExtend 64 a)) ⊑
            if
                ((BitVec.zeroExtend 64 x_1 <<< ((x.toNat &&& 31) % 18446744073709551616)).sshiftRight
                      ((x.toNat &&& 31) % 18446744073709551616) ==
                    BitVec.zeroExtend 64 x_1) =
                  true then
              none
            else
              if
                  (BitVec.zeroExtend 64 x_1 <<< ((x.toNat &&& 31) % 18446744073709551616) >>>
                        ((x.toNat &&& 31) % 18446744073709551616) ==
                      BitVec.zeroExtend 64 x_1) =
                    true then
                none
              else
                if (!64#64 >ᵤ BitVec.zeroExtend 64 x &&& 31#64) = true then none
                else some (BitVec.zeroExtend 64 x_1 <<< ((x.toNat &&& 31) % 18446744073709551616))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
error: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:64:84: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
info: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:64:84: [bv] [0.023832] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      x x_1 : BitVec 32
      a✝ :
        ¬((if 128#128 ≤ BitVec.setWidth 128 x &&& 31#128 then none
                else some (BitVec.setWidth 128 x_1 >>> (x.toNat % 340282366920938463463374607431768211456 &&& 31))).bind
              fun x' => some (BitVec.setWidth 64 x')) ⊑
            if 64#64 ≤ BitVec.setWidth 64 x &&& 31#64 then none
            else some (BitVec.setWidth 64 x_1 >>> ((x.toNat &&& 31) % 18446744073709551616))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      x x_1 : BitVec 32
      a✝ :
        ¬((if (!128#128 >ᵤ BitVec.zeroExtend 128 x &&& 31#128) = true then none
                else
                  some (BitVec.zeroExtend 128 x_1 >>> (x.toNat % 340282366920938463463374607431768211456 &&& 31))).bind
              fun a => some (BitVec.zeroExtend 64 a)) ⊑
            if (!64#64 >ᵤ BitVec.zeroExtend 64 x &&& 31#64) = true then none
            else some (BitVec.zeroExtend 64 x_1 >>> ((x.toNat &&& 31) % 18446744073709551616))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
error: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:72:96: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
info: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:72:96: [bv] [0.021660] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      x x_1 : BitVec 32
      a✝ :
        ¬((if 128#128 ≤ BitVec.setWidth 128 x &&& 31#128 then none
                else
                  some
                    ((BitVec.signExtend 128 x_1).sshiftRight
                      (x.toNat % 340282366920938463463374607431768211456 &&& 31))).bind
              fun x' => some (BitVec.setWidth 64 x')) ⊑
            if 64#64 ≤ BitVec.setWidth 64 x &&& 31#64 then none
            else some ((BitVec.signExtend 64 x_1).sshiftRight ((x.toNat &&& 31) % 18446744073709551616))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      x x_1 : BitVec 32
      a✝ :
        ¬((if (!128#128 >ᵤ BitVec.zeroExtend 128 x &&& 31#128) = true then none
                else
                  some
                    ((BitVec.signExtend 128 x_1).sshiftRight
                      (x.toNat % 340282366920938463463374607431768211456 &&& 31))).bind
              fun a => some (BitVec.zeroExtend 64 a)) ⊑
            if (!64#64 >ᵤ BitVec.zeroExtend 64 x &&& 31#64) = true then none
            else some ((BitVec.signExtend 64 x_1).sshiftRight ((x.toNat &&& 31) % 18446744073709551616))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
error: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:74:103: The external prover produced unexpected output, stdout:
stderr:
[error] /var/folders/mw/4wzj975d1_s2cxywvdfyyh000000gn/T/tmp.5zs99rwh:3:147: expected terms of same sort at indices 0 and 1 as argument to 'bvshl'
info: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:74:103: [Meta.Tactic.bv] Running preprocessing pipeline on:
    case h
    x : BitVec 64
    a✝ : ¬BitVec.setWidth 32 (x <<< 31) = BitVec.setWidth 32 x <<< 31
    ⊢ False
[Meta.Tactic.bv] Rerunning pipeline on:
    case h
    x : BitVec 64
    a✝ : (!BitVec.zeroExtend 32 (x <<< 31) == BitVec.zeroExtend 32 x <<< 31) = true
    ⊢ False
[Meta.Tactic.bv] Pipeline reached a fixpoint
[Meta.Tactic.bv] New atom of width 64: x
[Meta.Tactic.bv] Reflected bv logical expression: !((zext 32 (<< 31 var0)) == (<< 31 (zext 32 var0)))
[bv] [0.061973] Preparing LRAT reflection term
  [Meta.Tactic.bv] Encoded as SMT: (set-logic QF_BV)
      (declare-const x_0 (_ BitVec 64))
      (assert (not (= ((_ zero_extend 0) (bvshl x_0 #b0000000000000000000000000000000000000000000000000000000000011111)) (bvshl ((_ zero_extend 0) x_0) #b00000000000000000000000000011111))))
      (check-sat)
      (exit)
      
  [bv] [0.058413] Proving with bitwuzla
error: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:78:38: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
info: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:78:38: [bv] [0.015269] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      x : BitVec 64
      a✝ :
        ¬((if (x <<< 31).sshiftRight 31 = x then none else some (x <<< 31)).bind fun x' =>
              some (BitVec.setWidth 32 x')) ⊑
            some (BitVec.setWidth 32 x <<< 31)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      x : BitVec 64
      a✝ :
        ¬((if ((x <<< 31).sshiftRight 31 == x) = true then none else some (x <<< 31)).bind fun a =>
              some (BitVec.zeroExtend 32 a)) ⊑
            some (BitVec.zeroExtend 32 x <<< 31)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
error: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:82:38: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
info: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:82:38: [bv] [0.016890] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      x : BitVec 64
      a✝ :
        ¬((if x <<< 31 >>> 31 = x then none else some (x <<< 31)).bind fun x' => some (BitVec.setWidth 32 x')) ⊑
            some (BitVec.setWidth 32 x <<< 31)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      x : BitVec 64
      a✝ :
        ¬((if (x <<< 31 >>> 31 == x) = true then none else some (x <<< 31)).bind fun a =>
              some (BitVec.zeroExtend 32 a)) ⊑
            some (BitVec.zeroExtend 32 x <<< 31)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
error: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:87:38: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
info: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:87:38: [bv] [0.021525] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      x : BitVec 64
      a✝ :
        ¬((if (x <<< 31).sshiftRight 31 = x then none else if x <<< 31 >>> 31 = x then none else some (x <<< 31)).bind
              fun x' => some (BitVec.setWidth 32 x')) ⊑
            some (BitVec.setWidth 32 x <<< 31)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      x : BitVec 64
      a✝ :
        ¬((if ((x <<< 31).sshiftRight 31 == x) = true then none
                else if (x <<< 31 >>> 31 == x) = true then none else some (x <<< 31)).bind
              fun a => some (BitVec.zeroExtend 32 a)) ⊑
            some (BitVec.zeroExtend 32 x <<< 31)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
error: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:89:103: The external prover produced unexpected output, stdout:
stderr:
[error] /var/folders/mw/4wzj975d1_s2cxywvdfyyh000000gn/T/tmp.rPlku7xP:3:147: expected terms of same sort at indices 0 and 1 as argument to 'bvshl'
info: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:89:103: [Meta.Tactic.bv] Running preprocessing pipeline on:
    case h
    x : BitVec 64
    a✝ : ¬BitVec.setWidth 16 (x <<< 15) = BitVec.setWidth 16 x <<< 15
    ⊢ False
[Meta.Tactic.bv] Rerunning pipeline on:
    case h
    x : BitVec 64
    a✝ : (!BitVec.zeroExtend 16 (x <<< 15) == BitVec.zeroExtend 16 x <<< 15) = true
    ⊢ False
[Meta.Tactic.bv] Pipeline reached a fixpoint
[Meta.Tactic.bv] New atom of width 64: x
[Meta.Tactic.bv] Reflected bv logical expression: !((zext 16 (<< 15 var0)) == (<< 15 (zext 16 var0)))
[bv] [0.059399] Preparing LRAT reflection term
  [Meta.Tactic.bv] Encoded as SMT: (set-logic QF_BV)
      (declare-const x_0 (_ BitVec 64))
      (assert (not (= ((_ zero_extend 0) (bvshl x_0 #b0000000000000000000000000000000000000000000000000000000000001111)) (bvshl ((_ zero_extend 0) x_0) #b0000000000001111))))
      (check-sat)
      (exit)
      
  [bv] [0.057295] Proving with bitwuzla
error: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:91:103: The external prover produced unexpected output, stdout:
stderr:
[error] /var/folders/mw/4wzj975d1_s2cxywvdfyyh000000gn/T/tmp.HiCD0yWL:3:115: expected terms of same sort at indices 0 and 1 as argument to 'bvshl'
info: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:91:103: [bv] [0.010251] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      x : BitVec 32
      a✝ : ¬BitVec.setWidth 16 (x <<< 15) = BitVec.setWidth 16 x <<< 15
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      x : BitVec 32
      a✝ : (!BitVec.zeroExtend 16 (x <<< 15) == BitVec.zeroExtend 16 x <<< 15) = true
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
[Meta.Tactic.bv] New atom of width 32: x
[Meta.Tactic.bv] Reflected bv logical expression: !((zext 16 (<< 15 var0)) == (<< 15 (zext 16 var0)))
[bv] [0.064525] Preparing LRAT reflection term
  [Meta.Tactic.bv] Encoded as SMT: (set-logic QF_BV)
      (declare-const x_0 (_ BitVec 32))
      (assert (not (= ((_ zero_extend 0) (bvshl x_0 #b00000000000000000000000000001111)) (bvshl ((_ zero_extend 0) x_0) #b0000000000001111))))
      (check-sat)
      (exit)
      
  [bv] [0.061870] Proving with bitwuzla
error: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:93:97: The external prover produced unexpected output, stdout:
stderr:
[error] /var/folders/mw/4wzj975d1_s2cxywvdfyyh000000gn/T/tmp.M4SpIgt9:3:147: expected terms of same sort at indices 0 and 1 as argument to 'bvshl'
info: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:93:97: [Meta.Tactic.bv] Running preprocessing pipeline on:
    case h
    x : BitVec 64
    a✝ : ¬BitVec.setWidth 8 (x <<< 7) = BitVec.setWidth 8 x <<< 7
    ⊢ False
[Meta.Tactic.bv] Rerunning pipeline on:
    case h
    x : BitVec 64
    a✝ : (!BitVec.zeroExtend 8 (x <<< 7) == BitVec.zeroExtend 8 x <<< 7) = true
    ⊢ False
[Meta.Tactic.bv] Pipeline reached a fixpoint
[Meta.Tactic.bv] New atom of width 64: x
[Meta.Tactic.bv] Reflected bv logical expression: !((zext 8 (<< 7 var0)) == (<< 7 (zext 8 var0)))
[bv] [0.064430] Preparing LRAT reflection term
  [Meta.Tactic.bv] Encoded as SMT: (set-logic QF_BV)
      (declare-const x_0 (_ BitVec 64))
      (assert (not (= ((_ zero_extend 0) (bvshl x_0 #b0000000000000000000000000000000000000000000000000000000000000111)) (bvshl ((_ zero_extend 0) x_0) #b00000111))))
      (check-sat)
      (exit)
      
  [bv] [0.061839] Proving with bitwuzla
error: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:95:100: The external prover produced unexpected output, stdout:
stderr:
[error] /var/folders/mw/4wzj975d1_s2cxywvdfyyh000000gn/T/tmp.1lUsGZLz:3:147: expected terms of same sort at indices 0 and 1 as argument to 'bvshl'
info: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:95:100: [Meta.Tactic.bv] Running preprocessing pipeline on:
    case h
    x : BitVec 64
    a✝ : ¬BitVec.setWidth 32 (x <<< 1) = BitVec.setWidth 32 x <<< 1
    ⊢ False
[Meta.Tactic.bv] Rerunning pipeline on:
    case h
    x : BitVec 64
    a✝ : (!BitVec.zeroExtend 32 (x <<< 1) == BitVec.zeroExtend 32 x <<< 1) = true
    ⊢ False
[Meta.Tactic.bv] Pipeline reached a fixpoint
[Meta.Tactic.bv] New atom of width 64: x
[Meta.Tactic.bv] Reflected bv logical expression: !((zext 32 (<< 1 var0)) == (<< 1 (zext 32 var0)))
[bv] [0.059944] Preparing LRAT reflection term
  [Meta.Tactic.bv] Encoded as SMT: (set-logic QF_BV)
      (declare-const x_0 (_ BitVec 64))
      (assert (not (= ((_ zero_extend 0) (bvshl x_0 #b0000000000000000000000000000000000000000000000000000000000000001)) (bvshl ((_ zero_extend 0) x_0) #b00000000000000000000000000000001))))
      (check-sat)
      (exit)
      
  [bv] [0.057397] Proving with bitwuzla
error: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:97:103: The external prover produced unexpected output, stdout:
stderr:
[error] /var/folders/mw/4wzj975d1_s2cxywvdfyyh000000gn/T/tmp.5tLLHl61:3:147: expected terms of same sort at indices 0 and 1 as argument to 'bvshl'
info: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:97:103: [bv] [0.010432] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      x : BitVec 64
      a✝ : ¬BitVec.setWidth 32 (x <<< 16) = BitVec.setWidth 32 x <<< 16
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      x : BitVec 64
      a✝ : (!BitVec.zeroExtend 32 (x <<< 16) == BitVec.zeroExtend 32 x <<< 16) = true
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
[Meta.Tactic.bv] New atom of width 64: x
[Meta.Tactic.bv] Reflected bv logical expression: !((zext 32 (<< 16 var0)) == (<< 16 (zext 32 var0)))
[bv] [0.062226] Preparing LRAT reflection term
  [Meta.Tactic.bv] Encoded as SMT: (set-logic QF_BV)
      (declare-const x_0 (_ BitVec 64))
      (assert (not (= ((_ zero_extend 0) (bvshl x_0 #b0000000000000000000000000000000000000000000000000000000000010000)) (bvshl ((_ zero_extend 0) x_0) #b00000000000000000000000000010000))))
      (check-sat)
      (exit)
      
  [bv] [0.059780] Proving with bitwuzla
error: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:99:87: The external prover produced unexpected output, stdout:
stderr:
[error] /var/folders/mw/4wzj975d1_s2cxywvdfyyh000000gn/T/tmp.miyiM3ca:3:116: expected terms of same sort at indices 0 and 1 as argument to '='
info: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:99:87: [Meta.Tactic.bv] Running preprocessing pipeline on:
    case h
    x : BitVec 64
    a✝ : ¬BitVec.setWidth 32 (x <<< 33) = 0#32
    ⊢ False
[Meta.Tactic.bv] Rerunning pipeline on:
    case h
    x : BitVec 64
    a✝ : (!BitVec.zeroExtend 32 (x <<< 33) == 0#32) = true
    ⊢ False
[Meta.Tactic.bv] Pipeline reached a fixpoint
[Meta.Tactic.bv] New atom of width 64: x
[Meta.Tactic.bv] Reflected bv logical expression: !((zext 32 (<< 33 var0)) == 0x00000000#32)
[bv] [0.062992] Preparing LRAT reflection term
  [Meta.Tactic.bv] Encoded as SMT: (set-logic QF_BV)
      (declare-const x_0 (_ BitVec 64))
      (assert (not (= ((_ zero_extend 0) (bvshl x_0 #b0000000000000000000000000000000000000000000000000000000000100001)) #b00000000000000000000000000000000)))
      (check-sat)
      (exit)
      
  [bv] [0.060345] Proving with bitwuzla
error: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:101:87: The external prover produced unexpected output, stdout:
stderr:
[error] /var/folders/mw/4wzj975d1_s2cxywvdfyyh000000gn/T/tmp.TxU40RAz:3:116: expected terms of same sort at indices 0 and 1 as argument to '='
info: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:101:87: [Meta.Tactic.bv] Running preprocessing pipeline on:
    case h
    x : BitVec 64
    a✝ : ¬BitVec.setWidth 32 (x <<< 32) = 0#32
    ⊢ False
[Meta.Tactic.bv] Rerunning pipeline on:
    case h
    x : BitVec 64
    a✝ : (!BitVec.zeroExtend 32 (x <<< 32) == 0#32) = true
    ⊢ False
[Meta.Tactic.bv] Pipeline reached a fixpoint
[Meta.Tactic.bv] New atom of width 64: x
[Meta.Tactic.bv] Reflected bv logical expression: !((zext 32 (<< 32 var0)) == 0x00000000#32)
[bv] [0.064656] Preparing LRAT reflection term
  [Meta.Tactic.bv] Encoded as SMT: (set-logic QF_BV)
      (declare-const x_0 (_ BitVec 64))
      (assert (not (= ((_ zero_extend 0) (bvshl x_0 #b0000000000000000000000000000000000000000000000000000000000100000)) #b00000000000000000000000000000000)))
      (check-sat)
      (exit)
      
  [bv] [0.061648] Proving with bitwuzla
error: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:103:127: The external prover produced unexpected output, stdout:
stderr:
[error] /var/folders/mw/4wzj975d1_s2cxywvdfyyh000000gn/T/tmp.WZ6FTkTm:3:230: expected terms of same sort at indices 0 and 1 as argument to 'bvshl'
info: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:103:127: [bv] [0.012755] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      x : BitVec 64
      a✝ : ¬BitVec.setWidth 32 (x >>> 1 <<< 2) = BitVec.setWidth 32 x <<< 1 &&& 4294967292#32
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      x : BitVec 64
      a✝ : (!BitVec.zeroExtend 32 (x >>> 1 <<< 2) == BitVec.zeroExtend 32 x <<< 1 &&& 4294967292#32) = true
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
[Meta.Tactic.bv] New atom of width 64: x
[Meta.Tactic.bv] Reflected bv logical expression: !((zext 32 (<< 2 (>> 1 var0))) == ((<< 1 (zext 32 var0)) && 0xfffffffc#32))
[bv] [0.064179] Preparing LRAT reflection term
  [Meta.Tactic.bv] Encoded as SMT: (set-logic QF_BV)
      (declare-const x_0 (_ BitVec 64))
      (assert (not (= ((_ zero_extend 0) (bvshl (bvlshr x_0 #b0000000000000000000000000000000000000000000000000000000000000001) #b0000000000000000000000000000000000000000000000000000000000000010)) (bvand (bvshl ((_ zero_extend 0) x_0) #b00000000000000000000000000000001) #b11111111111111111111111111111100))))
      (check-sat)
      (exit)
      
  [bv] [0.061227] Proving with bitwuzla
error: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:106:86: The external prover produced unexpected output, stdout:
stderr:
[error] /var/folders/mw/4wzj975d1_s2cxywvdfyyh000000gn/T/tmp.XVSnuakP:3:299: expected terms of same sort at indices 0 and 1 as argument to 'bvand'
info: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:106:86: [bv] [0.011510] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      x : BitVec 64
      a✝ : ¬BitVec.setWidth 32 (x.sshiftRight 3 <<< 2) = BitVec.setWidth 32 (x >>> 1) &&& 4294967292#32
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      x : BitVec 64
      a✝ : (!BitVec.zeroExtend 32 (x.sshiftRight 3 <<< 2) == BitVec.zeroExtend 32 (x >>> 1) &&& 4294967292#32) = true
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
[Meta.Tactic.bv] New atom of width 64: x
[Meta.Tactic.bv] Reflected bv logical expression: !((zext 32 (<< 2 (>>a 3 var0))) == ((zext 32 (>> 1 var0)) && 0xfffffffc#32))
[bv] [0.060103] Preparing LRAT reflection term
  [Meta.Tactic.bv] Encoded as SMT: (set-logic QF_BV)
      (declare-const x_0 (_ BitVec 64))
      (assert (not (= ((_ zero_extend 0) (bvshl (bvashr x_0 #b0000000000000000000000000000000000000000000000000000000000000011) #b0000000000000000000000000000000000000000000000000000000000000010)) (bvand ((_ zero_extend 0) (bvlshr x_0 #b0000000000000000000000000000000000000000000000000000000000000001)) #b11111111111111111111111111111100))))
      (check-sat)
      (exit)
      
  [bv] [0.057304] Proving with bitwuzla
error: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:108:102: The external prover produced unexpected output, stdout:
stderr:
[error] /var/folders/mw/4wzj975d1_s2cxywvdfyyh000000gn/T/tmp.77Hmyj25:3:147: expected terms of same sort at indices 0 and 1 as argument to 'bvshl'
info: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:108:102: [Meta.Tactic.bv] Running preprocessing pipeline on:
    case h
    x : BitVec 64
    a✝ : ¬BitVec.setWidth 32 (x <<< 3) = BitVec.setWidth 32 x <<< 3
    ⊢ False
[Meta.Tactic.bv] Rerunning pipeline on:
    case h
    x : BitVec 64
    a✝ : (!BitVec.zeroExtend 32 (x <<< 3) == BitVec.zeroExtend 32 x <<< 3) = true
    ⊢ False
[Meta.Tactic.bv] Pipeline reached a fixpoint
[Meta.Tactic.bv] New atom of width 64: x
[Meta.Tactic.bv] Reflected bv logical expression: !((zext 32 (<< 3 var0)) == (<< 3 (zext 32 var0)))
[bv] [0.064165] Preparing LRAT reflection term
  [Meta.Tactic.bv] Encoded as SMT: (set-logic QF_BV)
      (declare-const x_0 (_ BitVec 64))
      (assert (not (= ((_ zero_extend 0) (bvshl x_0 #b0000000000000000000000000000000000000000000000000000000000000011)) (bvshl ((_ zero_extend 0) x_0) #b00000000000000000000000000000011))))
      (check-sat)
      (exit)
      
  [bv] [0.061684] Proving with bitwuzla
error: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:112:111: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
info: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:112:111: [bv] [0.020919] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      x x_1 : BitVec 64
      a✝ :
        ¬((if 64#64 ≤ x then none else some (x_1 >>> x.toNat)).bind fun x => some (BitVec.setWidth 32 (x <<< 2))) ⊑
            (if 64#64 ≤ x then none else some (x_1 >>> x.toNat)).bind fun x => some (BitVec.setWidth 32 x <<< 2)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      x x_1 : BitVec 64
      a✝ :
        ¬((if (!64#64 >ᵤ x) = true then none else some (x_1 >>> x.toNat)).bind fun a =>
              some (BitVec.zeroExtend 32 (a <<< 2))) ⊑
            (if (!64#64 >ᵤ x) = true then none else some (x_1 >>> x.toNat)).bind fun a =>
              some (BitVec.zeroExtend 32 a <<< 2)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
error: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:117:39: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
info: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:117:39: [bv] [0.019127] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      x x_1 : BitVec 64
      a✝ :
        ¬((if 64#64 ≤ x then none else some (x_1.sshiftRight x.toNat)).bind fun x =>
              some (BitVec.setWidth 32 (x <<< 2))) ⊑
            (if 64#64 ≤ x then none else some (x_1.sshiftRight x.toNat)).bind fun x => some (BitVec.setWidth 32 x <<< 2)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      x x_1 : BitVec 64
      a✝ :
        ¬((if (!64#64 >ᵤ x) = true then none else some (x_1.sshiftRight x.toNat)).bind fun a =>
              some (BitVec.zeroExtend 32 (a <<< 2))) ⊑
            (if (!64#64 >ᵤ x) = true then none else some (x_1.sshiftRight x.toNat)).bind fun a =>
              some (BitVec.zeroExtend 32 a <<< 2)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
error: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:121:111: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
info: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:121:111: [bv] [0.020242] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      x x_1 : BitVec 64
      a✝ :
        ¬((if 64#64 ≤ x then none else some (x_1 <<< x.toNat)).bind fun x => some (BitVec.setWidth 32 (x <<< 2))) ⊑
            (if 64#64 ≤ x then none else some (x_1 <<< x.toNat)).bind fun x => some (BitVec.setWidth 32 x <<< 2)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      x x_1 : BitVec 64
      a✝ :
        ¬((if (!64#64 >ᵤ x) = true then none else some (x_1 <<< x.toNat)).bind fun a =>
              some (BitVec.zeroExtend 32 (a <<< 2))) ⊑
            (if (!64#64 >ᵤ x) = true then none else some (x_1 <<< x.toNat)).bind fun a =>
              some (BitVec.zeroExtend 32 a <<< 2)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
info: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:124:84: Bitwuzla proved the goal after 0.000000ms
LeanSAT proved the goal after 5.000000ms: rewriting 0.000000ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
info: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:127:84: Bitwuzla proved the goal after 0.000000ms
LeanSAT proved the goal after 6.000000ms: rewriting 0.000000ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
info: ././././SSA/Projects/InstCombine/tests/proofs/gtrunc_proof.lean:130:84: Bitwuzla proved the goal after 0.000000ms
LeanSAT proved the goal after 5.000000ms: rewriting 0.000000ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
error: Lean exited with code 1
Some required builds logged failures:
- SSA.Projects.InstCombine.tests.proofs.gtrunc_proof
