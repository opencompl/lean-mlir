⚠ [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
⚠ [879/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [882/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
⚠ [887/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
⚠ [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:18:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:18:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:11:8: error: (kernel) declaration has metavariables 'and_xor_common_op_thm'
[bv] [0.048047] Normalizing goal
  [Meta.synthInstance] [0.001015] ✅️ Decidable
        ((if x✝ = 0 then none
          else if x✝ = 0 then none else if x✝¹ = 0 then none else some (42#32 / x✝ &&& (42#32 / x✝ ^^^ 43#32 / x✝¹))) ⊑
          if x✝ = 0 then none else if x✝¹ = 0 then none else some (42#32 / x✝ &&& (43#32 / x✝¹ ^^^ -1#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if x✝ = 0 then none
            else
              if x✝ = 0 then none else if x✝¹ = 0 then none else some (42#32 / x✝ &&& (42#32 / x✝ ^^^ 43#32 / x✝¹))) ⊑
            if x✝ = 0 then none else if x✝¹ = 0 then none else some (42#32 / x✝ &&& (43#32 / x✝¹ ^^^ -1#32))
      ⊢ False
  [Meta.isDefEq] [0.012101] ✅️ ?h₃ =?= fun a => Eq.refl (some (42#32 / x✝ &&& (43#32 / x✝¹ ^^^ 4294967295#32)))
    [Meta.isDefEq.assign] [0.012097] ✅️ ?h₃ := fun a => Eq.refl (some (42#32 / x✝ &&& (43#32 / x✝¹ ^^^ 4294967295#32)))
      [Meta.isDefEq.assign.checkTypes] [0.012072] ✅️ (?h₃ : ¬(x✝¹ == 0#32) = true →
            some (42#32 / x✝ &&& (43#32 / x✝¹ ^^^ -1#32)) =
              some
                (42#32 / x✝ &&&
                  (43#32 / x✝¹ ^^^
                    4294967295#32))) := (fun a =>
            Eq.refl
              (some
                (42#32 / x✝ &&&
                  (43#32 / x✝¹ ^^^
                    4294967295#32))) : ¬(x✝¹ == 0#32) = true →
            some (42#32 / x✝ &&& (43#32 / x✝¹ ^^^ 4294967295#32)) =
              some (42#32 / x✝ &&& (43#32 / x✝¹ ^^^ 4294967295#32)))
        [Meta.isDefEq] [0.012068] ✅️ ¬(x✝¹ == 0#32) = true →
              some (42#32 / x✝ &&& (43#32 / x✝¹ ^^^ -1#32)) =
                some
                  (42#32 / x✝ &&&
                    (43#32 / x✝¹ ^^^
                      4294967295#32)) =?= ¬(x✝¹ == 0#32) = true →
              some (42#32 / x✝ &&& (43#32 / x✝¹ ^^^ 4294967295#32)) =
                some (42#32 / x✝ &&& (43#32 / x✝¹ ^^^ 4294967295#32))
          [Meta.isDefEq] [0.012037] ✅️ some (42#32 / x✝ &&& (43#32 / x✝¹ ^^^ -1#32)) =
                some
                  (42#32 / x✝ &&&
                    (43#32 / x✝¹ ^^^
                      4294967295#32)) =?= some (42#32 / x✝ &&& (43#32 / x✝¹ ^^^ 4294967295#32)) =
                some (42#32 / x✝ &&& (43#32 / x✝¹ ^^^ 4294967295#32))
            [Meta.isDefEq] [0.012018] ✅️ some
                  (42#32 / x✝ &&& (43#32 / x✝¹ ^^^ -1#32)) =?= some (42#32 / x✝ &&& (43#32 / x✝¹ ^^^ 4294967295#32))
              [Meta.isDefEq] [0.011995] ✅️ 42#32 / x✝ &&&
                    (43#32 / x✝¹ ^^^ -1#32) =?= 42#32 / x✝ &&& (43#32 / x✝¹ ^^^ 4294967295#32)
                [Meta.isDefEq] [0.011968] ✅️ instHAndOfAndOp.1 (42#32 / x✝)
                      (43#32 / x✝¹ ^^^ -1#32) =?= instHAndOfAndOp.1 (42#32 / x✝) (43#32 / x✝¹ ^^^ 4294967295#32)
                  [Meta.isDefEq] [0.011899] ✅️ AndOp.and (42#32 / x✝)
                        (43#32 / x✝¹ ^^^ -1#32) =?= AndOp.and (42#32 / x✝) (43#32 / x✝¹ ^^^ 4294967295#32)
                    [Meta.isDefEq] [0.011868] ✅️ BitVec.instAndOp.1 (42#32 / x✝)
                          (43#32 / x✝¹ ^^^ -1#32) =?= BitVec.instAndOp.1 (42#32 / x✝) (43#32 / x✝¹ ^^^ 4294967295#32)
                      [Meta.isDefEq] [0.011809] ✅️ (42#32 / x✝).and
                            (43#32 / x✝¹ ^^^ -1#32) =?= (42#32 / x✝).and (43#32 / x✝¹ ^^^ 4294967295#32)
                        [Meta.isDefEq.delta] [0.011798] ✅️ (42#32 / x✝).and
                              (43#32 / x✝¹ ^^^ -1#32) =?= (42#32 / x✝).and (43#32 / x✝¹ ^^^ 4294967295#32)
                          [Meta.isDefEq] [0.011768] ✅️ 43#32 / x✝¹ ^^^ -1#32 =?= 43#32 / x✝¹ ^^^ 4294967295#32
                            [Meta.isDefEq] [0.011746] ✅️ instHXorOfXor.1 (43#32 / x✝¹)
                                  (-1#32) =?= instHXorOfXor.1 (43#32 / x✝¹) 4294967295#32
                              [Meta.isDefEq] [0.011687] ✅️ Xor.xor (43#32 / x✝¹)
                                    (-1#32) =?= Xor.xor (43#32 / x✝¹) 4294967295#32
                                [Meta.isDefEq] [0.011662] ✅️ BitVec.instXor.1 (43#32 / x✝¹)
                                      (-1#32) =?= BitVec.instXor.1 (43#32 / x✝¹) 4294967295#32
                                  [Meta.isDefEq] [0.011607] ✅️ (43#32 / x✝¹).xor
                                        (-1#32) =?= (43#32 / x✝¹).xor 4294967295#32
                                    [Meta.isDefEq.delta] [0.011596] ✅️ (43#32 / x✝¹).xor
                                          (-1#32) =?= (43#32 / x✝¹).xor 4294967295#32
                                      [Meta.isDefEq] [0.011569] ✅️ -1#32 =?= 4294967295#32
                                        [Meta.isDefEq] [0.011500] ✅️ -1#32 =?= {
                                              toFin := Fin.ofNat' (2 ^ 32) 4294967295 }
                                          [Meta.isDefEq] [0.011488] ✅️ BitVec.instNeg.1
                                                1#32 =?= { toFin := Fin.ofNat' (2 ^ 32) 4294967295 }
                                            [Meta.isDefEq] [0.011458] ✅️ (1#32).neg =?= {
                                                  toFin := Fin.ofNat' (2 ^ 32) 4294967295 }
                                              [Meta.isDefEq] [0.011441] ✅️ BitVec.ofNat 32
                                                    (2 ^ 32 -
                                                      (1#32).toNat) =?= { toFin := Fin.ofNat' (2 ^ 32) 4294967295 }
                                                [Meta.isDefEq] [0.011432] ✅️ {
                                                      toFin :=
                                                        Fin.ofNat' (2 ^ 32)
                                                          (2 ^ 32 -
                                                            (1#32).toNat) } =?= {
                                                      toFin := Fin.ofNat' (2 ^ 32) 4294967295 }
                                                  [Meta.isDefEq] [0.011395] ✅️ Fin.ofNat' (2 ^ 32)
                                                        (2 ^ 32 - (1#32).toNat) =?= Fin.ofNat' (2 ^ 32) 4294967295
                                                    [Meta.isDefEq.delta] [0.011377] ✅️ Fin.ofNat' (2 ^ 32)
                                                          (2 ^ 32 - (1#32).toNat) =?= Fin.ofNat' (2 ^ 32) 4294967295
                                                      [Meta.isDefEq] [0.011337] ✅️ 2 ^ 32 - (1#32).toNat =?= 4294967295
                                                        [Meta.whnf] [0.001828] Non-easy whnf: instSubNat
                                                        [Meta.isDefEq] [0.009385] ✅️ instHSub.1 (2 ^ 32)
                                                              (1#32).toNat =?= (instOfNatNat 4294967295).1
                                                          [Meta.isDefEq] [0.009330] ✅️ Sub.sub (2 ^ 32)
                                                                (1#32).toNat =?= 4294967295
                                                            [Meta.isDefEq] [0.009302] ✅️ instSubNat.1 (2 ^ 32)
                                                                  (1#32).toNat =?= 4294967295
                                                              [Meta.isDefEq] [0.009268] ✅️ (2 ^ 32).sub
                                                                    (1#32).toNat =?= 4294967295
                                                                [Meta.whnf] [0.003960] Non-easy whnf: 2 ^ 32
                                                                  [Meta.whnf] [0.003932] Non-easy whnf: instHPow.1 2 32
                                                                    [Meta.whnf] [0.001644] Non-easy whnf: instHPow
                                                                [Meta.whnf] [0.005289] Non-easy whnf: (1#32).toNat
                                                                  [Meta.whnf] [0.005271] Non-easy whnf: ↑(1#32).toFin
                                                                    [Meta.whnf] [0.005262] Non-easy whnf: (1#32).toFin.1
                                                                      [Meta.whnf] [0.003578] Non-easy whnf: instHMod.1 1
                                                                            (2 ^ 32)
                                                                        [Meta.whnf] [0.001844] Non-easy whnf: instHMod
                                                                        [Meta.whnf] [0.001713] Non-easy whnf: Nat.instMod.1
                                                                              1 (2 ^ 32)
                                                                          [Meta.whnf] [0.001680] Non-easy whnf: Nat.instMod
                                                                            [Meta.whnf] [0.001668] Non-easy whnf: {
                                                                                  mod := Nat.mod }
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝ == 0#32) = true then none
            else
              if (x✝ == 0#32) = true then none
              else if (x✝¹ == 0#32) = true then none else some (42#32 / x✝ &&& (42#32 / x✝ ^^^ 43#32 / x✝¹))) ⊑
            if (x✝ == 0#32) = true then none
            else if (x✝¹ == 0#32) = true then none else some (42#32 / x✝ &&& (43#32 / x✝¹ ^^^ 4294967295#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:29:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:22:8: error: (kernel) declaration has metavariables 'and_xor_common_op_commute1_thm'
[bv] [0.033668] Normalizing goal
  [Meta.synthInstance] [0.001094] ✅️ Decidable
        ((if x✝ = 0 then none
          else if x✝¹ = 0 then none else if x✝ = 0 then none else some (42#32 / x✝ &&& (43#32 / x✝¹ ^^^ 42#32 / x✝))) ⊑
          if x✝ = 0 then none else if x✝¹ = 0 then none else some (42#32 / x✝ &&& (43#32 / x✝¹ ^^^ -1#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if x✝ = 0 then none
            else
              if x✝¹ = 0 then none else if x✝ = 0 then none else some (42#32 / x✝ &&& (43#32 / x✝¹ ^^^ 42#32 / x✝))) ⊑
            if x✝ = 0 then none else if x✝¹ = 0 then none else some (42#32 / x✝ &&& (43#32 / x✝¹ ^^^ -1#32))
      ⊢ False
  [Meta.isDefEq] [0.001020] ✅️ ?h₃ =?= fun a => Eq.refl (some (42#32 / x✝ &&& (43#32 / x✝¹ ^^^ 4294967295#32)))
    [Meta.isDefEq.assign] [0.001016] ✅️ ?h₃ := fun a => Eq.refl (some (42#32 / x✝ &&& (43#32 / x✝¹ ^^^ 4294967295#32)))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝ == 0#32) = true then none
            else
              if (x✝¹ == 0#32) = true then none
              else if (x✝ == 0#32) = true then none else some (42#32 / x✝ &&& (43#32 / x✝¹ ^^^ 42#32 / x✝))) ⊑
            if (x✝ == 0#32) = true then none
            else if (x✝¹ == 0#32) = true then none else some (42#32 / x✝ &&& (43#32 / x✝¹ ^^^ 4294967295#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:40:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:40:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:33:8: error: (kernel) declaration has metavariables 'and_xor_common_op_commute2_thm'
[bv] [0.032830] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if x✝ = 0 then none
            else
              if x✝¹ = 0 then none else if x✝¹ = 0 then none else some ((43#32 / x✝ ^^^ 42#32 / x✝¹) &&& 42#32 / x✝¹)) ⊑
            if x✝¹ = 0 then none else if x✝ = 0 then none else some (42#32 / x✝¹ &&& (43#32 / x✝ ^^^ -1#32))
      ⊢ False
  [Meta.isDefEq] [0.001037] ✅️ ?h₃ =?= fun a => Eq.refl (some (42#32 / x✝¹ &&& (43#32 / x✝ ^^^ 4294967295#32)))
    [Meta.isDefEq.assign] [0.001034] ✅️ ?h₃ := fun a => Eq.refl (some (42#32 / x✝¹ &&& (43#32 / x✝ ^^^ 4294967295#32)))
      [Meta.isDefEq.assign.checkTypes] [0.001010] ✅️ (?h₃ : ¬(x✝ == 0#32) = true →
            some (42#32 / x✝¹ &&& (43#32 / x✝ ^^^ -1#32)) =
              some
                (42#32 / x✝¹ &&&
                  (43#32 / x✝ ^^^
                    4294967295#32))) := (fun a =>
            Eq.refl
              (some
                (42#32 / x✝¹ &&&
                  (43#32 / x✝ ^^^
                    4294967295#32))) : ¬(x✝ == 0#32) = true →
            some (42#32 / x✝¹ &&& (43#32 / x✝ ^^^ 4294967295#32)) =
              some (42#32 / x✝¹ &&& (43#32 / x✝ ^^^ 4294967295#32)))
        [Meta.isDefEq] [0.001005] ✅️ ¬(x✝ == 0#32) = true →
              some (42#32 / x✝¹ &&& (43#32 / x✝ ^^^ -1#32)) =
                some
                  (42#32 / x✝¹ &&&
                    (43#32 / x✝ ^^^
                      4294967295#32)) =?= ¬(x✝ == 0#32) = true →
              some (42#32 / x✝¹ &&& (43#32 / x✝ ^^^ 4294967295#32)) =
                some (42#32 / x✝¹ &&& (43#32 / x✝ ^^^ 4294967295#32))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝ == 0#32) = true then none
            else
              if (x✝¹ == 0#32) = true then none
              else if (x✝¹ == 0#32) = true then none else some ((43#32 / x✝ ^^^ 42#32 / x✝¹) &&& 42#32 / x✝¹)) ⊑
            if (x✝¹ == 0#32) = true then none
            else if (x✝ == 0#32) = true then none else some (42#32 / x✝¹ &&& (43#32 / x✝ ^^^ 4294967295#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 89.006010ms, solving context: 5.000000ms
LeanSAT proved the goal after 126.121490ms: rewriting 20.008930ms, bitblasting 0.000000ms, SAT solving 62.267980ms, LRAT trimming 16.528079ms, LRAT checking 14.982220ms
Bitwuzla proved the goal after 86.323919ms, solving context: 2.000000ms
LeanSAT proved the goal after 163.093210ms: rewriting 18.546930ms, bitblasting 0.000000ms, SAT solving 107.705810ms, LRAT trimming 13.929690ms, LRAT checking 11.778800ms
Bitwuzla proved the goal after 83.732580ms, solving context: 4.000000ms
LeanSAT proved the goal after 225.348839ms: rewriting 19.978570ms, bitblasting 0.000000ms, SAT solving 156.776789ms, LRAT trimming 11.452450ms, LRAT checking 10.242750ms
Bitwuzla proved the goal after 68.174780ms, solving context: 2.000000ms
LeanSAT proved the goal after 147.732329ms: rewriting 9.961010ms, bitblasting 0.000000ms, SAT solving 109.389889ms, LRAT trimming 13.284670ms, LRAT checking 7.874060ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:91:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:91:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:91:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:91:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:82:8: error: (kernel) declaration has metavariables 'and_xor_or1_thm'
[bv] [0.037131] Normalizing goal
  [Meta.synthInstance] [0.001017] ✅️ Decidable
        ((if x✝ = 0 then none
          else
            if x✝¹ = 0 then none
            else
              if x✝² = 0 then none
              else if x✝¹ = 0 then none else some (42#64 / x✝ &&& 42#64 / x✝¹ ^^^ 42#64 / x✝² ||| 42#64 / x✝¹)) ⊑
          if x✝² = 0 then none else if x✝¹ = 0 then none else some (42#64 / x✝² ||| 42#64 / x✝¹))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 64
      x✝² x✝¹ x✝ : BitVec 64
      a✝ :
        ¬(if x✝ = 0 then none
            else
              if x✝¹ = 0 then none
              else
                if x✝² = 0 then none
                else if x✝¹ = 0 then none else some (42#64 / x✝ &&& 42#64 / x✝¹ ^^^ 42#64 / x✝² ||| 42#64 / x✝¹)) ⊑
            if x✝² = 0 then none else if x✝¹ = 0 then none else some (42#64 / x✝² ||| 42#64 / x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 64
      x✝² x✝¹ x✝ : BitVec 64
      a✝ :
        ¬(if (x✝ == 0#64) = true then none
            else
              if (x✝¹ == 0#64) = true then none
              else
                if (x✝² == 0#64) = true then none
                else
                  if (x✝¹ == 0#64) = true then none
                  else some (42#64 / x✝ &&& 42#64 / x✝¹ ^^^ 42#64 / x✝² ||| 42#64 / x✝¹)) ⊑
            if (x✝² == 0#64) = true then none
            else if (x✝¹ == 0#64) = true then none else some (42#64 / x✝² ||| 42#64 / x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:104:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:104:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:104:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:104:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:95:8: error: (kernel) declaration has metavariables 'and_xor_or2_thm'
[bv] [0.036827] Normalizing goal
  [Meta.synthInstance] [0.001016] ✅️ Decidable
        ((if x✝ = 0 then none
          else
            if x✝¹ = 0 then none
            else
              if x✝² = 0 then none
              else if x✝ = 0 then none else some (42#64 / x✝ &&& 42#64 / x✝¹ ^^^ 42#64 / x✝² ||| 42#64 / x✝)) ⊑
          if x✝² = 0 then none else if x✝ = 0 then none else some (42#64 / x✝² ||| 42#64 / x✝))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 64
      x✝² x✝¹ x✝ : BitVec 64
      a✝ :
        ¬(if x✝ = 0 then none
            else
              if x✝¹ = 0 then none
              else
                if x✝² = 0 then none
                else if x✝ = 0 then none else some (42#64 / x✝ &&& 42#64 / x✝¹ ^^^ 42#64 / x✝² ||| 42#64 / x✝)) ⊑
            if x✝² = 0 then none else if x✝ = 0 then none else some (42#64 / x✝² ||| 42#64 / x✝)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 64
      x✝² x✝¹ x✝ : BitVec 64
      a✝ :
        ¬(if (x✝ == 0#64) = true then none
            else
              if (x✝¹ == 0#64) = true then none
              else
                if (x✝² == 0#64) = true then none
                else
                  if (x✝ == 0#64) = true then none
                  else some (42#64 / x✝ &&& 42#64 / x✝¹ ^^^ 42#64 / x✝² ||| 42#64 / x✝)) ⊑
            if (x✝² == 0#64) = true then none
            else if (x✝ == 0#64) = true then none else some (42#64 / x✝² ||| 42#64 / x✝)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:117:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:117:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:117:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:108:8: error: (kernel) declaration has metavariables 'and_xor_or3_thm'
[bv] [0.037354] Normalizing goal
  [Meta.synthInstance] [0.001016] ✅️ Decidable
        ((if x✝ = 0 then none
          else
            if x✝¹ = 0 then none
            else
              if x✝² = 0 then none
              else if x✝² = 0 then none else some (42#64 / x✝ ^^^ 42#64 / x✝¹ &&& 42#64 / x✝² ||| 42#64 / x✝²)) ⊑
          if x✝ = 0 then none else if x✝² = 0 then none else some (42#64 / x✝ ||| 42#64 / x✝²))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 64
      x✝² x✝¹ x✝ : BitVec 64
      a✝ :
        ¬(if x✝ = 0 then none
            else
              if x✝¹ = 0 then none
              else
                if x✝² = 0 then none
                else if x✝² = 0 then none else some (42#64 / x✝ ^^^ 42#64 / x✝¹ &&& 42#64 / x✝² ||| 42#64 / x✝²)) ⊑
            if x✝ = 0 then none else if x✝² = 0 then none else some (42#64 / x✝ ||| 42#64 / x✝²)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 64
      x✝² x✝¹ x✝ : BitVec 64
      a✝ :
        ¬(if (x✝ == 0#64) = true then none
            else
              if (x✝¹ == 0#64) = true then none
              else
                if (x✝² == 0#64) = true then none
                else
                  if (x✝² == 0#64) = true then none
                  else some (42#64 / x✝ ^^^ 42#64 / x✝¹ &&& 42#64 / x✝² ||| 42#64 / x✝²)) ⊑
            if (x✝ == 0#64) = true then none
            else if (x✝² == 0#64) = true then none else some (42#64 / x✝ ||| 42#64 / x✝²)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:130:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:130:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:121:8: error: (kernel) declaration has metavariables 'and_xor_or4_thm'
[bv] [0.035541] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 64
      x✝² x✝¹ x✝ : BitVec 64
      a✝ :
        ¬(if x✝ = 0 then none
            else
              if x✝¹ = 0 then none
              else
                if x✝² = 0 then none
                else if x✝¹ = 0 then none else some (42#64 / x✝ ^^^ 42#64 / x✝¹ &&& 42#64 / x✝² ||| 42#64 / x✝¹)) ⊑
            if x✝ = 0 then none else if x✝¹ = 0 then none else some (42#64 / x✝ ||| 42#64 / x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 64
      x✝² x✝¹ x✝ : BitVec 64
      a✝ :
        ¬(if (x✝ == 0#64) = true then none
            else
              if (x✝¹ == 0#64) = true then none
              else
                if (x✝² == 0#64) = true then none
                else
                  if (x✝¹ == 0#64) = true then none
                  else some (42#64 / x✝ ^^^ 42#64 / x✝¹ &&& 42#64 / x✝² ||| 42#64 / x✝¹)) ⊑
            if (x✝ == 0#64) = true then none
            else if (x✝¹ == 0#64) = true then none else some (42#64 / x✝ ||| 42#64 / x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:142:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:142:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:142:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:134:8: error: (kernel) declaration has metavariables 'and_xor_or5_thm'
[bv] [0.036287] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 64
      x✝² x✝¹ x✝ : BitVec 64
      a✝ :
        ¬(if x✝ = 0 then none
            else
              if x✝¹ = 0 then none
              else
                if x✝ = 0 then none
                else if x✝² = 0 then none else some (42#64 / x✝ ||| 42#64 / x✝¹ &&& 42#64 / x✝ ^^^ 42#64 / x✝²)) ⊑
            if x✝ = 0 then none else if x✝² = 0 then none else some (42#64 / x✝ ||| 42#64 / x✝²)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 64
      x✝² x✝¹ x✝ : BitVec 64
      a✝ :
        ¬(if (x✝ == 0#64) = true then none
            else
              if (x✝¹ == 0#64) = true then none
              else
                if (x✝ == 0#64) = true then none
                else
                  if (x✝² == 0#64) = true then none
                  else some (42#64 / x✝ ||| 42#64 / x✝¹ &&& 42#64 / x✝ ^^^ 42#64 / x✝²)) ⊑
            if (x✝ == 0#64) = true then none
            else if (x✝² == 0#64) = true then none else some (42#64 / x✝ ||| 42#64 / x✝²)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:154:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:154:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:154:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:154:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:146:8: error: (kernel) declaration has metavariables 'and_xor_or6_thm'
[bv] [0.036164] Normalizing goal
  [Meta.synthInstance] [0.001086] ✅️ Decidable
        ((if x✝ = 0 then none
          else
            if x✝ = 0 then none
            else
              if x✝¹ = 0 then none
              else if x✝² = 0 then none else some (42#64 / x✝ ||| 42#64 / x✝ &&& 42#64 / x✝¹ ^^^ 42#64 / x✝²)) ⊑
          if x✝ = 0 then none else if x✝² = 0 then none else some (42#64 / x✝ ||| 42#64 / x✝²))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 64
      x✝² x✝¹ x✝ : BitVec 64
      a✝ :
        ¬(if x✝ = 0 then none
            else
              if x✝ = 0 then none
              else
                if x✝¹ = 0 then none
                else if x✝² = 0 then none else some (42#64 / x✝ ||| 42#64 / x✝ &&& 42#64 / x✝¹ ^^^ 42#64 / x✝²)) ⊑
            if x✝ = 0 then none else if x✝² = 0 then none else some (42#64 / x✝ ||| 42#64 / x✝²)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 64
      x✝² x✝¹ x✝ : BitVec 64
      a✝ :
        ¬(if (x✝ == 0#64) = true then none
            else
              if (x✝ == 0#64) = true then none
              else
                if (x✝¹ == 0#64) = true then none
                else
                  if (x✝² == 0#64) = true then none
                  else some (42#64 / x✝ ||| 42#64 / x✝ &&& 42#64 / x✝¹ ^^^ 42#64 / x✝²)) ⊑
            if (x✝ == 0#64) = true then none
            else if (x✝² == 0#64) = true then none else some (42#64 / x✝ ||| 42#64 / x✝²)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:166:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:166:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:158:8: error: (kernel) declaration has metavariables 'and_xor_or7_thm'
[bv] [0.035561] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 64
      x✝² x✝¹ x✝ : BitVec 64
      a✝ :
        ¬(if x✝ = 0 then none
            else
              if x✝¹ = 0 then none
              else
                if x✝² = 0 then none
                else if x✝ = 0 then none else some (42#64 / x✝ ||| 42#64 / x✝¹ ^^^ 42#64 / x✝² &&& 42#64 / x✝)) ⊑
            if x✝ = 0 then none else if x✝¹ = 0 then none else some (42#64 / x✝ ||| 42#64 / x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 64
      x✝² x✝¹ x✝ : BitVec 64
      a✝ :
        ¬(if (x✝ == 0#64) = true then none
            else
              if (x✝¹ == 0#64) = true then none
              else
                if (x✝² == 0#64) = true then none
                else
                  if (x✝ == 0#64) = true then none
                  else some (42#64 / x✝ ||| 42#64 / x✝¹ ^^^ 42#64 / x✝² &&& 42#64 / x✝)) ⊑
            if (x✝ == 0#64) = true then none
            else if (x✝¹ == 0#64) = true then none else some (42#64 / x✝ ||| 42#64 / x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:178:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:178:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:170:8: error: (kernel) declaration has metavariables 'and_xor_or8_thm'
[bv] [0.035646] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 64
      x✝² x✝¹ x✝ : BitVec 64
      a✝ :
        ¬(if x✝ = 0 then none
            else
              if x✝¹ = 0 then none
              else
                if x✝ = 0 then none
                else if x✝² = 0 then none else some (42#64 / x✝ ||| 42#64 / x✝¹ ^^^ 42#64 / x✝ &&& 42#64 / x✝²)) ⊑
            if x✝ = 0 then none else if x✝¹ = 0 then none else some (42#64 / x✝ ||| 42#64 / x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 64
      x✝² x✝¹ x✝ : BitVec 64
      a✝ :
        ¬(if (x✝ == 0#64) = true then none
            else
              if (x✝¹ == 0#64) = true then none
              else
                if (x✝ == 0#64) = true then none
                else
                  if (x✝² == 0#64) = true then none
                  else some (42#64 / x✝ ||| 42#64 / x✝¹ ^^^ 42#64 / x✝ &&& 42#64 / x✝²)) ⊑
            if (x✝ == 0#64) = true then none
            else if (x✝¹ == 0#64) = true then none else some (42#64 / x✝ ||| 42#64 / x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:188:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:188:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:188:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:188:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:182:8: error: (kernel) declaration has metavariables 'and_shl_thm'
[bv] [0.023046] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 8
      x✝³ x✝² x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if x✝¹ ≥ ↑8 then none else if x✝¹ ≥ ↑8 then none else some (x✝ <<< x✝¹ &&& (x✝² <<< x✝¹ &&& x✝³))) ⊑
            if x✝¹ ≥ ↑8 then none else some ((x✝² &&& x✝) <<< x✝¹ &&& x✝³)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 8
      x✝³ x✝² x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if (!8#8 >ᵤ x✝¹) = true then none
            else if (!8#8 >ᵤ x✝¹) = true then none else some (x✝ <<< x✝¹ &&& (x✝² <<< x✝¹ &&& x✝³))) ⊑
            if (!8#8 >ᵤ x✝¹) = true then none else some ((x✝² &&& x✝) <<< x✝¹ &&& x✝³)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:198:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:198:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:192:8: error: (kernel) declaration has metavariables 'or_shl_thm'
[bv] [0.022165] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 8
      x✝³ x✝² x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if x✝¹ ≥ ↑8 then none else if x✝¹ ≥ ↑8 then none else some (x✝ <<< x✝¹ ||| x✝² ||| x✝³ <<< x✝¹)) ⊑
            if x✝¹ ≥ ↑8 then none else some ((x✝ ||| x✝³) <<< x✝¹ ||| x✝²)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 8
      x✝³ x✝² x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if (!8#8 >ᵤ x✝¹) = true then none
            else if (!8#8 >ᵤ x✝¹) = true then none else some (x✝ <<< x✝¹ ||| x✝² ||| x✝³ <<< x✝¹)) ⊑
            if (!8#8 >ᵤ x✝¹) = true then none else some ((x✝ ||| x✝³) <<< x✝¹ ||| x✝²)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:208:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:208:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:208:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:208:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:202:8: error: (kernel) declaration has metavariables 'or_lshr_thm'
[bv] [0.021602] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 8
      x✝³ x✝² x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if x✝¹ ≥ ↑8 then none else if x✝¹ ≥ ↑8 then none else some (x✝ >>> x✝¹ ||| (x✝² >>> x✝¹ ||| x✝³))) ⊑
            if x✝¹ ≥ ↑8 then none else some ((x✝² ||| x✝) >>> x✝¹ ||| x✝³)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 8
      x✝³ x✝² x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if (!8#8 >ᵤ x✝¹) = true then none
            else if (!8#8 >ᵤ x✝¹) = true then none else some (x✝ >>> x✝¹ ||| (x✝² >>> x✝¹ ||| x✝³))) ⊑
            if (!8#8 >ᵤ x✝¹) = true then none else some ((x✝² ||| x✝) >>> x✝¹ ||| x✝³)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:218:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:218:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:212:8: error: (kernel) declaration has metavariables 'xor_lshr_thm'
[bv] [0.021580] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 8
      x✝³ x✝² x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if x✝¹ ≥ ↑8 then none else if x✝¹ ≥ ↑8 then none else some (x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹)) ⊑
            if x✝¹ ≥ ↑8 then none else some ((x✝ ^^^ x✝³) >>> x✝¹ ^^^ x✝²)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 8
      x✝³ x✝² x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if (!8#8 >ᵤ x✝¹) = true then none
            else if (!8#8 >ᵤ x✝¹) = true then none else some (x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹)) ⊑
            if (!8#8 >ᵤ x✝¹) = true then none else some ((x✝ ^^^ x✝³) >>> x✝¹ ^^^ x✝²)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:229:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:229:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:222:8: error: (kernel) declaration has metavariables 'xor_lshr_multiuse_thm'
[bv] [0.108662] Normalizing goal
  [Meta.synthInstance] [0.001241] ✅️ Decidable
        ((if x✝¹ ≥ ↑8 then none
          else
            if x✝¹ ≥ ↑8 then none
            else
              if x✝¹ ≥ ↑8 then none
              else
                if
                    (x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 0 ||
                        8 != 1 && x✝ >>> x✝¹ ^^^ x✝² == BitVec.intMin 8 && x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == -1) =
                      true then
                  none
                else some ((x✝ >>> x✝¹ ^^^ x✝²).sdiv (x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹))) ⊑
          if x✝¹ ≥ ↑8 then none
          else
            if x✝¹ ≥ ↑8 then none
            else
              if
                  ((x✝ ^^^ x✝³) >>> x✝¹ ^^^ x✝² == 0 ||
                      8 != 1 && x✝ >>> x✝¹ ^^^ x✝² == BitVec.intMin 8 && (x✝ ^^^ x✝³) >>> x✝¹ ^^^ x✝² == -1) =
                    true then
                none
              else some ((x✝ >>> x✝¹ ^^^ x✝²).sdiv ((x✝ ^^^ x✝³) >>> x✝¹ ^^^ x✝²)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 8
      x✝³ x✝² x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if x✝¹ ≥ ↑8 then none
            else
              if x✝¹ ≥ ↑8 then none
              else
                if x✝¹ ≥ ↑8 then none
                else
                  if
                      (x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 0 ||
                          8 != 1 && x✝ >>> x✝¹ ^^^ x✝² == BitVec.intMin 8 && x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == -1) =
                        true then
                    none
                  else some ((x✝ >>> x✝¹ ^^^ x✝²).sdiv (x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹))) ⊑
            if x✝¹ ≥ ↑8 then none
            else
              if x✝¹ ≥ ↑8 then none
              else
                if
                    ((x✝ ^^^ x✝³) >>> x✝¹ ^^^ x✝² == 0 ||
                        8 != 1 && x✝ >>> x✝¹ ^^^ x✝² == BitVec.intMin 8 && (x✝ ^^^ x✝³) >>> x✝¹ ^^^ x✝² == -1) =
                      true then
                  none
                else some ((x✝ >>> x✝¹ ^^^ x✝²).sdiv ((x✝ ^^^ x✝³) >>> x✝¹ ^^^ x✝²))
      ⊢ False
  [Meta.isDefEq] [0.001270] ✅️ ?h₁ =?= congrArg (fun x => x = true)
        (Eq.trans
          (congrArg
            (fun x => x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 0#8 || x && x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 255#8)
            (Bool.true_and (x✝ >>> x✝¹ ^^^ x✝² == BitVec.intMin 8)))
          (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 0#8)
            (x✝ >>> x✝¹ ^^^ x✝² == BitVec.intMin 8 && x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 255#8)))
    [Meta.isDefEq.assign] [0.001268] ✅️ ?h₁ := congrArg (fun x => x = true)
          (Eq.trans
            (congrArg
              (fun x => x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 0#8 || x && x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 255#8)
              (Bool.true_and (x✝ >>> x✝¹ ^^^ x✝² == BitVec.intMin 8)))
            (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 0#8)
              (x✝ >>> x✝¹ ^^^ x✝² == BitVec.intMin 8 && x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 255#8)))
      [Meta.isDefEq.assign.checkTypes] [0.001254] ✅️ (?h₁ : ((x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 0 ||
                8 != 1 && x✝ >>> x✝¹ ^^^ x✝² == BitVec.intMin 8 && x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == -1) =
              true) =
            ((!(!x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 0#8 &&
                  !(x✝ >>> x✝¹ ^^^ x✝² == BitVec.intMin 8 && x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 255#8))) =
              true)) := (congrArg (fun x => x = true)
            (Eq.trans
              (congrArg
                (fun x => x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 0#8 || x && x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 255#8)
                (Bool.true_and (x✝ >>> x✝¹ ^^^ x✝² == BitVec.intMin 8)))
              (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 0#8)
                (x✝ >>> x✝¹ ^^^ x✝² == BitVec.intMin 8 &&
                  x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ ==
                    255#8))) : ((x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 0#8 ||
                true && x✝ >>> x✝¹ ^^^ x✝² == BitVec.intMin 8 && x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 255#8) =
              true) =
            ((!(!x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 0#8 &&
                  !(x✝ >>> x✝¹ ^^^ x✝² == BitVec.intMin 8 && x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 255#8))) =
              true))
        [Meta.isDefEq] [0.001251] ✅️ ((x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 0 ||
                  8 != 1 && x✝ >>> x✝¹ ^^^ x✝² == BitVec.intMin 8 && x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == -1) =
                true) =
              ((!(!x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 0#8 &&
                    !(x✝ >>> x✝¹ ^^^ x✝² == BitVec.intMin 8 && x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 255#8))) =
                true) =?= ((x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 0#8 ||
                  true && x✝ >>> x✝¹ ^^^ x✝² == BitVec.intMin 8 && x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 255#8) =
                true) =
              ((!(!x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 0#8 &&
                    !(x✝ >>> x✝¹ ^^^ x✝² == BitVec.intMin 8 && x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 255#8))) =
                true)
          [Meta.isDefEq] [0.001232] ✅️ (x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 0 ||
                  8 != 1 && x✝ >>> x✝¹ ^^^ x✝² == BitVec.intMin 8 && x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == -1) =
                true =?= (x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 0#8 ||
                  true && x✝ >>> x✝¹ ^^^ x✝² == BitVec.intMin 8 && x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 255#8) =
                true
            [Meta.isDefEq] [0.001218] ✅️ x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 0 ||
                  8 != 1 && x✝ >>> x✝¹ ^^^ x✝² == BitVec.intMin 8 &&
                    x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ ==
                      -1 =?= x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 0#8 ||
                  true && x✝ >>> x✝¹ ^^^ x✝² == BitVec.intMin 8 && x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 255#8
              [Meta.isDefEq.delta] [0.001204] ✅️ x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 0 ||
                    8 != 1 && x✝ >>> x✝¹ ^^^ x✝² == BitVec.intMin 8 &&
                      x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ ==
                        -1 =?= x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 0#8 ||
                    true && x✝ >>> x✝¹ ^^^ x✝² == BitVec.intMin 8 && x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 255#8
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 8
      x✝³ x✝² x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if (!8#8 >ᵤ x✝¹) = true then none
            else
              if (!8#8 >ᵤ x✝¹) = true then none
              else
                if (!8#8 >ᵤ x✝¹) = true then none
                else
                  if
                      (!(!x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 0#8 &&
                            !(x✝ >>> x✝¹ ^^^ x✝² == BitVec.intMin 8 && x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹ == 255#8))) =
                        true then
                    none
                  else
                    some
                      (if (x✝ >>> x✝¹ ^^^ x✝²).getLsbD 7 = true then
                        if (x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹).getLsbD 7 = true then
                          (~~~(x✝ >>> x✝¹ ^^^ x✝²) + 1#8) / (~~~(x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹) + 1#8)
                        else ~~~((~~~(x✝ >>> x✝¹ ^^^ x✝²) + 1#8) / (x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹)) + 1#8
                      else
                        if (x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹).getLsbD 7 = true then
                          ~~~((x✝ >>> x✝¹ ^^^ x✝²) / (~~~(x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹) + 1#8)) + 1#8
                        else (x✝ >>> x✝¹ ^^^ x✝²) / (x✝ >>> x✝¹ ^^^ x✝² ^^^ x✝³ >>> x✝¹))) ⊑
            if (!8#8 >ᵤ x✝¹) = true then none
            else
              if (!8#8 >ᵤ x✝¹) = true then none
              else
                if
                    (!(!(x✝ ^^^ x✝³) >>> x✝¹ ^^^ x✝² == 0#8 &&
                          !(x✝ >>> x✝¹ ^^^ x✝² == BitVec.intMin 8 && (x✝ ^^^ x✝³) >>> x✝¹ ^^^ x✝² == 255#8))) =
                      true then
                  none
                else
                  some
                    (if (x✝ >>> x✝¹ ^^^ x✝²).getLsbD 7 = true then
                      if ((x✝ ^^^ x✝³) >>> x✝¹ ^^^ x✝²).getLsbD 7 = true then
                        (~~~(x✝ >>> x✝¹ ^^^ x✝²) + 1#8) / (~~~((x✝ ^^^ x✝³) >>> x✝¹ ^^^ x✝²) + 1#8)
                      else ~~~((~~~(x✝ >>> x✝¹ ^^^ x✝²) + 1#8) / ((x✝ ^^^ x✝³) >>> x✝¹ ^^^ x✝²)) + 1#8
                    else
                      if ((x✝ ^^^ x✝³) >>> x✝¹ ^^^ x✝²).getLsbD 7 = true then
                        ~~~((x✝ >>> x✝¹ ^^^ x✝²) / (~~~((x✝ ^^^ x✝³) >>> x✝¹ ^^^ x✝²) + 1#8)) + 1#8
                      else (x✝ >>> x✝¹ ^^^ x✝²) / ((x✝ ^^^ x✝³) >>> x✝¹ ^^^ x✝²))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:240:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:233:8: error: (kernel) declaration has metavariables 'not_and_and_not_thm'
[bv] [0.046601] Normalizing goal
  [Meta.synthInstance] [0.001146] ✅️ Decidable
        ((if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else some ((42#32).sdiv x✝ &&& (x✝¹ ^^^ -1#32) &&& (x✝² ^^^ -1#32))) ⊑
          if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else some ((42#32).sdiv x✝ &&& ((x✝¹ ||| x✝²) ^^^ -1#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some ((42#32).sdiv x✝ &&& (x✝¹ ^^^ -1#32) &&& (x✝² ^^^ -1#32))) ⊑
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some ((42#32).sdiv x✝ &&& ((x✝¹ ||| x✝²) ^^^ -1#32))
      ⊢ False
  [Meta.isDefEq] [0.001282] ✅️ ?h₁ =?= congrArg (fun x => x = true)
        (Eq.trans
          (congrArg (fun x => x✝ == 0#32 || x && x✝ == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
          (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝ == 0#32) (42#32 == BitVec.intMin 32 && x✝ == 4294967295#32)))
    [Meta.isDefEq.assign] [0.001280] ✅️ ?h₁ := congrArg (fun x => x = true)
          (Eq.trans
            (congrArg (fun x => x✝ == 0#32 || x && x✝ == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
            (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝ == 0#32)
              (42#32 == BitVec.intMin 32 && x✝ == 4294967295#32)))
      [Meta.isDefEq.assign.checkTypes] [0.001269] ✅️ (?h₁ : ((x✝ == 0 ||
                32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) =
              true) =
            ((!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) =
              true)) := (congrArg (fun x => x = true)
            (Eq.trans
              (congrArg (fun x => x✝ == 0#32 || x && x✝ == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
              (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝ == 0#32)
                (42#32 == BitVec.intMin 32 &&
                  x✝ ==
                    4294967295#32))) : ((x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32) =
              true) =
            ((!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true))
        [Meta.isDefEq] [0.001266] ✅️ ((x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true) =
              ((!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) =
                true) =?= ((x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32) = true) =
              ((!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true)
          [Meta.isDefEq] [0.001248] ✅️ (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) =
                true =?= (x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32) = true
            [Meta.isDefEq] [0.001235] ✅️ x✝ == 0 ||
                  32 != 1 && 42#32 == BitVec.intMin 32 &&
                    x✝ == -1 =?= x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32
              [Meta.isDefEq.delta] [0.001219] ✅️ x✝ == 0 ||
                    32 != 1 && 42#32 == BitVec.intMin 32 &&
                      x✝ == -1 =?= x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              some
                ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                    (x✝¹ ^^^ 4294967295#32) &&&
                  (x✝² ^^^ 4294967295#32))) ⊑
            if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              some
                ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                  ((x✝¹ ||| x✝²) ^^^ 4294967295#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 73.200650ms, solving context: 1.000000ms
LeanSAT proved the goal after 77.226820ms: rewriting 14.952590ms, bitblasting 0.000000ms, SAT solving 55.929040ms, LRAT trimming 0.000000ms, LRAT checking 4.002620ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:262:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:255:8: error: (kernel) declaration has metavariables 'not_or_or_not_thm'
[bv] [0.045324] Normalizing goal
  [Meta.synthInstance] [0.001143] ✅️ Decidable
        ((if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else some ((42#32).sdiv x✝ ||| x✝¹ ^^^ -1#32 ||| x✝² ^^^ -1#32)) ⊑
          if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else some ((42#32).sdiv x✝ ||| x✝¹ &&& x✝² ^^^ -1#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some ((42#32).sdiv x✝ ||| x✝¹ ^^^ -1#32 ||| x✝² ^^^ -1#32)) ⊑
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some ((42#32).sdiv x✝ ||| x✝¹ &&& x✝² ^^^ -1#32)
      ⊢ False
  [Meta.isDefEq] [0.001283] ✅️ ?h₁ =?= congrArg (fun x => x = true)
        (Eq.trans
          (congrArg (fun x => x✝ == 0#32 || x && x✝ == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
          (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝ == 0#32) (42#32 == BitVec.intMin 32 && x✝ == 4294967295#32)))
    [Meta.isDefEq.assign] [0.001280] ✅️ ?h₁ := congrArg (fun x => x = true)
          (Eq.trans
            (congrArg (fun x => x✝ == 0#32 || x && x✝ == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
            (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝ == 0#32)
              (42#32 == BitVec.intMin 32 && x✝ == 4294967295#32)))
      [Meta.isDefEq.assign.checkTypes] [0.001269] ✅️ (?h₁ : ((x✝ == 0 ||
                32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) =
              true) =
            ((!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) =
              true)) := (congrArg (fun x => x = true)
            (Eq.trans
              (congrArg (fun x => x✝ == 0#32 || x && x✝ == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
              (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝ == 0#32)
                (42#32 == BitVec.intMin 32 &&
                  x✝ ==
                    4294967295#32))) : ((x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32) =
              true) =
            ((!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true))
        [Meta.isDefEq] [0.001266] ✅️ ((x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true) =
              ((!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) =
                true) =?= ((x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32) = true) =
              ((!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true)
          [Meta.isDefEq] [0.001248] ✅️ (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) =
                true =?= (x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32) = true
            [Meta.isDefEq] [0.001235] ✅️ x✝ == 0 ||
                  32 != 1 && 42#32 == BitVec.intMin 32 &&
                    x✝ == -1 =?= x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32
              [Meta.isDefEq.delta] [0.001220] ✅️ x✝ == 0 ||
                    32 != 1 && 42#32 == BitVec.intMin 32 &&
                      x✝ == -1 =?= x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              some
                ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                    x✝¹ ^^^ 4294967295#32 |||
                  x✝² ^^^ 4294967295#32)) ⊑
            if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              some
                ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                  x✝¹ &&& x✝² ^^^ 4294967295#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 71.389680ms, solving context: 1.000000ms
LeanSAT proved the goal after 76.455630ms: rewriting 13.685320ms, bitblasting 0.000000ms, SAT solving 56.177820ms, LRAT trimming 0.000000ms, LRAT checking 4.005090ms
Bitwuzla proved the goal after 74.172900ms, solving context: 1.000000ms
LeanSAT proved the goal after 80.152339ms: rewriting 16.440660ms, bitblasting 0.000000ms, SAT solving 55.824709ms, LRAT trimming 0.000000ms, LRAT checking 4.827190ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:297:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:289:8: error: (kernel) declaration has metavariables 'or_not_and_commute1_thm'
[bv] [0.052131] Normalizing goal
  [Meta.synthInstance] [0.001118] ✅️ Decidable
        ((if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
          else
            if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
            else
              some (((x✝ ||| (42#32).sdiv x✝¹) ^^^ -1#32) &&& x✝² ||| (42#32).sdiv x✝¹ &&& ((x✝ ||| x✝²) ^^^ -1#32))) ⊑
          if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
          else some (((42#32).sdiv x✝¹ ^^^ x✝²) &&& (x✝ ^^^ -1#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
            else
              if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
              else
                some
                  (((x✝ ||| (42#32).sdiv x✝¹) ^^^ -1#32) &&& x✝² ||| (42#32).sdiv x✝¹ &&& ((x✝ ||| x✝²) ^^^ -1#32))) ⊑
            if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
            else some (((42#32).sdiv x✝¹ ^^^ x✝²) &&& (x✝ ^^^ -1#32))
      ⊢ False
  [Meta.isDefEq] [0.001284] ✅️ ?h₁ =?= congrArg (fun x => x = true)
        (Eq.trans
          (congrArg (fun x => x✝¹ == 0#32 || x && x✝¹ == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
          (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝¹ == 0#32)
            (42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32)))
    [Meta.isDefEq.assign] [0.001281] ✅️ ?h₁ := congrArg (fun x => x = true)
          (Eq.trans
            (congrArg (fun x => x✝¹ == 0#32 || x && x✝¹ == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
            (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝¹ == 0#32)
              (42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32)))
      [Meta.isDefEq.assign.checkTypes] [0.001270] ✅️ (?h₁ : ((x✝¹ == 0 ||
                32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) =
              true) =
            ((!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) =
              true)) := (congrArg (fun x => x = true)
            (Eq.trans
              (congrArg (fun x => x✝¹ == 0#32 || x && x✝¹ == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
              (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝¹ == 0#32)
                (42#32 == BitVec.intMin 32 &&
                  x✝¹ ==
                    4294967295#32))) : ((x✝¹ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32) =
              true) =
            ((!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) = true))
        [Meta.isDefEq] [0.001267] ✅️ ((x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true) =
              ((!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) =
                true) =?= ((x✝¹ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32) = true) =
              ((!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) = true)
          [Meta.isDefEq] [0.001249] ✅️ (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) =
                true =?= (x✝¹ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32) = true
            [Meta.isDefEq] [0.001235] ✅️ x✝¹ == 0 ||
                  32 != 1 && 42#32 == BitVec.intMin 32 &&
                    x✝¹ == -1 =?= x✝¹ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32
              [Meta.isDefEq.delta] [0.001220] ✅️ x✝¹ == 0 ||
                    32 != 1 && 42#32 == BitVec.intMin 32 &&
                      x✝¹ == -1 =?= x✝¹ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32
  [Meta.isDefEq] [0.001061] ✅️ ?h₃ =?= fun a =>
        congrArg some
          (congr
            (congrArg (fun x => HOr.hOr (((x✝ ||| x) ^^^ 4294967295#32) &&& x✝²))
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                (Eq.trans
                  (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                    (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                      (eq_false' fun h => Bool.noConfusion h)))
                  (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                    (fun a =>
                      Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                        (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                    fun a => Eq.refl (42#32 / x✝¹)))))
            (congrArg (fun x => x &&& ((x✝ ||| x✝²) ^^^ 4294967295#32))
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                (Eq.trans
                  (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                    (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                      (eq_false' fun h => Bool.noConfusion h)))
                  (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                    (fun a =>
                      Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                        (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                    fun a => Eq.refl (42#32 / x✝¹))))))
    [Meta.isDefEq.assign] [0.001059] ✅️ ?h₃ := fun a =>
          congrArg some
            (congr
              (congrArg (fun x => HOr.hOr (((x✝ ||| x) ^^^ 4294967295#32) &&& x✝²))
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                      (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                      fun a => Eq.refl (42#32 / x✝¹)))))
              (congrArg (fun x => x &&& ((x✝ ||| x✝²) ^^^ 4294967295#32))
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                      (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                      fun a => Eq.refl (42#32 / x✝¹))))))
      [Meta.isDefEq.assign.checkTypes] [0.001006] ✅️ (?h₃ : ¬(!(!x✝¹ == 0#32 &&
                    !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) =
                true →
            some (((x✝ ||| (42#32).sdiv x✝¹) ^^^ -1#32) &&& x✝² ||| (42#32).sdiv x✝¹ &&& ((x✝ ||| x✝²) ^^^ -1#32)) =
              some
                (((x✝ ||| if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ^^^
                      4294967295#32) &&&
                    x✝² |||
                  (if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) &&&
                    ((x✝ ||| x✝²) ^^^
                      4294967295#32))) := (fun a =>
            congrArg some
              (congr
                (congrArg (fun x => HOr.hOr (((x✝ ||| x) ^^^ 4294967295#32) &&& x✝²))
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                        (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                        fun a => Eq.refl (42#32 / x✝¹)))))
                (congrArg (fun x => x &&& ((x✝ ||| x✝²) ^^^ 4294967295#32))
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                        (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                        fun a =>
                        Eq.refl
                          (42#32 /
                            x✝¹)))))) : ¬(!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) =
                true →
            some
                (((x✝ ||| (42#32).sdiv x✝¹) ^^^ 4294967295#32) &&& x✝² |||
                  (42#32).sdiv x✝¹ &&& ((x✝ ||| x✝²) ^^^ 4294967295#32)) =
              some
                (((x✝ ||| if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ^^^
                      4294967295#32) &&&
                    x✝² |||
                  (if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) &&&
                    ((x✝ ||| x✝²) ^^^ 4294967295#32)))
        [Meta.isDefEq] [0.001001] ✅️ ¬(!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) = true →
              some (((x✝ ||| (42#32).sdiv x✝¹) ^^^ -1#32) &&& x✝² ||| (42#32).sdiv x✝¹ &&& ((x✝ ||| x✝²) ^^^ -1#32)) =
                some
                  (((x✝ ||| if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ^^^
                        4294967295#32) &&&
                      x✝² |||
                    (if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) &&&
                      ((x✝ ||| x✝²) ^^^
                        4294967295#32)) =?= ¬(!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) =
                  true →
              some
                  (((x✝ ||| (42#32).sdiv x✝¹) ^^^ 4294967295#32) &&& x✝² |||
                    (42#32).sdiv x✝¹ &&& ((x✝ ||| x✝²) ^^^ 4294967295#32)) =
                some
                  (((x✝ ||| if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ^^^
                        4294967295#32) &&&
                      x✝² |||
                    (if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) &&&
                      ((x✝ ||| x✝²) ^^^ 4294967295#32))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) = true then none
            else
              if (!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) = true then none
              else
                some
                  (((x✝ ||| if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ^^^
                        4294967295#32) &&&
                      x✝² |||
                    (if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) &&&
                      ((x✝ ||| x✝²) ^^^ 4294967295#32))) ⊑
            if (!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) = true then none
            else
              some
                (((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ^^^ x✝²) &&&
                  (x✝ ^^^ 4294967295#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:309:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:309:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:301:8: error: (kernel) declaration has metavariables 'or_not_and_commute2_thm'
[bv] [0.051228] Normalizing goal
  [Meta.synthInstance] [0.001055] ✅️ Decidable
        ((if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else
              some ((42#32).sdiv x✝ &&& ((x✝¹ ||| x✝²) ^^^ -1#32) ||| ((x✝¹ ||| (42#32).sdiv x✝) ^^^ -1#32) &&& x✝²)) ⊑
          if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else some ((x✝² ^^^ (42#32).sdiv x✝) &&& (x✝¹ ^^^ -1#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else
              if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
              else
                some
                  ((42#32).sdiv x✝ &&& ((x✝¹ ||| x✝²) ^^^ -1#32) ||| ((x✝¹ ||| (42#32).sdiv x✝) ^^^ -1#32) &&& x✝²)) ⊑
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some ((x✝² ^^^ (42#32).sdiv x✝) &&& (x✝¹ ^^^ -1#32))
      ⊢ False
  [Meta.isDefEq] [0.001101] ✅️ ?h₃ =?= fun a =>
        congrArg some
          (congr
            (congrArg (fun x => HOr.hOr (x &&& ((x✝¹ ||| x✝²) ^^^ 4294967295#32)))
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                (Eq.trans
                  (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                    (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                      (eq_false' fun h => Bool.noConfusion h)))
                  (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                    (fun a =>
                      Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                        (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                    fun a => Eq.refl (42#32 / x✝)))))
            (congrArg (fun x => ((x✝¹ ||| x) ^^^ 4294967295#32) &&& x✝²)
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                (Eq.trans
                  (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                    (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                      (eq_false' fun h => Bool.noConfusion h)))
                  (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                    (fun a =>
                      Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                        (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                    fun a => Eq.refl (42#32 / x✝))))))
    [Meta.isDefEq.assign] [0.001099] ✅️ ?h₃ := fun a =>
          congrArg some
            (congr
              (congrArg (fun x => HOr.hOr (x &&& ((x✝¹ ||| x✝²) ^^^ 4294967295#32)))
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                      (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                      fun a => Eq.refl (42#32 / x✝)))))
              (congrArg (fun x => ((x✝¹ ||| x) ^^^ 4294967295#32) &&& x✝²)
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                      (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                      fun a => Eq.refl (42#32 / x✝))))))
      [Meta.isDefEq.assign.checkTypes] [0.001036] ✅️ (?h₃ : ¬(!(!x✝ == 0#32 &&
                    !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) =
                true →
            some ((42#32).sdiv x✝ &&& ((x✝¹ ||| x✝²) ^^^ -1#32) ||| ((x✝¹ ||| (42#32).sdiv x✝) ^^^ -1#32) &&& x✝²) =
              some
                ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                    ((x✝¹ ||| x✝²) ^^^ 4294967295#32) |||
                  ((x✝¹ ||| if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                      4294967295#32) &&&
                    x✝²)) := (fun a =>
            congrArg some
              (congr
                (congrArg (fun x => HOr.hOr (x &&& ((x✝¹ ||| x✝²) ^^^ 4294967295#32)))
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                        (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                        fun a => Eq.refl (42#32 / x✝)))))
                (congrArg (fun x => ((x✝¹ ||| x) ^^^ 4294967295#32) &&& x✝²)
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                        (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                        fun a =>
                        Eq.refl
                          (42#32 /
                            x✝)))))) : ¬(!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true →
            some
                ((42#32).sdiv x✝ &&& ((x✝¹ ||| x✝²) ^^^ 4294967295#32) |||
                  ((x✝¹ ||| (42#32).sdiv x✝) ^^^ 4294967295#32) &&& x✝²) =
              some
                ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                    ((x✝¹ ||| x✝²) ^^^ 4294967295#32) |||
                  ((x✝¹ ||| if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                      4294967295#32) &&&
                    x✝²))
        [Meta.isDefEq] [0.001031] ✅️ ¬(!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true →
              some ((42#32).sdiv x✝ &&& ((x✝¹ ||| x✝²) ^^^ -1#32) ||| ((x✝¹ ||| (42#32).sdiv x✝) ^^^ -1#32) &&& x✝²) =
                some
                  ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                      ((x✝¹ ||| x✝²) ^^^ 4294967295#32) |||
                    ((x✝¹ ||| if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                        4294967295#32) &&&
                      x✝²) =?= ¬(!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true →
              some
                  ((42#32).sdiv x✝ &&& ((x✝¹ ||| x✝²) ^^^ 4294967295#32) |||
                    ((x✝¹ ||| (42#32).sdiv x✝) ^^^ 4294967295#32) &&& x✝²) =
                some
                  ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                      ((x✝¹ ||| x✝²) ^^^ 4294967295#32) |||
                    ((x✝¹ ||| if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                        4294967295#32) &&&
                      x✝²)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
              else
                some
                  ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                      ((x✝¹ ||| x✝²) ^^^ 4294967295#32) |||
                    ((x✝¹ ||| if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                        4294967295#32) &&&
                      x✝²)) ⊑
            if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              some
                ((x✝² ^^^ if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                  (x✝¹ ^^^ 4294967295#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 74.724979ms, solving context: 1.000000ms
LeanSAT proved the goal after 231.257159ms: rewriting 16.599080ms, bitblasting 0.000000ms, SAT solving 206.343479ms, LRAT trimming 0.000000ms, LRAT checking 5.197680ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:333:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:333:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:325:8: error: (kernel) declaration has metavariables 'or_not_and_commute4_thm'
[bv] [0.051074] Normalizing goal
  [Meta.synthInstance] [0.001030] ✅️ Decidable
        ((if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else
              some ((42#32).sdiv x✝ &&& ((x✝¹ ||| x✝²) ^^^ -1#32) ||| ((x✝¹ ||| (42#32).sdiv x✝) ^^^ -1#32) &&& x✝²)) ⊑
          if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else some ((x✝² ^^^ (42#32).sdiv x✝) &&& (x✝¹ ^^^ -1#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else
              if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
              else
                some
                  ((42#32).sdiv x✝ &&& ((x✝¹ ||| x✝²) ^^^ -1#32) ||| ((x✝¹ ||| (42#32).sdiv x✝) ^^^ -1#32) &&& x✝²)) ⊑
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some ((x✝² ^^^ (42#32).sdiv x✝) &&& (x✝¹ ^^^ -1#32))
      ⊢ False
  [Meta.isDefEq] [0.001075] ✅️ ?h₃ =?= fun a =>
        congrArg some
          (congr
            (congrArg (fun x => HOr.hOr (x &&& ((x✝¹ ||| x✝²) ^^^ 4294967295#32)))
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                (Eq.trans
                  (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                    (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                      (eq_false' fun h => Bool.noConfusion h)))
                  (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                    (fun a =>
                      Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                        (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                    fun a => Eq.refl (42#32 / x✝)))))
            (congrArg (fun x => ((x✝¹ ||| x) ^^^ 4294967295#32) &&& x✝²)
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                (Eq.trans
                  (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                    (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                      (eq_false' fun h => Bool.noConfusion h)))
                  (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                    (fun a =>
                      Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                        (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                    fun a => Eq.refl (42#32 / x✝))))))
    [Meta.isDefEq.assign] [0.001072] ✅️ ?h₃ := fun a =>
          congrArg some
            (congr
              (congrArg (fun x => HOr.hOr (x &&& ((x✝¹ ||| x✝²) ^^^ 4294967295#32)))
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                      (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                      fun a => Eq.refl (42#32 / x✝)))))
              (congrArg (fun x => ((x✝¹ ||| x) ^^^ 4294967295#32) &&& x✝²)
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                      (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                      fun a => Eq.refl (42#32 / x✝))))))
      [Meta.isDefEq.assign.checkTypes] [0.001018] ✅️ (?h₃ : ¬(!(!x✝ == 0#32 &&
                    !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) =
                true →
            some ((42#32).sdiv x✝ &&& ((x✝¹ ||| x✝²) ^^^ -1#32) ||| ((x✝¹ ||| (42#32).sdiv x✝) ^^^ -1#32) &&& x✝²) =
              some
                ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                    ((x✝¹ ||| x✝²) ^^^ 4294967295#32) |||
                  ((x✝¹ ||| if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                      4294967295#32) &&&
                    x✝²)) := (fun a =>
            congrArg some
              (congr
                (congrArg (fun x => HOr.hOr (x &&& ((x✝¹ ||| x✝²) ^^^ 4294967295#32)))
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                        (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                        fun a => Eq.refl (42#32 / x✝)))))
                (congrArg (fun x => ((x✝¹ ||| x) ^^^ 4294967295#32) &&& x✝²)
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                        (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                        fun a =>
                        Eq.refl
                          (42#32 /
                            x✝)))))) : ¬(!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true →
            some
                ((42#32).sdiv x✝ &&& ((x✝¹ ||| x✝²) ^^^ 4294967295#32) |||
                  ((x✝¹ ||| (42#32).sdiv x✝) ^^^ 4294967295#32) &&& x✝²) =
              some
                ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                    ((x✝¹ ||| x✝²) ^^^ 4294967295#32) |||
                  ((x✝¹ ||| if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                      4294967295#32) &&&
                    x✝²))
        [Meta.isDefEq] [0.001013] ✅️ ¬(!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true →
              some ((42#32).sdiv x✝ &&& ((x✝¹ ||| x✝²) ^^^ -1#32) ||| ((x✝¹ ||| (42#32).sdiv x✝) ^^^ -1#32) &&& x✝²) =
                some
                  ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                      ((x✝¹ ||| x✝²) ^^^ 4294967295#32) |||
                    ((x✝¹ ||| if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                        4294967295#32) &&&
                      x✝²) =?= ¬(!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true →
              some
                  ((42#32).sdiv x✝ &&& ((x✝¹ ||| x✝²) ^^^ 4294967295#32) |||
                    ((x✝¹ ||| (42#32).sdiv x✝) ^^^ 4294967295#32) &&& x✝²) =
                some
                  ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                      ((x✝¹ ||| x✝²) ^^^ 4294967295#32) |||
                    ((x✝¹ ||| if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                        4294967295#32) &&&
                      x✝²)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
              else
                some
                  ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                      ((x✝¹ ||| x✝²) ^^^ 4294967295#32) |||
                    ((x✝¹ ||| if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                        4294967295#32) &&&
                      x✝²)) ⊑
            if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              some
                ((x✝² ^^^ if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                  (x✝¹ ^^^ 4294967295#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:347:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:347:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:347:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:337:8: error: (kernel) declaration has metavariables 'or_not_and_commute5_thm'
[bv] [0.080723] Normalizing goal
  [Meta.synthInstance] [0.001130] ✅️ Decidable
        ((if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else
            if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
            else
              if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
              else
                if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
                else
                  some
                    ((42#32).sdiv x✝ &&& (((42#32).sdiv x✝¹ ||| x✝²) ^^^ -1#32) |||
                      (((42#32).sdiv x✝¹ ||| (42#32).sdiv x✝) ^^^ -1#32) &&& x✝²)) ⊑
          if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else
            if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
            else some ((x✝² ^^^ (42#32).sdiv x✝) &&& ((42#32).sdiv x✝¹ ^^^ -1#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else
              if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
              else
                if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
                else
                  if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
                  else
                    some
                      ((42#32).sdiv x✝ &&& (((42#32).sdiv x✝¹ ||| x✝²) ^^^ -1#32) |||
                        (((42#32).sdiv x✝¹ ||| (42#32).sdiv x✝) ^^^ -1#32) &&& x✝²)) ⊑
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else
              if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
              else some ((x✝² ^^^ (42#32).sdiv x✝) &&& ((42#32).sdiv x✝¹ ^^^ -1#32))
      ⊢ False
  [Meta.isDefEq] [0.001144] ✅️ ?h₃ =?= fun a =>
        congrArg some
          (congr
            (congrArg HOr.hOr
              (congr
                (congrArg HAnd.hAnd
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                        (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                        fun a => Eq.refl (42#32 / x✝)))))
                (congrArg (fun x => (x ||| x✝²) ^^^ 4294967295#32)
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                        (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                        fun a => Eq.refl (42#32 / x✝¹)))))))
            (congrArg (fun x => (x ^^^ 4294967295#32) &&& x✝²)
              (congr
                (congrArg HOr.hOr
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                        (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                        fun a => Eq.refl (42#32 / x✝¹)))))
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                      (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                      fun a => Eq.refl (42#32 / x✝)))))))
    [Meta.isDefEq.assign] [0.001142] ✅️ ?h₃ := fun a =>
          congrArg some
            (congr
              (congrArg HOr.hOr
                (congr
                  (congrArg HAnd.hAnd
                    (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                      (Eq.trans
                        (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                          (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                          (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                            (eq_false' fun h => Bool.noConfusion h)))
                        (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                          (fun a =>
                            Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                              (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                          fun a => Eq.refl (42#32 / x✝)))))
                  (congrArg (fun x => (x ||| x✝²) ^^^ 4294967295#32)
                    (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                      (Eq.trans
                        (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                          (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                          (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                            (eq_false' fun h => Bool.noConfusion h)))
                        (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                          (fun a =>
                            Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                              (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                          fun a => Eq.refl (42#32 / x✝¹)))))))
              (congrArg (fun x => (x ^^^ 4294967295#32) &&& x✝²)
                (congr
                  (congrArg HOr.hOr
                    (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                      (Eq.trans
                        (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                          (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                          (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                            (eq_false' fun h => Bool.noConfusion h)))
                        (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                          (fun a =>
                            Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                              (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                          fun a => Eq.refl (42#32 / x✝¹)))))
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                        (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                        fun a => Eq.refl (42#32 / x✝)))))))
      [Meta.isDefEq.assign.checkTypes] [0.001054] ✅️ (?h₃ : ¬(!(!x✝ == 0#32 &&
                    !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) =
                true →
            some
                ((42#32).sdiv x✝ &&& (((42#32).sdiv x✝¹ ||| x✝²) ^^^ -1#32) |||
                  (((42#32).sdiv x✝¹ ||| (42#32).sdiv x✝) ^^^ -1#32) &&& x✝²) =
              some
                ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                    (((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ||| x✝²) ^^^
                      4294967295#32) |||
                  (((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) |||
                        if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                      4294967295#32) &&&
                    x✝²)) := (fun a =>
            congrArg some
              (congr
                (congrArg HOr.hOr
                  (congr
                    (congrArg HAnd.hAnd
                      (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                        (Eq.trans
                          (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                            (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                            (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                              (eq_false' fun h => Bool.noConfusion h)))
                          (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                            (fun a =>
                              Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                                (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                            fun a => Eq.refl (42#32 / x✝)))))
                    (congrArg (fun x => (x ||| x✝²) ^^^ 4294967295#32)
                      (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                        (Eq.trans
                          (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                            (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                            (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                              (eq_false' fun h => Bool.noConfusion h)))
                          (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                            (fun a =>
                              Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                                (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                            fun a => Eq.refl (42#32 / x✝¹)))))))
                (congrArg (fun x => (x ^^^ 4294967295#32) &&& x✝²)
                  (congr
                    (congrArg HOr.hOr
                      (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                        (Eq.trans
                          (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                            (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                            (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                              (eq_false' fun h => Bool.noConfusion h)))
                          (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                            (fun a =>
                              Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                                (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                            fun a => Eq.refl (42#32 / x✝¹)))))
                    (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                      (Eq.trans
                        (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                          (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                          (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                            (eq_false' fun h => Bool.noConfusion h)))
                        (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                          (fun a =>
                            Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                              (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                          fun a =>
                          Eq.refl
                            (42#32 /
                              x✝))))))) : ¬(!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) =
                true →
            some
                ((42#32).sdiv x✝ &&& (((42#32).sdiv x✝¹ ||| x✝²) ^^^ 4294967295#32) |||
                  (((42#32).sdiv x✝¹ ||| (42#32).sdiv x✝) ^^^ 4294967295#32) &&& x✝²) =
              some
                ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                    (((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ||| x✝²) ^^^
                      4294967295#32) |||
                  (((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) |||
                        if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                      4294967295#32) &&&
                    x✝²))
        [Meta.isDefEq] [0.001051] ✅️ ¬(!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true →
              some
                  ((42#32).sdiv x✝ &&& (((42#32).sdiv x✝¹ ||| x✝²) ^^^ -1#32) |||
                    (((42#32).sdiv x✝¹ ||| (42#32).sdiv x✝) ^^^ -1#32) &&& x✝²) =
                some
                  ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                      (((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) |||
                          x✝²) ^^^
                        4294967295#32) |||
                    (((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) |||
                          if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                        4294967295#32) &&&
                      x✝²) =?= ¬(!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true →
              some
                  ((42#32).sdiv x✝ &&& (((42#32).sdiv x✝¹ ||| x✝²) ^^^ 4294967295#32) |||
                    (((42#32).sdiv x✝¹ ||| (42#32).sdiv x✝) ^^^ 4294967295#32) &&& x✝²) =
                some
                  ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                      (((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) |||
                          x✝²) ^^^
                        4294967295#32) |||
                    (((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) |||
                          if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                        4294967295#32) &&&
                      x✝²)
          [Meta.isDefEq] [0.001016] ✅️ some
                  ((42#32).sdiv x✝ &&& (((42#32).sdiv x✝¹ ||| x✝²) ^^^ -1#32) |||
                    (((42#32).sdiv x✝¹ ||| (42#32).sdiv x✝) ^^^ -1#32) &&& x✝²) =
                some
                  ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                      (((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) |||
                          x✝²) ^^^
                        4294967295#32) |||
                    (((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) |||
                          if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                        4294967295#32) &&&
                      x✝²) =?= some
                  ((42#32).sdiv x✝ &&& (((42#32).sdiv x✝¹ ||| x✝²) ^^^ 4294967295#32) |||
                    (((42#32).sdiv x✝¹ ||| (42#32).sdiv x✝) ^^^ 4294967295#32) &&& x✝²) =
                some
                  ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                      (((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) |||
                          x✝²) ^^^
                        4294967295#32) |||
                    (((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) |||
                          if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                        4294967295#32) &&&
                      x✝²)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              if (!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) = true then none
              else
                if (!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) = true then none
                else
                  if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
                  else
                    some
                      ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                          (((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) |||
                              x✝²) ^^^
                            4294967295#32) |||
                        (((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) |||
                              if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                            4294967295#32) &&&
                          x✝²)) ⊑
            if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              if (!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) = true then none
              else
                some
                  ((x✝² ^^^ if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                    ((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ^^^
                      4294967295#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 74.522409ms, solving context: 1.000000ms
LeanSAT proved the goal after 81.133140ms: rewriting 16.534610ms, bitblasting 0.000000ms, SAT solving 56.547680ms, LRAT trimming 0.000000ms, LRAT checking 4.880950ms
Bitwuzla proved the goal after 74.821930ms, solving context: 1.000000ms
LeanSAT proved the goal after 80.979610ms: rewriting 16.783420ms, bitblasting 0.000000ms, SAT solving 55.903490ms, LRAT trimming 0.000000ms, LRAT checking 5.061540ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:385:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:385:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:385:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:385:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:375:8: error: (kernel) declaration has metavariables 'or_not_and_commute8_thm'
[bv] [0.080544] Normalizing goal
  [Meta.synthInstance] [0.001131] ✅️ Decidable
        ((if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else
            if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
            else
              if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
              else
                if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
                else
                  some
                    ((((42#32).sdiv x✝ ||| (42#32).sdiv x✝¹) ^^^ -1#32) &&& x✝² |||
                      (42#32).sdiv x✝¹ &&& ((x✝² ||| (42#32).sdiv x✝) ^^^ -1#32))) ⊑
          if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
          else
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some (((42#32).sdiv x✝¹ ^^^ x✝²) &&& ((42#32).sdiv x✝ ^^^ -1#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else
              if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
              else
                if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
                else
                  if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
                  else
                    some
                      ((((42#32).sdiv x✝ ||| (42#32).sdiv x✝¹) ^^^ -1#32) &&& x✝² |||
                        (42#32).sdiv x✝¹ &&& ((x✝² ||| (42#32).sdiv x✝) ^^^ -1#32))) ⊑
            if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
            else
              if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
              else some (((42#32).sdiv x✝¹ ^^^ x✝²) &&& ((42#32).sdiv x✝ ^^^ -1#32))
      ⊢ False
  [Meta.isDefEq] [0.001102] ✅️ ?h₃ =?= fun a =>
        congrArg some
          (congr
            (congrArg (fun x => HOr.hOr ((x ^^^ 4294967295#32) &&& x✝²))
              (congr
                (congrArg HOr.hOr
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                        (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                        fun a => Eq.refl (42#32 / x✝)))))
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                      (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                      fun a => Eq.refl (42#32 / x✝¹))))))
            (congr
              (congrArg HAnd.hAnd
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                      (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                      fun a => Eq.refl (42#32 / x✝¹)))))
              (congrArg (fun x => (x✝² ||| x) ^^^ 4294967295#32)
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                      (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                      fun a => Eq.refl (42#32 / x✝)))))))
    [Meta.isDefEq.assign] [0.001100] ✅️ ?h₃ := fun a =>
          congrArg some
            (congr
              (congrArg (fun x => HOr.hOr ((x ^^^ 4294967295#32) &&& x✝²))
                (congr
                  (congrArg HOr.hOr
                    (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                      (Eq.trans
                        (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                          (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                          (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                            (eq_false' fun h => Bool.noConfusion h)))
                        (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                          (fun a =>
                            Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                              (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                          fun a => Eq.refl (42#32 / x✝)))))
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                        (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                        fun a => Eq.refl (42#32 / x✝¹))))))
              (congr
                (congrArg HAnd.hAnd
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                        (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                        fun a => Eq.refl (42#32 / x✝¹)))))
                (congrArg (fun x => (x✝² ||| x) ^^^ 4294967295#32)
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                        (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                        fun a => Eq.refl (42#32 / x✝)))))))
      [Meta.isDefEq.assign.checkTypes] [0.001026] ✅️ (?h₃ : ¬(!(!x✝ == 0#32 &&
                    !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) =
                true →
            some
                ((((42#32).sdiv x✝ ||| (42#32).sdiv x✝¹) ^^^ -1#32) &&& x✝² |||
                  (42#32).sdiv x✝¹ &&& ((x✝² ||| (42#32).sdiv x✝) ^^^ -1#32)) =
              some
                ((((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                        if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ^^^
                      4294967295#32) &&&
                    x✝² |||
                  (if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) &&&
                    ((x✝² ||| if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                      4294967295#32))) := (fun a =>
            congrArg some
              (congr
                (congrArg (fun x => HOr.hOr ((x ^^^ 4294967295#32) &&& x✝²))
                  (congr
                    (congrArg HOr.hOr
                      (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                        (Eq.trans
                          (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                            (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                            (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                              (eq_false' fun h => Bool.noConfusion h)))
                          (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                            (fun a =>
                              Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                                (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                            fun a => Eq.refl (42#32 / x✝)))))
                    (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                      (Eq.trans
                        (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                          (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                          (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                            (eq_false' fun h => Bool.noConfusion h)))
                        (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                          (fun a =>
                            Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                              (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                          fun a => Eq.refl (42#32 / x✝¹))))))
                (congr
                  (congrArg HAnd.hAnd
                    (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                      (Eq.trans
                        (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                          (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                          (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                            (eq_false' fun h => Bool.noConfusion h)))
                        (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                          (fun a =>
                            Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                              (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                          fun a => Eq.refl (42#32 / x✝¹)))))
                  (congrArg (fun x => (x✝² ||| x) ^^^ 4294967295#32)
                    (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                      (Eq.trans
                        (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                          (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                          (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                            (eq_false' fun h => Bool.noConfusion h)))
                        (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                          (fun a =>
                            Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                              (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                          fun a =>
                          Eq.refl
                            (42#32 /
                              x✝))))))) : ¬(!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) =
                true →
            some
                ((((42#32).sdiv x✝ ||| (42#32).sdiv x✝¹) ^^^ 4294967295#32) &&& x✝² |||
                  (42#32).sdiv x✝¹ &&& ((x✝² ||| (42#32).sdiv x✝) ^^^ 4294967295#32)) =
              some
                ((((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                        if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ^^^
                      4294967295#32) &&&
                    x✝² |||
                  (if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) &&&
                    ((x✝² ||| if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                      4294967295#32)))
        [Meta.isDefEq] [0.001021] ✅️ ¬(!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true →
              some
                  ((((42#32).sdiv x✝ ||| (42#32).sdiv x✝¹) ^^^ -1#32) &&& x✝² |||
                    (42#32).sdiv x✝¹ &&& ((x✝² ||| (42#32).sdiv x✝) ^^^ -1#32)) =
                some
                  ((((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                          if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ^^^
                        4294967295#32) &&&
                      x✝² |||
                    (if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) &&&
                      ((x✝² ||| if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                        4294967295#32)) =?= ¬(!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) =
                  true →
              some
                  ((((42#32).sdiv x✝ ||| (42#32).sdiv x✝¹) ^^^ 4294967295#32) &&& x✝² |||
                    (42#32).sdiv x✝¹ &&& ((x✝² ||| (42#32).sdiv x✝) ^^^ 4294967295#32)) =
                some
                  ((((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                          if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ^^^
                        4294967295#32) &&&
                      x✝² |||
                    (if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) &&&
                      ((x✝² ||| if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                        4294967295#32))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              if (!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) = true then none
              else
                if (!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) = true then none
                else
                  if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
                  else
                    some
                      ((((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                              if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ^^^
                            4294967295#32) &&&
                          x✝² |||
                        (if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) &&&
                          ((x✝² ||| if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                            4294967295#32))) ⊑
            if (!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) = true then none
            else
              if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
              else
                some
                  (((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ^^^ x✝²) &&&
                    ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                      4294967295#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:401:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:401:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:401:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:401:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:389:8: error: (kernel) declaration has metavariables 'or_not_and_commute9_thm'
[bv] [0.110861] Normalizing goal
  [Meta.synthInstance] [0.001200] ✅️ Decidable
        ((if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else
            if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
            else
              if (x✝² == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝² == -1) = true then none
              else
                if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
                else
                  if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
                  else
                    if (x✝² == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝² == -1) = true then none
                    else
                      some
                        ((((42#32).sdiv x✝ ||| (42#32).sdiv x✝¹) ^^^ -1#32) &&& (42#32).sdiv x✝² |||
                          (42#32).sdiv x✝¹ &&& (((42#32).sdiv x✝ ||| (42#32).sdiv x✝²) ^^^ -1#32))) ⊑
          if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
          else
            if (x✝² == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝² == -1) = true then none
            else
              if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
              else some (((42#32).sdiv x✝¹ ^^^ (42#32).sdiv x✝²) &&& ((42#32).sdiv x✝ ^^^ -1#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else
              if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
              else
                if (x✝² == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝² == -1) = true then none
                else
                  if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
                  else
                    if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
                    else
                      if (x✝² == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝² == -1) = true then none
                      else
                        some
                          ((((42#32).sdiv x✝ ||| (42#32).sdiv x✝¹) ^^^ -1#32) &&& (42#32).sdiv x✝² |||
                            (42#32).sdiv x✝¹ &&& (((42#32).sdiv x✝ ||| (42#32).sdiv x✝²) ^^^ -1#32))) ⊑
            if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
            else
              if (x✝² == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝² == -1) = true then none
              else
                if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
                else some (((42#32).sdiv x✝¹ ^^^ (42#32).sdiv x✝²) &&& ((42#32).sdiv x✝ ^^^ -1#32))
      ⊢ False
  [Meta.isDefEq] [0.001150] ✅️ ?h₃ =?= fun a =>
        congrArg some
          (congr
            (congrArg HOr.hOr
              (congr
                (congrArg (fun x => HAnd.hAnd (x ^^^ 4294967295#32))
                  (congr
                    (congrArg HOr.hOr
                      (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                        (Eq.trans
                          (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                            (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                            (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                              (eq_false' fun h => Bool.noConfusion h)))
                          (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                            (fun a =>
                              Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                                (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                            fun a => Eq.refl (42#32 / x✝)))))
                    (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                      (Eq.trans
                        (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                          (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                          (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                            (eq_false' fun h => Bool.noConfusion h)))
                        (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                          (fun a =>
                            Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                              (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                          fun a => Eq.refl (42#32 / x✝¹))))))
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝²)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝².msb = true then -42#32 / -x✝² else -(-42#32 / x✝²))
                      (if x✝².msb = true then -(42#32 / -x✝²) else 42#32 / x✝²)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝²))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝²))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝² + 1#32))))
                      fun a => Eq.refl (42#32 / x✝²))))))
            (congr
              (congrArg HAnd.hAnd
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                      (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                      fun a => Eq.refl (42#32 / x✝¹)))))
              (congrArg (fun x => x ^^^ 4294967295#32)
                (congr
                  (congrArg HOr.hOr
                    (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                      (Eq.trans
                        (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                          (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                          (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                            (eq_false' fun h => Bool.noConfusion h)))
                        (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                          (fun a =>
                            Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                              (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                          fun a => Eq.refl (42#32 / x✝)))))
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝²)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝².msb = true then -42#32 / -x✝² else -(-42#32 / x✝²))
                        (if x✝².msb = true then -(42#32 / -x✝²) else 42#32 / x✝²)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝²))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝²))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝² + 1#32))))
                        fun a => Eq.refl (42#32 / x✝²))))))))
    [Meta.isDefEq.assign] [0.001148] ✅️ ?h₃ := fun a =>
          congrArg some
            (congr
              (congrArg HOr.hOr
                (congr
                  (congrArg (fun x => HAnd.hAnd (x ^^^ 4294967295#32))
                    (congr
                      (congrArg HOr.hOr
                        (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                          (Eq.trans
                            (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                              (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                              (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                                (eq_false' fun h => Bool.noConfusion h)))
                            (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                              (fun a =>
                                Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                                  (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                              fun a => Eq.refl (42#32 / x✝)))))
                      (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                        (Eq.trans
                          (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                            (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                            (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                              (eq_false' fun h => Bool.noConfusion h)))
                          (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                            (fun a =>
                              Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                                (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                            fun a => Eq.refl (42#32 / x✝¹))))))
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝²)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝².msb = true then -42#32 / -x✝² else -(-42#32 / x✝²))
                        (if x✝².msb = true then -(42#32 / -x✝²) else 42#32 / x✝²)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝²))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝²))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝² + 1#32))))
                        fun a => Eq.refl (42#32 / x✝²))))))
              (congr
                (congrArg HAnd.hAnd
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                        (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                        fun a => Eq.refl (42#32 / x✝¹)))))
                (congrArg (fun x => x ^^^ 4294967295#32)
                  (congr
                    (congrArg HOr.hOr
                      (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                        (Eq.trans
                          (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                            (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                            (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                              (eq_false' fun h => Bool.noConfusion h)))
                          (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                            (fun a =>
                              Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                                (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                            fun a => Eq.refl (42#32 / x✝)))))
                    (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝²)
                      (Eq.trans
                        (ite_cond_eq_false (if x✝².msb = true then -42#32 / -x✝² else -(-42#32 / x✝²))
                          (if x✝².msb = true then -(42#32 / -x✝²) else 42#32 / x✝²)
                          (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                            (eq_false' fun h => Bool.noConfusion h)))
                        (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝²))
                          (fun a =>
                            Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝²))
                              (BitVec.neg_eq_not_add (42#32 / (~~~x✝² + 1#32))))
                          fun a => Eq.refl (42#32 / x✝²))))))))
      [Meta.isDefEq.assign.checkTypes] [0.001038] ✅️ (?h₃ : ¬(!(!x✝² == 0#32 &&
                    !(42#32 == BitVec.intMin 32 && x✝² == 4294967295#32))) =
                true →
            some
                ((((42#32).sdiv x✝ ||| (42#32).sdiv x✝¹) ^^^ -1#32) &&& (42#32).sdiv x✝² |||
                  (42#32).sdiv x✝¹ &&& (((42#32).sdiv x✝ ||| (42#32).sdiv x✝²) ^^^ -1#32)) =
              some
                (((((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                        if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ^^^
                      4294967295#32) &&&
                    if x✝².getLsbD 31 = true then ~~~(42#32 / (~~~x✝² + 1#32)) + 1#32 else 42#32 / x✝²) |||
                  (if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) &&&
                    (((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                        if x✝².getLsbD 31 = true then ~~~(42#32 / (~~~x✝² + 1#32)) + 1#32 else 42#32 / x✝²) ^^^
                      4294967295#32))) := (fun a =>
            congrArg some
              (congr
                (congrArg HOr.hOr
                  (congr
                    (congrArg (fun x => HAnd.hAnd (x ^^^ 4294967295#32))
                      (congr
                        (congrArg HOr.hOr
                          (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                            (Eq.trans
                              (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                                (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                                (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                                  (eq_false' fun h => Bool.noConfusion h)))
                              (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                                (fun a =>
                                  Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                                    (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                                fun a => Eq.refl (42#32 / x✝)))))
                        (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                          (Eq.trans
                            (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                              (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                              (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                                (eq_false' fun h => Bool.noConfusion h)))
                            (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                              (fun a =>
                                Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                                  (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                              fun a => Eq.refl (42#32 / x✝¹))))))
                    (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝²)
                      (Eq.trans
                        (ite_cond_eq_false (if x✝².msb = true then -42#32 / -x✝² else -(-42#32 / x✝²))
                          (if x✝².msb = true then -(42#32 / -x✝²) else 42#32 / x✝²)
                          (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                            (eq_false' fun h => Bool.noConfusion h)))
                        (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝²))
                          (fun a =>
                            Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝²))
                              (BitVec.neg_eq_not_add (42#32 / (~~~x✝² + 1#32))))
                          fun a => Eq.refl (42#32 / x✝²))))))
                (congr
                  (congrArg HAnd.hAnd
                    (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                      (Eq.trans
                        (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                          (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                          (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                            (eq_false' fun h => Bool.noConfusion h)))
                        (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                          (fun a =>
                            Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                              (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                          fun a => Eq.refl (42#32 / x✝¹)))))
                  (congrArg (fun x => x ^^^ 4294967295#32)
                    (congr
                      (congrArg HOr.hOr
                        (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                          (Eq.trans
                            (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                              (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                              (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                                (eq_false' fun h => Bool.noConfusion h)))
                            (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                              (fun a =>
                                Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                                  (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                              fun a => Eq.refl (42#32 / x✝)))))
                      (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝²)
                        (Eq.trans
                          (ite_cond_eq_false (if x✝².msb = true then -42#32 / -x✝² else -(-42#32 / x✝²))
                            (if x✝².msb = true then -(42#32 / -x✝²) else 42#32 / x✝²)
                            (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                              (eq_false' fun h => Bool.noConfusion h)))
                          (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝²))
                            (fun a =>
                              Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝²))
                                (BitVec.neg_eq_not_add (42#32 / (~~~x✝² + 1#32))))
                            fun a =>
                            Eq.refl
                              (42#32 /
                                x✝²)))))))) : ¬(!(!x✝² == 0#32 &&
                    !(42#32 == BitVec.intMin 32 && x✝² == 4294967295#32))) =
                true →
            some
                ((((42#32).sdiv x✝ ||| (42#32).sdiv x✝¹) ^^^ 4294967295#32) &&& (42#32).sdiv x✝² |||
                  (42#32).sdiv x✝¹ &&& (((42#32).sdiv x✝ ||| (42#32).sdiv x✝²) ^^^ 4294967295#32)) =
              some
                (((((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                        if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ^^^
                      4294967295#32) &&&
                    if x✝².getLsbD 31 = true then ~~~(42#32 / (~~~x✝² + 1#32)) + 1#32 else 42#32 / x✝²) |||
                  (if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) &&&
                    (((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                        if x✝².getLsbD 31 = true then ~~~(42#32 / (~~~x✝² + 1#32)) + 1#32 else 42#32 / x✝²) ^^^
                      4294967295#32)))
        [Meta.isDefEq] [0.001033] ✅️ ¬(!(!x✝² == 0#32 && !(42#32 == BitVec.intMin 32 && x✝² == 4294967295#32))) = true →
              some
                  ((((42#32).sdiv x✝ ||| (42#32).sdiv x✝¹) ^^^ -1#32) &&& (42#32).sdiv x✝² |||
                    (42#32).sdiv x✝¹ &&& (((42#32).sdiv x✝ ||| (42#32).sdiv x✝²) ^^^ -1#32)) =
                some
                  (((((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                          if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ^^^
                        4294967295#32) &&&
                      if x✝².getLsbD 31 = true then ~~~(42#32 / (~~~x✝² + 1#32)) + 1#32 else 42#32 / x✝²) |||
                    (if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) &&&
                      (((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                          if x✝².getLsbD 31 = true then ~~~(42#32 / (~~~x✝² + 1#32)) + 1#32 else 42#32 / x✝²) ^^^
                        4294967295#32)) =?= ¬(!(!x✝² == 0#32 && !(42#32 == BitVec.intMin 32 && x✝² == 4294967295#32))) =
                  true →
              some
                  ((((42#32).sdiv x✝ ||| (42#32).sdiv x✝¹) ^^^ 4294967295#32) &&& (42#32).sdiv x✝² |||
                    (42#32).sdiv x✝¹ &&& (((42#32).sdiv x✝ ||| (42#32).sdiv x✝²) ^^^ 4294967295#32)) =
                some
                  (((((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                          if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ^^^
                        4294967295#32) &&&
                      if x✝².getLsbD 31 = true then ~~~(42#32 / (~~~x✝² + 1#32)) + 1#32 else 42#32 / x✝²) |||
                    (if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) &&&
                      (((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                          if x✝².getLsbD 31 = true then ~~~(42#32 / (~~~x✝² + 1#32)) + 1#32 else 42#32 / x✝²) ^^^
                        4294967295#32))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              if (!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) = true then none
              else
                if (!(!x✝² == 0#32 && !(42#32 == BitVec.intMin 32 && x✝² == 4294967295#32))) = true then none
                else
                  if (!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) = true then none
                  else
                    if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
                    else
                      if (!(!x✝² == 0#32 && !(42#32 == BitVec.intMin 32 && x✝² == 4294967295#32))) = true then none
                      else
                        some
                          (((((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                                  if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32
                                  else 42#32 / x✝¹) ^^^
                                4294967295#32) &&&
                              if x✝².getLsbD 31 = true then ~~~(42#32 / (~~~x✝² + 1#32)) + 1#32 else 42#32 / x✝²) |||
                            (if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) &&&
                              (((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                                  if x✝².getLsbD 31 = true then ~~~(42#32 / (~~~x✝² + 1#32)) + 1#32
                                  else 42#32 / x✝²) ^^^
                                4294967295#32))) ⊑
            if (!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) = true then none
            else
              if (!(!x✝² == 0#32 && !(42#32 == BitVec.intMin 32 && x✝² == 4294967295#32))) = true then none
              else
                if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
                else
                  some
                    (((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ^^^
                        if x✝².getLsbD 31 = true then ~~~(42#32 / (~~~x✝² + 1#32)) + 1#32 else 42#32 / x✝²) &&&
                      ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                        4294967295#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 75.612279ms, solving context: 0.000000ms
LeanSAT proved the goal after 77.594440ms: rewriting 17.599080ms, bitblasting 0.000000ms, SAT solving 55.704430ms, LRAT trimming 0.000000ms, LRAT checking 2.318390ms
Bitwuzla proved the goal after 75.214709ms, solving context: 0.000000ms
LeanSAT proved the goal after 76.855800ms: rewriting 17.383510ms, bitblasting 0.000000ms, SAT solving 55.542620ms, LRAT trimming 0.000000ms, LRAT checking 1.995500ms
Bitwuzla proved the goal after 74.449390ms, solving context: 1.000000ms
LeanSAT proved the goal after 79.166119ms: rewriting 16.402460ms, bitblasting 0.000000ms, SAT solving 55.355580ms, LRAT trimming 0.000000ms, LRAT checking 4.539129ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:451:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:443:8: error: (kernel) declaration has metavariables 'and_not_or_commute1_thm'
[bv] [0.052039] Normalizing goal
  [Meta.synthInstance] [0.001109] ✅️ Decidable
        ((if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
          else
            if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
            else some ((x✝ &&& (42#32).sdiv x✝¹ ^^^ -1#32 ||| x✝²) &&& ((42#32).sdiv x✝¹ ||| x✝ &&& x✝² ^^^ -1#32))) ⊑
          if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
          else some (((42#32).sdiv x✝¹ ^^^ x✝²) &&& x✝ ^^^ -1#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
            else
              if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
              else some ((x✝ &&& (42#32).sdiv x✝¹ ^^^ -1#32 ||| x✝²) &&& ((42#32).sdiv x✝¹ ||| x✝ &&& x✝² ^^^ -1#32))) ⊑
            if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
            else some (((42#32).sdiv x✝¹ ^^^ x✝²) &&& x✝ ^^^ -1#32)
      ⊢ False
  [Meta.isDefEq] [0.001268] ✅️ ?h₁ =?= congrArg (fun x => x = true)
        (Eq.trans
          (congrArg (fun x => x✝¹ == 0#32 || x && x✝¹ == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
          (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝¹ == 0#32)
            (42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32)))
    [Meta.isDefEq.assign] [0.001265] ✅️ ?h₁ := congrArg (fun x => x = true)
          (Eq.trans
            (congrArg (fun x => x✝¹ == 0#32 || x && x✝¹ == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
            (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝¹ == 0#32)
              (42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32)))
      [Meta.isDefEq.assign.checkTypes] [0.001255] ✅️ (?h₁ : ((x✝¹ == 0 ||
                32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) =
              true) =
            ((!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) =
              true)) := (congrArg (fun x => x = true)
            (Eq.trans
              (congrArg (fun x => x✝¹ == 0#32 || x && x✝¹ == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
              (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝¹ == 0#32)
                (42#32 == BitVec.intMin 32 &&
                  x✝¹ ==
                    4294967295#32))) : ((x✝¹ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32) =
              true) =
            ((!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) = true))
        [Meta.isDefEq] [0.001251] ✅️ ((x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true) =
              ((!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) =
                true) =?= ((x✝¹ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32) = true) =
              ((!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) = true)
          [Meta.isDefEq] [0.001233] ✅️ (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) =
                true =?= (x✝¹ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32) = true
            [Meta.isDefEq] [0.001220] ✅️ x✝¹ == 0 ||
                  32 != 1 && 42#32 == BitVec.intMin 32 &&
                    x✝¹ == -1 =?= x✝¹ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32
              [Meta.isDefEq.delta] [0.001205] ✅️ x✝¹ == 0 ||
                    32 != 1 && 42#32 == BitVec.intMin 32 &&
                      x✝¹ == -1 =?= x✝¹ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32
  [Meta.isDefEq] [0.001047] ✅️ ?h₃ =?= fun a =>
        congrArg some
          (congr
            (congrArg (fun x => HAnd.hAnd (x✝ &&& x ^^^ 4294967295#32 ||| x✝²))
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                (Eq.trans
                  (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                    (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                      (eq_false' fun h => Bool.noConfusion h)))
                  (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                    (fun a =>
                      Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                        (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                    fun a => Eq.refl (42#32 / x✝¹)))))
            (congrArg (fun x => x ||| x✝ &&& x✝² ^^^ 4294967295#32)
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                (Eq.trans
                  (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                    (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                      (eq_false' fun h => Bool.noConfusion h)))
                  (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                    (fun a =>
                      Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                        (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                    fun a => Eq.refl (42#32 / x✝¹))))))
    [Meta.isDefEq.assign] [0.001043] ✅️ ?h₃ := fun a =>
          congrArg some
            (congr
              (congrArg (fun x => HAnd.hAnd (x✝ &&& x ^^^ 4294967295#32 ||| x✝²))
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                      (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                      fun a => Eq.refl (42#32 / x✝¹)))))
              (congrArg (fun x => x ||| x✝ &&& x✝² ^^^ 4294967295#32)
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                      (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                      fun a => Eq.refl (42#32 / x✝¹))))))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) = true then none
            else
              if (!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) = true then none
              else
                some
                  (((x✝ &&& if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ^^^
                        4294967295#32 |||
                      x✝²) &&&
                    ((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) |||
                      x✝ &&& x✝² ^^^ 4294967295#32))) ⊑
            if (!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) = true then none
            else
              some
                (((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ^^^ x✝²) &&&
                    x✝ ^^^
                  4294967295#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:463:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:463:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:455:8: error: (kernel) declaration has metavariables 'and_not_or_commute2_thm'
[bv] [0.050961] Normalizing goal
  [Meta.synthInstance] [0.001030] ✅️ Decidable
        ((if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some (((42#32).sdiv x✝ ||| x✝¹ &&& x✝² ^^^ -1#32) &&& (x✝¹ &&& (42#32).sdiv x✝ ^^^ -1#32 ||| x✝²))) ⊑
          if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else some ((x✝² ^^^ (42#32).sdiv x✝) &&& x✝¹ ^^^ -1#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else
              if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
              else some (((42#32).sdiv x✝ ||| x✝¹ &&& x✝² ^^^ -1#32) &&& (x✝¹ &&& (42#32).sdiv x✝ ^^^ -1#32 ||| x✝²))) ⊑
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some ((x✝² ^^^ (42#32).sdiv x✝) &&& x✝¹ ^^^ -1#32)
      ⊢ False
  [Meta.isDefEq] [0.001064] ✅️ ?h₃ =?= fun a =>
        congrArg some
          (congr
            (congrArg (fun x => HAnd.hAnd (x ||| x✝¹ &&& x✝² ^^^ 4294967295#32))
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                (Eq.trans
                  (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                    (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                      (eq_false' fun h => Bool.noConfusion h)))
                  (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                    (fun a =>
                      Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                        (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                    fun a => Eq.refl (42#32 / x✝)))))
            (congrArg (fun x => x✝¹ &&& x ^^^ 4294967295#32 ||| x✝²)
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                (Eq.trans
                  (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                    (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                      (eq_false' fun h => Bool.noConfusion h)))
                  (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                    (fun a =>
                      Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                        (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                    fun a => Eq.refl (42#32 / x✝))))))
    [Meta.isDefEq.assign] [0.001061] ✅️ ?h₃ := fun a =>
          congrArg some
            (congr
              (congrArg (fun x => HAnd.hAnd (x ||| x✝¹ &&& x✝² ^^^ 4294967295#32))
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                      (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                      fun a => Eq.refl (42#32 / x✝)))))
              (congrArg (fun x => x✝¹ &&& x ^^^ 4294967295#32 ||| x✝²)
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                      (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                      fun a => Eq.refl (42#32 / x✝))))))
      [Meta.isDefEq.assign.checkTypes] [0.001000] ✅️ (?h₃ : ¬(!(!x✝ == 0#32 &&
                    !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) =
                true →
            some (((42#32).sdiv x✝ ||| x✝¹ &&& x✝² ^^^ -1#32) &&& (x✝¹ &&& (42#32).sdiv x✝ ^^^ -1#32 ||| x✝²)) =
              some
                (((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                    x✝¹ &&& x✝² ^^^ 4294967295#32) &&&
                  ((x✝¹ &&& if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                      4294967295#32 |||
                    x✝²))) := (fun a =>
            congrArg some
              (congr
                (congrArg (fun x => HAnd.hAnd (x ||| x✝¹ &&& x✝² ^^^ 4294967295#32))
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                        (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                        fun a => Eq.refl (42#32 / x✝)))))
                (congrArg (fun x => x✝¹ &&& x ^^^ 4294967295#32 ||| x✝²)
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                        (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                        fun a =>
                        Eq.refl
                          (42#32 /
                            x✝)))))) : ¬(!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true →
            some
                (((42#32).sdiv x✝ ||| x✝¹ &&& x✝² ^^^ 4294967295#32) &&&
                  (x✝¹ &&& (42#32).sdiv x✝ ^^^ 4294967295#32 ||| x✝²)) =
              some
                (((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                    x✝¹ &&& x✝² ^^^ 4294967295#32) &&&
                  ((x✝¹ &&& if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                      4294967295#32 |||
                    x✝²)))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
              else
                some
                  (((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                      x✝¹ &&& x✝² ^^^ 4294967295#32) &&&
                    ((x✝¹ &&& if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                        4294967295#32 |||
                      x✝²))) ⊑
            if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              some
                ((x✝² ^^^ if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&& x✝¹ ^^^
                  4294967295#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 73.993480ms, solving context: 1.000000ms
LeanSAT proved the goal after 78.928329ms: rewriting 16.240110ms, bitblasting 0.000000ms, SAT solving 55.519639ms, LRAT trimming 0.000000ms, LRAT checking 4.391580ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:487:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:487:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:479:8: error: (kernel) declaration has metavariables 'and_not_or_commute4_thm'
[bv] [0.050993] Normalizing goal
  [Meta.synthInstance] [0.001038] ✅️ Decidable
        ((if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some (((42#32).sdiv x✝ ||| x✝¹ &&& x✝² ^^^ -1#32) &&& (x✝¹ &&& (42#32).sdiv x✝ ^^^ -1#32 ||| x✝²))) ⊑
          if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else some ((x✝² ^^^ (42#32).sdiv x✝) &&& x✝¹ ^^^ -1#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else
              if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
              else some (((42#32).sdiv x✝ ||| x✝¹ &&& x✝² ^^^ -1#32) &&& (x✝¹ &&& (42#32).sdiv x✝ ^^^ -1#32 ||| x✝²))) ⊑
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some ((x✝² ^^^ (42#32).sdiv x✝) &&& x✝¹ ^^^ -1#32)
      ⊢ False
  [Meta.isDefEq] [0.001071] ✅️ ?h₃ =?= fun a =>
        congrArg some
          (congr
            (congrArg (fun x => HAnd.hAnd (x ||| x✝¹ &&& x✝² ^^^ 4294967295#32))
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                (Eq.trans
                  (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                    (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                      (eq_false' fun h => Bool.noConfusion h)))
                  (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                    (fun a =>
                      Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                        (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                    fun a => Eq.refl (42#32 / x✝)))))
            (congrArg (fun x => x✝¹ &&& x ^^^ 4294967295#32 ||| x✝²)
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                (Eq.trans
                  (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                    (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                      (eq_false' fun h => Bool.noConfusion h)))
                  (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                    (fun a =>
                      Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                        (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                    fun a => Eq.refl (42#32 / x✝))))))
    [Meta.isDefEq.assign] [0.001068] ✅️ ?h₃ := fun a =>
          congrArg some
            (congr
              (congrArg (fun x => HAnd.hAnd (x ||| x✝¹ &&& x✝² ^^^ 4294967295#32))
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                      (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                      fun a => Eq.refl (42#32 / x✝)))))
              (congrArg (fun x => x✝¹ &&& x ^^^ 4294967295#32 ||| x✝²)
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                      (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                      fun a => Eq.refl (42#32 / x✝))))))
      [Meta.isDefEq.assign.checkTypes] [0.001011] ✅️ (?h₃ : ¬(!(!x✝ == 0#32 &&
                    !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) =
                true →
            some (((42#32).sdiv x✝ ||| x✝¹ &&& x✝² ^^^ -1#32) &&& (x✝¹ &&& (42#32).sdiv x✝ ^^^ -1#32 ||| x✝²)) =
              some
                (((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                    x✝¹ &&& x✝² ^^^ 4294967295#32) &&&
                  ((x✝¹ &&& if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                      4294967295#32 |||
                    x✝²))) := (fun a =>
            congrArg some
              (congr
                (congrArg (fun x => HAnd.hAnd (x ||| x✝¹ &&& x✝² ^^^ 4294967295#32))
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                        (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                        fun a => Eq.refl (42#32 / x✝)))))
                (congrArg (fun x => x✝¹ &&& x ^^^ 4294967295#32 ||| x✝²)
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                        (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                        fun a =>
                        Eq.refl
                          (42#32 /
                            x✝)))))) : ¬(!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true →
            some
                (((42#32).sdiv x✝ ||| x✝¹ &&& x✝² ^^^ 4294967295#32) &&&
                  (x✝¹ &&& (42#32).sdiv x✝ ^^^ 4294967295#32 ||| x✝²)) =
              some
                (((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                    x✝¹ &&& x✝² ^^^ 4294967295#32) &&&
                  ((x✝¹ &&& if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                      4294967295#32 |||
                    x✝²)))
        [Meta.isDefEq] [0.001006] ✅️ ¬(!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true →
              some (((42#32).sdiv x✝ ||| x✝¹ &&& x✝² ^^^ -1#32) &&& (x✝¹ &&& (42#32).sdiv x✝ ^^^ -1#32 ||| x✝²)) =
                some
                  (((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                      x✝¹ &&& x✝² ^^^ 4294967295#32) &&&
                    ((x✝¹ &&& if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                        4294967295#32 |||
                      x✝²)) =?= ¬(!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true →
              some
                  (((42#32).sdiv x✝ ||| x✝¹ &&& x✝² ^^^ 4294967295#32) &&&
                    (x✝¹ &&& (42#32).sdiv x✝ ^^^ 4294967295#32 ||| x✝²)) =
                some
                  (((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                      x✝¹ &&& x✝² ^^^ 4294967295#32) &&&
                    ((x✝¹ &&& if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                        4294967295#32 |||
                      x✝²))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
              else
                some
                  (((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                      x✝¹ &&& x✝² ^^^ 4294967295#32) &&&
                    ((x✝¹ &&& if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                        4294967295#32 |||
                      x✝²))) ⊑
            if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              some
                ((x✝² ^^^ if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&& x✝¹ ^^^
                  4294967295#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:501:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:501:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:501:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:491:8: error: (kernel) declaration has metavariables 'and_not_or_commute5_thm'
[bv] [0.080337] Normalizing goal
  [Meta.synthInstance] [0.001122] ✅️ Decidable
        ((if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else
            if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
            else
              if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
              else
                if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
                else
                  some
                    (((42#32).sdiv x✝ ||| (42#32).sdiv x✝¹ &&& x✝² ^^^ -1#32) &&&
                      ((42#32).sdiv x✝¹ &&& (42#32).sdiv x✝ ^^^ -1#32 ||| x✝²))) ⊑
          if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else
            if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
            else some ((x✝² ^^^ (42#32).sdiv x✝) &&& (42#32).sdiv x✝¹ ^^^ -1#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else
              if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
              else
                if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
                else
                  if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
                  else
                    some
                      (((42#32).sdiv x✝ ||| (42#32).sdiv x✝¹ &&& x✝² ^^^ -1#32) &&&
                        ((42#32).sdiv x✝¹ &&& (42#32).sdiv x✝ ^^^ -1#32 ||| x✝²))) ⊑
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else
              if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
              else some ((x✝² ^^^ (42#32).sdiv x✝) &&& (42#32).sdiv x✝¹ ^^^ -1#32)
      ⊢ False
  [Meta.isDefEq] [0.001095] ✅️ ?h₃ =?= fun a =>
        congrArg some
          (congr
            (congrArg HAnd.hAnd
              (congr
                (congrArg HOr.hOr
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                        (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                        fun a => Eq.refl (42#32 / x✝)))))
                (congrArg (fun x => x &&& x✝² ^^^ 4294967295#32)
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                        (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                        fun a => Eq.refl (42#32 / x✝¹)))))))
            (congrArg (fun x => x ^^^ 4294967295#32 ||| x✝²)
              (congr
                (congrArg HAnd.hAnd
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                        (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                        fun a => Eq.refl (42#32 / x✝¹)))))
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                      (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                      fun a => Eq.refl (42#32 / x✝)))))))
    [Meta.isDefEq.assign] [0.001092] ✅️ ?h₃ := fun a =>
          congrArg some
            (congr
              (congrArg HAnd.hAnd
                (congr
                  (congrArg HOr.hOr
                    (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                      (Eq.trans
                        (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                          (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                          (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                            (eq_false' fun h => Bool.noConfusion h)))
                        (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                          (fun a =>
                            Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                              (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                          fun a => Eq.refl (42#32 / x✝)))))
                  (congrArg (fun x => x &&& x✝² ^^^ 4294967295#32)
                    (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                      (Eq.trans
                        (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                          (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                          (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                            (eq_false' fun h => Bool.noConfusion h)))
                        (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                          (fun a =>
                            Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                              (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                          fun a => Eq.refl (42#32 / x✝¹)))))))
              (congrArg (fun x => x ^^^ 4294967295#32 ||| x✝²)
                (congr
                  (congrArg HAnd.hAnd
                    (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                      (Eq.trans
                        (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                          (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                          (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                            (eq_false' fun h => Bool.noConfusion h)))
                        (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                          (fun a =>
                            Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                              (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                          fun a => Eq.refl (42#32 / x✝¹)))))
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                        (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                        fun a => Eq.refl (42#32 / x✝)))))))
      [Meta.isDefEq.assign.checkTypes] [0.001017] ✅️ (?h₃ : ¬(!(!x✝ == 0#32 &&
                    !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) =
                true →
            some
                (((42#32).sdiv x✝ ||| (42#32).sdiv x✝¹ &&& x✝² ^^^ -1#32) &&&
                  ((42#32).sdiv x✝¹ &&& (42#32).sdiv x✝ ^^^ -1#32 ||| x✝²)) =
              some
                (((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                    (if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) &&& x✝² ^^^
                      4294967295#32) &&&
                  (((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) &&&
                        if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                      4294967295#32 |||
                    x✝²))) := (fun a =>
            congrArg some
              (congr
                (congrArg HAnd.hAnd
                  (congr
                    (congrArg HOr.hOr
                      (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                        (Eq.trans
                          (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                            (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                            (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                              (eq_false' fun h => Bool.noConfusion h)))
                          (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                            (fun a =>
                              Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                                (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                            fun a => Eq.refl (42#32 / x✝)))))
                    (congrArg (fun x => x &&& x✝² ^^^ 4294967295#32)
                      (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                        (Eq.trans
                          (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                            (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                            (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                              (eq_false' fun h => Bool.noConfusion h)))
                          (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                            (fun a =>
                              Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                                (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                            fun a => Eq.refl (42#32 / x✝¹)))))))
                (congrArg (fun x => x ^^^ 4294967295#32 ||| x✝²)
                  (congr
                    (congrArg HAnd.hAnd
                      (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                        (Eq.trans
                          (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                            (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                            (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                              (eq_false' fun h => Bool.noConfusion h)))
                          (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                            (fun a =>
                              Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                                (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                            fun a => Eq.refl (42#32 / x✝¹)))))
                    (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                      (Eq.trans
                        (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                          (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                          (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                            (eq_false' fun h => Bool.noConfusion h)))
                        (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                          (fun a =>
                            Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                              (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                          fun a =>
                          Eq.refl
                            (42#32 /
                              x✝))))))) : ¬(!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) =
                true →
            some
                (((42#32).sdiv x✝ ||| (42#32).sdiv x✝¹ &&& x✝² ^^^ 4294967295#32) &&&
                  ((42#32).sdiv x✝¹ &&& (42#32).sdiv x✝ ^^^ 4294967295#32 ||| x✝²)) =
              some
                (((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                    (if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) &&& x✝² ^^^
                      4294967295#32) &&&
                  (((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) &&&
                        if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                      4294967295#32 |||
                    x✝²)))
        [Meta.isDefEq] [0.001012] ✅️ ¬(!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true →
              some
                  (((42#32).sdiv x✝ ||| (42#32).sdiv x✝¹ &&& x✝² ^^^ -1#32) &&&
                    ((42#32).sdiv x✝¹ &&& (42#32).sdiv x✝ ^^^ -1#32 ||| x✝²)) =
                some
                  (((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                      (if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) &&& x✝² ^^^
                        4294967295#32) &&&
                    (((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) &&&
                          if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                        4294967295#32 |||
                      x✝²)) =?= ¬(!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true →
              some
                  (((42#32).sdiv x✝ ||| (42#32).sdiv x✝¹ &&& x✝² ^^^ 4294967295#32) &&&
                    ((42#32).sdiv x✝¹ &&& (42#32).sdiv x✝ ^^^ 4294967295#32 ||| x✝²)) =
                some
                  (((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                      (if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) &&& x✝² ^^^
                        4294967295#32) &&&
                    (((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) &&&
                          if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                        4294967295#32 |||
                      x✝²))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              if (!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) = true then none
              else
                if (!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) = true then none
                else
                  if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
                  else
                    some
                      (((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                          (if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) &&&
                              x✝² ^^^
                            4294967295#32) &&&
                        (((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) &&&
                              if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                            4294967295#32 |||
                          x✝²))) ⊑
            if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              if (!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) = true then none
              else
                some
                  (((x✝² ^^^ if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                      if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ^^^
                    4294967295#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 73.996659ms, solving context: 1.000000ms
LeanSAT proved the goal after 79.261500ms: rewriting 16.149200ms, bitblasting 0.000000ms, SAT solving 55.820440ms, LRAT trimming 0.000000ms, LRAT checking 4.444980ms
Bitwuzla proved the goal after 74.495620ms, solving context: 1.000000ms
LeanSAT proved the goal after 78.927180ms: rewriting 16.388400ms, bitblasting 0.000000ms, SAT solving 55.468120ms, LRAT trimming 0.000000ms, LRAT checking 4.350540ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:539:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:539:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:539:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:539:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:529:8: error: (kernel) declaration has metavariables 'and_not_or_commute8_thm'
[bv] [0.080896] Normalizing goal
  [Meta.synthInstance] [0.001110] ✅️ Decidable
        ((if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else
            if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
            else
              if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
              else
                if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
                else
                  some
                    (((42#32).sdiv x✝ &&& (42#32).sdiv x✝¹ ^^^ -1#32 ||| x✝²) &&&
                      ((42#32).sdiv x✝¹ ||| x✝² &&& (42#32).sdiv x✝ ^^^ -1#32))) ⊑
          if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
          else
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some (((42#32).sdiv x✝¹ ^^^ x✝²) &&& (42#32).sdiv x✝ ^^^ -1#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else
              if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
              else
                if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
                else
                  if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
                  else
                    some
                      (((42#32).sdiv x✝ &&& (42#32).sdiv x✝¹ ^^^ -1#32 ||| x✝²) &&&
                        ((42#32).sdiv x✝¹ ||| x✝² &&& (42#32).sdiv x✝ ^^^ -1#32))) ⊑
            if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
            else
              if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
              else some (((42#32).sdiv x✝¹ ^^^ x✝²) &&& (42#32).sdiv x✝ ^^^ -1#32)
      ⊢ False
  [Meta.isDefEq] [0.001108] ✅️ ?h₃ =?= fun a =>
        congrArg some
          (congr
            (congrArg (fun x => HAnd.hAnd (x ^^^ 4294967295#32 ||| x✝²))
              (congr
                (congrArg HAnd.hAnd
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                        (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                        fun a => Eq.refl (42#32 / x✝)))))
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                      (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                      fun a => Eq.refl (42#32 / x✝¹))))))
            (congr
              (congrArg HOr.hOr
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                      (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                      fun a => Eq.refl (42#32 / x✝¹)))))
              (congrArg (fun x => x✝² &&& x ^^^ 4294967295#32)
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                      (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                      fun a => Eq.refl (42#32 / x✝)))))))
    [Meta.isDefEq.assign] [0.001105] ✅️ ?h₃ := fun a =>
          congrArg some
            (congr
              (congrArg (fun x => HAnd.hAnd (x ^^^ 4294967295#32 ||| x✝²))
                (congr
                  (congrArg HAnd.hAnd
                    (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                      (Eq.trans
                        (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                          (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                          (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                            (eq_false' fun h => Bool.noConfusion h)))
                        (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                          (fun a =>
                            Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                              (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                          fun a => Eq.refl (42#32 / x✝)))))
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                        (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                        fun a => Eq.refl (42#32 / x✝¹))))))
              (congr
                (congrArg HOr.hOr
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                        (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                        fun a => Eq.refl (42#32 / x✝¹)))))
                (congrArg (fun x => x✝² &&& x ^^^ 4294967295#32)
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                        (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                        fun a => Eq.refl (42#32 / x✝)))))))
      [Meta.isDefEq.assign.checkTypes] [0.001030] ✅️ (?h₃ : ¬(!(!x✝ == 0#32 &&
                    !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) =
                true →
            some
                (((42#32).sdiv x✝ &&& (42#32).sdiv x✝¹ ^^^ -1#32 ||| x✝²) &&&
                  ((42#32).sdiv x✝¹ ||| x✝² &&& (42#32).sdiv x✝ ^^^ -1#32)) =
              some
                ((((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                        if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ^^^
                      4294967295#32 |||
                    x✝²) &&&
                  ((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) |||
                    (x✝² &&& if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                      4294967295#32))) := (fun a =>
            congrArg some
              (congr
                (congrArg (fun x => HAnd.hAnd (x ^^^ 4294967295#32 ||| x✝²))
                  (congr
                    (congrArg HAnd.hAnd
                      (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                        (Eq.trans
                          (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                            (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                            (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                              (eq_false' fun h => Bool.noConfusion h)))
                          (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                            (fun a =>
                              Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                                (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                            fun a => Eq.refl (42#32 / x✝)))))
                    (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                      (Eq.trans
                        (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                          (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                          (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                            (eq_false' fun h => Bool.noConfusion h)))
                        (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                          (fun a =>
                            Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                              (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                          fun a => Eq.refl (42#32 / x✝¹))))))
                (congr
                  (congrArg HOr.hOr
                    (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                      (Eq.trans
                        (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                          (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                          (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                            (eq_false' fun h => Bool.noConfusion h)))
                        (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                          (fun a =>
                            Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                              (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                          fun a => Eq.refl (42#32 / x✝¹)))))
                  (congrArg (fun x => x✝² &&& x ^^^ 4294967295#32)
                    (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                      (Eq.trans
                        (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                          (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                          (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                            (eq_false' fun h => Bool.noConfusion h)))
                        (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                          (fun a =>
                            Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                              (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                          fun a =>
                          Eq.refl
                            (42#32 /
                              x✝))))))) : ¬(!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) =
                true →
            some
                (((42#32).sdiv x✝ &&& (42#32).sdiv x✝¹ ^^^ 4294967295#32 ||| x✝²) &&&
                  ((42#32).sdiv x✝¹ ||| x✝² &&& (42#32).sdiv x✝ ^^^ 4294967295#32)) =
              some
                ((((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                        if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ^^^
                      4294967295#32 |||
                    x✝²) &&&
                  ((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) |||
                    (x✝² &&& if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                      4294967295#32)))
        [Meta.isDefEq] [0.001025] ✅️ ¬(!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true →
              some
                  (((42#32).sdiv x✝ &&& (42#32).sdiv x✝¹ ^^^ -1#32 ||| x✝²) &&&
                    ((42#32).sdiv x✝¹ ||| x✝² &&& (42#32).sdiv x✝ ^^^ -1#32)) =
                some
                  ((((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                          if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ^^^
                        4294967295#32 |||
                      x✝²) &&&
                    ((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) |||
                      (x✝² &&& if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                        4294967295#32)) =?= ¬(!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) =
                  true →
              some
                  (((42#32).sdiv x✝ &&& (42#32).sdiv x✝¹ ^^^ 4294967295#32 ||| x✝²) &&&
                    ((42#32).sdiv x✝¹ ||| x✝² &&& (42#32).sdiv x✝ ^^^ 4294967295#32)) =
                some
                  ((((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                          if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ^^^
                        4294967295#32 |||
                      x✝²) &&&
                    ((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) |||
                      (x✝² &&& if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                        4294967295#32))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              if (!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) = true then none
              else
                if (!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) = true then none
                else
                  if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
                  else
                    some
                      ((((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                              if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ^^^
                            4294967295#32 |||
                          x✝²) &&&
                        ((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) |||
                          (x✝² &&& if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                            4294967295#32))) ⊑
            if (!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) = true then none
            else
              if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
              else
                some
                  ((((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ^^^ x✝²) &&&
                      if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                    4294967295#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:556:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:556:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:556:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:556:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:543:8: error: (kernel) declaration has metavariables 'and_not_or_commute9_thm'
[bv] [0.110662] Normalizing goal
  [Meta.synthInstance] [0.001175] ✅️ Decidable
        ((if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else
            if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
            else
              if (x✝² == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝² == -1) = true then none
              else
                if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
                else
                  if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
                  else
                    if (x✝² == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝² == -1) = true then none
                    else
                      some
                        (((42#32).sdiv x✝ &&& (42#32).sdiv x✝¹ ^^^ -1#32 ||| (42#32).sdiv x✝²) &&&
                          ((42#32).sdiv x✝¹ ||| (42#32).sdiv x✝ &&& (42#32).sdiv x✝² ^^^ -1#32))) ⊑
          if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
          else
            if (x✝² == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝² == -1) = true then none
            else
              if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
              else some (((42#32).sdiv x✝¹ ^^^ (42#32).sdiv x✝²) &&& (42#32).sdiv x✝ ^^^ -1#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else
              if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
              else
                if (x✝² == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝² == -1) = true then none
                else
                  if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
                  else
                    if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
                    else
                      if (x✝² == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝² == -1) = true then none
                      else
                        some
                          (((42#32).sdiv x✝ &&& (42#32).sdiv x✝¹ ^^^ -1#32 ||| (42#32).sdiv x✝²) &&&
                            ((42#32).sdiv x✝¹ ||| (42#32).sdiv x✝ &&& (42#32).sdiv x✝² ^^^ -1#32))) ⊑
            if (x✝¹ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝¹ == -1) = true then none
            else
              if (x✝² == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝² == -1) = true then none
              else
                if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
                else some (((42#32).sdiv x✝¹ ^^^ (42#32).sdiv x✝²) &&& (42#32).sdiv x✝ ^^^ -1#32)
      ⊢ False
  [Meta.isDefEq] [0.001143] ✅️ ?h₃ =?= fun a =>
        congrArg some
          (congr
            (congrArg HAnd.hAnd
              (congr
                (congrArg (fun x => HOr.hOr (x ^^^ 4294967295#32))
                  (congr
                    (congrArg HAnd.hAnd
                      (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                        (Eq.trans
                          (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                            (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                            (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                              (eq_false' fun h => Bool.noConfusion h)))
                          (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                            (fun a =>
                              Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                                (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                            fun a => Eq.refl (42#32 / x✝)))))
                    (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                      (Eq.trans
                        (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                          (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                          (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                            (eq_false' fun h => Bool.noConfusion h)))
                        (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                          (fun a =>
                            Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                              (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                          fun a => Eq.refl (42#32 / x✝¹))))))
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝²)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝².msb = true then -42#32 / -x✝² else -(-42#32 / x✝²))
                      (if x✝².msb = true then -(42#32 / -x✝²) else 42#32 / x✝²)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝²))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝²))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝² + 1#32))))
                      fun a => Eq.refl (42#32 / x✝²))))))
            (congr
              (congrArg HOr.hOr
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                      (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                      fun a => Eq.refl (42#32 / x✝¹)))))
              (congrArg (fun x => x ^^^ 4294967295#32)
                (congr
                  (congrArg HAnd.hAnd
                    (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                      (Eq.trans
                        (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                          (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                          (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                            (eq_false' fun h => Bool.noConfusion h)))
                        (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                          (fun a =>
                            Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                              (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                          fun a => Eq.refl (42#32 / x✝)))))
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝²)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝².msb = true then -42#32 / -x✝² else -(-42#32 / x✝²))
                        (if x✝².msb = true then -(42#32 / -x✝²) else 42#32 / x✝²)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝²))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝²))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝² + 1#32))))
                        fun a => Eq.refl (42#32 / x✝²))))))))
    [Meta.isDefEq.assign] [0.001140] ✅️ ?h₃ := fun a =>
          congrArg some
            (congr
              (congrArg HAnd.hAnd
                (congr
                  (congrArg (fun x => HOr.hOr (x ^^^ 4294967295#32))
                    (congr
                      (congrArg HAnd.hAnd
                        (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                          (Eq.trans
                            (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                              (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                              (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                                (eq_false' fun h => Bool.noConfusion h)))
                            (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                              (fun a =>
                                Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                                  (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                              fun a => Eq.refl (42#32 / x✝)))))
                      (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                        (Eq.trans
                          (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                            (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                            (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                              (eq_false' fun h => Bool.noConfusion h)))
                          (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                            (fun a =>
                              Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                                (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                            fun a => Eq.refl (42#32 / x✝¹))))))
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝²)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝².msb = true then -42#32 / -x✝² else -(-42#32 / x✝²))
                        (if x✝².msb = true then -(42#32 / -x✝²) else 42#32 / x✝²)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝²))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝²))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝² + 1#32))))
                        fun a => Eq.refl (42#32 / x✝²))))))
              (congr
                (congrArg HOr.hOr
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                        (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                        fun a => Eq.refl (42#32 / x✝¹)))))
                (congrArg (fun x => x ^^^ 4294967295#32)
                  (congr
                    (congrArg HAnd.hAnd
                      (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                        (Eq.trans
                          (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                            (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                            (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                              (eq_false' fun h => Bool.noConfusion h)))
                          (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                            (fun a =>
                              Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                                (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                            fun a => Eq.refl (42#32 / x✝)))))
                    (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝²)
                      (Eq.trans
                        (ite_cond_eq_false (if x✝².msb = true then -42#32 / -x✝² else -(-42#32 / x✝²))
                          (if x✝².msb = true then -(42#32 / -x✝²) else 42#32 / x✝²)
                          (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                            (eq_false' fun h => Bool.noConfusion h)))
                        (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝²))
                          (fun a =>
                            Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝²))
                              (BitVec.neg_eq_not_add (42#32 / (~~~x✝² + 1#32))))
                          fun a => Eq.refl (42#32 / x✝²))))))))
      [Meta.isDefEq.assign.checkTypes] [0.001043] ✅️ (?h₃ : ¬(!(!x✝² == 0#32 &&
                    !(42#32 == BitVec.intMin 32 && x✝² == 4294967295#32))) =
                true →
            some
                (((42#32).sdiv x✝ &&& (42#32).sdiv x✝¹ ^^^ -1#32 ||| (42#32).sdiv x✝²) &&&
                  ((42#32).sdiv x✝¹ ||| (42#32).sdiv x✝ &&& (42#32).sdiv x✝² ^^^ -1#32)) =
              some
                ((((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                        if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ^^^
                      4294967295#32 |||
                    if x✝².getLsbD 31 = true then ~~~(42#32 / (~~~x✝² + 1#32)) + 1#32 else 42#32 / x✝²) &&&
                  ((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) |||
                    ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                        if x✝².getLsbD 31 = true then ~~~(42#32 / (~~~x✝² + 1#32)) + 1#32 else 42#32 / x✝²) ^^^
                      4294967295#32))) := (fun a =>
            congrArg some
              (congr
                (congrArg HAnd.hAnd
                  (congr
                    (congrArg (fun x => HOr.hOr (x ^^^ 4294967295#32))
                      (congr
                        (congrArg HAnd.hAnd
                          (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                            (Eq.trans
                              (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                                (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                                (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                                  (eq_false' fun h => Bool.noConfusion h)))
                              (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                                (fun a =>
                                  Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                                    (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                                fun a => Eq.refl (42#32 / x✝)))))
                        (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                          (Eq.trans
                            (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                              (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                              (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                                (eq_false' fun h => Bool.noConfusion h)))
                            (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                              (fun a =>
                                Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                                  (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                              fun a => Eq.refl (42#32 / x✝¹))))))
                    (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝²)
                      (Eq.trans
                        (ite_cond_eq_false (if x✝².msb = true then -42#32 / -x✝² else -(-42#32 / x✝²))
                          (if x✝².msb = true then -(42#32 / -x✝²) else 42#32 / x✝²)
                          (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                            (eq_false' fun h => Bool.noConfusion h)))
                        (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝²))
                          (fun a =>
                            Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝²))
                              (BitVec.neg_eq_not_add (42#32 / (~~~x✝² + 1#32))))
                          fun a => Eq.refl (42#32 / x✝²))))))
                (congr
                  (congrArg HOr.hOr
                    (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝¹)
                      (Eq.trans
                        (ite_cond_eq_false (if x✝¹.msb = true then -42#32 / -x✝¹ else -(-42#32 / x✝¹))
                          (if x✝¹.msb = true then -(42#32 / -x✝¹) else 42#32 / x✝¹)
                          (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                            (eq_false' fun h => Bool.noConfusion h)))
                        (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝¹))
                          (fun a =>
                            Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝¹))
                              (BitVec.neg_eq_not_add (42#32 / (~~~x✝¹ + 1#32))))
                          fun a => Eq.refl (42#32 / x✝¹)))))
                  (congrArg (fun x => x ^^^ 4294967295#32)
                    (congr
                      (congrArg HAnd.hAnd
                        (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                          (Eq.trans
                            (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                              (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                              (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                                (eq_false' fun h => Bool.noConfusion h)))
                            (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                              (fun a =>
                                Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                                  (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                              fun a => Eq.refl (42#32 / x✝)))))
                      (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝²)
                        (Eq.trans
                          (ite_cond_eq_false (if x✝².msb = true then -42#32 / -x✝² else -(-42#32 / x✝²))
                            (if x✝².msb = true then -(42#32 / -x✝²) else 42#32 / x✝²)
                            (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                              (eq_false' fun h => Bool.noConfusion h)))
                          (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝²))
                            (fun a =>
                              Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝²))
                                (BitVec.neg_eq_not_add (42#32 / (~~~x✝² + 1#32))))
                            fun a =>
                            Eq.refl
                              (42#32 /
                                x✝²)))))))) : ¬(!(!x✝² == 0#32 &&
                    !(42#32 == BitVec.intMin 32 && x✝² == 4294967295#32))) =
                true →
            some
                (((42#32).sdiv x✝ &&& (42#32).sdiv x✝¹ ^^^ 4294967295#32 ||| (42#32).sdiv x✝²) &&&
                  ((42#32).sdiv x✝¹ ||| (42#32).sdiv x✝ &&& (42#32).sdiv x✝² ^^^ 4294967295#32)) =
              some
                ((((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                        if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ^^^
                      4294967295#32 |||
                    if x✝².getLsbD 31 = true then ~~~(42#32 / (~~~x✝² + 1#32)) + 1#32 else 42#32 / x✝²) &&&
                  ((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) |||
                    ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                        if x✝².getLsbD 31 = true then ~~~(42#32 / (~~~x✝² + 1#32)) + 1#32 else 42#32 / x✝²) ^^^
                      4294967295#32)))
        [Meta.isDefEq] [0.001039] ✅️ ¬(!(!x✝² == 0#32 && !(42#32 == BitVec.intMin 32 && x✝² == 4294967295#32))) = true →
              some
                  (((42#32).sdiv x✝ &&& (42#32).sdiv x✝¹ ^^^ -1#32 ||| (42#32).sdiv x✝²) &&&
                    ((42#32).sdiv x✝¹ ||| (42#32).sdiv x✝ &&& (42#32).sdiv x✝² ^^^ -1#32)) =
                some
                  ((((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                          if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ^^^
                        4294967295#32 |||
                      if x✝².getLsbD 31 = true then ~~~(42#32 / (~~~x✝² + 1#32)) + 1#32 else 42#32 / x✝²) &&&
                    ((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) |||
                      ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                          if x✝².getLsbD 31 = true then ~~~(42#32 / (~~~x✝² + 1#32)) + 1#32 else 42#32 / x✝²) ^^^
                        4294967295#32)) =?= ¬(!(!x✝² == 0#32 && !(42#32 == BitVec.intMin 32 && x✝² == 4294967295#32))) =
                  true →
              some
                  (((42#32).sdiv x✝ &&& (42#32).sdiv x✝¹ ^^^ 4294967295#32 ||| (42#32).sdiv x✝²) &&&
                    ((42#32).sdiv x✝¹ ||| (42#32).sdiv x✝ &&& (42#32).sdiv x✝² ^^^ 4294967295#32)) =
                some
                  ((((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                          if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ^^^
                        4294967295#32 |||
                      if x✝².getLsbD 31 = true then ~~~(42#32 / (~~~x✝² + 1#32)) + 1#32 else 42#32 / x✝²) &&&
                    ((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) |||
                      ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                          if x✝².getLsbD 31 = true then ~~~(42#32 / (~~~x✝² + 1#32)) + 1#32 else 42#32 / x✝²) ^^^
                        4294967295#32))
          [Meta.isDefEq] [0.001005] ✅️ some
                  (((42#32).sdiv x✝ &&& (42#32).sdiv x✝¹ ^^^ -1#32 ||| (42#32).sdiv x✝²) &&&
                    ((42#32).sdiv x✝¹ ||| (42#32).sdiv x✝ &&& (42#32).sdiv x✝² ^^^ -1#32)) =
                some
                  ((((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                          if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ^^^
                        4294967295#32 |||
                      if x✝².getLsbD 31 = true then ~~~(42#32 / (~~~x✝² + 1#32)) + 1#32 else 42#32 / x✝²) &&&
                    ((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) |||
                      ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                          if x✝².getLsbD 31 = true then ~~~(42#32 / (~~~x✝² + 1#32)) + 1#32 else 42#32 / x✝²) ^^^
                        4294967295#32)) =?= some
                  (((42#32).sdiv x✝ &&& (42#32).sdiv x✝¹ ^^^ 4294967295#32 ||| (42#32).sdiv x✝²) &&&
                    ((42#32).sdiv x✝¹ ||| (42#32).sdiv x✝ &&& (42#32).sdiv x✝² ^^^ 4294967295#32)) =
                some
                  ((((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                          if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ^^^
                        4294967295#32 |||
                      if x✝².getLsbD 31 = true then ~~~(42#32 / (~~~x✝² + 1#32)) + 1#32 else 42#32 / x✝²) &&&
                    ((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) |||
                      ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                          if x✝².getLsbD 31 = true then ~~~(42#32 / (~~~x✝² + 1#32)) + 1#32 else 42#32 / x✝²) ^^^
                        4294967295#32))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              if (!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) = true then none
              else
                if (!(!x✝² == 0#32 && !(42#32 == BitVec.intMin 32 && x✝² == 4294967295#32))) = true then none
                else
                  if (!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) = true then none
                  else
                    if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
                    else
                      if (!(!x✝² == 0#32 && !(42#32 == BitVec.intMin 32 && x✝² == 4294967295#32))) = true then none
                      else
                        some
                          ((((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                                  if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32
                                  else 42#32 / x✝¹) ^^^
                                4294967295#32 |||
                              if x✝².getLsbD 31 = true then ~~~(42#32 / (~~~x✝² + 1#32)) + 1#32 else 42#32 / x✝²) &&&
                            ((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) |||
                              ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                                  if x✝².getLsbD 31 = true then ~~~(42#32 / (~~~x✝² + 1#32)) + 1#32
                                  else 42#32 / x✝²) ^^^
                                4294967295#32))) ⊑
            if (!(!x✝¹ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝¹ == 4294967295#32))) = true then none
            else
              if (!(!x✝² == 0#32 && !(42#32 == BitVec.intMin 32 && x✝² == 4294967295#32))) = true then none
              else
                if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
                else
                  some
                    ((((if x✝¹.getLsbD 31 = true then ~~~(42#32 / (~~~x✝¹ + 1#32)) + 1#32 else 42#32 / x✝¹) ^^^
                          if x✝².getLsbD 31 = true then ~~~(42#32 / (~~~x✝² + 1#32)) + 1#32 else 42#32 / x✝²) &&&
                        if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                      4294967295#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 75.979389ms, solving context: 0.000000ms
LeanSAT proved the goal after 78.378280ms: rewriting 17.446060ms, bitblasting 0.000000ms, SAT solving 56.716740ms, LRAT trimming 0.000000ms, LRAT checking 2.248440ms
Bitwuzla proved the goal after 75.434840ms, solving context: 0.000000ms
LeanSAT proved the goal after 77.116060ms: rewriting 17.251980ms, bitblasting 0.000000ms, SAT solving 55.908190ms, LRAT trimming 0.000000ms, LRAT checking 2.061350ms
Bitwuzla proved the goal after 72.772479ms, solving context: 1.000000ms
LeanSAT proved the goal after 78.533400ms: rewriting 14.621420ms, bitblasting 0.000000ms, SAT solving 56.840450ms, LRAT trimming 0.000000ms, LRAT checking 4.218330ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:605:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:605:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:597:8: error: (kernel) declaration has metavariables 'or_and_not_not_commute1_thm'
[bv] [0.049258] Normalizing goal
  [Meta.synthInstance] [0.001031] ✅️ Decidable
        ((if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some ((42#32).sdiv x✝ &&& ((x✝¹ ||| x✝²) ^^^ -1#32) ||| ((42#32).sdiv x✝ ||| x✝¹) ^^^ -1#32)) ⊑
          if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else some ((x✝² &&& (42#32).sdiv x✝ ||| x✝¹) ^^^ -1#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else
              if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
              else some ((42#32).sdiv x✝ &&& ((x✝¹ ||| x✝²) ^^^ -1#32) ||| ((42#32).sdiv x✝ ||| x✝¹) ^^^ -1#32)) ⊑
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some ((x✝² &&& (42#32).sdiv x✝ ||| x✝¹) ^^^ -1#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
              else
                some
                  ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                      ((x✝¹ ||| x✝²) ^^^ 4294967295#32) |||
                    ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ||| x✝¹) ^^^
                      4294967295#32)) ⊑
            if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              some
                (((x✝² &&& if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ||| x✝¹) ^^^
                  4294967295#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 72.905450ms, solving context: 1.000000ms
LeanSAT proved the goal after 77.096750ms: rewriting 14.534750ms, bitblasting 0.000000ms, SAT solving 56.047590ms, LRAT trimming 0.000000ms, LRAT checking 3.760760ms
Bitwuzla proved the goal after 72.883880ms, solving context: 1.000000ms
LeanSAT proved the goal after 78.143640ms: rewriting 14.720980ms, bitblasting 0.000000ms, SAT solving 56.610150ms, LRAT trimming 0.000000ms, LRAT checking 4.120580ms
Bitwuzla proved the goal after 72.987290ms, solving context: 1.000000ms
LeanSAT proved the goal after 78.080790ms: rewriting 14.670450ms, bitblasting 0.000000ms, SAT solving 56.777960ms, LRAT trimming 0.000000ms, LRAT checking 3.970930ms
Bitwuzla proved the goal after 72.934879ms, solving context: 1.000000ms
LeanSAT proved the goal after 77.537480ms: rewriting 14.668260ms, bitblasting 0.000000ms, SAT solving 56.090750ms, LRAT trimming 0.000000ms, LRAT checking 4.074800ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:661:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:661:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:661:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:653:8: error: (kernel) declaration has metavariables 'or_and_not_not_commute6_thm'
[bv] [0.049567] Normalizing goal
  [Meta.synthInstance] [0.001019] ✅️ Decidable
        ((if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some ((42#32).sdiv x✝ &&& ((x✝¹ ||| x✝²) ^^^ -1#32) ||| ((42#32).sdiv x✝ ||| x✝²) ^^^ -1#32)) ⊑
          if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else some ((x✝¹ &&& (42#32).sdiv x✝ ||| x✝²) ^^^ -1#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else
              if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
              else some ((42#32).sdiv x✝ &&& ((x✝¹ ||| x✝²) ^^^ -1#32) ||| ((42#32).sdiv x✝ ||| x✝²) ^^^ -1#32)) ⊑
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some ((x✝¹ &&& (42#32).sdiv x✝ ||| x✝²) ^^^ -1#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
              else
                some
                  ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                      ((x✝¹ ||| x✝²) ^^^ 4294967295#32) |||
                    ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ||| x✝²) ^^^
                      4294967295#32)) ⊑
            if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              some
                (((x✝¹ &&& if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ||| x✝²) ^^^
                  4294967295#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 73.238150ms, solving context: 1.000000ms
LeanSAT proved the goal after 78.802849ms: rewriting 14.635920ms, bitblasting 0.000000ms, SAT solving 57.430899ms, LRAT trimming 0.000000ms, LRAT checking 4.017740ms
Bitwuzla proved the goal after 73.339760ms, solving context: 0.000000ms
LeanSAT proved the goal after 74.346750ms: rewriting 15.115600ms, bitblasting 0.000000ms, SAT solving 55.549370ms, LRAT trimming 0.000000ms, LRAT checking 1.889470ms
Bitwuzla proved the goal after 73.396590ms, solving context: 0.000000ms
LeanSAT proved the goal after 75.578610ms: rewriting 15.000060ms, bitblasting 0.000000ms, SAT solving 56.858940ms, LRAT trimming 0.000000ms, LRAT checking 1.924130ms
Bitwuzla proved the goal after 74.269370ms, solving context: 1.000000ms
LeanSAT proved the goal after 78.698510ms: rewriting 15.474980ms, bitblasting 0.000000ms, SAT solving 56.843900ms, LRAT trimming 0.000000ms, LRAT checking 3.901730ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:719:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:719:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:711:8: error: (kernel) declaration has metavariables 'and_or_not_not_commute1_thm'
[bv] [0.050200] Normalizing goal
  [Meta.synthInstance] [0.001030] ✅️ Decidable
        ((if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some (((42#32).sdiv x✝ ||| x✝¹ &&& x✝² ^^^ -1#32) &&& ((42#32).sdiv x✝ &&& x✝¹ ^^^ -1#32))) ⊑
          if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else some ((x✝² ||| (42#32).sdiv x✝) &&& x✝¹ ^^^ -1#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else
              if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
              else some (((42#32).sdiv x✝ ||| x✝¹ &&& x✝² ^^^ -1#32) &&& ((42#32).sdiv x✝ &&& x✝¹ ^^^ -1#32))) ⊑
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some ((x✝² ||| (42#32).sdiv x✝) &&& x✝¹ ^^^ -1#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
              else
                some
                  (((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                      x✝¹ &&& x✝² ^^^ 4294967295#32) &&&
                    ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&& x✝¹ ^^^
                      4294967295#32))) ⊑
            if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              some
                ((x✝² ||| if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&& x✝¹ ^^^
                  4294967295#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 73.584510ms, solving context: 1.000000ms
LeanSAT proved the goal after 78.394979ms: rewriting 15.474369ms, bitblasting 0.000000ms, SAT solving 56.963569ms, LRAT trimming 0.000000ms, LRAT checking 3.534560ms
Bitwuzla proved the goal after 73.874370ms, solving context: 1.000000ms
LeanSAT proved the goal after 79.082839ms: rewriting 15.407060ms, bitblasting 0.000000ms, SAT solving 57.341990ms, LRAT trimming 0.000000ms, LRAT checking 3.913080ms
Bitwuzla proved the goal after 74.088750ms, solving context: 1.000000ms
LeanSAT proved the goal after 78.691029ms: rewriting 15.421179ms, bitblasting 0.000000ms, SAT solving 57.173969ms, LRAT trimming 0.000000ms, LRAT checking 3.701200ms
Bitwuzla proved the goal after 73.717350ms, solving context: 1.000000ms
LeanSAT proved the goal after 78.942050ms: rewriting 15.508310ms, bitblasting 0.000000ms, SAT solving 57.083840ms, LRAT trimming 0.000000ms, LRAT checking 3.845560ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:775:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:775:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:775:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:767:8: error: (kernel) declaration has metavariables 'and_or_not_not_commute6_thm'
[bv] [0.050226] Normalizing goal
  [Meta.synthInstance] [0.001016] ✅️ Decidable
        ((if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some (((42#32).sdiv x✝ ||| x✝¹ &&& x✝² ^^^ -1#32) &&& ((42#32).sdiv x✝ &&& x✝² ^^^ -1#32))) ⊑
          if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else some ((x✝¹ ||| (42#32).sdiv x✝) &&& x✝² ^^^ -1#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else
              if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
              else some (((42#32).sdiv x✝ ||| x✝¹ &&& x✝² ^^^ -1#32) &&& ((42#32).sdiv x✝ &&& x✝² ^^^ -1#32))) ⊑
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some ((x✝¹ ||| (42#32).sdiv x✝) &&& x✝² ^^^ -1#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
              else
                some
                  (((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                      x✝¹ &&& x✝² ^^^ 4294967295#32) &&&
                    ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&& x✝² ^^^
                      4294967295#32))) ⊑
            if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              some
                ((x✝¹ ||| if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&& x✝² ^^^
                  4294967295#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 73.997670ms, solving context: 1.000000ms
LeanSAT proved the goal after 77.947239ms: rewriting 15.336200ms, bitblasting 0.000000ms, SAT solving 56.394599ms, LRAT trimming 0.000000ms, LRAT checking 3.712639ms
Bitwuzla proved the goal after 73.533820ms, solving context: 0.000000ms
LeanSAT proved the goal after 78.119129ms: rewriting 15.312450ms, bitblasting 0.000000ms, SAT solving 56.415039ms, LRAT trimming 0.000000ms, LRAT checking 3.929690ms
Bitwuzla proved the goal after 74.393199ms, solving context: 0.000000ms
LeanSAT proved the goal after 77.116930ms: rewriting 15.806690ms, bitblasting 0.000000ms, SAT solving 57.584190ms, LRAT trimming 0.000000ms, LRAT checking 1.934050ms
Bitwuzla proved the goal after 73.590080ms, solving context: 0.000000ms
LeanSAT proved the goal after 78.131599ms: rewriting 14.774540ms, bitblasting 0.000000ms, SAT solving 56.468930ms, LRAT trimming 0.000000ms, LRAT checking 4.193770ms
Bitwuzla proved the goal after 73.559860ms, solving context: 0.000000ms
LeanSAT proved the goal after 79.092339ms: rewriting 14.951260ms, bitblasting 0.000000ms, SAT solving 57.199929ms, LRAT trimming 0.000000ms, LRAT checking 4.241040ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:846:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:846:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:846:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:837:8: error: (kernel) declaration has metavariables 'and_not_or_or_not_or_xor_commute2_thm'
[bv] [0.049369] Normalizing goal
  [Meta.synthInstance] [0.001016] ✅️ Decidable
        ((if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some ((42#32).sdiv x✝ &&& ((x✝¹ ||| x✝²) ^^^ -1#32) ||| (x✝¹ ^^^ x✝² ||| (42#32).sdiv x✝) ^^^ -1#32)) ⊑
          if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else some ((x✝¹ ||| x✝²) &&& (x✝¹ ^^^ x✝² ||| (42#32).sdiv x✝) ^^^ -1#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else
              if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
              else
                some ((42#32).sdiv x✝ &&& ((x✝¹ ||| x✝²) ^^^ -1#32) ||| (x✝¹ ^^^ x✝² ||| (42#32).sdiv x✝) ^^^ -1#32)) ⊑
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some ((x✝¹ ||| x✝²) &&& (x✝¹ ^^^ x✝² ||| (42#32).sdiv x✝) ^^^ -1#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
              else
                some
                  ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                      ((x✝¹ ||| x✝²) ^^^ 4294967295#32) |||
                    (x✝¹ ^^^ x✝² |||
                        if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                      4294967295#32)) ⊑
            if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              some
                ((x✝¹ ||| x✝²) &&&
                    (x✝¹ ^^^ x✝² |||
                      if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                  4294967295#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 73.622549ms, solving context: 0.000000ms
LeanSAT proved the goal after 77.912580ms: rewriting 14.810460ms, bitblasting 0.000000ms, SAT solving 56.619950ms, LRAT trimming 0.000000ms, LRAT checking 3.766400ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:871:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:871:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:871:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:862:8: error: (kernel) declaration has metavariables 'and_not_or_or_not_or_xor_commute4_thm'
[bv] [0.049272] Normalizing goal
  [Meta.synthInstance] [0.001020] ✅️ Decidable
        ((if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some ((42#32).sdiv x✝ &&& ((x✝¹ ||| x✝²) ^^^ -1#32) ||| ((42#32).sdiv x✝ ||| x✝¹ ^^^ x✝²) ^^^ -1#32)) ⊑
          if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else some ((x✝¹ ||| x✝²) &&& ((42#32).sdiv x✝ ||| x✝¹ ^^^ x✝²) ^^^ -1#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else
              if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
              else
                some ((42#32).sdiv x✝ &&& ((x✝¹ ||| x✝²) ^^^ -1#32) ||| ((42#32).sdiv x✝ ||| x✝¹ ^^^ x✝²) ^^^ -1#32)) ⊑
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some ((x✝¹ ||| x✝²) &&& ((42#32).sdiv x✝ ||| x✝¹ ^^^ x✝²) ^^^ -1#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
              else
                some
                  ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                      ((x✝¹ ||| x✝²) ^^^ 4294967295#32) |||
                    ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                        x✝¹ ^^^ x✝²) ^^^
                      4294967295#32)) ⊑
            if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              some
                ((x✝¹ ||| x✝²) &&&
                    ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                      x✝¹ ^^^ x✝²) ^^^
                  4294967295#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 73.503319ms, solving context: 0.000000ms
LeanSAT proved the goal after 78.556270ms: rewriting 14.823080ms, bitblasting 0.000000ms, SAT solving 56.630380ms, LRAT trimming 0.000000ms, LRAT checking 4.347090ms
Bitwuzla proved the goal after 74.689679ms, solving context: 0.000000ms
LeanSAT proved the goal after 78.421940ms: rewriting 15.376900ms, bitblasting 0.000000ms, SAT solving 56.627280ms, LRAT trimming 0.000000ms, LRAT checking 3.957170ms
Bitwuzla proved the goal after 74.225709ms, solving context: 0.000000ms
LeanSAT proved the goal after 78.444110ms: rewriting 15.375250ms, bitblasting 0.000000ms, SAT solving 56.703600ms, LRAT trimming 0.000000ms, LRAT checking 3.944770ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:920:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:920:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:920:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:911:8: error: (kernel) declaration has metavariables 'or_not_and_and_not_and_xor_commute2_thm'
[bv] [0.052923] Normalizing goal
  [Meta.synthInstance] [0.001050] ✅️ Decidable
        ((if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some (((42#32).sdiv x✝ ||| x✝¹ &&& x✝² ^^^ -1#32) &&& ((x✝¹ ^^^ x✝²) &&& (42#32).sdiv x✝ ^^^ -1#32))) ⊑
          if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some ((x✝¹ ^^^ x✝²) &&& (42#32).sdiv x✝ ^^^ ((42#32).sdiv x✝ ||| x✝¹ &&& x✝² ^^^ -1#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else
              if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
              else
                some (((42#32).sdiv x✝ ||| x✝¹ &&& x✝² ^^^ -1#32) &&& ((x✝¹ ^^^ x✝²) &&& (42#32).sdiv x✝ ^^^ -1#32))) ⊑
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else
              if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
              else some ((x✝¹ ^^^ x✝²) &&& (42#32).sdiv x✝ ^^^ ((42#32).sdiv x✝ ||| x✝¹ &&& x✝² ^^^ -1#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
              else
                some
                  (((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                      x✝¹ &&& x✝² ^^^ 4294967295#32) &&&
                    (((x✝¹ ^^^ x✝²) &&&
                        if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                      4294967295#32))) ⊑
            if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
              else
                some
                  (((x✝¹ ^^^ x✝²) &&&
                      if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                    ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                      x✝¹ &&& x✝² ^^^ 4294967295#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 74.437950ms, solving context: 0.000000ms
LeanSAT proved the goal after 78.096389ms: rewriting 15.296020ms, bitblasting 0.000000ms, SAT solving 56.746599ms, LRAT trimming 0.000000ms, LRAT checking 3.582920ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:945:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:936:8: error: (kernel) declaration has metavariables 'or_not_and_and_not_and_xor_commute4_thm'
[bv] [0.054309] Normalizing goal
  [Meta.synthInstance] [0.001125] ✅️ Decidable
        ((if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some (((42#32).sdiv x✝ ||| x✝¹ &&& x✝² ^^^ -1#32) &&& ((42#32).sdiv x✝ &&& (x✝¹ ^^^ x✝²) ^^^ -1#32))) ⊑
          if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some ((42#32).sdiv x✝ &&& (x✝¹ ^^^ x✝²) ^^^ ((42#32).sdiv x✝ ||| x✝¹ &&& x✝² ^^^ -1#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else
              if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
              else
                some (((42#32).sdiv x✝ ||| x✝¹ &&& x✝² ^^^ -1#32) &&& ((42#32).sdiv x✝ &&& (x✝¹ ^^^ x✝²) ^^^ -1#32))) ⊑
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else
              if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
              else some ((42#32).sdiv x✝ &&& (x✝¹ ^^^ x✝²) ^^^ ((42#32).sdiv x✝ ||| x✝¹ &&& x✝² ^^^ -1#32))
      ⊢ False
  [Meta.isDefEq] [0.001183] ✅️ ?h₁ =?= congrArg (fun x => x = true)
        (Eq.trans
          (congrArg (fun x => x✝ == 0#32 || x && x✝ == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
          (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝ == 0#32) (42#32 == BitVec.intMin 32 && x✝ == 4294967295#32)))
    [Meta.isDefEq.assign] [0.001181] ✅️ ?h₁ := congrArg (fun x => x = true)
          (Eq.trans
            (congrArg (fun x => x✝ == 0#32 || x && x✝ == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
            (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝ == 0#32)
              (42#32 == BitVec.intMin 32 && x✝ == 4294967295#32)))
      [Meta.isDefEq.assign.checkTypes] [0.001170] ✅️ (?h₁ : ((x✝ == 0 ||
                32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) =
              true) =
            ((!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) =
              true)) := (congrArg (fun x => x = true)
            (Eq.trans
              (congrArg (fun x => x✝ == 0#32 || x && x✝ == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
              (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝ == 0#32)
                (42#32 == BitVec.intMin 32 &&
                  x✝ ==
                    4294967295#32))) : ((x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32) =
              true) =
            ((!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true))
        [Meta.isDefEq] [0.001166] ✅️ ((x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true) =
              ((!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) =
                true) =?= ((x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32) = true) =
              ((!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true)
          [Meta.isDefEq] [0.001149] ✅️ (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) =
                true =?= (x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32) = true
            [Meta.isDefEq] [0.001135] ✅️ x✝ == 0 ||
                  32 != 1 && 42#32 == BitVec.intMin 32 &&
                    x✝ == -1 =?= x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32
              [Meta.isDefEq.delta] [0.001121] ✅️ x✝ == 0 ||
                    32 != 1 && 42#32 == BitVec.intMin 32 &&
                      x✝ == -1 =?= x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
              else
                some
                  (((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                      x✝¹ &&& x✝² ^^^ 4294967295#32) &&&
                    ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                        (x✝¹ ^^^ x✝²) ^^^
                      4294967295#32))) ⊑
            if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
              else
                some
                  ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                      (x✝¹ ^^^ x✝²) ^^^
                    ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                      x✝¹ &&& x✝² ^^^ 4294967295#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 74.409199ms, solving context: 0.000000ms
LeanSAT proved the goal after 78.970730ms: rewriting 15.451780ms, bitblasting 0.000000ms, SAT solving 56.807040ms, LRAT trimming 0.000000ms, LRAT checking 4.225900ms
Bitwuzla proved the goal after 74.516110ms, solving context: 1.000000ms
LeanSAT proved the goal after 80.124099ms: rewriting 15.530800ms, bitblasting 0.000000ms, SAT solving 56.830389ms, LRAT trimming 0.000000ms, LRAT checking 4.761110ms
Bitwuzla proved the goal after 74.493659ms, solving context: 1.000000ms
LeanSAT proved the goal after 80.972770ms: rewriting 15.435800ms, bitblasting 0.000000ms, SAT solving 58.053530ms, LRAT trimming 0.000000ms, LRAT checking 4.501200ms
Bitwuzla proved the goal after 74.587830ms, solving context: 1.000000ms
LeanSAT proved the goal after 79.809169ms: rewriting 15.427330ms, bitblasting 0.000000ms, SAT solving 57.113939ms, LRAT trimming 0.000000ms, LRAT checking 4.369870ms
Bitwuzla proved the goal after 74.380589ms, solving context: 1.000000ms
LeanSAT proved the goal after 79.297340ms: rewriting 15.417440ms, bitblasting 0.000000ms, SAT solving 56.903010ms, LRAT trimming 0.000000ms, LRAT checking 4.030170ms
Bitwuzla proved the goal after 74.269730ms, solving context: 1.000000ms
LeanSAT proved the goal after 79.985579ms: rewriting 15.130450ms, bitblasting 0.000000ms, SAT solving 57.782710ms, LRAT trimming 0.000000ms, LRAT checking 4.369199ms
Bitwuzla proved the goal after 74.491399ms, solving context: 1.000000ms
LeanSAT proved the goal after 79.802880ms: rewriting 15.436250ms, bitblasting 0.000000ms, SAT solving 56.985200ms, LRAT trimming 0.000000ms, LRAT checking 4.468720ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1041:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1033:8: error: (kernel) declaration has metavariables 'not_and_and_or_not_or_or_commute2_thm'
[bv] [0.051052] Normalizing goal
  [Meta.synthInstance] [0.001104] ✅️ Decidable
        ((if (x✝² == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝² == -1) = true then none
          else
            if (x✝² == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝² == -1) = true then none
            else some ((x✝ ^^^ -1#32) &&& x✝¹ &&& (42#32).sdiv x✝² ||| ((42#32).sdiv x✝² ||| (x✝¹ ||| x✝)) ^^^ -1#32)) ⊑
          if (x✝² == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝² == -1) = true then none
          else some (((42#32).sdiv x✝² ^^^ x✝¹ ||| x✝) ^^^ -1#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝² == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝² == -1) = true then none
            else
              if (x✝² == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝² == -1) = true then none
              else
                some ((x✝ ^^^ -1#32) &&& x✝¹ &&& (42#32).sdiv x✝² ||| ((42#32).sdiv x✝² ||| (x✝¹ ||| x✝)) ^^^ -1#32)) ⊑
            if (x✝² == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝² == -1) = true then none
            else some (((42#32).sdiv x✝² ^^^ x✝¹ ||| x✝) ^^^ -1#32)
      ⊢ False
  [Meta.isDefEq] [0.001253] ✅️ ?h₁ =?= congrArg (fun x => x = true)
        (Eq.trans
          (congrArg (fun x => x✝² == 0#32 || x && x✝² == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
          (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝² == 0#32)
            (42#32 == BitVec.intMin 32 && x✝² == 4294967295#32)))
    [Meta.isDefEq.assign] [0.001250] ✅️ ?h₁ := congrArg (fun x => x = true)
          (Eq.trans
            (congrArg (fun x => x✝² == 0#32 || x && x✝² == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
            (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝² == 0#32)
              (42#32 == BitVec.intMin 32 && x✝² == 4294967295#32)))
      [Meta.isDefEq.assign.checkTypes] [0.001240] ✅️ (?h₁ : ((x✝² == 0 ||
                32 != 1 && 42#32 == BitVec.intMin 32 && x✝² == -1) =
              true) =
            ((!(!x✝² == 0#32 && !(42#32 == BitVec.intMin 32 && x✝² == 4294967295#32))) =
              true)) := (congrArg (fun x => x = true)
            (Eq.trans
              (congrArg (fun x => x✝² == 0#32 || x && x✝² == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
              (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝² == 0#32)
                (42#32 == BitVec.intMin 32 &&
                  x✝² ==
                    4294967295#32))) : ((x✝² == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝² == 4294967295#32) =
              true) =
            ((!(!x✝² == 0#32 && !(42#32 == BitVec.intMin 32 && x✝² == 4294967295#32))) = true))
        [Meta.isDefEq] [0.001236] ✅️ ((x✝² == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝² == -1) = true) =
              ((!(!x✝² == 0#32 && !(42#32 == BitVec.intMin 32 && x✝² == 4294967295#32))) =
                true) =?= ((x✝² == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝² == 4294967295#32) = true) =
              ((!(!x✝² == 0#32 && !(42#32 == BitVec.intMin 32 && x✝² == 4294967295#32))) = true)
          [Meta.isDefEq] [0.001219] ✅️ (x✝² == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝² == -1) =
                true =?= (x✝² == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝² == 4294967295#32) = true
            [Meta.isDefEq] [0.001206] ✅️ x✝² == 0 ||
                  32 != 1 && 42#32 == BitVec.intMin 32 &&
                    x✝² == -1 =?= x✝² == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝² == 4294967295#32
              [Meta.isDefEq.delta] [0.001190] ✅️ x✝² == 0 ||
                    32 != 1 && 42#32 == BitVec.intMin 32 &&
                      x✝² == -1 =?= x✝² == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝² == 4294967295#32
  [Meta.isDefEq] [0.001040] ✅️ ?h₃ =?= fun a =>
        congrArg some
          (congr
            (congrArg (fun x => HOr.hOr ((x✝ ^^^ 4294967295#32) &&& x✝¹ &&& x))
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝²)
                (Eq.trans
                  (ite_cond_eq_false (if x✝².msb = true then -42#32 / -x✝² else -(-42#32 / x✝²))
                    (if x✝².msb = true then -(42#32 / -x✝²) else 42#32 / x✝²)
                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                      (eq_false' fun h => Bool.noConfusion h)))
                  (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝²))
                    (fun a =>
                      Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝²))
                        (BitVec.neg_eq_not_add (42#32 / (~~~x✝² + 1#32))))
                    fun a => Eq.refl (42#32 / x✝²)))))
            (congrArg (fun x => (x ||| (x✝¹ ||| x✝)) ^^^ 4294967295#32)
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝²)
                (Eq.trans
                  (ite_cond_eq_false (if x✝².msb = true then -42#32 / -x✝² else -(-42#32 / x✝²))
                    (if x✝².msb = true then -(42#32 / -x✝²) else 42#32 / x✝²)
                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                      (eq_false' fun h => Bool.noConfusion h)))
                  (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝²))
                    (fun a =>
                      Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝²))
                        (BitVec.neg_eq_not_add (42#32 / (~~~x✝² + 1#32))))
                    fun a => Eq.refl (42#32 / x✝²))))))
    [Meta.isDefEq.assign] [0.001036] ✅️ ?h₃ := fun a =>
          congrArg some
            (congr
              (congrArg (fun x => HOr.hOr ((x✝ ^^^ 4294967295#32) &&& x✝¹ &&& x))
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝²)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝².msb = true then -42#32 / -x✝² else -(-42#32 / x✝²))
                      (if x✝².msb = true then -(42#32 / -x✝²) else 42#32 / x✝²)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝²))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝²))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝² + 1#32))))
                      fun a => Eq.refl (42#32 / x✝²)))))
              (congrArg (fun x => (x ||| (x✝¹ ||| x✝)) ^^^ 4294967295#32)
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝²)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝².msb = true then -42#32 / -x✝² else -(-42#32 / x✝²))
                      (if x✝².msb = true then -(42#32 / -x✝²) else 42#32 / x✝²)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝²))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝²))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝² + 1#32))))
                      fun a => Eq.refl (42#32 / x✝²))))))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!(!x✝² == 0#32 && !(42#32 == BitVec.intMin 32 && x✝² == 4294967295#32))) = true then none
            else
              if (!(!x✝² == 0#32 && !(42#32 == BitVec.intMin 32 && x✝² == 4294967295#32))) = true then none
              else
                some
                  (((x✝ ^^^ 4294967295#32) &&& x✝¹ &&&
                      if x✝².getLsbD 31 = true then ~~~(42#32 / (~~~x✝² + 1#32)) + 1#32 else 42#32 / x✝²) |||
                    ((if x✝².getLsbD 31 = true then ~~~(42#32 / (~~~x✝² + 1#32)) + 1#32 else 42#32 / x✝²) |||
                        (x✝¹ ||| x✝)) ^^^
                      4294967295#32)) ⊑
            if (!(!x✝² == 0#32 && !(42#32 == BitVec.intMin 32 && x✝² == 4294967295#32))) = true then none
            else
              some
                (((if x✝².getLsbD 31 = true then ~~~(42#32 / (~~~x✝² + 1#32)) + 1#32 else 42#32 / x✝²) ^^^ x✝¹ |||
                    x✝) ^^^
                  4294967295#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1053:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1053:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1045:8: error: (kernel) declaration has metavariables 'not_and_and_or_not_or_or_commute3_thm'
[bv] [0.051354] Normalizing goal
  [Meta.synthInstance] [0.001015] ✅️ Decidable
        ((if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some ((42#32).sdiv x✝ &&& (x✝¹ ^^^ -1#32) &&& x✝² ||| ((42#32).sdiv x✝ ||| x✝¹ ||| x✝²) ^^^ -1#32)) ⊑
          if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else some ((x✝² ^^^ (42#32).sdiv x✝ ||| x✝¹) ^^^ -1#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else
              if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
              else some ((42#32).sdiv x✝ &&& (x✝¹ ^^^ -1#32) &&& x✝² ||| ((42#32).sdiv x✝ ||| x✝¹ ||| x✝²) ^^^ -1#32)) ⊑
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some ((x✝² ^^^ (42#32).sdiv x✝ ||| x✝¹) ^^^ -1#32)
      ⊢ False
  [Meta.isDefEq] [0.001085] ✅️ ?h₃ =?= fun a =>
        congrArg some
          (congr
            (congrArg (fun x => HOr.hOr (x &&& (x✝¹ ^^^ 4294967295#32) &&& x✝²))
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                (Eq.trans
                  (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                    (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                      (eq_false' fun h => Bool.noConfusion h)))
                  (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                    (fun a =>
                      Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                        (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                    fun a => Eq.refl (42#32 / x✝)))))
            (congrArg (fun x => (x ||| x✝¹ ||| x✝²) ^^^ 4294967295#32)
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                (Eq.trans
                  (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                    (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                      (eq_false' fun h => Bool.noConfusion h)))
                  (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                    (fun a =>
                      Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                        (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                    fun a => Eq.refl (42#32 / x✝))))))
    [Meta.isDefEq.assign] [0.001082] ✅️ ?h₃ := fun a =>
          congrArg some
            (congr
              (congrArg (fun x => HOr.hOr (x &&& (x✝¹ ^^^ 4294967295#32) &&& x✝²))
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                      (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                      fun a => Eq.refl (42#32 / x✝)))))
              (congrArg (fun x => (x ||| x✝¹ ||| x✝²) ^^^ 4294967295#32)
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                      (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                      fun a => Eq.refl (42#32 / x✝))))))
      [Meta.isDefEq.assign.checkTypes] [0.001007] ✅️ (?h₃ : ¬(!(!x✝ == 0#32 &&
                    !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) =
                true →
            some ((42#32).sdiv x✝ &&& (x✝¹ ^^^ -1#32) &&& x✝² ||| ((42#32).sdiv x✝ ||| x✝¹ ||| x✝²) ^^^ -1#32) =
              some
                ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                      (x✝¹ ^^^ 4294967295#32) &&&
                    x✝² |||
                  ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ||| x✝¹ |||
                      x✝²) ^^^
                    4294967295#32)) := (fun a =>
            congrArg some
              (congr
                (congrArg (fun x => HOr.hOr (x &&& (x✝¹ ^^^ 4294967295#32) &&& x✝²))
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                        (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                        fun a => Eq.refl (42#32 / x✝)))))
                (congrArg (fun x => (x ||| x✝¹ ||| x✝²) ^^^ 4294967295#32)
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                        (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                        fun a =>
                        Eq.refl
                          (42#32 /
                            x✝)))))) : ¬(!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true →
            some
                ((42#32).sdiv x✝ &&& (x✝¹ ^^^ 4294967295#32) &&& x✝² |||
                  ((42#32).sdiv x✝ ||| x✝¹ ||| x✝²) ^^^ 4294967295#32) =
              some
                ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                      (x✝¹ ^^^ 4294967295#32) &&&
                    x✝² |||
                  ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ||| x✝¹ |||
                      x✝²) ^^^
                    4294967295#32))
        [Meta.isDefEq] [0.001002] ✅️ ¬(!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true →
              some ((42#32).sdiv x✝ &&& (x✝¹ ^^^ -1#32) &&& x✝² ||| ((42#32).sdiv x✝ ||| x✝¹ ||| x✝²) ^^^ -1#32) =
                some
                  ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                        (x✝¹ ^^^ 4294967295#32) &&&
                      x✝² |||
                    ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ||| x✝¹ |||
                        x✝²) ^^^
                      4294967295#32) =?= ¬(!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) =
                  true →
              some
                  ((42#32).sdiv x✝ &&& (x✝¹ ^^^ 4294967295#32) &&& x✝² |||
                    ((42#32).sdiv x✝ ||| x✝¹ ||| x✝²) ^^^ 4294967295#32) =
                some
                  ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                        (x✝¹ ^^^ 4294967295#32) &&&
                      x✝² |||
                    ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ||| x✝¹ |||
                        x✝²) ^^^
                      4294967295#32)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
              else
                some
                  ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                        (x✝¹ ^^^ 4294967295#32) &&&
                      x✝² |||
                    ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ||| x✝¹ |||
                        x✝²) ^^^
                      4294967295#32)) ⊑
            if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              some
                (((x✝² ^^^ if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ||| x✝¹) ^^^
                  4294967295#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1065:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1057:8: error: (kernel) declaration has metavariables 'not_and_and_or_not_or_or_commute4_thm'
[bv] [0.051328] Normalizing goal
  [Meta.synthInstance] [0.001126] ✅️ Decidable
        ((if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some ((42#32).sdiv x✝ &&& ((x✝¹ ^^^ -1#32) &&& x✝²) ||| (x✝² ||| x✝¹ ||| (42#32).sdiv x✝) ^^^ -1#32)) ⊑
          if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else some (((42#32).sdiv x✝ ^^^ x✝² ||| x✝¹) ^^^ -1#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else
              if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
              else
                some ((42#32).sdiv x✝ &&& ((x✝¹ ^^^ -1#32) &&& x✝²) ||| (x✝² ||| x✝¹ ||| (42#32).sdiv x✝) ^^^ -1#32)) ⊑
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some (((42#32).sdiv x✝ ^^^ x✝² ||| x✝¹) ^^^ -1#32)
      ⊢ False
  [Meta.isDefEq] [0.001174] ✅️ ?h₁ =?= congrArg (fun x => x = true)
        (Eq.trans
          (congrArg (fun x => x✝ == 0#32 || x && x✝ == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
          (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝ == 0#32) (42#32 == BitVec.intMin 32 && x✝ == 4294967295#32)))
    [Meta.isDefEq.assign] [0.001172] ✅️ ?h₁ := congrArg (fun x => x = true)
          (Eq.trans
            (congrArg (fun x => x✝ == 0#32 || x && x✝ == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
            (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝ == 0#32)
              (42#32 == BitVec.intMin 32 && x✝ == 4294967295#32)))
      [Meta.isDefEq.assign.checkTypes] [0.001161] ✅️ (?h₁ : ((x✝ == 0 ||
                32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) =
              true) =
            ((!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) =
              true)) := (congrArg (fun x => x = true)
            (Eq.trans
              (congrArg (fun x => x✝ == 0#32 || x && x✝ == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
              (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝ == 0#32)
                (42#32 == BitVec.intMin 32 &&
                  x✝ ==
                    4294967295#32))) : ((x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32) =
              true) =
            ((!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true))
        [Meta.isDefEq] [0.001158] ✅️ ((x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true) =
              ((!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) =
                true) =?= ((x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32) = true) =
              ((!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true)
          [Meta.isDefEq] [0.001140] ✅️ (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) =
                true =?= (x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32) = true
            [Meta.isDefEq] [0.001127] ✅️ x✝ == 0 ||
                  32 != 1 && 42#32 == BitVec.intMin 32 &&
                    x✝ == -1 =?= x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32
              [Meta.isDefEq.delta] [0.001111] ✅️ x✝ == 0 ||
                    32 != 1 && 42#32 == BitVec.intMin 32 &&
                      x✝ == -1 =?= x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32
  [Meta.isDefEq] [0.001052] ✅️ ?h₃ =?= fun a =>
        congrArg some
          (congr
            (congrArg (fun x => HOr.hOr (x &&& ((x✝¹ ^^^ 4294967295#32) &&& x✝²)))
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                (Eq.trans
                  (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                    (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                      (eq_false' fun h => Bool.noConfusion h)))
                  (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                    (fun a =>
                      Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                        (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                    fun a => Eq.refl (42#32 / x✝)))))
            (congrArg (fun x => (x✝² ||| x✝¹ ||| x) ^^^ 4294967295#32)
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                (Eq.trans
                  (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                    (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                      (eq_false' fun h => Bool.noConfusion h)))
                  (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                    (fun a =>
                      Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                        (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                    fun a => Eq.refl (42#32 / x✝))))))
    [Meta.isDefEq.assign] [0.001047] ✅️ ?h₃ := fun a =>
          congrArg some
            (congr
              (congrArg (fun x => HOr.hOr (x &&& ((x✝¹ ^^^ 4294967295#32) &&& x✝²)))
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                      (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                      fun a => Eq.refl (42#32 / x✝)))))
              (congrArg (fun x => (x✝² ||| x✝¹ ||| x) ^^^ 4294967295#32)
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                      (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                      fun a => Eq.refl (42#32 / x✝))))))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
              else
                some
                  ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                      ((x✝¹ ^^^ 4294967295#32) &&& x✝²) |||
                    (x✝² ||| x✝¹ |||
                        if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                      4294967295#32)) ⊑
            if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              some
                (((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^ x✝² ||| x✝¹) ^^^
                  4294967295#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 74.407259ms, solving context: 1.000000ms
LeanSAT proved the goal after 79.483790ms: rewriting 15.119370ms, bitblasting 0.000000ms, SAT solving 57.135780ms, LRAT trimming 0.000000ms, LRAT checking 4.378980ms
Bitwuzla proved the goal after 74.902120ms, solving context: 1.000000ms
LeanSAT proved the goal after 80.619299ms: rewriting 15.217580ms, bitblasting 0.000000ms, SAT solving 58.368630ms, LRAT trimming 0.000000ms, LRAT checking 4.245611ms
Bitwuzla proved the goal after 74.350179ms, solving context: 1.000000ms
LeanSAT proved the goal after 79.289010ms: rewriting 15.277630ms, bitblasting 0.000000ms, SAT solving 57.084940ms, LRAT trimming 0.000000ms, LRAT checking 4.144860ms
Bitwuzla proved the goal after 74.324210ms, solving context: 1.000000ms
LeanSAT proved the goal after 78.953509ms: rewriting 15.200220ms, bitblasting 0.000000ms, SAT solving 57.170349ms, LRAT trimming 0.000000ms, LRAT checking 3.843059ms
Bitwuzla proved the goal after 74.382250ms, solving context: 1.000000ms
LeanSAT proved the goal after 80.268509ms: rewriting 14.981619ms, bitblasting 0.000000ms, SAT solving 58.216380ms, LRAT trimming 0.000000ms, LRAT checking 4.335700ms
Bitwuzla proved the goal after 74.485859ms, solving context: 1.000000ms
LeanSAT proved the goal after 79.464090ms: rewriting 15.180460ms, bitblasting 0.000000ms, SAT solving 57.313340ms, LRAT trimming 0.000000ms, LRAT checking 4.200680ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1149:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1141:8: error: (kernel) declaration has metavariables 'not_or_or_and_not_and_and_commute2_thm'
[bv] [0.050950] Normalizing goal
  [Meta.synthInstance] [0.001084] ✅️ Decidable
        ((if (x✝² == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝² == -1) = true then none
          else
            if (x✝² == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝² == -1) = true then none
            else some ((x✝ ^^^ -1#32 ||| x✝¹ ||| (42#32).sdiv x✝²) &&& ((42#32).sdiv x✝² &&& (x✝¹ &&& x✝) ^^^ -1#32))) ⊑
          if (x✝² == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝² == -1) = true then none
          else some ((42#32).sdiv x✝² ^^^ x✝¹ ||| x✝ ^^^ -1#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝² == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝² == -1) = true then none
            else
              if (x✝² == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝² == -1) = true then none
              else
                some ((x✝ ^^^ -1#32 ||| x✝¹ ||| (42#32).sdiv x✝²) &&& ((42#32).sdiv x✝² &&& (x✝¹ &&& x✝) ^^^ -1#32))) ⊑
            if (x✝² == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝² == -1) = true then none
            else some ((42#32).sdiv x✝² ^^^ x✝¹ ||| x✝ ^^^ -1#32)
      ⊢ False
  [Meta.isDefEq] [0.001262] ✅️ ?h₁ =?= congrArg (fun x => x = true)
        (Eq.trans
          (congrArg (fun x => x✝² == 0#32 || x && x✝² == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
          (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝² == 0#32)
            (42#32 == BitVec.intMin 32 && x✝² == 4294967295#32)))
    [Meta.isDefEq.assign] [0.001259] ✅️ ?h₁ := congrArg (fun x => x = true)
          (Eq.trans
            (congrArg (fun x => x✝² == 0#32 || x && x✝² == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
            (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝² == 0#32)
              (42#32 == BitVec.intMin 32 && x✝² == 4294967295#32)))
      [Meta.isDefEq.assign.checkTypes] [0.001242] ✅️ (?h₁ : ((x✝² == 0 ||
                32 != 1 && 42#32 == BitVec.intMin 32 && x✝² == -1) =
              true) =
            ((!(!x✝² == 0#32 && !(42#32 == BitVec.intMin 32 && x✝² == 4294967295#32))) =
              true)) := (congrArg (fun x => x = true)
            (Eq.trans
              (congrArg (fun x => x✝² == 0#32 || x && x✝² == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
              (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝² == 0#32)
                (42#32 == BitVec.intMin 32 &&
                  x✝² ==
                    4294967295#32))) : ((x✝² == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝² == 4294967295#32) =
              true) =
            ((!(!x✝² == 0#32 && !(42#32 == BitVec.intMin 32 && x✝² == 4294967295#32))) = true))
        [Meta.isDefEq] [0.001239] ✅️ ((x✝² == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝² == -1) = true) =
              ((!(!x✝² == 0#32 && !(42#32 == BitVec.intMin 32 && x✝² == 4294967295#32))) =
                true) =?= ((x✝² == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝² == 4294967295#32) = true) =
              ((!(!x✝² == 0#32 && !(42#32 == BitVec.intMin 32 && x✝² == 4294967295#32))) = true)
          [Meta.isDefEq] [0.001221] ✅️ (x✝² == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝² == -1) =
                true =?= (x✝² == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝² == 4294967295#32) = true
            [Meta.isDefEq] [0.001208] ✅️ x✝² == 0 ||
                  32 != 1 && 42#32 == BitVec.intMin 32 &&
                    x✝² == -1 =?= x✝² == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝² == 4294967295#32
              [Meta.isDefEq.delta] [0.001193] ✅️ x✝² == 0 ||
                    32 != 1 && 42#32 == BitVec.intMin 32 &&
                      x✝² == -1 =?= x✝² == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝² == 4294967295#32
  [Meta.isDefEq] [0.001039] ✅️ ?h₃ =?= fun a =>
        congrArg some
          (congr
            (congrArg (fun x => HAnd.hAnd (x✝ ^^^ 4294967295#32 ||| x✝¹ ||| x))
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝²)
                (Eq.trans
                  (ite_cond_eq_false (if x✝².msb = true then -42#32 / -x✝² else -(-42#32 / x✝²))
                    (if x✝².msb = true then -(42#32 / -x✝²) else 42#32 / x✝²)
                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                      (eq_false' fun h => Bool.noConfusion h)))
                  (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝²))
                    (fun a =>
                      Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝²))
                        (BitVec.neg_eq_not_add (42#32 / (~~~x✝² + 1#32))))
                    fun a => Eq.refl (42#32 / x✝²)))))
            (congrArg (fun x => x &&& (x✝¹ &&& x✝) ^^^ 4294967295#32)
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝²)
                (Eq.trans
                  (ite_cond_eq_false (if x✝².msb = true then -42#32 / -x✝² else -(-42#32 / x✝²))
                    (if x✝².msb = true then -(42#32 / -x✝²) else 42#32 / x✝²)
                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                      (eq_false' fun h => Bool.noConfusion h)))
                  (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝²))
                    (fun a =>
                      Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝²))
                        (BitVec.neg_eq_not_add (42#32 / (~~~x✝² + 1#32))))
                    fun a => Eq.refl (42#32 / x✝²))))))
    [Meta.isDefEq.assign] [0.001035] ✅️ ?h₃ := fun a =>
          congrArg some
            (congr
              (congrArg (fun x => HAnd.hAnd (x✝ ^^^ 4294967295#32 ||| x✝¹ ||| x))
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝²)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝².msb = true then -42#32 / -x✝² else -(-42#32 / x✝²))
                      (if x✝².msb = true then -(42#32 / -x✝²) else 42#32 / x✝²)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝²))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝²))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝² + 1#32))))
                      fun a => Eq.refl (42#32 / x✝²)))))
              (congrArg (fun x => x &&& (x✝¹ &&& x✝) ^^^ 4294967295#32)
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝²)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝².msb = true then -42#32 / -x✝² else -(-42#32 / x✝²))
                      (if x✝².msb = true then -(42#32 / -x✝²) else 42#32 / x✝²)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝²))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝²))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝² + 1#32))))
                      fun a => Eq.refl (42#32 / x✝²))))))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!(!x✝² == 0#32 && !(42#32 == BitVec.intMin 32 && x✝² == 4294967295#32))) = true then none
            else
              if (!(!x✝² == 0#32 && !(42#32 == BitVec.intMin 32 && x✝² == 4294967295#32))) = true then none
              else
                some
                  ((x✝ ^^^ 4294967295#32 ||| x✝¹ |||
                      if x✝².getLsbD 31 = true then ~~~(42#32 / (~~~x✝² + 1#32)) + 1#32 else 42#32 / x✝²) &&&
                    ((if x✝².getLsbD 31 = true then ~~~(42#32 / (~~~x✝² + 1#32)) + 1#32 else 42#32 / x✝²) &&&
                        (x✝¹ &&& x✝) ^^^
                      4294967295#32))) ⊑
            if (!(!x✝² == 0#32 && !(42#32 == BitVec.intMin 32 && x✝² == 4294967295#32))) = true then none
            else
              some
                ((if x✝².getLsbD 31 = true then ~~~(42#32 / (~~~x✝² + 1#32)) + 1#32 else 42#32 / x✝²) ^^^ x✝¹ |||
                  x✝ ^^^ 4294967295#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1161:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1161:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1153:8: error: (kernel) declaration has metavariables 'not_or_or_and_not_and_and_commute3_thm'
[bv] [0.050204] Normalizing goal
  [Meta.synthInstance] [0.001016] ✅️ Decidable
        ((if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some (((42#32).sdiv x✝ ||| x✝¹ ^^^ -1#32 ||| x✝²) &&& ((42#32).sdiv x✝ &&& x✝¹ &&& x✝² ^^^ -1#32))) ⊑
          if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else some (x✝² ^^^ (42#32).sdiv x✝ ||| x✝¹ ^^^ -1#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else
              if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
              else some (((42#32).sdiv x✝ ||| x✝¹ ^^^ -1#32 ||| x✝²) &&& ((42#32).sdiv x✝ &&& x✝¹ &&& x✝² ^^^ -1#32))) ⊑
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some (x✝² ^^^ (42#32).sdiv x✝ ||| x✝¹ ^^^ -1#32)
      ⊢ False
  [Meta.isDefEq] [0.001069] ✅️ ?h₃ =?= fun a =>
        congrArg some
          (congr
            (congrArg (fun x => HAnd.hAnd (x ||| x✝¹ ^^^ 4294967295#32 ||| x✝²))
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                (Eq.trans
                  (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                    (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                      (eq_false' fun h => Bool.noConfusion h)))
                  (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                    (fun a =>
                      Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                        (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                    fun a => Eq.refl (42#32 / x✝)))))
            (congrArg (fun x => x &&& x✝¹ &&& x✝² ^^^ 4294967295#32)
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                (Eq.trans
                  (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                    (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                      (eq_false' fun h => Bool.noConfusion h)))
                  (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                    (fun a =>
                      Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                        (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                    fun a => Eq.refl (42#32 / x✝))))))
    [Meta.isDefEq.assign] [0.001066] ✅️ ?h₃ := fun a =>
          congrArg some
            (congr
              (congrArg (fun x => HAnd.hAnd (x ||| x✝¹ ^^^ 4294967295#32 ||| x✝²))
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                      (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                      fun a => Eq.refl (42#32 / x✝)))))
              (congrArg (fun x => x &&& x✝¹ &&& x✝² ^^^ 4294967295#32)
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                      (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                      fun a => Eq.refl (42#32 / x✝))))))
      [Meta.isDefEq.assign.checkTypes] [0.001013] ✅️ (?h₃ : ¬(!(!x✝ == 0#32 &&
                    !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) =
                true →
            some (((42#32).sdiv x✝ ||| x✝¹ ^^^ -1#32 ||| x✝²) &&& ((42#32).sdiv x✝ &&& x✝¹ &&& x✝² ^^^ -1#32)) =
              some
                (((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                      x✝¹ ^^^ 4294967295#32 |||
                    x✝²) &&&
                  ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&& x✝¹ &&& x✝² ^^^
                    4294967295#32))) := (fun a =>
            congrArg some
              (congr
                (congrArg (fun x => HAnd.hAnd (x ||| x✝¹ ^^^ 4294967295#32 ||| x✝²))
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                        (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                        fun a => Eq.refl (42#32 / x✝)))))
                (congrArg (fun x => x &&& x✝¹ &&& x✝² ^^^ 4294967295#32)
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                    (Eq.trans
                      (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                        (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                        (fun a =>
                          Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                            (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                        fun a =>
                        Eq.refl
                          (42#32 /
                            x✝)))))) : ¬(!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true →
            some
                (((42#32).sdiv x✝ ||| x✝¹ ^^^ 4294967295#32 ||| x✝²) &&&
                  ((42#32).sdiv x✝ &&& x✝¹ &&& x✝² ^^^ 4294967295#32)) =
              some
                (((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                      x✝¹ ^^^ 4294967295#32 |||
                    x✝²) &&&
                  ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&& x✝¹ &&& x✝² ^^^
                    4294967295#32)))
        [Meta.isDefEq] [0.001008] ✅️ ¬(!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true →
              some (((42#32).sdiv x✝ ||| x✝¹ ^^^ -1#32 ||| x✝²) &&& ((42#32).sdiv x✝ &&& x✝¹ &&& x✝² ^^^ -1#32)) =
                some
                  (((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                        x✝¹ ^^^ 4294967295#32 |||
                      x✝²) &&&
                    ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&& x✝¹ &&&
                        x✝² ^^^
                      4294967295#32)) =?= ¬(!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) =
                  true →
              some
                  (((42#32).sdiv x✝ ||| x✝¹ ^^^ 4294967295#32 ||| x✝²) &&&
                    ((42#32).sdiv x✝ &&& x✝¹ &&& x✝² ^^^ 4294967295#32)) =
                some
                  (((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                        x✝¹ ^^^ 4294967295#32 |||
                      x✝²) &&&
                    ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&& x✝¹ &&&
                        x✝² ^^^
                      4294967295#32))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
              else
                some
                  (((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                        x✝¹ ^^^ 4294967295#32 |||
                      x✝²) &&&
                    ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&& x✝¹ &&&
                        x✝² ^^^
                      4294967295#32))) ⊑
            if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              some
                ((x✝² ^^^ if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                  x✝¹ ^^^ 4294967295#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1173:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1165:8: error: (kernel) declaration has metavariables 'not_or_or_and_not_and_and_commute4_thm'
[bv] [0.051269] Normalizing goal
  [Meta.synthInstance] [0.001123] ✅️ Decidable
        ((if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some (((42#32).sdiv x✝ ||| (x✝¹ ^^^ -1#32 ||| x✝²)) &&& (x✝² &&& x✝¹ &&& (42#32).sdiv x✝ ^^^ -1#32))) ⊑
          if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else some ((42#32).sdiv x✝ ^^^ x✝² ||| x✝¹ ^^^ -1#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else
              if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
              else
                some (((42#32).sdiv x✝ ||| (x✝¹ ^^^ -1#32 ||| x✝²)) &&& (x✝² &&& x✝¹ &&& (42#32).sdiv x✝ ^^^ -1#32))) ⊑
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some ((42#32).sdiv x✝ ^^^ x✝² ||| x✝¹ ^^^ -1#32)
      ⊢ False
  [Meta.isDefEq] [0.001194] ✅️ ?h₁ =?= congrArg (fun x => x = true)
        (Eq.trans
          (congrArg (fun x => x✝ == 0#32 || x && x✝ == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
          (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝ == 0#32) (42#32 == BitVec.intMin 32 && x✝ == 4294967295#32)))
    [Meta.isDefEq.assign] [0.001192] ✅️ ?h₁ := congrArg (fun x => x = true)
          (Eq.trans
            (congrArg (fun x => x✝ == 0#32 || x && x✝ == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
            (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝ == 0#32)
              (42#32 == BitVec.intMin 32 && x✝ == 4294967295#32)))
      [Meta.isDefEq.assign.checkTypes] [0.001181] ✅️ (?h₁ : ((x✝ == 0 ||
                32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) =
              true) =
            ((!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) =
              true)) := (congrArg (fun x => x = true)
            (Eq.trans
              (congrArg (fun x => x✝ == 0#32 || x && x✝ == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
              (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝ == 0#32)
                (42#32 == BitVec.intMin 32 &&
                  x✝ ==
                    4294967295#32))) : ((x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32) =
              true) =
            ((!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true))
        [Meta.isDefEq] [0.001177] ✅️ ((x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true) =
              ((!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) =
                true) =?= ((x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32) = true) =
              ((!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true)
          [Meta.isDefEq] [0.001160] ✅️ (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) =
                true =?= (x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32) = true
            [Meta.isDefEq] [0.001146] ✅️ x✝ == 0 ||
                  32 != 1 && 42#32 == BitVec.intMin 32 &&
                    x✝ == -1 =?= x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32
              [Meta.isDefEq.delta] [0.001131] ✅️ x✝ == 0 ||
                    32 != 1 && 42#32 == BitVec.intMin 32 &&
                      x✝ == -1 =?= x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32
  [Meta.isDefEq] [0.001034] ✅️ ?h₃ =?= fun a =>
        congrArg some
          (congr
            (congrArg (fun x => HAnd.hAnd (x ||| (x✝¹ ^^^ 4294967295#32 ||| x✝²)))
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                (Eq.trans
                  (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                    (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                      (eq_false' fun h => Bool.noConfusion h)))
                  (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                    (fun a =>
                      Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                        (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                    fun a => Eq.refl (42#32 / x✝)))))
            (congrArg (fun x => x✝² &&& x✝¹ &&& x ^^^ 4294967295#32)
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                (Eq.trans
                  (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                    (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                      (eq_false' fun h => Bool.noConfusion h)))
                  (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                    (fun a =>
                      Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                        (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                    fun a => Eq.refl (42#32 / x✝))))))
    [Meta.isDefEq.assign] [0.001030] ✅️ ?h₃ := fun a =>
          congrArg some
            (congr
              (congrArg (fun x => HAnd.hAnd (x ||| (x✝¹ ^^^ 4294967295#32 ||| x✝²)))
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                      (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                      fun a => Eq.refl (42#32 / x✝)))))
              (congrArg (fun x => x✝² &&& x✝¹ &&& x ^^^ 4294967295#32)
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                      (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                      fun a => Eq.refl (42#32 / x✝))))))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
              else
                some
                  (((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                      (x✝¹ ^^^ 4294967295#32 ||| x✝²)) &&&
                    ((x✝² &&& x✝¹ &&&
                        if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                      4294967295#32))) ⊑
            if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              some
                ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^ x✝² |||
                  x✝¹ ^^^ 4294967295#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 75.545649ms, solving context: 1.000000ms
LeanSAT proved the goal after 81.441270ms: rewriting 16.029020ms, bitblasting 0.000000ms, SAT solving 58.375190ms, LRAT trimming 0.000000ms, LRAT checking 4.307460ms
Bitwuzla proved the goal after 75.261649ms, solving context: 1.000000ms
LeanSAT proved the goal after 79.554950ms: rewriting 15.723630ms, bitblasting 0.000000ms, SAT solving 57.391810ms, LRAT trimming 0.000000ms, LRAT checking 3.895780ms
Bitwuzla proved the goal after 75.342879ms, solving context: 1.000000ms
LeanSAT proved the goal after 79.975270ms: rewriting 15.950200ms, bitblasting 0.000000ms, SAT solving 57.321410ms, LRAT trimming 0.000000ms, LRAT checking 4.038790ms
Bitwuzla proved the goal after 75.346600ms, solving context: 1.000000ms
LeanSAT proved the goal after 80.095999ms: rewriting 16.008940ms, bitblasting 0.000000ms, SAT solving 57.282879ms, LRAT trimming 0.000000ms, LRAT checking 4.066810ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1230:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1230:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1221:8: error: (kernel) declaration has metavariables 'not_and_and_or_no_or_commute2_thm'
[bv] [0.050448] Normalizing goal
  [Meta.synthInstance] [0.001033] ✅️ Decidable
        ((if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some ((42#32).sdiv x✝ &&& (x✝¹ ^^^ -1#32) &&& x✝² ||| ((42#32).sdiv x✝ ||| x✝¹) ^^^ -1#32)) ⊑
          if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else some ((x✝² ||| (42#32).sdiv x✝ ^^^ -1#32) &&& (x✝¹ ^^^ -1#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else
              if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
              else some ((42#32).sdiv x✝ &&& (x✝¹ ^^^ -1#32) &&& x✝² ||| ((42#32).sdiv x✝ ||| x✝¹) ^^^ -1#32)) ⊑
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some ((x✝² ||| (42#32).sdiv x✝ ^^^ -1#32) &&& (x✝¹ ^^^ -1#32))
      ⊢ False
  [Meta.isDefEq] [0.001045] ✅️ ?h₃ =?= fun a =>
        congrArg some
          (congr
            (congrArg (fun x => HOr.hOr (x &&& (x✝¹ ^^^ 4294967295#32) &&& x✝²))
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                (Eq.trans
                  (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                    (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                      (eq_false' fun h => Bool.noConfusion h)))
                  (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                    (fun a =>
                      Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                        (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                    fun a => Eq.refl (42#32 / x✝)))))
            (congrArg (fun x => (x ||| x✝¹) ^^^ 4294967295#32)
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                (Eq.trans
                  (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                    (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                      (eq_false' fun h => Bool.noConfusion h)))
                  (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                    (fun a =>
                      Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                        (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                    fun a => Eq.refl (42#32 / x✝))))))
    [Meta.isDefEq.assign] [0.001040] ✅️ ?h₃ := fun a =>
          congrArg some
            (congr
              (congrArg (fun x => HOr.hOr (x &&& (x✝¹ ^^^ 4294967295#32) &&& x✝²))
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                      (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                      fun a => Eq.refl (42#32 / x✝)))))
              (congrArg (fun x => (x ||| x✝¹) ^^^ 4294967295#32)
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                      (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                      fun a => Eq.refl (42#32 / x✝))))))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
              else
                some
                  ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                        (x✝¹ ^^^ 4294967295#32) &&&
                      x✝² |||
                    ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ||| x✝¹) ^^^
                      4294967295#32)) ⊑
            if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              some
                ((x✝² |||
                    (if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                      4294967295#32) &&&
                  (x✝¹ ^^^ 4294967295#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1243:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1234:8: error: (kernel) declaration has metavariables 'not_and_and_or_no_or_commute3_thm'
[bv] [0.047739] Normalizing goal
  [Meta.synthInstance] [0.001158] ✅️ Decidable
        ((if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else some ((42#32).sdiv x✝ &&& ((x✝¹ ^^^ -1#32) &&& x✝²) ||| (x✝² ||| x✝¹) ^^^ -1#32)) ⊑
          if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else some (((42#32).sdiv x✝ ||| x✝² ^^^ -1#32) &&& (x✝¹ ^^^ -1#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some ((42#32).sdiv x✝ &&& ((x✝¹ ^^^ -1#32) &&& x✝²) ||| (x✝² ||| x✝¹) ^^^ -1#32)) ⊑
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some (((42#32).sdiv x✝ ||| x✝² ^^^ -1#32) &&& (x✝¹ ^^^ -1#32))
      ⊢ False
  [Meta.isDefEq] [0.001267] ✅️ ?h₁ =?= congrArg (fun x => x = true)
        (Eq.trans
          (congrArg (fun x => x✝ == 0#32 || x && x✝ == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
          (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝ == 0#32) (42#32 == BitVec.intMin 32 && x✝ == 4294967295#32)))
    [Meta.isDefEq.assign] [0.001264] ✅️ ?h₁ := congrArg (fun x => x = true)
          (Eq.trans
            (congrArg (fun x => x✝ == 0#32 || x && x✝ == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
            (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝ == 0#32)
              (42#32 == BitVec.intMin 32 && x✝ == 4294967295#32)))
      [Meta.isDefEq.assign.checkTypes] [0.001254] ✅️ (?h₁ : ((x✝ == 0 ||
                32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) =
              true) =
            ((!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) =
              true)) := (congrArg (fun x => x = true)
            (Eq.trans
              (congrArg (fun x => x✝ == 0#32 || x && x✝ == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
              (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝ == 0#32)
                (42#32 == BitVec.intMin 32 &&
                  x✝ ==
                    4294967295#32))) : ((x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32) =
              true) =
            ((!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true))
        [Meta.isDefEq] [0.001250] ✅️ ((x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true) =
              ((!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) =
                true) =?= ((x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32) = true) =
              ((!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true)
          [Meta.isDefEq] [0.001233] ✅️ (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) =
                true =?= (x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32) = true
            [Meta.isDefEq] [0.001220] ✅️ x✝ == 0 ||
                  32 != 1 && 42#32 == BitVec.intMin 32 &&
                    x✝ == -1 =?= x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32
              [Meta.isDefEq.delta] [0.001205] ✅️ x✝ == 0 ||
                    32 != 1 && 42#32 == BitVec.intMin 32 &&
                      x✝ == -1 =?= x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32
  [Meta.isDefEq] [0.001035] ✅️ ?h₃ =?= fun a =>
        congrArg (fun x => some (x &&& ((x✝¹ ^^^ 4294967295#32) &&& x✝²) ||| (x✝² ||| x✝¹) ^^^ 4294967295#32))
          (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
            (Eq.trans
              (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                  (eq_false' fun h => Bool.noConfusion h)))
              (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                (fun a =>
                  Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                    (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                fun a => Eq.refl (42#32 / x✝))))
    [Meta.isDefEq.assign] [0.001031] ✅️ ?h₃ := fun a =>
          congrArg (fun x => some (x &&& ((x✝¹ ^^^ 4294967295#32) &&& x✝²) ||| (x✝² ||| x✝¹) ^^^ 4294967295#32))
            (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
              (Eq.trans
                (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                  (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                  (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                    (eq_false' fun h => Bool.noConfusion h)))
                (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                  (fun a =>
                    Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                      (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                  fun a => Eq.refl (42#32 / x✝))))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              some
                ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                    ((x✝¹ ^^^ 4294967295#32) &&& x✝²) |||
                  (x✝² ||| x✝¹) ^^^ 4294967295#32)) ⊑
            if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              some
                (((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                    x✝² ^^^ 4294967295#32) &&&
                  (x✝¹ ^^^ 4294967295#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 75.273610ms, solving context: 1.000000ms
LeanSAT proved the goal after 80.180689ms: rewriting 15.901860ms, bitblasting 0.000000ms, SAT solving 57.382959ms, LRAT trimming 0.000000ms, LRAT checking 4.227050ms
Bitwuzla proved the goal after 75.373310ms, solving context: 1.000000ms
LeanSAT proved the goal after 80.648849ms: rewriting 15.698170ms, bitblasting 0.000000ms, SAT solving 58.487759ms, LRAT trimming 0.000000ms, LRAT checking 3.962970ms
Bitwuzla proved the goal after 75.535630ms, solving context: 1.000000ms
LeanSAT proved the goal after 79.765839ms: rewriting 15.787240ms, bitblasting 0.000000ms, SAT solving 57.400239ms, LRAT trimming 0.000000ms, LRAT checking 3.972810ms
Bitwuzla proved the goal after 75.332219ms, solving context: 1.000000ms
LeanSAT proved the goal after 79.861760ms: rewriting 15.898570ms, bitblasting 0.000000ms, SAT solving 57.472170ms, LRAT trimming 0.000000ms, LRAT checking 3.902020ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1300:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1300:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1291:8: error: (kernel) declaration has metavariables 'not_or_or_and_no_and_commute2_thm'
[bv] [0.050479] Normalizing goal
  [Meta.synthInstance] [0.001013] ✅️ Decidable
        ((if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some (((42#32).sdiv x✝ ||| x✝¹ ^^^ -1#32 ||| x✝²) &&& ((42#32).sdiv x✝ &&& x✝¹ ^^^ -1#32))) ⊑
          if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else some (x✝² &&& ((42#32).sdiv x✝ ^^^ -1#32) ||| x✝¹ ^^^ -1#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else
              if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
              else some (((42#32).sdiv x✝ ||| x✝¹ ^^^ -1#32 ||| x✝²) &&& ((42#32).sdiv x✝ &&& x✝¹ ^^^ -1#32))) ⊑
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some (x✝² &&& ((42#32).sdiv x✝ ^^^ -1#32) ||| x✝¹ ^^^ -1#32)
      ⊢ False
  [Meta.isDefEq] [0.001039] ✅️ ?h₃ =?= fun a =>
        congrArg some
          (congr
            (congrArg (fun x => HAnd.hAnd (x ||| x✝¹ ^^^ 4294967295#32 ||| x✝²))
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                (Eq.trans
                  (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                    (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                      (eq_false' fun h => Bool.noConfusion h)))
                  (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                    (fun a =>
                      Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                        (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                    fun a => Eq.refl (42#32 / x✝)))))
            (congrArg (fun x => x &&& x✝¹ ^^^ 4294967295#32)
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                (Eq.trans
                  (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                    (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                      (eq_false' fun h => Bool.noConfusion h)))
                  (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                    (fun a =>
                      Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                        (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                    fun a => Eq.refl (42#32 / x✝))))))
    [Meta.isDefEq.assign] [0.001036] ✅️ ?h₃ := fun a =>
          congrArg some
            (congr
              (congrArg (fun x => HAnd.hAnd (x ||| x✝¹ ^^^ 4294967295#32 ||| x✝²))
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                      (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                      fun a => Eq.refl (42#32 / x✝)))))
              (congrArg (fun x => x &&& x✝¹ ^^^ 4294967295#32)
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
                  (Eq.trans
                    (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                      (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                      (fun a =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                          (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                      fun a => Eq.refl (42#32 / x✝))))))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
              else
                some
                  (((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                        x✝¹ ^^^ 4294967295#32 |||
                      x✝²) &&&
                    ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&& x✝¹ ^^^
                      4294967295#32))) ⊑
            if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              some
                (x✝² &&&
                    ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) ^^^
                      4294967295#32) |||
                  x✝¹ ^^^ 4294967295#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1313:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1304:8: error: (kernel) declaration has metavariables 'not_or_or_and_no_and_commute3_thm'
[bv] [0.047520] Normalizing goal
  [Meta.synthInstance] [0.001148] ✅️ Decidable
        ((if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else some (((42#32).sdiv x✝ ||| (x✝¹ ^^^ -1#32 ||| x✝²)) &&& (x✝² &&& x✝¹ ^^^ -1#32))) ⊑
          if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
          else some ((42#32).sdiv x✝ &&& (x✝² ^^^ -1#32) ||| x✝¹ ^^^ -1#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some (((42#32).sdiv x✝ ||| (x✝¹ ^^^ -1#32 ||| x✝²)) &&& (x✝² &&& x✝¹ ^^^ -1#32))) ⊑
            if (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true then none
            else some ((42#32).sdiv x✝ &&& (x✝² ^^^ -1#32) ||| x✝¹ ^^^ -1#32)
      ⊢ False
  [Meta.isDefEq] [0.001253] ✅️ ?h₁ =?= congrArg (fun x => x = true)
        (Eq.trans
          (congrArg (fun x => x✝ == 0#32 || x && x✝ == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
          (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝ == 0#32) (42#32 == BitVec.intMin 32 && x✝ == 4294967295#32)))
    [Meta.isDefEq.assign] [0.001251] ✅️ ?h₁ := congrArg (fun x => x = true)
          (Eq.trans
            (congrArg (fun x => x✝ == 0#32 || x && x✝ == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
            (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝ == 0#32)
              (42#32 == BitVec.intMin 32 && x✝ == 4294967295#32)))
      [Meta.isDefEq.assign.checkTypes] [0.001240] ✅️ (?h₁ : ((x✝ == 0 ||
                32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) =
              true) =
            ((!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) =
              true)) := (congrArg (fun x => x = true)
            (Eq.trans
              (congrArg (fun x => x✝ == 0#32 || x && x✝ == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
              (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝ == 0#32)
                (42#32 == BitVec.intMin 32 &&
                  x✝ ==
                    4294967295#32))) : ((x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32) =
              true) =
            ((!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true))
        [Meta.isDefEq] [0.001237] ✅️ ((x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) = true) =
              ((!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) =
                true) =?= ((x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32) = true) =
              ((!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true)
          [Meta.isDefEq] [0.001220] ✅️ (x✝ == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && x✝ == -1) =
                true =?= (x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32) = true
            [Meta.isDefEq] [0.001207] ✅️ x✝ == 0 ||
                  32 != 1 && 42#32 == BitVec.intMin 32 &&
                    x✝ == -1 =?= x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32
              [Meta.isDefEq.delta] [0.001191] ✅️ x✝ == 0 ||
                    32 != 1 && 42#32 == BitVec.intMin 32 &&
                      x✝ == -1 =?= x✝ == 0#32 || true && 42#32 == BitVec.intMin 32 && x✝ == 4294967295#32
  [Meta.isDefEq] [0.001013] ✅️ ?h₃ =?= fun a =>
        congrArg (fun x => some ((x ||| (x✝¹ ^^^ 4294967295#32 ||| x✝²)) &&& (x✝² &&& x✝¹ ^^^ 4294967295#32)))
          (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
            (Eq.trans
              (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                  (eq_false' fun h => Bool.noConfusion h)))
              (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                (fun a =>
                  Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                    (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                fun a => Eq.refl (42#32 / x✝))))
    [Meta.isDefEq.assign] [0.001009] ✅️ ?h₃ := fun a =>
          congrArg (fun x => some ((x ||| (x✝¹ ^^^ 4294967295#32 ||| x✝²)) &&& (x✝² &&& x✝¹ ^^^ 4294967295#32)))
            (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) x✝)
              (Eq.trans
                (ite_cond_eq_false (if x✝.msb = true then -42#32 / -x✝ else -(-42#32 / x✝))
                  (if x✝.msb = true then -(42#32 / -x✝) else 42#32 / x✝)
                  (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                    (eq_false' fun h => Bool.noConfusion h)))
                (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x✝))
                  (fun a =>
                    Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add x✝))
                      (BitVec.neg_eq_not_add (42#32 / (~~~x✝ + 1#32))))
                  fun a => Eq.refl (42#32 / x✝))))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              some
                (((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) |||
                    (x✝¹ ^^^ 4294967295#32 ||| x✝²)) &&&
                  (x✝² &&& x✝¹ ^^^ 4294967295#32))) ⊑
            if (!(!x✝ == 0#32 && !(42#32 == BitVec.intMin 32 && x✝ == 4294967295#32))) = true then none
            else
              some
                ((if x✝.getLsbD 31 = true then ~~~(42#32 / (~~~x✝ + 1#32)) + 1#32 else 42#32 / x✝) &&&
                    (x✝² ^^^ 4294967295#32) |||
                  x✝¹ ^^^ 4294967295#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 72.176370ms, solving context: 0.000000ms
LeanSAT proved the goal after 73.102660ms: rewriting 12.800760ms, bitblasting 0.000000ms, SAT solving 56.830750ms, LRAT trimming 0.000000ms, LRAT checking 1.874900ms
Bitwuzla proved the goal after 74.032790ms, solving context: 5.000000ms
LeanSAT proved the goal after 235.295379ms: rewriting 14.486180ms, bitblasting 15.170960ms, SAT solving 108.054669ms, LRAT trimming 3.648670ms, LRAT checking 63.028380ms
Bitwuzla proved the goal after 70.892360ms, solving context: 0.000000ms
LeanSAT proved the goal after 73.599220ms: rewriting 11.272450ms, bitblasting 0.000000ms, SAT solving 59.543310ms, LRAT trimming 0.000000ms, LRAT checking 1.619440ms
Bitwuzla proved the goal after 70.868180ms, solving context: 0.000000ms
LeanSAT proved the goal after 71.541300ms: rewriting 10.669280ms, bitblasting 0.000000ms, SAT solving 58.095300ms, LRAT trimming 0.000000ms, LRAT checking 1.592980ms
Bitwuzla proved the goal after 68.699260ms, solving context: 0.000000ms
LeanSAT proved the goal after 70.189430ms: rewriting 9.421600ms, bitblasting 0.000000ms, SAT solving 58.063150ms, LRAT trimming 0.000000ms, LRAT checking 1.629830ms
Bitwuzla proved the goal after 68.063320ms, solving context: 0.000000ms
LeanSAT proved the goal after 69.594800ms: rewriting 8.781430ms, bitblasting 0.000000ms, SAT solving 58.074160ms, LRAT trimming 0.000000ms, LRAT checking 1.581230ms
Bitwuzla proved the goal after 68.107580ms, solving context: 0.000000ms
LeanSAT proved the goal after 69.424849ms: rewriting 8.710880ms, bitblasting 0.000000ms, SAT solving 58.083250ms, LRAT trimming 0.000000ms, LRAT checking 1.497420ms
Bitwuzla proved the goal after 89.895670ms, solving context: 0.000000ms
LeanSAT proved the goal after 94.053139ms: rewriting 23.865700ms, bitblasting 0.000000ms, SAT solving 57.803619ms, LRAT trimming 0.000000ms, LRAT checking 4.618890ms
Bitwuzla proved the goal after 70.042340ms, solving context: 0.000000ms
LeanSAT proved the goal after 81.450879ms: rewriting 10.550060ms, bitblasting 0.000000ms, SAT solving 59.675700ms, LRAT trimming 3.328170ms, LRAT checking 6.121250ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1418:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1411:8: error: (kernel) declaration has metavariables 'canonicalize_logic_first_or0_nsw_thm'
[bv] [0.028857] Normalizing goal
  [Meta.synthInstance] [0.001160] ✅️ Decidable
        ((if True ∧ x✝.msb = (112#32).msb ∧ (x✝ + 112#32).msb ≠ x✝.msb then none else some (x✝ + 112#32 ||| 15#32)) ⊑
          if True ∧ (x✝ ||| 15#32).msb = (112#32).msb ∧ ((x✝ ||| 15#32) + 112#32).msb ≠ (x✝ ||| 15#32).msb then none
          else some ((x✝ ||| 15#32) + 112#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if True ∧ x✝.msb = (112#32).msb ∧ (x✝ + 112#32).msb ≠ x✝.msb then none else some (x✝ + 112#32 ||| 15#32)) ⊑
            if True ∧ (x✝ ||| 15#32).msb = (112#32).msb ∧ ((x✝ ||| 15#32) + 112#32).msb ≠ (x✝ ||| 15#32).msb then none
            else some ((x✝ ||| 15#32) + 112#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if (!x✝.getLsbD 31 && !(x✝ + 112#32).getLsbD 31 == x✝.getLsbD 31) = true then none
            else some (x✝ + 112#32 ||| 15#32)) ⊑
            if
                (!(x✝ ||| 15#32).getLsbD 31 && !((x✝ ||| 15#32) + 112#32).getLsbD 31 == (x✝ ||| 15#32).getLsbD 31) =
                  true then
              none
            else some ((x✝ ||| 15#32) + 112#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1429:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1422:8: error: (kernel) declaration has metavariables 'canonicalize_logic_first_or0_nswnuw_thm'
[bv] [0.043999] Normalizing goal
  [Meta.synthInstance] [0.001322] ✅️ Decidable
        ((if True ∧ x✝.msb = (112#32).msb ∧ (x✝ + 112#32).msb ≠ x✝.msb then none
          else if True ∧ (x✝ + 112#32 < x✝ ∨ x✝ + 112#32 < 112#32) then none else some (x✝ + 112#32 ||| 15#32)) ⊑
          if True ∧ (x✝ ||| 15#32).msb = (112#32).msb ∧ ((x✝ ||| 15#32) + 112#32).msb ≠ (x✝ ||| 15#32).msb then none
          else
            if True ∧ ((x✝ ||| 15#32) + 112#32 < x✝ ||| 15#32 ∨ (x✝ ||| 15#32) + 112#32 < 112#32) then none
            else some ((x✝ ||| 15#32) + 112#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if True ∧ x✝.msb = (112#32).msb ∧ (x✝ + 112#32).msb ≠ x✝.msb then none
            else if True ∧ (x✝ + 112#32 < x✝ ∨ x✝ + 112#32 < 112#32) then none else some (x✝ + 112#32 ||| 15#32)) ⊑
            if True ∧ (x✝ ||| 15#32).msb = (112#32).msb ∧ ((x✝ ||| 15#32) + 112#32).msb ≠ (x✝ ||| 15#32).msb then none
            else
              if True ∧ ((x✝ ||| 15#32) + 112#32 < x✝ ||| 15#32 ∨ (x✝ ||| 15#32) + 112#32 < 112#32) then none
              else some ((x✝ ||| 15#32) + 112#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if (!x✝.getLsbD 31 && !(x✝ + 112#32).getLsbD 31 == x✝.getLsbD 31) = true then none
            else
              if (!((!x✝ >ᵤ x✝ + 112#32) && !112#32 >ᵤ x✝ + 112#32)) = true then none
              else some (x✝ + 112#32 ||| 15#32)) ⊑
            if
                (!(x✝ ||| 15#32).getLsbD 31 && !((x✝ ||| 15#32) + 112#32).getLsbD 31 == (x✝ ||| 15#32).getLsbD 31) =
                  true then
              none
            else
              if (!((!x✝ ||| 15#32 >ᵤ (x✝ ||| 15#32) + 112#32) && !112#32 >ᵤ (x✝ ||| 15#32) + 112#32)) = true then none
              else some ((x✝ ||| 15#32) + 112#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 70.696159ms, solving context: 0.000000ms
LeanSAT proved the goal after 73.116750ms: rewriting 11.376310ms, bitblasting 0.000000ms, SAT solving 58.026370ms, LRAT trimming 0.000000ms, LRAT checking 1.741910ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1450:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1443:8: error: (kernel) declaration has metavariables 'canonicalize_logic_first_and0_nsw_thm'
[bv] [0.029564] Normalizing goal
  [Meta.synthInstance] [0.001120] ✅️ Decidable
        ((if True ∧ x✝.msb = (48#8).msb ∧ (x✝ + 48#8).msb ≠ x✝.msb then none else some (x✝ + 48#8 &&& 246#8)) ⊑
          if True ∧ (x✝ &&& 246#8).msb = (48#8).msb ∧ ((x✝ &&& 246#8) + 48#8).msb ≠ (x✝ &&& 246#8).msb then none
          else some ((x✝ &&& 246#8) + 48#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if True ∧ x✝.msb = (48#8).msb ∧ (x✝ + 48#8).msb ≠ x✝.msb then none else some (x✝ + 48#8 &&& 246#8)) ⊑
            if True ∧ (x✝ &&& 246#8).msb = (48#8).msb ∧ ((x✝ &&& 246#8) + 48#8).msb ≠ (x✝ &&& 246#8).msb then none
            else some ((x✝ &&& 246#8) + 48#8)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if (!x✝.getLsbD 7 && !(x✝ + 48#8).getLsbD 7 == x✝.getLsbD 7) = true then none
            else some (x✝ + 48#8 &&& 246#8)) ⊑
            if (!(x✝ &&& 246#8).getLsbD 7 && !((x✝ &&& 246#8) + 48#8).getLsbD 7 == (x✝ &&& 246#8).getLsbD 7) = true then
              none
            else some ((x✝ &&& 246#8) + 48#8)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1461:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1454:8: error: (kernel) declaration has metavariables 'canonicalize_logic_first_and0_nswnuw_thm'
[bv] [0.045101] Normalizing goal
  [Meta.synthInstance] [0.001338] ✅️ Decidable
        ((if True ∧ x✝.msb = (48#8).msb ∧ (x✝ + 48#8).msb ≠ x✝.msb then none
          else if True ∧ (x✝ + 48#8 < x✝ ∨ x✝ + 48#8 < 48#8) then none else some (x✝ + 48#8 &&& 246#8)) ⊑
          if True ∧ (x✝ &&& 246#8).msb = (48#8).msb ∧ ((x✝ &&& 246#8) + 48#8).msb ≠ (x✝ &&& 246#8).msb then none
          else
            if True ∧ ((x✝ &&& 246#8) + 48#8 < x✝ &&& 246#8 ∨ (x✝ &&& 246#8) + 48#8 < 48#8) then none
            else some ((x✝ &&& 246#8) + 48#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if True ∧ x✝.msb = (48#8).msb ∧ (x✝ + 48#8).msb ≠ x✝.msb then none
            else if True ∧ (x✝ + 48#8 < x✝ ∨ x✝ + 48#8 < 48#8) then none else some (x✝ + 48#8 &&& 246#8)) ⊑
            if True ∧ (x✝ &&& 246#8).msb = (48#8).msb ∧ ((x✝ &&& 246#8) + 48#8).msb ≠ (x✝ &&& 246#8).msb then none
            else
              if True ∧ ((x✝ &&& 246#8) + 48#8 < x✝ &&& 246#8 ∨ (x✝ &&& 246#8) + 48#8 < 48#8) then none
              else some ((x✝ &&& 246#8) + 48#8)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if (!x✝.getLsbD 7 && !(x✝ + 48#8).getLsbD 7 == x✝.getLsbD 7) = true then none
            else if (!((!x✝ >ᵤ x✝ + 48#8) && !48#8 >ᵤ x✝ + 48#8)) = true then none else some (x✝ + 48#8 &&& 246#8)) ⊑
            if (!(x✝ &&& 246#8).getLsbD 7 && !((x✝ &&& 246#8) + 48#8).getLsbD 7 == (x✝ &&& 246#8).getLsbD 7) = true then
              none
            else
              if (!((!x✝ &&& 246#8 >ᵤ (x✝ &&& 246#8) + 48#8) && !48#8 >ᵤ (x✝ &&& 246#8) + 48#8)) = true then none
              else some ((x✝ &&& 246#8) + 48#8)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 70.024100ms, solving context: 0.000000ms
LeanSAT proved the goal after 72.631319ms: rewriting 10.619330ms, bitblasting 0.000000ms, SAT solving 58.166730ms, LRAT trimming 0.000000ms, LRAT checking 1.760781ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1482:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1475:8: error: (kernel) declaration has metavariables 'canonicalize_logic_first_xor_0_nsw_thm'
[bv] [0.028828] Normalizing goal
  [Meta.synthInstance] [0.001143] ✅️ Decidable
        ((if True ∧ x✝.msb = (96#8).msb ∧ (x✝ + 96#8).msb ≠ x✝.msb then none else some (x✝ + 96#8 ^^^ 31#8)) ⊑
          if True ∧ (x✝ ^^^ 31#8).msb = (96#8).msb ∧ ((x✝ ^^^ 31#8) + 96#8).msb ≠ (x✝ ^^^ 31#8).msb then none
          else some ((x✝ ^^^ 31#8) + 96#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if True ∧ x✝.msb = (96#8).msb ∧ (x✝ + 96#8).msb ≠ x✝.msb then none else some (x✝ + 96#8 ^^^ 31#8)) ⊑
            if True ∧ (x✝ ^^^ 31#8).msb = (96#8).msb ∧ ((x✝ ^^^ 31#8) + 96#8).msb ≠ (x✝ ^^^ 31#8).msb then none
            else some ((x✝ ^^^ 31#8) + 96#8)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if (!x✝.getLsbD 7 && !(x✝ + 96#8).getLsbD 7 == x✝.getLsbD 7) = true then none
            else some (x✝ + 96#8 ^^^ 31#8)) ⊑
            if (!(x✝ ^^^ 31#8).getLsbD 7 && !((x✝ ^^^ 31#8) + 96#8).getLsbD 7 == (x✝ ^^^ 31#8).getLsbD 7) = true then
              none
            else some ((x✝ ^^^ 31#8) + 96#8)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1493:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gandhxorhor_proof.lean:1486:8: error: (kernel) declaration has metavariables 'canonicalize_logic_first_xor_0_nswnuw_thm'
[bv] [0.044216] Normalizing goal
  [Meta.synthInstance] [0.001373] ✅️ Decidable
        ((if True ∧ x✝.msb = (96#8).msb ∧ (x✝ + 96#8).msb ≠ x✝.msb then none
          else if True ∧ (x✝ + 96#8 < x✝ ∨ x✝ + 96#8 < 96#8) then none else some (x✝ + 96#8 ^^^ 31#8)) ⊑
          if True ∧ (x✝ ^^^ 31#8).msb = (96#8).msb ∧ ((x✝ ^^^ 31#8) + 96#8).msb ≠ (x✝ ^^^ 31#8).msb then none
          else
            if True ∧ ((x✝ ^^^ 31#8) + 96#8 < x✝ ^^^ 31#8 ∨ (x✝ ^^^ 31#8) + 96#8 < 96#8) then none
            else some ((x✝ ^^^ 31#8) + 96#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if True ∧ x✝.msb = (96#8).msb ∧ (x✝ + 96#8).msb ≠ x✝.msb then none
            else if True ∧ (x✝ + 96#8 < x✝ ∨ x✝ + 96#8 < 96#8) then none else some (x✝ + 96#8 ^^^ 31#8)) ⊑
            if True ∧ (x✝ ^^^ 31#8).msb = (96#8).msb ∧ ((x✝ ^^^ 31#8) + 96#8).msb ≠ (x✝ ^^^ 31#8).msb then none
            else
              if True ∧ ((x✝ ^^^ 31#8) + 96#8 < x✝ ^^^ 31#8 ∨ (x✝ ^^^ 31#8) + 96#8 < 96#8) then none
              else some ((x✝ ^^^ 31#8) + 96#8)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if (!x✝.getLsbD 7 && !(x✝ + 96#8).getLsbD 7 == x✝.getLsbD 7) = true then none
            else if (!((!x✝ >ᵤ x✝ + 96#8) && !96#8 >ᵤ x✝ + 96#8)) = true then none else some (x✝ + 96#8 ^^^ 31#8)) ⊑
            if (!(x✝ ^^^ 31#8).getLsbD 7 && !((x✝ ^^^ 31#8) + 96#8).getLsbD 7 == (x✝ ^^^ 31#8).getLsbD 7) = true then
              none
            else
              if (!((!x✝ ^^^ 31#8 >ᵤ (x✝ ^^^ 31#8) + 96#8) && !96#8 >ᵤ (x✝ ^^^ 31#8) + 96#8)) = true then none
              else some ((x✝ ^^^ 31#8) + 96#8)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 92.876499ms, solving context: 0.000000ms
LeanSAT proved the goal after 98.559900ms: rewriting 26.166800ms, bitblasting 0.000000ms, SAT solving 59.218340ms, LRAT trimming 0.000000ms, LRAT checking 6.092570ms
