âš  [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
âš  [881/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
âš  [884/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
âš  [887/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
âš  [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:17:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:17:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:17:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:17:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:17:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:17:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:11:8: error: (kernel) declaration has metavariables 'udiv_common_divisor_thm'
[bv] [0.073670] Normalizing goal
  [Meta.synthInstance] [0.001593] âœ…ï¸ Decidable
        ((match some xâœ with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } => if xâœÂ² = 0 then none else some (xâœÂ¹ / xâœÂ²)
          | some { toFin := âŸ¨0, â‹¯âŸ© } => if xâœÂ² = 0 then none else some (xâœÂ³ / xâœÂ²)) âŠ‘
          Option.bind
            (match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³)
            fun a => if xâœÂ² = 0 then none else some (a / xâœÂ²))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 5
      e_3 : LLVM.IntW 1
      xâœÂ³ xâœÂ² xâœÂ¹ : BitVec 5
      xâœ : BitVec 1
      aâœ :
        Â¬(match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => if xâœÂ² = 0 then none else some (xâœÂ¹ / xâœÂ²)
            | some { toFin := âŸ¨0, â‹¯âŸ© } => if xâœÂ² = 0 then none else some (xâœÂ³ / xâœÂ²)) âŠ‘
            Option.bind
              (match some xâœ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³)
              fun a => if xâœÂ² = 0 then none else some (a / xâœÂ²)
      âŠ¢ False
  [Meta.isDefEq] [0.001009] âŒï¸ match none with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => if xâœÂ² = 0 then none else some (xâœÂ¹ / xâœÂ²)
      | some { toFin := âŸ¨0, â‹¯âŸ© } => if xâœÂ² = 0 then none else some (xâœÂ³ / xâœÂ²)
  [Meta.isDefEq] [0.001112] âŒï¸ match some { toFin := âŸ¨1, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => if xâœÂ² = 0 then none else some (xâœÂ¹ / xâœÂ²)
      | some { toFin := âŸ¨0, â‹¯âŸ© } => if xâœÂ² = 0 then none else some (xâœÂ³ / xâœÂ²)
  [Meta.isDefEq] [0.001017] âŒï¸ match some { toFin := âŸ¨1, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ¹ / xâœÂ²)
      | some { toFin := âŸ¨0, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ³ / xâœÂ²)
  [Meta.isDefEq] [0.001017] âŒï¸ match some { toFin := âŸ¨0, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ¹ / xâœÂ²)
      | some { toFin := âŸ¨0, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ³ / xâœÂ²)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 5
      e_3 : LLVM.IntW 1
      xâœÂ³ xâœÂ² xâœÂ¹ : BitVec 5
      xâœ : BitVec 1
      aâœ :
        Â¬(match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ¹ / xâœÂ²)
            | some { toFin := âŸ¨0, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ³ / xâœÂ²)) âŠ‘
            Option.bind
              (match some xâœ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³)
              fun a => if (xâœÂ² == 0#5) = true then none else some (a / xâœÂ²)
      âŠ¢ False
  [Meta.isDefEq] [0.001005] âŒï¸ match some { toFin := âŸ¨0, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³
  [Meta.isDefEq] [0.001072] âŒï¸ match some { toFin := âŸ¨1, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ¹ / xâœÂ²)
      | some { toFin := âŸ¨0, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ³ / xâœÂ²)
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:27:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:27:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:27:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:27:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:27:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:27:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:21:8: error: (kernel) declaration has metavariables 'urem_common_divisor_thm'
[bv] [0.099903] Normalizing goal
  [Meta.synthInstance] [0.002469] âœ…ï¸ Decidable
        ((match some xâœ with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } => if xâœÂ² = 0 then none else some (xâœÂ¹ % xâœÂ²)
          | some { toFin := âŸ¨0, â‹¯âŸ© } => if xâœÂ² = 0 then none else some (xâœÂ³ % xâœÂ²)) âŠ‘
          Option.bind
            (match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³)
            fun a => if xâœÂ² = 0 then none else some (a % xâœÂ²))
    [Meta.check] [0.001158] âœ…ï¸ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (match some xâœ with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } => if xâœÂ² = 0 then none else some (xâœÂ¹ % xâœÂ²)
          | some { toFin := âŸ¨0, â‹¯âŸ© } => if xâœÂ² = 0 then none else some (xâœÂ³ % xâœÂ²))
          (Option.bind
            (match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³)
            fun a => if xâœÂ² = 0 then none else some (a % xâœÂ²))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 5
      e_3 : LLVM.IntW 1
      xâœÂ³ xâœÂ² xâœÂ¹ : BitVec 5
      xâœ : BitVec 1
      aâœ :
        Â¬(match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => if xâœÂ² = 0 then none else some (xâœÂ¹ % xâœÂ²)
            | some { toFin := âŸ¨0, â‹¯âŸ© } => if xâœÂ² = 0 then none else some (xâœÂ³ % xâœÂ²)) âŠ‘
            Option.bind
              (match some xâœ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³)
              fun a => if xâœÂ² = 0 then none else some (a % xâœÂ²)
      âŠ¢ False
  [Meta.isDefEq] [0.001072] âŒï¸ match none with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => if xâœÂ² = 0 then none else some (xâœÂ¹ % xâœÂ²)
      | some { toFin := âŸ¨0, â‹¯âŸ© } => if xâœÂ² = 0 then none else some (xâœÂ³ % xâœÂ²)
  [Meta.isDefEq] [0.001126] âŒï¸ match some { toFin := âŸ¨1, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => if xâœÂ² = 0 then none else some (xâœÂ¹ % xâœÂ²)
      | some { toFin := âŸ¨0, â‹¯âŸ© } => if xâœÂ² = 0 then none else some (xâœÂ³ % xâœÂ²)
  [Meta.isDefEq] [0.001046] âŒï¸ match some { toFin := âŸ¨0, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => if xâœÂ² = 0 then none else some (xâœÂ¹ % xâœÂ²)
      | some { toFin := âŸ¨0, â‹¯âŸ© } => if xâœÂ² = 0 then none else some (xâœÂ³ % xâœÂ²)
  [Meta.isDefEq] [0.001181] âŒï¸ match none with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ¹ % xâœÂ²)
      | some { toFin := âŸ¨0, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ³ % xâœÂ²)
  [Meta.isDefEq] [0.001266] âŒï¸ match some { toFin := âŸ¨1, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ¹ % xâœÂ²)
      | some { toFin := âŸ¨0, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ³ % xâœÂ²)
  [Meta.isDefEq] [0.001262] âŒï¸ match some { toFin := âŸ¨0, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ¹ % xâœÂ²)
      | some { toFin := âŸ¨0, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ³ % xâœÂ²)
  [Meta.isDefEq] [0.001202] âŒï¸ match none with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³
  [Meta.isDefEq] [0.001217] âŒï¸ match some { toFin := âŸ¨1, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³
  [Meta.isDefEq] [0.001236] âŒï¸ match some { toFin := âŸ¨0, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³
  [Meta.isDefEq] [0.001116] âŒï¸ match none with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ¹ % xâœÂ²)
      | some { toFin := âŸ¨0, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ³ % xâœÂ²)
  [Meta.isDefEq] [0.001245] âŒï¸ match some { toFin := âŸ¨1, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ¹ % xâœÂ²)
      | some { toFin := âŸ¨0, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ³ % xâœÂ²)
  [Meta.isDefEq] [0.001257] âŒï¸ match some { toFin := âŸ¨0, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ¹ % xâœÂ²)
      | some { toFin := âŸ¨0, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ³ % xâœÂ²)
  [Meta.isDefEq] [0.001111] âŒï¸ match none with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³
  [Meta.isDefEq] [0.001287] âŒï¸ match some { toFin := âŸ¨1, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³
  [Meta.isDefEq] [0.001213] âŒï¸ match some { toFin := âŸ¨0, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 5
      e_3 : LLVM.IntW 1
      xâœÂ³ xâœÂ² xâœÂ¹ : BitVec 5
      xâœ : BitVec 1
      aâœ :
        Â¬(match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ¹ % xâœÂ²)
            | some { toFin := âŸ¨0, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ³ % xâœÂ²)) âŠ‘
            Option.bind
              (match some xâœ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³)
              fun a => if (xâœÂ² == 0#5) = true then none else some (a % xâœÂ²)
      âŠ¢ False
  [Meta.isDefEq] [0.001115] âŒï¸ match none with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ¹ % xâœÂ²)
      | some { toFin := âŸ¨0, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ³ % xâœÂ²)
  [Meta.isDefEq] [0.001201] âŒï¸ match some { toFin := âŸ¨1, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ¹ % xâœÂ²)
      | some { toFin := âŸ¨0, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ³ % xâœÂ²)
  [Meta.isDefEq] [0.001229] âŒï¸ match some { toFin := âŸ¨0, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ¹ % xâœÂ²)
      | some { toFin := âŸ¨0, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ³ % xâœÂ²)
  [Meta.isDefEq] [0.001119] âŒï¸ match none with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³
  [Meta.isDefEq] [0.001271] âŒï¸ match some { toFin := âŸ¨1, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³
  [Meta.isDefEq] [0.001229] âŒï¸ match some { toFin := âŸ¨0, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³
  [Meta.isDefEq] [0.001093] âŒï¸ match none with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ¹ % xâœÂ²)
      | some { toFin := âŸ¨0, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ³ % xâœÂ²)
  [Meta.isDefEq] [0.001227] âŒï¸ match some { toFin := âŸ¨1, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ¹ % xâœÂ²)
      | some { toFin := âŸ¨0, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ³ % xâœÂ²)
  [Meta.isDefEq] [0.001253] âŒï¸ match some { toFin := âŸ¨0, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ¹ % xâœÂ²)
      | some { toFin := âŸ¨0, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ³ % xâœÂ²)
  [Meta.isDefEq] [0.001189] âŒï¸ match some { toFin := âŸ¨0, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:37:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:37:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:37:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:37:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:37:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:37:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:31:8: error: (kernel) declaration has metavariables 'sdiv_common_divisor_defined_cond_thm'
[bv] [0.251429] Normalizing goal
  [Meta.synthInstance] [0.002759] âœ…ï¸ Decidable
        ((match some xâœ with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } =>
            if (xâœÂ² == 0 || 5 != 1 && xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == -1) = true then none else some (xâœÂ¹.sdiv xâœÂ²)
          | some { toFin := âŸ¨0, â‹¯âŸ© } =>
            if (xâœÂ² == 0 || 5 != 1 && xâœÂ³ == BitVec.intMin 5 && xâœÂ² == -1) = true then none else some (xâœÂ³.sdiv xâœÂ²)) âŠ‘
          Option.bind
            (match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³)
            fun a =>
            if (xâœÂ² == 0 || 5 != 1 && a == BitVec.intMin 5 && xâœÂ² == -1) = true then none else some (a.sdiv xâœÂ²))
    [Meta.check] [0.001464] âœ…ï¸ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (match some xâœ with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } =>
            if (xâœÂ² == 0 || 5 != 1 && xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == -1) = true then none else some (xâœÂ¹.sdiv xâœÂ²)
          | some { toFin := âŸ¨0, â‹¯âŸ© } =>
            if (xâœÂ² == 0 || 5 != 1 && xâœÂ³ == BitVec.intMin 5 && xâœÂ² == -1) = true then none else some (xâœÂ³.sdiv xâœÂ²))
          (Option.bind
            (match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³)
            fun a =>
            if (xâœÂ² == 0 || 5 != 1 && a == BitVec.intMin 5 && xâœÂ² == -1) = true then none else some (a.sdiv xâœÂ²))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 5
      e_3 : LLVM.IntW 1
      xâœÂ³ xâœÂ² xâœÂ¹ : BitVec 5
      xâœ : BitVec 1
      aâœ :
        Â¬(match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              if (xâœÂ² == 0 || 5 != 1 && xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == -1) = true then none else some (xâœÂ¹.sdiv xâœÂ²)
            | some { toFin := âŸ¨0, â‹¯âŸ© } =>
              if (xâœÂ² == 0 || 5 != 1 && xâœÂ³ == BitVec.intMin 5 && xâœÂ² == -1) = true then none
              else some (xâœÂ³.sdiv xâœÂ²)) âŠ‘
            Option.bind
              (match some xâœ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³)
              fun a =>
              if (xâœÂ² == 0 || 5 != 1 && a == BitVec.intMin 5 && xâœÂ² == -1) = true then none else some (a.sdiv xâœÂ²)
      âŠ¢ False
  [Meta.isDefEq] [0.001177] âŒï¸ match none with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } =>
        if (xâœÂ² == 0 || 5 != 1 && xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == -1) = true then none else some (xâœÂ¹.sdiv xâœÂ²)
      | some { toFin := âŸ¨0, â‹¯âŸ© } =>
        if (xâœÂ² == 0 || 5 != 1 && xâœÂ³ == BitVec.intMin 5 && xâœÂ² == -1) = true then none else some (xâœÂ³.sdiv xâœÂ²)
  [Meta.isDefEq] [0.001198] âŒï¸ match some { toFin := âŸ¨1, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } =>
        if (xâœÂ² == 0 || 5 != 1 && xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == -1) = true then none else some (xâœÂ¹.sdiv xâœÂ²)
      | some { toFin := âŸ¨0, â‹¯âŸ© } =>
        if (xâœÂ² == 0 || 5 != 1 && xâœÂ³ == BitVec.intMin 5 && xâœÂ² == -1) = true then none else some (xâœÂ³.sdiv xâœÂ²)
  [Meta.isDefEq] [0.001125] âŒï¸ match some { toFin := âŸ¨0, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } =>
        if (xâœÂ² == 0 || 5 != 1 && xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == -1) = true then none else some (xâœÂ¹.sdiv xâœÂ²)
      | some { toFin := âŸ¨0, â‹¯âŸ© } =>
        if (xâœÂ² == 0 || 5 != 1 && xâœÂ³ == BitVec.intMin 5 && xâœÂ² == -1) = true then none else some (xâœÂ³.sdiv xâœÂ²)
  [Meta.isDefEq] [0.003568] âŒï¸ ?a == ?a =?= xâœÂ¹ == BitVec.intMin 5
    [Meta.isDefEq.onFailure] [0.002741] âŒï¸ ?a == ?a =?= xâœÂ¹ == BitVec.intMin 5
      [Meta.synthInstance] [0.002682] ğŸ’¥ï¸ BEq ?Î±
        [Meta.synthInstance] [0.002520] ğŸ’¥ï¸ apply Nat.Linear.instBEqPolyCnstr to BEq ?Î±
  [Meta.isDefEq] [0.001451] âœ…ï¸ ?hâ‚ =?= congrArg (fun x => x = true)
        (Eq.trans (congrArg (fun x => xâœÂ² == 0#5 || x && xâœÂ² == 31#5) (Bool.true_and (xâœÂ¹ == BitVec.intMin 5)))
          (Std.Tactic.BVDecide.Normalize.Bool.or_elim (xâœÂ² == 0#5) (xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == 31#5)))
    [Meta.isDefEq.assign] [0.001447] âœ…ï¸ ?hâ‚ := congrArg (fun x => x = true)
          (Eq.trans (congrArg (fun x => xâœÂ² == 0#5 || x && xâœÂ² == 31#5) (Bool.true_and (xâœÂ¹ == BitVec.intMin 5)))
            (Std.Tactic.BVDecide.Normalize.Bool.or_elim (xâœÂ² == 0#5) (xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == 31#5)))
      [Meta.isDefEq.assign.checkTypes] [0.001422] âœ…ï¸ (?hâ‚ : ((xâœÂ² == 0 ||
                5 != 1 && xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == -1) =
              true) =
            ((!(!xâœÂ² == 0#5 && !(xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == 31#5))) =
              true)) := (congrArg (fun x => x = true)
            (Eq.trans (congrArg (fun x => xâœÂ² == 0#5 || x && xâœÂ² == 31#5) (Bool.true_and (xâœÂ¹ == BitVec.intMin 5)))
              (Std.Tactic.BVDecide.Normalize.Bool.or_elim (xâœÂ² == 0#5)
                (xâœÂ¹ == BitVec.intMin 5 &&
                  xâœÂ² ==
                    31#5))) : ((xâœÂ² == 0#5 || true && xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == 31#5) = true) =
            ((!(!xâœÂ² == 0#5 && !(xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == 31#5))) = true))
        [Meta.isDefEq] [0.001417] âœ…ï¸ ((xâœÂ² == 0 || 5 != 1 && xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == -1) = true) =
              ((!(!xâœÂ² == 0#5 && !(xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == 31#5))) =
                true) =?= ((xâœÂ² == 0#5 || true && xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == 31#5) = true) =
              ((!(!xâœÂ² == 0#5 && !(xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == 31#5))) = true)
          [Meta.isDefEq] [0.001361] âœ…ï¸ (xâœÂ² == 0 || 5 != 1 && xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == -1) =
                true =?= (xâœÂ² == 0#5 || true && xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == 31#5) = true
            [Meta.isDefEq] [0.001337] âœ…ï¸ xâœÂ² == 0 ||
                  5 != 1 && xâœÂ¹ == BitVec.intMin 5 &&
                    xâœÂ² == -1 =?= xâœÂ² == 0#5 || true && xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == 31#5
              [Meta.isDefEq.delta] [0.001313] âœ…ï¸ xâœÂ² == 0 ||
                    5 != 1 && xâœÂ¹ == BitVec.intMin 5 &&
                      xâœÂ² == -1 =?= xâœÂ² == 0#5 || true && xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == 31#5
  [Meta.isDefEq] [0.002095] âœ…ï¸ ?hâ‚ =?= congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last xâœÂ³)
    [Meta.isDefEq.assign] [0.002092] âœ…ï¸ ?hâ‚ := congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last xâœÂ³)
      [Meta.isDefEq.assign.checkTypes] [0.002083] âœ…ï¸ (?hâ‚ : (xâœÂ³.msb = true) =
            (xâœÂ³.getLsbD 4 =
              true)) := (congrArg (fun x => x = true)
            (BitVec.msb_eq_getLsbD_last xâœÂ³) : (xâœÂ³.msb = true) = (xâœÂ³.getLsbD (5 - 1) = true))
        [Meta.isDefEq] [0.002079] âœ…ï¸ (xâœÂ³.msb = true) =
              (xâœÂ³.getLsbD 4 = true) =?= (xâœÂ³.msb = true) = (xâœÂ³.getLsbD (5 - 1) = true)
          [Meta.isDefEq] [0.002056] âœ…ï¸ xâœÂ³.getLsbD 4 = true =?= xâœÂ³.getLsbD (5 - 1) = true
            [Meta.isDefEq] [0.002039] âœ…ï¸ xâœÂ³.getLsbD 4 =?= xâœÂ³.getLsbD (5 - 1)
  [Meta.isDefEq] [0.001039] âœ…ï¸ ?hâ‚ =?= congrArg (fun x => x = true)
        (Eq.trans (congrArg (fun x => xâœÂ² == 0#5 || x && xâœÂ² == 31#5) (Bool.true_and (a == BitVec.intMin 5)))
          (Std.Tactic.BVDecide.Normalize.Bool.or_elim (xâœÂ² == 0#5) (a == BitVec.intMin 5 && xâœÂ² == 31#5)))
    [Meta.isDefEq.assign] [0.001035] âœ…ï¸ ?hâ‚ := congrArg (fun x => x = true)
          (Eq.trans (congrArg (fun x => xâœÂ² == 0#5 || x && xâœÂ² == 31#5) (Bool.true_and (a == BitVec.intMin 5)))
            (Std.Tactic.BVDecide.Normalize.Bool.or_elim (xâœÂ² == 0#5) (a == BitVec.intMin 5 && xâœÂ² == 31#5)))
      [Meta.isDefEq.assign.checkTypes] [0.001013] âœ…ï¸ (?hâ‚ : ((xâœÂ² == 0 || 5 != 1 && a == BitVec.intMin 5 && xâœÂ² == -1) =
              true) =
            ((!(!xâœÂ² == 0#5 && !(a == BitVec.intMin 5 && xâœÂ² == 31#5))) =
              true)) := (congrArg (fun x => x = true)
            (Eq.trans (congrArg (fun x => xâœÂ² == 0#5 || x && xâœÂ² == 31#5) (Bool.true_and (a == BitVec.intMin 5)))
              (Std.Tactic.BVDecide.Normalize.Bool.or_elim (xâœÂ² == 0#5)
                (a == BitVec.intMin 5 &&
                  xâœÂ² ==
                    31#5))) : ((xâœÂ² == 0#5 || true && a == BitVec.intMin 5 && xâœÂ² == 31#5) = true) =
            ((!(!xâœÂ² == 0#5 && !(a == BitVec.intMin 5 && xâœÂ² == 31#5))) = true))
        [Meta.isDefEq] [0.001006] âœ…ï¸ ((xâœÂ² == 0 || 5 != 1 && a == BitVec.intMin 5 && xâœÂ² == -1) = true) =
              ((!(!xâœÂ² == 0#5 && !(a == BitVec.intMin 5 && xâœÂ² == 31#5))) =
                true) =?= ((xâœÂ² == 0#5 || true && a == BitVec.intMin 5 && xâœÂ² == 31#5) = true) =
              ((!(!xâœÂ² == 0#5 && !(a == BitVec.intMin 5 && xâœÂ² == 31#5))) = true)
  [Meta.isDefEq] [0.002242] âŒï¸ ~~~?a + ?a =?= ~~~a + 1#5
    [Meta.isDefEq] [0.002088] âŒï¸ instHAdd =?= instHAdd
      [Meta.isDefEq] [0.002048] âŒï¸ { hAdd := fun a b => Add.add a b } =?= { hAdd := fun a b => Add.add a b }
        [Meta.isDefEq] [0.002014] âŒï¸ fun a b => Add.add a b =?= fun a b => Add.add a b
          [Meta.isDefEq] [0.002009] âŒï¸ BitVec ?w =?= â„•
            [Meta.isDefEq.onFailure] [0.001996] âŒï¸ BitVec ?w =?= â„•
  [Meta.isDefEq] [0.002169] âœ…ï¸ ?hf =?= fun a a_1 =>
        ite_congr
          (congrArg (fun x => x = true)
            (Eq.trans (congrArg (fun x => xâœÂ² == 0#5 || x && xâœÂ² == 31#5) (Bool.true_and (a == BitVec.intMin 5)))
              (Std.Tactic.BVDecide.Normalize.Bool.or_elim (xâœÂ² == 0#5) (a == BitVec.intMin 5 && xâœÂ² == 31#5))))
          (fun a => Eq.refl none) fun a_2 =>
          congrArg some
            (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv a xâœÂ²)
              (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last a))
                (fun a_3 =>
                  ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last xâœÂ²))
                    (fun a_4 => congr (congrArg HDiv.hDiv (BitVec.neg_eq_not_add a)) (BitVec.neg_eq_not_add xâœÂ²))
                    fun a_4 =>
                    Eq.trans (congrArg (fun x => -(x / xâœÂ²)) (BitVec.neg_eq_not_add a))
                      (BitVec.neg_eq_not_add ((~~~a + 1#5) / xâœÂ²)))
                fun a_3 =>
                ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last xâœÂ²))
                  (fun a_4 =>
                    Eq.trans (congrArg (fun x => -(a / x)) (BitVec.neg_eq_not_add xâœÂ²))
                      (BitVec.neg_eq_not_add (a / (~~~xâœÂ² + 1#5))))
                  fun a_4 => Eq.refl (a / xâœÂ²)))
    [Meta.isDefEq.assign] [0.002164] âœ…ï¸ ?hf := fun a a_1 =>
          ite_congr
            (congrArg (fun x => x = true)
              (Eq.trans (congrArg (fun x => xâœÂ² == 0#5 || x && xâœÂ² == 31#5) (Bool.true_and (a == BitVec.intMin 5)))
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim (xâœÂ² == 0#5) (a == BitVec.intMin 5 && xâœÂ² == 31#5))))
            (fun a => Eq.refl none) fun a_2 =>
            congrArg some
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv a xâœÂ²)
                (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last a))
                  (fun a_3 =>
                    ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last xâœÂ²))
                      (fun a_4 => congr (congrArg HDiv.hDiv (BitVec.neg_eq_not_add a)) (BitVec.neg_eq_not_add xâœÂ²))
                      fun a_4 =>
                      Eq.trans (congrArg (fun x => -(x / xâœÂ²)) (BitVec.neg_eq_not_add a))
                        (BitVec.neg_eq_not_add ((~~~a + 1#5) / xâœÂ²)))
                  fun a_3 =>
                  ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last xâœÂ²))
                    (fun a_4 =>
                      Eq.trans (congrArg (fun x => -(a / x)) (BitVec.neg_eq_not_add xâœÂ²))
                        (BitVec.neg_eq_not_add (a / (~~~xâœÂ² + 1#5))))
                    fun a_4 => Eq.refl (a / xâœÂ²)))
  [Meta.isDefEq] [0.002096] âœ…ï¸ ?hf =?= fun a a_1 =>
        Eq.refl
          (if (!(!xâœÂ² == 0#5 && !(a == BitVec.intMin 5 && xâœÂ² == 31#5))) = true then none
          else
            some
              (if a.getLsbD 4 = true then
                if xâœÂ².getLsbD 4 = true then (~~~a + 1#5) / (~~~xâœÂ² + 1#5) else ~~~((~~~a + 1#5) / xâœÂ²) + 1#5
              else if xâœÂ².getLsbD 4 = true then ~~~(a / (~~~xâœÂ² + 1#5)) + 1#5 else a / xâœÂ²))
    [Meta.isDefEq.assign] [0.002092] âœ…ï¸ ?hf := fun a a_1 =>
          Eq.refl
            (if (!(!xâœÂ² == 0#5 && !(a == BitVec.intMin 5 && xâœÂ² == 31#5))) = true then none
            else
              some
                (if a.getLsbD 4 = true then
                  if xâœÂ².getLsbD 4 = true then (~~~a + 1#5) / (~~~xâœÂ² + 1#5) else ~~~((~~~a + 1#5) / xâœÂ²) + 1#5
                else if xâœÂ².getLsbD 4 = true then ~~~(a / (~~~xâœÂ² + 1#5)) + 1#5 else a / xâœÂ²))
      [Meta.isDefEq.assign.checkTypes] [0.002046] âœ…ï¸ (?hf : âˆ€
            a âˆˆ
              match some xâœ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³,
            (if (!(!xâœÂ² == 0#5 && !(a == BitVec.intMin 5 && xâœÂ² == 31#5))) = true then none
              else
                some
                  (if a.getLsbD 4 = true then
                    if xâœÂ².getLsbD 4 = true then (~~~a + 1#5) / (~~~xâœÂ² + 1#5) else ~~~((~~~a + 1#5) / xâœÂ²) + 1#5
                  else if xâœÂ².getLsbD 4 = true then ~~~(a / (~~~xâœÂ² + 1#5)) + 1#5 else a / xâœÂ²)) =
              if (!(!xâœÂ² == 0#5 && !(a == BitVec.intMin 5 && xâœÂ² == 31#5))) = true then none
              else
                some
                  (if a.getLsbD 4 = true then
                    if xâœÂ².getLsbD 4 = true then (~~~a + 1#5) / (~~~xâœÂ² + 1#5) else ~~~((~~~a + 1#5) / xâœÂ²) + 1#5
                  else
                    if xâœÂ².getLsbD 4 = true then ~~~(a / (~~~xâœÂ² + 1#5)) + 1#5
                    else
                      a /
                        xâœÂ²)) := (fun a a_1 =>
            Eq.refl
              (if (!(!xâœÂ² == 0#5 && !(a == BitVec.intMin 5 && xâœÂ² == 31#5))) = true then none
              else
                some
                  (if a.getLsbD 4 = true then
                    if xâœÂ².getLsbD 4 = true then (~~~a + 1#5) / (~~~xâœÂ² + 1#5) else ~~~((~~~a + 1#5) / xâœÂ²) + 1#5
                  else
                    if xâœÂ².getLsbD 4 = true then ~~~(a / (~~~xâœÂ² + 1#5)) + 1#5 else a / xâœÂ²)) : âˆ€
            a âˆˆ
              match some xâœ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³,
            (if (!(!xâœÂ² == 0#5 && !(a == BitVec.intMin 5 && xâœÂ² == 31#5))) = true then none
              else
                some
                  (if a.getLsbD 4 = true then
                    if xâœÂ².getLsbD 4 = true then (~~~a + 1#5) / (~~~xâœÂ² + 1#5) else ~~~((~~~a + 1#5) / xâœÂ²) + 1#5
                  else if xâœÂ².getLsbD 4 = true then ~~~(a / (~~~xâœÂ² + 1#5)) + 1#5 else a / xâœÂ²)) =
              if (!(!xâœÂ² == 0#5 && !(a == BitVec.intMin 5 && xâœÂ² == 31#5))) = true then none
              else
                some
                  (if a.getLsbD 4 = true then
                    if xâœÂ².getLsbD 4 = true then (~~~a + 1#5) / (~~~xâœÂ² + 1#5) else ~~~((~~~a + 1#5) / xâœÂ²) + 1#5
                  else if xâœÂ².getLsbD 4 = true then ~~~(a / (~~~xâœÂ² + 1#5)) + 1#5 else a / xâœÂ²))
        [Meta.isDefEq] [0.002041] âœ…ï¸ âˆ€
              a âˆˆ
                match some xâœ with
                | none => none
                | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
                | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³,
              (if (!(!xâœÂ² == 0#5 && !(a == BitVec.intMin 5 && xâœÂ² == 31#5))) = true then none
                else
                  some
                    (if a.getLsbD 4 = true then
                      if xâœÂ².getLsbD 4 = true then (~~~a + 1#5) / (~~~xâœÂ² + 1#5) else ~~~((~~~a + 1#5) / xâœÂ²) + 1#5
                    else if xâœÂ².getLsbD 4 = true then ~~~(a / (~~~xâœÂ² + 1#5)) + 1#5 else a / xâœÂ²)) =
                if (!(!xâœÂ² == 0#5 && !(a == BitVec.intMin 5 && xâœÂ² == 31#5))) = true then none
                else
                  some
                    (if a.getLsbD 4 = true then
                      if xâœÂ².getLsbD 4 = true then (~~~a + 1#5) / (~~~xâœÂ² + 1#5) else ~~~((~~~a + 1#5) / xâœÂ²) + 1#5
                    else
                      if xâœÂ².getLsbD 4 = true then ~~~(a / (~~~xâœÂ² + 1#5)) + 1#5
                      else a / xâœÂ²) =?= âˆ€
              a âˆˆ
                match some xâœ with
                | none => none
                | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
                | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³,
              (if (!(!xâœÂ² == 0#5 && !(a == BitVec.intMin 5 && xâœÂ² == 31#5))) = true then none
                else
                  some
                    (if a.getLsbD 4 = true then
                      if xâœÂ².getLsbD 4 = true then (~~~a + 1#5) / (~~~xâœÂ² + 1#5) else ~~~((~~~a + 1#5) / xâœÂ²) + 1#5
                    else if xâœÂ².getLsbD 4 = true then ~~~(a / (~~~xâœÂ² + 1#5)) + 1#5 else a / xâœÂ²)) =
                if (!(!xâœÂ² == 0#5 && !(a == BitVec.intMin 5 && xâœÂ² == 31#5))) = true then none
                else
                  some
                    (if a.getLsbD 4 = true then
                      if xâœÂ².getLsbD 4 = true then (~~~a + 1#5) / (~~~xâœÂ² + 1#5) else ~~~((~~~a + 1#5) / xâœÂ²) + 1#5
                    else if xâœÂ².getLsbD 4 = true then ~~~(a / (~~~xâœÂ² + 1#5)) + 1#5 else a / xâœÂ²)
  [Meta.isDefEq] [0.001063] âŒï¸ match none with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } =>
        if (!(!xâœÂ² == 0#5 && !(xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == 31#5))) = true then none
        else
          some
            (if xâœÂ¹.getLsbD 4 = true then
              if xâœÂ².getLsbD 4 = true then (~~~xâœÂ¹ + 1#5) / (~~~xâœÂ² + 1#5) else ~~~((~~~xâœÂ¹ + 1#5) / xâœÂ²) + 1#5
            else if xâœÂ².getLsbD 4 = true then ~~~(xâœÂ¹ / (~~~xâœÂ² + 1#5)) + 1#5 else xâœÂ¹ / xâœÂ²)
      | some { toFin := âŸ¨0, â‹¯âŸ© } =>
        if (!(!xâœÂ² == 0#5 && !(xâœÂ³ == BitVec.intMin 5 && xâœÂ² == 31#5))) = true then none
        else
          some
            (if xâœÂ³.getLsbD 4 = true then
              if xâœÂ².getLsbD 4 = true then (~~~xâœÂ³ + 1#5) / (~~~xâœÂ² + 1#5) else ~~~((~~~xâœÂ³ + 1#5) / xâœÂ²) + 1#5
            else if xâœÂ².getLsbD 4 = true then ~~~(xâœÂ³ / (~~~xâœÂ² + 1#5)) + 1#5 else xâœÂ³ / xâœÂ²)
  [Meta.isDefEq] [0.001184] âŒï¸ match some { toFin := âŸ¨1, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } =>
        if (!(!xâœÂ² == 0#5 && !(xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == 31#5))) = true then none
        else
          some
            (if xâœÂ¹.getLsbD 4 = true then
              if xâœÂ².getLsbD 4 = true then (~~~xâœÂ¹ + 1#5) / (~~~xâœÂ² + 1#5) else ~~~((~~~xâœÂ¹ + 1#5) / xâœÂ²) + 1#5
            else if xâœÂ².getLsbD 4 = true then ~~~(xâœÂ¹ / (~~~xâœÂ² + 1#5)) + 1#5 else xâœÂ¹ / xâœÂ²)
      | some { toFin := âŸ¨0, â‹¯âŸ© } =>
        if (!(!xâœÂ² == 0#5 && !(xâœÂ³ == BitVec.intMin 5 && xâœÂ² == 31#5))) = true then none
        else
          some
            (if xâœÂ³.getLsbD 4 = true then
              if xâœÂ².getLsbD 4 = true then (~~~xâœÂ³ + 1#5) / (~~~xâœÂ² + 1#5) else ~~~((~~~xâœÂ³ + 1#5) / xâœÂ²) + 1#5
            else if xâœÂ².getLsbD 4 = true then ~~~(xâœÂ³ / (~~~xâœÂ² + 1#5)) + 1#5 else xâœÂ³ / xâœÂ²)
  [Meta.isDefEq] [0.001149] âŒï¸ match some { toFin := âŸ¨0, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } =>
        if (!(!xâœÂ² == 0#5 && !(xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == 31#5))) = true then none
        else
          some
            (if xâœÂ¹.getLsbD 4 = true then
              if xâœÂ².getLsbD 4 = true then (~~~xâœÂ¹ + 1#5) / (~~~xâœÂ² + 1#5) else ~~~((~~~xâœÂ¹ + 1#5) / xâœÂ²) + 1#5
            else if xâœÂ².getLsbD 4 = true then ~~~(xâœÂ¹ / (~~~xâœÂ² + 1#5)) + 1#5 else xâœÂ¹ / xâœÂ²)
      | some { toFin := âŸ¨0, â‹¯âŸ© } =>
        if (!(!xâœÂ² == 0#5 && !(xâœÂ³ == BitVec.intMin 5 && xâœÂ² == 31#5))) = true then none
        else
          some
            (if xâœÂ³.getLsbD 4 = true then
              if xâœÂ².getLsbD 4 = true then (~~~xâœÂ³ + 1#5) / (~~~xâœÂ² + 1#5) else ~~~((~~~xâœÂ³ + 1#5) / xâœÂ²) + 1#5
            else if xâœÂ².getLsbD 4 = true then ~~~(xâœÂ³ / (~~~xâœÂ² + 1#5)) + 1#5 else xâœÂ³ / xâœÂ²)
  [Meta.appBuilder] [0.002261] âœ…ï¸ f: Subsingleton.elim, xs: [hâœ, h]
    [Meta.synthInstance] [0.002188] âœ…ï¸ Subsingleton (Decidable câœ)
      [Meta.synthInstance] [0.002102] âœ…ï¸ apply instSubsingletonDecidable to Subsingleton (Decidable câœ)
        [Meta.synthInstance.tryResolve] [0.002060] âœ…ï¸ Subsingleton (Decidable câœ) â‰Ÿ Subsingleton (Decidable câœ)
          [Meta.isDefEq] [0.001975] âœ…ï¸ ?m.134896 =?= instSubsingletonDecidable câœ
            [Meta.isDefEq.assign] [0.001969] âœ…ï¸ ?m.134896 := instSubsingletonDecidable câœ
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 5
      e_3 : LLVM.IntW 1
      xâœÂ³ xâœÂ² xâœÂ¹ : BitVec 5
      xâœ : BitVec 1
      aâœ :
        Â¬(match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              if (!(!xâœÂ² == 0#5 && !(xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == 31#5))) = true then none
              else
                some
                  (if xâœÂ¹.getLsbD 4 = true then
                    if xâœÂ².getLsbD 4 = true then (~~~xâœÂ¹ + 1#5) / (~~~xâœÂ² + 1#5) else ~~~((~~~xâœÂ¹ + 1#5) / xâœÂ²) + 1#5
                  else if xâœÂ².getLsbD 4 = true then ~~~(xâœÂ¹ / (~~~xâœÂ² + 1#5)) + 1#5 else xâœÂ¹ / xâœÂ²)
            | some { toFin := âŸ¨0, â‹¯âŸ© } =>
              if (!(!xâœÂ² == 0#5 && !(xâœÂ³ == BitVec.intMin 5 && xâœÂ² == 31#5))) = true then none
              else
                some
                  (if xâœÂ³.getLsbD 4 = true then
                    if xâœÂ².getLsbD 4 = true then (~~~xâœÂ³ + 1#5) / (~~~xâœÂ² + 1#5) else ~~~((~~~xâœÂ³ + 1#5) / xâœÂ²) + 1#5
                  else if xâœÂ².getLsbD 4 = true then ~~~(xâœÂ³ / (~~~xâœÂ² + 1#5)) + 1#5 else xâœÂ³ / xâœÂ²)) âŠ‘
            Option.bind
              (match some xâœ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³)
              fun a =>
              if (!(!xâœÂ² == 0#5 && !(a == BitVec.intMin 5 && xâœÂ² == 31#5))) = true then none
              else
                some
                  (if a.getLsbD 4 = true then
                    if xâœÂ².getLsbD 4 = true then (~~~a + 1#5) / (~~~xâœÂ² + 1#5) else ~~~((~~~a + 1#5) / xâœÂ²) + 1#5
                  else if xâœÂ².getLsbD 4 = true then ~~~(a / (~~~xâœÂ² + 1#5)) + 1#5 else a / xâœÂ²)
      âŠ¢ False
  [Meta.isDefEq] [0.001081] âŒï¸ match some { toFin := âŸ¨1, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } =>
        if (!(!xâœÂ² == 0#5 && !(xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == 31#5))) = true then none
        else
          some
            (if xâœÂ¹.getLsbD 4 = true then
              if xâœÂ².getLsbD 4 = true then (~~~xâœÂ¹ + 1#5) / (~~~xâœÂ² + 1#5) else ~~~((~~~xâœÂ¹ + 1#5) / xâœÂ²) + 1#5
            else if xâœÂ².getLsbD 4 = true then ~~~(xâœÂ¹ / (~~~xâœÂ² + 1#5)) + 1#5 else xâœÂ¹ / xâœÂ²)
      | some { toFin := âŸ¨0, â‹¯âŸ© } =>
        if (!(!xâœÂ² == 0#5 && !(xâœÂ³ == BitVec.intMin 5 && xâœÂ² == 31#5))) = true then none
        else
          some
            (if xâœÂ³.getLsbD 4 = true then
              if xâœÂ².getLsbD 4 = true then (~~~xâœÂ³ + 1#5) / (~~~xâœÂ² + 1#5) else ~~~((~~~xâœÂ³ + 1#5) / xâœÂ²) + 1#5
            else if xâœÂ².getLsbD 4 = true then ~~~(xâœÂ³ / (~~~xâœÂ² + 1#5)) + 1#5 else xâœÂ³ / xâœÂ²)
  [Meta.isDefEq] [0.001059] âŒï¸ match some { toFin := âŸ¨0, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } =>
        if (!(!xâœÂ² == 0#5 && !(xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == 31#5))) = true then none
        else
          some
            (if xâœÂ¹.getLsbD 4 = true then
              if xâœÂ².getLsbD 4 = true then (~~~xâœÂ¹ + 1#5) / (~~~xâœÂ² + 1#5) else ~~~((~~~xâœÂ¹ + 1#5) / xâœÂ²) + 1#5
            else if xâœÂ².getLsbD 4 = true then ~~~(xâœÂ¹ / (~~~xâœÂ² + 1#5)) + 1#5 else xâœÂ¹ / xâœÂ²)
      | some { toFin := âŸ¨0, â‹¯âŸ© } =>
        if (!(!xâœÂ² == 0#5 && !(xâœÂ³ == BitVec.intMin 5 && xâœÂ² == 31#5))) = true then none
        else
          some
            (if xâœÂ³.getLsbD 4 = true then
              if xâœÂ².getLsbD 4 = true then (~~~xâœÂ³ + 1#5) / (~~~xâœÂ² + 1#5) else ~~~((~~~xâœÂ³ + 1#5) / xâœÂ²) + 1#5
            else if xâœÂ².getLsbD 4 = true then ~~~(xâœÂ³ / (~~~xâœÂ² + 1#5)) + 1#5 else xâœÂ³ / xâœÂ²)
  [Meta.isDefEq] [0.001063] âŒï¸ match some { toFin := âŸ¨1, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³
  [Meta.isDefEq] [0.001039] âŒï¸ match some { toFin := âŸ¨0, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³
  [Meta.isDefEq] [0.002310] âŒï¸ ~~~?a + ?a =?= ~~~(a / (~~~xâœÂ² + 1#5)) + 1#5
    [Meta.isDefEq] [0.002040] âœ…ï¸ ~~~?a =?= ~~~(a / (~~~xâœÂ² + 1#5))
      [Meta.isDefEq] [0.001967] âœ…ï¸ ?a =?= a / (~~~xâœÂ² + 1#5)
        [Meta.isDefEq.assign] [0.001963] âœ…ï¸ ?a := a / (~~~xâœÂ² + 1#5)
          [Meta.isDefEq.assign.checkTypes] [0.001952] âœ…ï¸ (?a : BitVec ?w) := (a / (~~~xâœÂ² + 1#5) : BitVec 5)
            [Meta.isDefEq] [0.001945] âœ…ï¸ BitVec ?w =?= BitVec 5
  [Meta.isDefEq] [0.002710] âŒï¸ match none with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³
    [Meta.whnf] [0.002122] Non-easy whnf: (fun motive c? h_1 h_2 h_3 =>
            Option.casesOn c? (h_1 ()) fun val =>
              BitVec.casesOn val fun toFin =>
                Fin.casesOn toFin fun val isLt =>
                  Nat.casesOn (motive := fun x => (isLt : x < 2 ^ 1) â†’ motive (some { toFin := âŸ¨x, isLtâŸ© })) val
                    (fun isLt => h_3 ())
                    (fun n isLt =>
                      Nat.casesOn (motive := fun x =>
                        (isLt : x.succ < 2 ^ 1) â†’ motive (some { toFin := âŸ¨x.succ, isLtâŸ© })) n (fun isLt => h_2 ())
                        (fun n isLt => â‹¯.elim) isLt)
                    isLt)
          (fun c? => LLVM.IntW 5) (some xâœ) h_1 h_2 h_3
  [Meta.isDefEq] [0.001220] âœ…ï¸ if ?b then ?x
      else
        ?y =?= if a.getLsbD 4 = true then
        if xâœÂ².getLsbD 4 = true then (~~~a + 1#5) / (~~~xâœÂ² + 1#5) else ~~~((~~~a + 1#5) / xâœÂ²) + 1#5
      else if xâœÂ².getLsbD 4 = true then ~~~(a / (~~~xâœÂ² + 1#5)) + 1#5 else a / xâœÂ²
    [Meta.isDefEq] [0.001102] âœ…ï¸ ?Î± =?= BitVec 5
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:47:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:47:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:47:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:47:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:47:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:47:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:41:8: error: (kernel) declaration has metavariables 'srem_common_divisor_defined_cond_thm'
[bv] [0.261866] Normalizing goal
  [Meta.synthInstance] [0.003068] âœ…ï¸ Decidable
        ((match some xâœ with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } =>
            Option.map (fun div => xâœÂ¹ - div * xâœÂ²)
              (if (xâœÂ² == 0 || 5 != 1 && xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == -1) = true then none else some (xâœÂ¹.sdiv xâœÂ²))
          | some { toFin := âŸ¨0, â‹¯âŸ© } =>
            Option.map (fun div => xâœÂ³ - div * xâœÂ²)
              (if (xâœÂ² == 0 || 5 != 1 && xâœÂ³ == BitVec.intMin 5 && xâœÂ² == -1) = true then none
              else some (xâœÂ³.sdiv xâœÂ²))) âŠ‘
          Option.bind
            (match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³)
            fun a =>
            Option.map (fun div => a - div * xâœÂ²)
              (if (xâœÂ² == 0 || 5 != 1 && a == BitVec.intMin 5 && xâœÂ² == -1) = true then none else some (a.sdiv xâœÂ²)))
    [Meta.check] [0.001794] âœ…ï¸ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (match some xâœ with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } =>
            Option.map (fun div => xâœÂ¹ - div * xâœÂ²)
              (if (xâœÂ² == 0 || 5 != 1 && xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == -1) = true then none else some (xâœÂ¹.sdiv xâœÂ²))
          | some { toFin := âŸ¨0, â‹¯âŸ© } =>
            Option.map (fun div => xâœÂ³ - div * xâœÂ²)
              (if (xâœÂ² == 0 || 5 != 1 && xâœÂ³ == BitVec.intMin 5 && xâœÂ² == -1) = true then none
              else some (xâœÂ³.sdiv xâœÂ²)))
          (Option.bind
            (match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³)
            fun a =>
            Option.map (fun div => a - div * xâœÂ²)
              (if (xâœÂ² == 0 || 5 != 1 && a == BitVec.intMin 5 && xâœÂ² == -1) = true then none else some (a.sdiv xâœÂ²)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 5
      e_3 : LLVM.IntW 1
      xâœÂ³ xâœÂ² xâœÂ¹ : BitVec 5
      xâœ : BitVec 1
      aâœ :
        Â¬(match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              Option.map (fun div => xâœÂ¹ - div * xâœÂ²)
                (if (xâœÂ² == 0 || 5 != 1 && xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == -1) = true then none
                else some (xâœÂ¹.sdiv xâœÂ²))
            | some { toFin := âŸ¨0, â‹¯âŸ© } =>
              Option.map (fun div => xâœÂ³ - div * xâœÂ²)
                (if (xâœÂ² == 0 || 5 != 1 && xâœÂ³ == BitVec.intMin 5 && xâœÂ² == -1) = true then none
                else some (xâœÂ³.sdiv xâœÂ²))) âŠ‘
            Option.bind
              (match some xâœ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³)
              fun a =>
              Option.map (fun div => a - div * xâœÂ²)
                (if (xâœÂ² == 0 || 5 != 1 && a == BitVec.intMin 5 && xâœÂ² == -1) = true then none else some (a.sdiv xâœÂ²))
      âŠ¢ False
  [Meta.isDefEq] [0.002251] âœ…ï¸ ?hâ‚ =?= congrArg (fun x => x = true)
        (Eq.trans (congrArg (fun x => xâœÂ² == 0#5 || x && xâœÂ² == 31#5) (Bool.true_and (xâœÂ³ == BitVec.intMin 5)))
          (Std.Tactic.BVDecide.Normalize.Bool.or_elim (xâœÂ² == 0#5) (xâœÂ³ == BitVec.intMin 5 && xâœÂ² == 31#5)))
    [Meta.isDefEq.assign] [0.002249] âœ…ï¸ ?hâ‚ := congrArg (fun x => x = true)
          (Eq.trans (congrArg (fun x => xâœÂ² == 0#5 || x && xâœÂ² == 31#5) (Bool.true_and (xâœÂ³ == BitVec.intMin 5)))
            (Std.Tactic.BVDecide.Normalize.Bool.or_elim (xâœÂ² == 0#5) (xâœÂ³ == BitVec.intMin 5 && xâœÂ² == 31#5)))
      [Meta.isDefEq.assign.checkTypes] [0.002237] âœ…ï¸ (?hâ‚ : ((xâœÂ² == 0 ||
                5 != 1 && xâœÂ³ == BitVec.intMin 5 && xâœÂ² == -1) =
              true) =
            ((!(!xâœÂ² == 0#5 && !(xâœÂ³ == BitVec.intMin 5 && xâœÂ² == 31#5))) =
              true)) := (congrArg (fun x => x = true)
            (Eq.trans (congrArg (fun x => xâœÂ² == 0#5 || x && xâœÂ² == 31#5) (Bool.true_and (xâœÂ³ == BitVec.intMin 5)))
              (Std.Tactic.BVDecide.Normalize.Bool.or_elim (xâœÂ² == 0#5)
                (xâœÂ³ == BitVec.intMin 5 &&
                  xâœÂ² ==
                    31#5))) : ((xâœÂ² == 0#5 || true && xâœÂ³ == BitVec.intMin 5 && xâœÂ² == 31#5) = true) =
            ((!(!xâœÂ² == 0#5 && !(xâœÂ³ == BitVec.intMin 5 && xâœÂ² == 31#5))) = true))
        [Meta.isDefEq] [0.002234] âœ…ï¸ ((xâœÂ² == 0 || 5 != 1 && xâœÂ³ == BitVec.intMin 5 && xâœÂ² == -1) = true) =
              ((!(!xâœÂ² == 0#5 && !(xâœÂ³ == BitVec.intMin 5 && xâœÂ² == 31#5))) =
                true) =?= ((xâœÂ² == 0#5 || true && xâœÂ³ == BitVec.intMin 5 && xâœÂ² == 31#5) = true) =
              ((!(!xâœÂ² == 0#5 && !(xâœÂ³ == BitVec.intMin 5 && xâœÂ² == 31#5))) = true)
          [Meta.isDefEq] [0.002217] âœ…ï¸ (xâœÂ² == 0 || 5 != 1 && xâœÂ³ == BitVec.intMin 5 && xâœÂ² == -1) =
                true =?= (xâœÂ² == 0#5 || true && xâœÂ³ == BitVec.intMin 5 && xâœÂ² == 31#5) = true
            [Meta.isDefEq] [0.002204] âœ…ï¸ xâœÂ² == 0 ||
                  5 != 1 && xâœÂ³ == BitVec.intMin 5 &&
                    xâœÂ² == -1 =?= xâœÂ² == 0#5 || true && xâœÂ³ == BitVec.intMin 5 && xâœÂ² == 31#5
              [Meta.isDefEq.delta] [0.002192] âœ…ï¸ xâœÂ² == 0 ||
                    5 != 1 && xâœÂ³ == BitVec.intMin 5 &&
                      xâœÂ² == -1 =?= xâœÂ² == 0#5 || true && xâœÂ³ == BitVec.intMin 5 && xâœÂ² == 31#5
                [Meta.isDefEq] [0.002024] âœ…ï¸ 5 != 1 && xâœÂ³ == BitVec.intMin 5 &&
                      xâœÂ² == -1 =?= true && xâœÂ³ == BitVec.intMin 5 && xâœÂ² == 31#5
                  [Meta.isDefEq.delta] [0.002014] âœ…ï¸ 5 != 1 && xâœÂ³ == BitVec.intMin 5 &&
                        xâœÂ² == -1 =?= true && xâœÂ³ == BitVec.intMin 5 && xâœÂ² == 31#5
                    [Meta.isDefEq] [0.001936] âœ…ï¸ xâœÂ² == -1 =?= xâœÂ² == 31#5
                      [Meta.isDefEq] [0.001922] âœ…ï¸ instBEqOfDecidableEq.1 xâœÂ² (-1) =?= instBEqOfDecidableEq.1 xâœÂ² 31#5
                        [Meta.isDefEq] [0.001898] âœ…ï¸ Decidable.decide (xâœÂ² = -1) =?= Decidable.decide (xâœÂ² = 31#5)
                          [Meta.isDefEq.delta] [0.001889] âœ…ï¸ Decidable.decide
                                (xâœÂ² = -1) =?= Decidable.decide (xâœÂ² = 31#5)
                            [Meta.isDefEq] [0.001855] âœ…ï¸ xâœÂ² = -1 =?= xâœÂ² = 31#5
                              [Meta.isDefEq] [0.001841] âœ…ï¸ -1 =?= 31#5
                                [Meta.isDefEq] [0.001819] âœ…ï¸ -1 =?= { toFin := Fin.ofNat' (2 ^ 5) 31 }
                                  [Meta.isDefEq] [0.001810] âœ…ï¸ BitVec.instNeg.1 1 =?= { toFin := Fin.ofNat' (2 ^ 5) 31 }
                                    [Meta.isDefEq] [0.001796] âœ…ï¸ BitVec.neg 1 =?= { toFin := Fin.ofNat' (2 ^ 5) 31 }
                                      [Meta.isDefEq] [0.001786] âœ…ï¸ BitVec.ofNat 5
                                            (2 ^ 5 - BitVec.toNat 1) =?= { toFin := Fin.ofNat' (2 ^ 5) 31 }
                                        [Meta.isDefEq] [0.001777] âœ…ï¸ {
                                              toFin :=
                                                Fin.ofNat' (2 ^ 5)
                                                  (2 ^ 5 - BitVec.toNat 1) } =?= { toFin := Fin.ofNat' (2 ^ 5) 31 }
                                          [Meta.isDefEq] [0.001763] âœ…ï¸ Fin.ofNat' (2 ^ 5)
                                                (2 ^ 5 - BitVec.toNat 1) =?= Fin.ofNat' (2 ^ 5) 31
  [Meta.isDefEq] [0.001864] âœ…ï¸ ?hâ‚ƒ =?= fun a_1 =>
        congrArg some
          (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv a xâœÂ²)
            (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last a))
              (fun a_2 =>
                ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last xâœÂ²))
                  (fun a_3 => congr (congrArg HDiv.hDiv (BitVec.neg_eq_not_add a)) (BitVec.neg_eq_not_add xâœÂ²))
                  fun a_3 =>
                  Eq.trans (congrArg (fun x => -(x / xâœÂ²)) (BitVec.neg_eq_not_add a))
                    (BitVec.neg_eq_not_add ((~~~a + 1#5) / xâœÂ²)))
              fun a_2 =>
              ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last xâœÂ²))
                (fun a_3 =>
                  Eq.trans (congrArg (fun x => -(a / x)) (BitVec.neg_eq_not_add xâœÂ²))
                    (BitVec.neg_eq_not_add (a / (~~~xâœÂ² + 1#5))))
                fun a_3 => Eq.refl (a / xâœÂ²)))
    [Meta.isDefEq.assign] [0.001859] âœ…ï¸ ?hâ‚ƒ := fun a_1 =>
          congrArg some
            (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv a xâœÂ²)
              (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last a))
                (fun a_2 =>
                  ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last xâœÂ²))
                    (fun a_3 => congr (congrArg HDiv.hDiv (BitVec.neg_eq_not_add a)) (BitVec.neg_eq_not_add xâœÂ²))
                    fun a_3 =>
                    Eq.trans (congrArg (fun x => -(x / xâœÂ²)) (BitVec.neg_eq_not_add a))
                      (BitVec.neg_eq_not_add ((~~~a + 1#5) / xâœÂ²)))
                fun a_2 =>
                ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last xâœÂ²))
                  (fun a_3 =>
                    Eq.trans (congrArg (fun x => -(a / x)) (BitVec.neg_eq_not_add xâœÂ²))
                      (BitVec.neg_eq_not_add (a / (~~~xâœÂ² + 1#5))))
                  fun a_3 => Eq.refl (a / xâœÂ²)))
  [Meta.isDefEq] [0.001869] âœ…ï¸ if ?b then ?x
      else ?y =?= if xâœÂ².getLsbD 4 = true then (~~~a + 1#5) / (~~~xâœÂ² + 1#5) else ~~~((~~~a + 1#5) / xâœÂ²) + 1#5
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 5
      e_3 : LLVM.IntW 1
      xâœÂ³ xâœÂ² xâœÂ¹ : BitVec 5
      xâœ : BitVec 1
      aâœ :
        Â¬(match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              Option.map (fun div => xâœÂ¹ + (~~~(div * xâœÂ²) + 1#5))
                (if (!(!xâœÂ² == 0#5 && !(xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == 31#5))) = true then none
                else
                  some
                    (if xâœÂ¹.getLsbD 4 = true then
                      if xâœÂ².getLsbD 4 = true then (~~~xâœÂ¹ + 1#5) / (~~~xâœÂ² + 1#5) else ~~~((~~~xâœÂ¹ + 1#5) / xâœÂ²) + 1#5
                    else if xâœÂ².getLsbD 4 = true then ~~~(xâœÂ¹ / (~~~xâœÂ² + 1#5)) + 1#5 else xâœÂ¹ / xâœÂ²))
            | some { toFin := âŸ¨0, â‹¯âŸ© } =>
              Option.map (fun div => xâœÂ³ + (~~~(div * xâœÂ²) + 1#5))
                (if (!(!xâœÂ² == 0#5 && !(xâœÂ³ == BitVec.intMin 5 && xâœÂ² == 31#5))) = true then none
                else
                  some
                    (if xâœÂ³.getLsbD 4 = true then
                      if xâœÂ².getLsbD 4 = true then (~~~xâœÂ³ + 1#5) / (~~~xâœÂ² + 1#5) else ~~~((~~~xâœÂ³ + 1#5) / xâœÂ²) + 1#5
                    else if xâœÂ².getLsbD 4 = true then ~~~(xâœÂ³ / (~~~xâœÂ² + 1#5)) + 1#5 else xâœÂ³ / xâœÂ²))) âŠ‘
            Option.bind
              (match some xâœ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³)
              fun a =>
              Option.map (fun div => a + (~~~(div * xâœÂ²) + 1#5))
                (if (!(!xâœÂ² == 0#5 && !(a == BitVec.intMin 5 && xâœÂ² == 31#5))) = true then none
                else
                  some
                    (if a.getLsbD 4 = true then
                      if xâœÂ².getLsbD 4 = true then (~~~a + 1#5) / (~~~xâœÂ² + 1#5) else ~~~((~~~a + 1#5) / xâœÂ²) + 1#5
                    else if xâœÂ².getLsbD 4 = true then ~~~(a / (~~~xâœÂ² + 1#5)) + 1#5 else a / xâœÂ²))
      âŠ¢ False
  [Meta.appBuilder] [0.001881] âœ…ï¸ f: Subsingleton.elim, xs: [hâœ, h]
    [Meta.isDefEq] [0.001701] âœ…ï¸ ?Î± =?= Decidable câœ
      [Meta.isDefEq.assign] [0.001696] âœ…ï¸ ?Î± := Decidable câœ
        [Meta.isDefEq.assign.checkTypes] [0.001688] âœ…ï¸ (?Î± : Sort ?u.203881) := (Decidable câœ : Type)
          [Meta.isDefEq] [0.001683] âœ…ï¸ Sort ?u.203881 =?= Type
  [Meta.isDefEq] [0.002037] âŒï¸ ?a + ?a =?= ~~~xâœÂ³ + 1#5
    [Meta.isDefEq] [0.001911] âŒï¸ instHAdd =?= instHAdd
      [Meta.isDefEq] [0.001825] âŒï¸ { hAdd := fun a b => Add.add a b } =?= { hAdd := fun a b => Add.add a b }
        [Meta.isDefEq] [0.001788] âŒï¸ fun a b => Add.add a b =?= fun a b => Add.add a b
  [Meta.isDefEq] [0.001914] âœ…ï¸ if ?b then ?x
      else
        ?y =?= if (!(!xâœÂ² == 0#5 && !(a == BitVec.intMin 5 && xâœÂ² == 31#5))) = true then none
      else
        some
          (if a.getLsbD 4 = true then
            if xâœÂ².getLsbD 4 = true then (~~~a + 1#5) / (~~~xâœÂ² + 1#5) else ~~~((~~~a + 1#5) / xâœÂ²) + 1#5
          else if xâœÂ².getLsbD 4 = true then ~~~(a / (~~~xâœÂ² + 1#5)) + 1#5 else a / xâœÂ²)
    [Meta.isDefEq] [0.001775] âœ…ï¸ ?s =?= instDecidableEqBool (!(!xâœÂ² == 0#5 && !(a == BitVec.intMin 5 && xâœÂ² == 31#5)))
          true
      [Meta.isDefEq.assign] [0.001772] âœ…ï¸ ?s := instDecidableEqBool
            (!(!xâœÂ² == 0#5 && !(a == BitVec.intMin 5 && xâœÂ² == 31#5))) true
        [Meta.isDefEq.assign.checkTypes] [0.001760] âœ…ï¸ (?s : Decidable
              ((!(!xâœÂ² == 0#5 && !(a == BitVec.intMin 5 && xâœÂ² == 31#5))) =
                true)) := (instDecidableEqBool (!(!xâœÂ² == 0#5 && !(a == BitVec.intMin 5 && xâœÂ² == 31#5)))
              true : Decidable ((!(!xâœÂ² == 0#5 && !(a == BitVec.intMin 5 && xâœÂ² == 31#5))) = true))
  [Meta.isDefEq] [0.001920] âŒï¸ ~~~?a + ?a =?= ~~~(a / (~~~xâœÂ² + 1#5)) + 1#5
    [Meta.isDefEq] [0.001746] âŒï¸ instHAdd =?= instHAdd
      [Meta.isDefEq] [0.001707] âŒï¸ { hAdd := fun a b => Add.add a b } =?= { hAdd := fun a b => Add.add a b }
        [Meta.isDefEq] [0.001675] âŒï¸ fun a b => Add.add a b =?= fun a b => Add.add a b
  [Meta.isDefEq] [0.001963] âŒï¸ ?a + ?a =?= ~~~(a / (~~~xâœÂ² + 1#5)) + 1#5
    [Meta.isDefEq] [0.001758] âœ…ï¸ ?a =?= ~~~(a / (~~~xâœÂ² + 1#5))
      [Meta.isDefEq.assign] [0.001755] âœ…ï¸ ?a := ~~~(a / (~~~xâœÂ² + 1#5))
        [Meta.isDefEq.assign.checkTypes] [0.001745] âœ…ï¸ (?a : BitVec ?w) := (~~~(a / (~~~xâœÂ² + 1#5)) : BitVec 5)
          [Meta.isDefEq] [0.001738] âœ…ï¸ BitVec ?w =?= BitVec 5
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:57:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:57:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:57:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:57:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:57:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:57:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:51:8: error: (kernel) declaration has metavariables 'udiv_common_divisor_defined_cond_thm'
[bv] [0.059853] Normalizing goal
  [Meta.synthInstance] [0.001389] âœ…ï¸ Decidable
        ((match some xâœ with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } => if xâœÂ² = 0 then none else some (xâœÂ¹ / xâœÂ²)
          | some { toFin := âŸ¨0, â‹¯âŸ© } => if xâœÂ² = 0 then none else some (xâœÂ³ / xâœÂ²)) âŠ‘
          Option.bind
            (match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³)
            fun a => if xâœÂ² = 0 then none else some (a / xâœÂ²))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 5
      e_3 : LLVM.IntW 1
      xâœÂ³ xâœÂ² xâœÂ¹ : BitVec 5
      xâœ : BitVec 1
      aâœ :
        Â¬(match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => if xâœÂ² = 0 then none else some (xâœÂ¹ / xâœÂ²)
            | some { toFin := âŸ¨0, â‹¯âŸ© } => if xâœÂ² = 0 then none else some (xâœÂ³ / xâœÂ²)) âŠ‘
            Option.bind
              (match some xâœ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³)
              fun a => if xâœÂ² = 0 then none else some (a / xâœÂ²)
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 5
      e_3 : LLVM.IntW 1
      xâœÂ³ xâœÂ² xâœÂ¹ : BitVec 5
      xâœ : BitVec 1
      aâœ :
        Â¬(match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ¹ / xâœÂ²)
            | some { toFin := âŸ¨0, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ³ / xâœÂ²)) âŠ‘
            Option.bind
              (match some xâœ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³)
              fun a => if (xâœÂ² == 0#5) = true then none else some (a / xâœÂ²)
      âŠ¢ False
  [Meta.isDefEq] [0.001185] âŒï¸ match some { toFin := âŸ¨0, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:67:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:67:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:67:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:67:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:67:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:67:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:61:8: error: (kernel) declaration has metavariables 'urem_common_divisor_defined_cond_thm'
[bv] [0.061268] Normalizing goal
  [Meta.synthInstance] [0.001368] âœ…ï¸ Decidable
        ((match some xâœ with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } => if xâœÂ² = 0 then none else some (xâœÂ¹ % xâœÂ²)
          | some { toFin := âŸ¨0, â‹¯âŸ© } => if xâœÂ² = 0 then none else some (xâœÂ³ % xâœÂ²)) âŠ‘
          Option.bind
            (match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³)
            fun a => if xâœÂ² = 0 then none else some (a % xâœÂ²))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 5
      e_3 : LLVM.IntW 1
      xâœÂ³ xâœÂ² xâœÂ¹ : BitVec 5
      xâœ : BitVec 1
      aâœ :
        Â¬(match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => if xâœÂ² = 0 then none else some (xâœÂ¹ % xâœÂ²)
            | some { toFin := âŸ¨0, â‹¯âŸ© } => if xâœÂ² = 0 then none else some (xâœÂ³ % xâœÂ²)) âŠ‘
            Option.bind
              (match some xâœ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³)
              fun a => if xâœÂ² = 0 then none else some (a % xâœÂ²)
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 5
      e_3 : LLVM.IntW 1
      xâœÂ³ xâœÂ² xâœÂ¹ : BitVec 5
      xâœ : BitVec 1
      aâœ :
        Â¬(match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ¹ % xâœÂ²)
            | some { toFin := âŸ¨0, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ³ % xâœÂ²)) âŠ‘
            Option.bind
              (match some xâœ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³)
              fun a => if (xâœÂ² == 0#5) = true then none else some (a % xâœÂ²)
      âŠ¢ False
  [Meta.isDefEq] [0.001780] âŒï¸ match some { toFin := âŸ¨1, â‹¯âŸ© } with
      | none => ?h_1 ()
      | some { toFin := âŸ¨1, â‹¯âŸ© } => ?h_2 ()
      | some { toFin := âŸ¨0, â‹¯âŸ© } => ?h_3 () =?= match some xâœ with
      | none => none
      | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ¹
      | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³
    [Meta.whnf] [0.001153] Non-easy whnf: (fun motive c? h_1 h_2 h_3 =>
            Option.casesOn c? (h_1 ()) fun val =>
              BitVec.casesOn val fun toFin =>
                Fin.casesOn toFin fun val isLt =>
                  Nat.casesOn (motive := fun x => (isLt : x < 2 ^ 1) â†’ motive (some { toFin := âŸ¨x, isLtâŸ© })) val
                    (fun isLt => h_3 ())
                    (fun n isLt =>
                      Nat.casesOn (motive := fun x =>
                        (isLt : x.succ < 2 ^ 1) â†’ motive (some { toFin := âŸ¨x.succ, isLtâŸ© })) n (fun isLt => h_2 ())
                        (fun n isLt => â‹¯.elim) isLt)
                    isLt)
          ?motive (some { toFin := âŸ¨1, â‹¯âŸ© }) h_1 h_2 h_3
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:77:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:77:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:77:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:77:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:77:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:77:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:77:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:77:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:71:8: error: (kernel) declaration has metavariables 'sdiv_common_dividend_defined_cond_thm'
[bv] [0.180972] Normalizing goal
  [Meta.synthInstance] [0.001592] âœ…ï¸ Decidable
        ((match some xâœ with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } =>
            if (xâœÂ² == 0 || 5 != 1 && xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == -1) = true then none else some (xâœÂ¹.sdiv xâœÂ²)
          | some { toFin := âŸ¨0, â‹¯âŸ© } =>
            if (xâœÂ³ == 0 || 5 != 1 && xâœÂ¹ == BitVec.intMin 5 && xâœÂ³ == -1) = true then none else some (xâœÂ¹.sdiv xâœÂ³)) âŠ‘
          Option.bind
            (match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ²
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³)
            fun y' =>
            if (y' == 0 || 5 != 1 && xâœÂ¹ == BitVec.intMin 5 && y' == -1) = true then none else some (xâœÂ¹.sdiv y'))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 5
      e_3 : LLVM.IntW 1
      xâœÂ³ xâœÂ² xâœÂ¹ : BitVec 5
      xâœ : BitVec 1
      aâœ :
        Â¬(match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              if (xâœÂ² == 0 || 5 != 1 && xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == -1) = true then none else some (xâœÂ¹.sdiv xâœÂ²)
            | some { toFin := âŸ¨0, â‹¯âŸ© } =>
              if (xâœÂ³ == 0 || 5 != 1 && xâœÂ¹ == BitVec.intMin 5 && xâœÂ³ == -1) = true then none
              else some (xâœÂ¹.sdiv xâœÂ³)) âŠ‘
            Option.bind
              (match some xâœ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ²
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³)
              fun y' =>
              if (y' == 0 || 5 != 1 && xâœÂ¹ == BitVec.intMin 5 && y' == -1) = true then none else some (xâœÂ¹.sdiv y')
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 5
      e_3 : LLVM.IntW 1
      xâœÂ³ xâœÂ² xâœÂ¹ : BitVec 5
      xâœ : BitVec 1
      aâœ :
        Â¬(match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              if (!(!xâœÂ² == 0#5 && !(xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == 31#5))) = true then none
              else
                some
                  (if xâœÂ¹.getLsbD 4 = true then
                    if xâœÂ².getLsbD 4 = true then (~~~xâœÂ¹ + 1#5) / (~~~xâœÂ² + 1#5) else ~~~((~~~xâœÂ¹ + 1#5) / xâœÂ²) + 1#5
                  else if xâœÂ².getLsbD 4 = true then ~~~(xâœÂ¹ / (~~~xâœÂ² + 1#5)) + 1#5 else xâœÂ¹ / xâœÂ²)
            | some { toFin := âŸ¨0, â‹¯âŸ© } =>
              if (!(!xâœÂ³ == 0#5 && !(xâœÂ¹ == BitVec.intMin 5 && xâœÂ³ == 31#5))) = true then none
              else
                some
                  (if xâœÂ¹.getLsbD 4 = true then
                    if xâœÂ³.getLsbD 4 = true then (~~~xâœÂ¹ + 1#5) / (~~~xâœÂ³ + 1#5) else ~~~((~~~xâœÂ¹ + 1#5) / xâœÂ³) + 1#5
                  else if xâœÂ³.getLsbD 4 = true then ~~~(xâœÂ¹ / (~~~xâœÂ³ + 1#5)) + 1#5 else xâœÂ¹ / xâœÂ³)) âŠ‘
            Option.bind
              (match some xâœ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ²
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³)
              fun a =>
              if (!(!a == 0#5 && !(xâœÂ¹ == BitVec.intMin 5 && a == 31#5))) = true then none
              else
                some
                  (if xâœÂ¹.getLsbD 4 = true then
                    if a.getLsbD 4 = true then (~~~xâœÂ¹ + 1#5) / (~~~a + 1#5) else ~~~((~~~xâœÂ¹ + 1#5) / a) + 1#5
                  else if a.getLsbD 4 = true then ~~~(xâœÂ¹ / (~~~a + 1#5)) + 1#5 else xâœÂ¹ / a)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:87:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:87:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:87:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:87:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:87:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:87:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:87:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:87:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:81:8: error: (kernel) declaration has metavariables 'srem_common_dividend_defined_cond_thm'
[bv] [0.210127] Normalizing goal
  [Meta.synthInstance] [0.001802] âœ…ï¸ Decidable
        ((match some xâœ with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } =>
            Option.map (fun div => xâœÂ¹ - div * xâœÂ²)
              (if (xâœÂ² == 0 || 5 != 1 && xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == -1) = true then none else some (xâœÂ¹.sdiv xâœÂ²))
          | some { toFin := âŸ¨0, â‹¯âŸ© } =>
            Option.map (fun div => xâœÂ¹ - div * xâœÂ³)
              (if (xâœÂ³ == 0 || 5 != 1 && xâœÂ¹ == BitVec.intMin 5 && xâœÂ³ == -1) = true then none
              else some (xâœÂ¹.sdiv xâœÂ³))) âŠ‘
          Option.bind
            (match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ²
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³)
            fun y' =>
            Option.map (fun div => xâœÂ¹ - div * y')
              (if (y' == 0 || 5 != 1 && xâœÂ¹ == BitVec.intMin 5 && y' == -1) = true then none else some (xâœÂ¹.sdiv y')))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 5
      e_3 : LLVM.IntW 1
      xâœÂ³ xâœÂ² xâœÂ¹ : BitVec 5
      xâœ : BitVec 1
      aâœ :
        Â¬(match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              Option.map (fun div => xâœÂ¹ - div * xâœÂ²)
                (if (xâœÂ² == 0 || 5 != 1 && xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == -1) = true then none
                else some (xâœÂ¹.sdiv xâœÂ²))
            | some { toFin := âŸ¨0, â‹¯âŸ© } =>
              Option.map (fun div => xâœÂ¹ - div * xâœÂ³)
                (if (xâœÂ³ == 0 || 5 != 1 && xâœÂ¹ == BitVec.intMin 5 && xâœÂ³ == -1) = true then none
                else some (xâœÂ¹.sdiv xâœÂ³))) âŠ‘
            Option.bind
              (match some xâœ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ²
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³)
              fun y' =>
              Option.map (fun div => xâœÂ¹ - div * y')
                (if (y' == 0 || 5 != 1 && xâœÂ¹ == BitVec.intMin 5 && y' == -1) = true then none else some (xâœÂ¹.sdiv y'))
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 5
      e_3 : LLVM.IntW 1
      xâœÂ³ xâœÂ² xâœÂ¹ : BitVec 5
      xâœ : BitVec 1
      aâœ :
        Â¬(match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              Option.map (fun div => xâœÂ¹ + (~~~(div * xâœÂ²) + 1#5))
                (if (!(!xâœÂ² == 0#5 && !(xâœÂ¹ == BitVec.intMin 5 && xâœÂ² == 31#5))) = true then none
                else
                  some
                    (if xâœÂ¹.getLsbD 4 = true then
                      if xâœÂ².getLsbD 4 = true then (~~~xâœÂ¹ + 1#5) / (~~~xâœÂ² + 1#5) else ~~~((~~~xâœÂ¹ + 1#5) / xâœÂ²) + 1#5
                    else if xâœÂ².getLsbD 4 = true then ~~~(xâœÂ¹ / (~~~xâœÂ² + 1#5)) + 1#5 else xâœÂ¹ / xâœÂ²))
            | some { toFin := âŸ¨0, â‹¯âŸ© } =>
              Option.map (fun div => xâœÂ¹ + (~~~(div * xâœÂ³) + 1#5))
                (if (!(!xâœÂ³ == 0#5 && !(xâœÂ¹ == BitVec.intMin 5 && xâœÂ³ == 31#5))) = true then none
                else
                  some
                    (if xâœÂ¹.getLsbD 4 = true then
                      if xâœÂ³.getLsbD 4 = true then (~~~xâœÂ¹ + 1#5) / (~~~xâœÂ³ + 1#5) else ~~~((~~~xâœÂ¹ + 1#5) / xâœÂ³) + 1#5
                    else if xâœÂ³.getLsbD 4 = true then ~~~(xâœÂ¹ / (~~~xâœÂ³ + 1#5)) + 1#5 else xâœÂ¹ / xâœÂ³))) âŠ‘
            Option.bind
              (match some xâœ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ²
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³)
              fun a =>
              Option.map (fun div => xâœÂ¹ + (~~~(div * a) + 1#5))
                (if (!(!a == 0#5 && !(xâœÂ¹ == BitVec.intMin 5 && a == 31#5))) = true then none
                else
                  some
                    (if xâœÂ¹.getLsbD 4 = true then
                      if a.getLsbD 4 = true then (~~~xâœÂ¹ + 1#5) / (~~~a + 1#5) else ~~~((~~~xâœÂ¹ + 1#5) / a) + 1#5
                    else if a.getLsbD 4 = true then ~~~(xâœÂ¹ / (~~~a + 1#5)) + 1#5 else xâœÂ¹ / a))
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:97:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:97:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:97:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:97:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:97:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:97:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:97:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:97:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:91:8: error: (kernel) declaration has metavariables 'udiv_common_dividend_defined_cond_thm'
[bv] [0.064957] Normalizing goal
  [Meta.synthInstance] [0.001423] âœ…ï¸ Decidable
        ((match some xâœ with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } => if xâœÂ² = 0 then none else some (xâœÂ¹ / xâœÂ²)
          | some { toFin := âŸ¨0, â‹¯âŸ© } => if xâœÂ³ = 0 then none else some (xâœÂ¹ / xâœÂ³)) âŠ‘
          Option.bind
            (match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ²
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³)
            fun y' => if y' = 0 then none else some (xâœÂ¹ / y'))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 5
      e_3 : LLVM.IntW 1
      xâœÂ³ xâœÂ² xâœÂ¹ : BitVec 5
      xâœ : BitVec 1
      aâœ :
        Â¬(match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => if xâœÂ² = 0 then none else some (xâœÂ¹ / xâœÂ²)
            | some { toFin := âŸ¨0, â‹¯âŸ© } => if xâœÂ³ = 0 then none else some (xâœÂ¹ / xâœÂ³)) âŠ‘
            Option.bind
              (match some xâœ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ²
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³)
              fun y' => if y' = 0 then none else some (xâœÂ¹ / y')
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 5
      e_3 : LLVM.IntW 1
      xâœÂ³ xâœÂ² xâœÂ¹ : BitVec 5
      xâœ : BitVec 1
      aâœ :
        Â¬(match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ¹ / xâœÂ²)
            | some { toFin := âŸ¨0, â‹¯âŸ© } => if (xâœÂ³ == 0#5) = true then none else some (xâœÂ¹ / xâœÂ³)) âŠ‘
            Option.bind
              (match some xâœ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ²
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³)
              fun a => if (a == 0#5) = true then none else some (xâœÂ¹ / a)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:107:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:107:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:107:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:107:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:107:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:107:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:107:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:107:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:101:8: error: (kernel) declaration has metavariables 'urem_common_dividend_defined_cond_thm'
[bv] [0.064877] Normalizing goal
  [Meta.synthInstance] [0.001449] âœ…ï¸ Decidable
        ((match some xâœ with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } => if xâœÂ² = 0 then none else some (xâœÂ¹ % xâœÂ²)
          | some { toFin := âŸ¨0, â‹¯âŸ© } => if xâœÂ³ = 0 then none else some (xâœÂ¹ % xâœÂ³)) âŠ‘
          Option.bind
            (match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ²
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³)
            fun y' => if y' = 0 then none else some (xâœÂ¹ % y'))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 5
      e_3 : LLVM.IntW 1
      xâœÂ³ xâœÂ² xâœÂ¹ : BitVec 5
      xâœ : BitVec 1
      aâœ :
        Â¬(match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => if xâœÂ² = 0 then none else some (xâœÂ¹ % xâœÂ²)
            | some { toFin := âŸ¨0, â‹¯âŸ© } => if xâœÂ³ = 0 then none else some (xâœÂ¹ % xâœÂ³)) âŠ‘
            Option.bind
              (match some xâœ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ²
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³)
              fun y' => if y' = 0 then none else some (xâœÂ¹ % y')
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 5
      e_3 : LLVM.IntW 1
      xâœÂ³ xâœÂ² xâœÂ¹ : BitVec 5
      xâœ : BitVec 1
      aâœ :
        Â¬(match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => if (xâœÂ² == 0#5) = true then none else some (xâœÂ¹ % xâœÂ²)
            | some { toFin := âŸ¨0, â‹¯âŸ© } => if (xâœÂ³ == 0#5) = true then none else some (xâœÂ¹ % xâœÂ³)) âŠ‘
            Option.bind
              (match some xâœ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some xâœÂ²
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some xâœÂ³)
              fun a => if (a == 0#5) = true then none else some (xâœÂ¹ % a)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:119:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:111:8: error: (kernel) declaration has metavariables 'rem_euclid_1_thm'
[bv] [0.074792] Normalizing goal
  [Meta.synthInstance] [0.001734] âœ…ï¸ Decidable
        ((match
            (Option.map (fun div => xâœ - div * 8#32)
                  (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                  else some (xâœ.sdiv 8#32))).bind
              fun x' => some (BitVec.ofBool (0#32 >â‚› x')) with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } =>
            (Option.map (fun div => xâœ - div * 8#32)
                  (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                  else some (xâœ.sdiv 8#32))).bind
              fun x' => some (x' + 8#32)
          | some { toFin := âŸ¨0, â‹¯âŸ© } =>
            Option.map (fun div => xâœ - div * 8#32)
              (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
              else some (xâœ.sdiv 8#32))) âŠ‘
          some (xâœ &&& 7#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(match
              (Option.map (fun div => xâœ - div * 8#32)
                    (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                    else some (xâœ.sdiv 8#32))).bind
                fun x' => some (BitVec.ofBool (0#32 >â‚› x')) with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              (Option.map (fun div => xâœ - div * 8#32)
                    (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                    else some (xâœ.sdiv 8#32))).bind
                fun x' => some (x' + 8#32)
            | some { toFin := âŸ¨0, â‹¯âŸ© } =>
              Option.map (fun div => xâœ - div * 8#32)
                (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                else some (xâœ.sdiv 8#32))) âŠ‘
            some (xâœ &&& 7#32)
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(match
              (Option.map (fun div => xâœ + (~~~(div * 8#32) + 1#32))
                    (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 8#32) + 1#32 else xâœ / 8#32))).bind
                fun a => some (if (!a.getLsbD 31 == (0#32 >áµ¤ a)) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              (Option.map (fun div => xâœ + (~~~(div * 8#32) + 1#32))
                    (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 8#32) + 1#32 else xâœ / 8#32))).bind
                fun a => some (a + 8#32)
            | some { toFin := âŸ¨0, â‹¯âŸ© } =>
              Option.map (fun div => xâœ + (~~~(div * 8#32) + 1#32))
                (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 8#32) + 1#32 else xâœ / 8#32))) âŠ‘
            some (xâœ &&& 7#32)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:131:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:123:8: error: (kernel) declaration has metavariables 'rem_euclid_2_thm'
[bv] [0.072902] Normalizing goal
  [Meta.synthInstance] [0.001746] âœ…ï¸ Decidable
        ((match
            (Option.map (fun div => xâœ - div * 8#32)
                  (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                  else some (xâœ.sdiv 8#32))).bind
              fun x' => some (BitVec.ofBool (x' >â‚› -1#32)) with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } =>
            Option.map (fun div => xâœ - div * 8#32)
              (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
              else some (xâœ.sdiv 8#32))
          | some { toFin := âŸ¨0, â‹¯âŸ© } =>
            (Option.map (fun div => xâœ - div * 8#32)
                  (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                  else some (xâœ.sdiv 8#32))).bind
              fun x' => some (x' + 8#32)) âŠ‘
          some (xâœ &&& 7#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(match
              (Option.map (fun div => xâœ - div * 8#32)
                    (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                    else some (xâœ.sdiv 8#32))).bind
                fun x' => some (BitVec.ofBool (x' >â‚› -1#32)) with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              Option.map (fun div => xâœ - div * 8#32)
                (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                else some (xâœ.sdiv 8#32))
            | some { toFin := âŸ¨0, â‹¯âŸ© } =>
              (Option.map (fun div => xâœ - div * 8#32)
                    (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                    else some (xâœ.sdiv 8#32))).bind
                fun x' => some (x' + 8#32)) âŠ‘
            some (xâœ &&& 7#32)
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(match
              (Option.map (fun div => xâœ + (~~~(div * 8#32) + 1#32))
                    (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 8#32) + 1#32 else xâœ / 8#32))).bind
                fun a => some (if (!a.getLsbD 31) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              Option.map (fun div => xâœ + (~~~(div * 8#32) + 1#32))
                (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 8#32) + 1#32 else xâœ / 8#32))
            | some { toFin := âŸ¨0, â‹¯âŸ© } =>
              (Option.map (fun div => xâœ + (~~~(div * 8#32) + 1#32))
                    (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 8#32) + 1#32 else xâœ / 8#32))).bind
                fun a => some (a + 8#32)) âŠ‘
            some (xâœ &&& 7#32)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:145:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:135:8: error: (kernel) declaration has metavariables 'rem_euclid_wrong_sign_test_thm'
[bv] [0.113534] Normalizing goal
  [Meta.synthInstance] [0.002114] âœ…ï¸ Decidable
        ((match
            (Option.map (fun div => xâœ - div * 8#32)
                  (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                  else some (xâœ.sdiv 8#32))).bind
              fun x' => some (BitVec.ofBool (x' >â‚› 0#32)) with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } =>
            (Option.map (fun div => xâœ - div * 8#32)
                  (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                  else some (xâœ.sdiv 8#32))).bind
              fun x' => some (x' + 8#32)
          | some { toFin := âŸ¨0, â‹¯âŸ© } =>
            Option.map (fun div => xâœ - div * 8#32)
              (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
              else some (xâœ.sdiv 8#32))) âŠ‘
          match
            (Option.map (fun div => xâœ - div * 8#32)
                  (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                  else some (xâœ.sdiv 8#32))).bind
              fun x' => some (BitVec.ofBool (x' >â‚› 0#32)) with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } =>
            (Option.map (fun div => xâœ - div * 8#32)
                  (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                  else some (xâœ.sdiv 8#32))).bind
              fun x' => if True âˆ§ x'.msb = (8#32).msb âˆ§ (x' + 8#32).msb â‰  x'.msb then none else some (x' + 8#32)
          | some { toFin := âŸ¨0, â‹¯âŸ© } =>
            Option.map (fun div => xâœ - div * 8#32)
              (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
              else some (xâœ.sdiv 8#32)))
    [Meta.check] [0.001176] âœ…ï¸ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (match
            (Option.map (fun div => xâœ - div * 8#32)
                  (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                  else some (xâœ.sdiv 8#32))).bind
              fun x' => some (BitVec.ofBool (x' >â‚› 0#32)) with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } =>
            (Option.map (fun div => xâœ - div * 8#32)
                  (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                  else some (xâœ.sdiv 8#32))).bind
              fun x' => some (x' + 8#32)
          | some { toFin := âŸ¨0, â‹¯âŸ© } =>
            Option.map (fun div => xâœ - div * 8#32)
              (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
              else some (xâœ.sdiv 8#32)))
          (match
            (Option.map (fun div => xâœ - div * 8#32)
                  (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                  else some (xâœ.sdiv 8#32))).bind
              fun x' => some (BitVec.ofBool (x' >â‚› 0#32)) with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } =>
            (Option.map (fun div => xâœ - div * 8#32)
                  (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                  else some (xâœ.sdiv 8#32))).bind
              fun x' => if True âˆ§ x'.msb = (8#32).msb âˆ§ (x' + 8#32).msb â‰  x'.msb then none else some (x' + 8#32)
          | some { toFin := âŸ¨0, â‹¯âŸ© } =>
            Option.map (fun div => xâœ - div * 8#32)
              (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
              else some (xâœ.sdiv 8#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(match
              (Option.map (fun div => xâœ - div * 8#32)
                    (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                    else some (xâœ.sdiv 8#32))).bind
                fun x' => some (BitVec.ofBool (x' >â‚› 0#32)) with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              (Option.map (fun div => xâœ - div * 8#32)
                    (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                    else some (xâœ.sdiv 8#32))).bind
                fun x' => some (x' + 8#32)
            | some { toFin := âŸ¨0, â‹¯âŸ© } =>
              Option.map (fun div => xâœ - div * 8#32)
                (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                else some (xâœ.sdiv 8#32))) âŠ‘
            match
              (Option.map (fun div => xâœ - div * 8#32)
                    (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                    else some (xâœ.sdiv 8#32))).bind
                fun x' => some (BitVec.ofBool (x' >â‚› 0#32)) with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              (Option.map (fun div => xâœ - div * 8#32)
                    (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                    else some (xâœ.sdiv 8#32))).bind
                fun x' => if True âˆ§ x'.msb = (8#32).msb âˆ§ (x' + 8#32).msb â‰  x'.msb then none else some (x' + 8#32)
            | some { toFin := âŸ¨0, â‹¯âŸ© } =>
              Option.map (fun div => xâœ - div * 8#32)
                (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                else some (xâœ.sdiv 8#32))
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(match
              (Option.map (fun div => xâœ + (~~~(div * 8#32) + 1#32))
                    (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 8#32) + 1#32 else xâœ / 8#32))).bind
                fun a => some (if (!a.getLsbD 31 == !a == 0#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              (Option.map (fun div => xâœ + (~~~(div * 8#32) + 1#32))
                    (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 8#32) + 1#32 else xâœ / 8#32))).bind
                fun a => some (a + 8#32)
            | some { toFin := âŸ¨0, â‹¯âŸ© } =>
              Option.map (fun div => xâœ + (~~~(div * 8#32) + 1#32))
                (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 8#32) + 1#32 else xâœ / 8#32))) âŠ‘
            match
              (Option.map (fun div => xâœ + (~~~(div * 8#32) + 1#32))
                    (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 8#32) + 1#32 else xâœ / 8#32))).bind
                fun a => some (if (!a.getLsbD 31 == !a == 0#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              (Option.map (fun div => xâœ + (~~~(div * 8#32) + 1#32))
                    (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 8#32) + 1#32 else xâœ / 8#32))).bind
                fun a =>
                if (!a.getLsbD 31 && !(a + 8#32).getLsbD 31 == a.getLsbD 31) = true then none else some (a + 8#32)
            | some { toFin := âŸ¨0, â‹¯âŸ© } =>
              Option.map (fun div => xâœ + (~~~(div * 8#32) + 1#32))
                (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 8#32) + 1#32 else xâœ / 8#32))
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:159:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:149:8: error: (kernel) declaration has metavariables 'rem_euclid_add_different_const_thm'
[bv] [0.110969] Normalizing goal
  [Meta.synthInstance] [0.002230] âœ…ï¸ Decidable
        ((match
            (Option.map (fun div => xâœ - div * 8#32)
                  (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                  else some (xâœ.sdiv 8#32))).bind
              fun x' => some (BitVec.ofBool (0#32 >â‚› x')) with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } =>
            (Option.map (fun div => xâœ - div * 8#32)
                  (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                  else some (xâœ.sdiv 8#32))).bind
              fun x' => some (x' + 9#32)
          | some { toFin := âŸ¨0, â‹¯âŸ© } =>
            Option.map (fun div => xâœ - div * 8#32)
              (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
              else some (xâœ.sdiv 8#32))) âŠ‘
          match
            (Option.map (fun div => xâœ - div * 8#32)
                  (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                  else some (xâœ.sdiv 8#32))).bind
              fun x' => some (BitVec.ofBool (0#32 >â‚› x')) with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } =>
            (Option.map (fun div => xâœ - div * 8#32)
                  (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                  else some (xâœ.sdiv 8#32))).bind
              fun x' => if True âˆ§ x'.msb = (9#32).msb âˆ§ (x' + 9#32).msb â‰  x'.msb then none else some (x' + 9#32)
          | some { toFin := âŸ¨0, â‹¯âŸ© } =>
            Option.map (fun div => xâœ - div * 8#32)
              (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
              else some (xâœ.sdiv 8#32)))
    [Meta.check] [0.001219] âœ…ï¸ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (match
            (Option.map (fun div => xâœ - div * 8#32)
                  (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                  else some (xâœ.sdiv 8#32))).bind
              fun x' => some (BitVec.ofBool (0#32 >â‚› x')) with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } =>
            (Option.map (fun div => xâœ - div * 8#32)
                  (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                  else some (xâœ.sdiv 8#32))).bind
              fun x' => some (x' + 9#32)
          | some { toFin := âŸ¨0, â‹¯âŸ© } =>
            Option.map (fun div => xâœ - div * 8#32)
              (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
              else some (xâœ.sdiv 8#32)))
          (match
            (Option.map (fun div => xâœ - div * 8#32)
                  (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                  else some (xâœ.sdiv 8#32))).bind
              fun x' => some (BitVec.ofBool (0#32 >â‚› x')) with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } =>
            (Option.map (fun div => xâœ - div * 8#32)
                  (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                  else some (xâœ.sdiv 8#32))).bind
              fun x' => if True âˆ§ x'.msb = (9#32).msb âˆ§ (x' + 9#32).msb â‰  x'.msb then none else some (x' + 9#32)
          | some { toFin := âŸ¨0, â‹¯âŸ© } =>
            Option.map (fun div => xâœ - div * 8#32)
              (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
              else some (xâœ.sdiv 8#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(match
              (Option.map (fun div => xâœ - div * 8#32)
                    (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                    else some (xâœ.sdiv 8#32))).bind
                fun x' => some (BitVec.ofBool (0#32 >â‚› x')) with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              (Option.map (fun div => xâœ - div * 8#32)
                    (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                    else some (xâœ.sdiv 8#32))).bind
                fun x' => some (x' + 9#32)
            | some { toFin := âŸ¨0, â‹¯âŸ© } =>
              Option.map (fun div => xâœ - div * 8#32)
                (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                else some (xâœ.sdiv 8#32))) âŠ‘
            match
              (Option.map (fun div => xâœ - div * 8#32)
                    (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                    else some (xâœ.sdiv 8#32))).bind
                fun x' => some (BitVec.ofBool (0#32 >â‚› x')) with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              (Option.map (fun div => xâœ - div * 8#32)
                    (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                    else some (xâœ.sdiv 8#32))).bind
                fun x' => if True âˆ§ x'.msb = (9#32).msb âˆ§ (x' + 9#32).msb â‰  x'.msb then none else some (x' + 9#32)
            | some { toFin := âŸ¨0, â‹¯âŸ© } =>
              Option.map (fun div => xâœ - div * 8#32)
                (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                else some (xâœ.sdiv 8#32))
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(match
              (Option.map (fun div => xâœ + (~~~(div * 8#32) + 1#32))
                    (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 8#32) + 1#32 else xâœ / 8#32))).bind
                fun a => some (if (!a.getLsbD 31 == (0#32 >áµ¤ a)) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              (Option.map (fun div => xâœ + (~~~(div * 8#32) + 1#32))
                    (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 8#32) + 1#32 else xâœ / 8#32))).bind
                fun a => some (a + 9#32)
            | some { toFin := âŸ¨0, â‹¯âŸ© } =>
              Option.map (fun div => xâœ + (~~~(div * 8#32) + 1#32))
                (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 8#32) + 1#32 else xâœ / 8#32))) âŠ‘
            match
              (Option.map (fun div => xâœ + (~~~(div * 8#32) + 1#32))
                    (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 8#32) + 1#32 else xâœ / 8#32))).bind
                fun a => some (if (!a.getLsbD 31 == (0#32 >áµ¤ a)) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              (Option.map (fun div => xâœ + (~~~(div * 8#32) + 1#32))
                    (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 8#32) + 1#32 else xâœ / 8#32))).bind
                fun a =>
                if (!a.getLsbD 31 && !(a + 9#32).getLsbD 31 == a.getLsbD 31) = true then none else some (a + 9#32)
            | some { toFin := âŸ¨0, â‹¯âŸ© } =>
              Option.map (fun div => xâœ + (~~~(div * 8#32) + 1#32))
                (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 8#32) + 1#32 else xâœ / 8#32))
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:172:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:163:8: error: (kernel) declaration has metavariables 'rem_euclid_wrong_operands_select_thm'
[bv] [0.109172] Normalizing goal
  [Meta.synthInstance] [0.002073] âœ…ï¸ Decidable
        ((match
            (Option.map (fun div => xâœ - div * 8#32)
                  (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                  else some (xâœ.sdiv 8#32))).bind
              fun x' => some (BitVec.ofBool (0#32 >â‚› x')) with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } =>
            Option.map (fun div => xâœ - div * 8#32)
              (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
              else some (xâœ.sdiv 8#32))
          | some { toFin := âŸ¨0, â‹¯âŸ© } =>
            (Option.map (fun div => xâœ - div * 8#32)
                  (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                  else some (xâœ.sdiv 8#32))).bind
              fun x' => some (x' + 8#32)) âŠ‘
          match
            (Option.map (fun div => xâœ - div * 8#32)
                  (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                  else some (xâœ.sdiv 8#32))).bind
              fun x' => some (BitVec.ofBool (0#32 >â‚› x')) with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } =>
            Option.map (fun div => xâœ - div * 8#32)
              (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
              else some (xâœ.sdiv 8#32))
          | some { toFin := âŸ¨0, â‹¯âŸ© } =>
            (Option.map (fun div => xâœ - div * 8#32)
                  (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                  else some (xâœ.sdiv 8#32))).bind
              fun x' => if True âˆ§ x'.msb = (8#32).msb âˆ§ (x' + 8#32).msb â‰  x'.msb then none else some (x' + 8#32))
    [Meta.check] [0.001152] âœ…ï¸ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (match
            (Option.map (fun div => xâœ - div * 8#32)
                  (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                  else some (xâœ.sdiv 8#32))).bind
              fun x' => some (BitVec.ofBool (0#32 >â‚› x')) with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } =>
            Option.map (fun div => xâœ - div * 8#32)
              (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
              else some (xâœ.sdiv 8#32))
          | some { toFin := âŸ¨0, â‹¯âŸ© } =>
            (Option.map (fun div => xâœ - div * 8#32)
                  (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                  else some (xâœ.sdiv 8#32))).bind
              fun x' => some (x' + 8#32))
          (match
            (Option.map (fun div => xâœ - div * 8#32)
                  (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                  else some (xâœ.sdiv 8#32))).bind
              fun x' => some (BitVec.ofBool (0#32 >â‚› x')) with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } =>
            Option.map (fun div => xâœ - div * 8#32)
              (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
              else some (xâœ.sdiv 8#32))
          | some { toFin := âŸ¨0, â‹¯âŸ© } =>
            (Option.map (fun div => xâœ - div * 8#32)
                  (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                  else some (xâœ.sdiv 8#32))).bind
              fun x' => if True âˆ§ x'.msb = (8#32).msb âˆ§ (x' + 8#32).msb â‰  x'.msb then none else some (x' + 8#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(match
              (Option.map (fun div => xâœ - div * 8#32)
                    (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                    else some (xâœ.sdiv 8#32))).bind
                fun x' => some (BitVec.ofBool (0#32 >â‚› x')) with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              Option.map (fun div => xâœ - div * 8#32)
                (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                else some (xâœ.sdiv 8#32))
            | some { toFin := âŸ¨0, â‹¯âŸ© } =>
              (Option.map (fun div => xâœ - div * 8#32)
                    (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                    else some (xâœ.sdiv 8#32))).bind
                fun x' => some (x' + 8#32)) âŠ‘
            match
              (Option.map (fun div => xâœ - div * 8#32)
                    (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                    else some (xâœ.sdiv 8#32))).bind
                fun x' => some (BitVec.ofBool (0#32 >â‚› x')) with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              Option.map (fun div => xâœ - div * 8#32)
                (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                else some (xâœ.sdiv 8#32))
            | some { toFin := âŸ¨0, â‹¯âŸ© } =>
              (Option.map (fun div => xâœ - div * 8#32)
                    (if (8#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 8#32 == -1) = true then none
                    else some (xâœ.sdiv 8#32))).bind
                fun x' => if True âˆ§ x'.msb = (8#32).msb âˆ§ (x' + 8#32).msb â‰  x'.msb then none else some (x' + 8#32)
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(match
              (Option.map (fun div => xâœ + (~~~(div * 8#32) + 1#32))
                    (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 8#32) + 1#32 else xâœ / 8#32))).bind
                fun a => some (if (!a.getLsbD 31 == (0#32 >áµ¤ a)) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              Option.map (fun div => xâœ + (~~~(div * 8#32) + 1#32))
                (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 8#32) + 1#32 else xâœ / 8#32))
            | some { toFin := âŸ¨0, â‹¯âŸ© } =>
              (Option.map (fun div => xâœ + (~~~(div * 8#32) + 1#32))
                    (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 8#32) + 1#32 else xâœ / 8#32))).bind
                fun a => some (a + 8#32)) âŠ‘
            match
              (Option.map (fun div => xâœ + (~~~(div * 8#32) + 1#32))
                    (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 8#32) + 1#32 else xâœ / 8#32))).bind
                fun a => some (if (!a.getLsbD 31 == (0#32 >áµ¤ a)) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              Option.map (fun div => xâœ + (~~~(div * 8#32) + 1#32))
                (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 8#32) + 1#32 else xâœ / 8#32))
            | some { toFin := âŸ¨0, â‹¯âŸ© } =>
              (Option.map (fun div => xâœ + (~~~(div * 8#32) + 1#32))
                    (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 8#32) + 1#32 else xâœ / 8#32))).bind
                fun a =>
                if (!a.getLsbD 31 && !(a + 8#32).getLsbD 31 == a.getLsbD 31) = true then none else some (a + 8#32)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:184:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:176:8: error: (kernel) declaration has metavariables 'rem_euclid_i128_thm'
[bv] [0.074710] Normalizing goal
  [Meta.synthInstance] [0.001750] âœ…ï¸ Decidable
        ((match
            (Option.map (fun div => xâœ - div * 8#128)
                  (if (8#128 == 0 || 128 != 1 && xâœ == BitVec.intMin 128 && 8#128 == -1) = true then none
                  else some (xâœ.sdiv 8#128))).bind
              fun x' => some (BitVec.ofBool (0#128 >â‚› x')) with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } =>
            (Option.map (fun div => xâœ - div * 8#128)
                  (if (8#128 == 0 || 128 != 1 && xâœ == BitVec.intMin 128 && 8#128 == -1) = true then none
                  else some (xâœ.sdiv 8#128))).bind
              fun x' => some (x' + 8#128)
          | some { toFin := âŸ¨0, â‹¯âŸ© } =>
            Option.map (fun div => xâœ - div * 8#128)
              (if (8#128 == 0 || 128 != 1 && xâœ == BitVec.intMin 128 && 8#128 == -1) = true then none
              else some (xâœ.sdiv 8#128))) âŠ‘
          some (xâœ &&& 7#128))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 128
      xâœ : BitVec 128
      aâœ :
        Â¬(match
              (Option.map (fun div => xâœ - div * 8#128)
                    (if (8#128 == 0 || 128 != 1 && xâœ == BitVec.intMin 128 && 8#128 == -1) = true then none
                    else some (xâœ.sdiv 8#128))).bind
                fun x' => some (BitVec.ofBool (0#128 >â‚› x')) with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              (Option.map (fun div => xâœ - div * 8#128)
                    (if (8#128 == 0 || 128 != 1 && xâœ == BitVec.intMin 128 && 8#128 == -1) = true then none
                    else some (xâœ.sdiv 8#128))).bind
                fun x' => some (x' + 8#128)
            | some { toFin := âŸ¨0, â‹¯âŸ© } =>
              Option.map (fun div => xâœ - div * 8#128)
                (if (8#128 == 0 || 128 != 1 && xâœ == BitVec.intMin 128 && 8#128 == -1) = true then none
                else some (xâœ.sdiv 8#128))) âŠ‘
            some (xâœ &&& 7#128)
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 128
      xâœ : BitVec 128
      aâœ :
        Â¬(match
              (Option.map (fun div => xâœ + (~~~(div * 8#128) + 1#128))
                    (some (if xâœ.getLsbD 127 = true then ~~~((~~~xâœ + 1#128) / 8#128) + 1#128 else xâœ / 8#128))).bind
                fun a => some (if (!a.getLsbD 127 == (0#128 >áµ¤ a)) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              (Option.map (fun div => xâœ + (~~~(div * 8#128) + 1#128))
                    (some (if xâœ.getLsbD 127 = true then ~~~((~~~xâœ + 1#128) / 8#128) + 1#128 else xâœ / 8#128))).bind
                fun a => some (a + 8#128)
            | some { toFin := âŸ¨0, â‹¯âŸ© } =>
              Option.map (fun div => xâœ + (~~~(div * 8#128) + 1#128))
                (some (if xâœ.getLsbD 127 = true then ~~~((~~~xâœ + 1#128) / 8#128) + 1#128 else xâœ / 8#128))) âŠ‘
            some (xâœ &&& 7#128)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:196:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:188:8: error: (kernel) declaration has metavariables 'rem_euclid_non_const_pow2_thm'
[bv] [0.133185] Normalizing goal
  [Meta.synthInstance] [0.002215] âœ…ï¸ Decidable
        ((match
            if xâœÂ¹ â‰¥ â†‘8 then none
            else
              (Option.map (fun div => xâœ - div * 1#8 <<< xâœÂ¹)
                    (if (1#8 <<< xâœÂ¹ == 0 || 8 != 1 && xâœ == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == -1) = true then none
                    else some (xâœ.sdiv (1#8 <<< xâœÂ¹)))).bind
                fun x' => some (BitVec.ofBool (0#8 >â‚› x')) with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } =>
            if xâœÂ¹ â‰¥ â†‘8 then none
            else
              (Option.map (fun div => xâœ - div * 1#8 <<< xâœÂ¹)
                    (if (1#8 <<< xâœÂ¹ == 0 || 8 != 1 && xâœ == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == -1) = true then none
                    else some (xâœ.sdiv (1#8 <<< xâœÂ¹)))).bind
                fun x' => if xâœÂ¹ â‰¥ â†‘8 then none else some (x' + 1#8 <<< xâœÂ¹)
          | some { toFin := âŸ¨0, â‹¯âŸ© } =>
            if xâœÂ¹ â‰¥ â†‘8 then none
            else
              Option.map (fun div => xâœ - div * 1#8 <<< xâœÂ¹)
                (if (1#8 <<< xâœÂ¹ == 0 || 8 != 1 && xâœ == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == -1) = true then none
                else some (xâœ.sdiv (1#8 <<< xâœÂ¹)))) âŠ‘
          if True âˆ§ ((-1#8) <<< xâœÂ¹).sshiftRight xâœÂ¹.toNat = -1#8 then none
          else if xâœÂ¹ â‰¥ â†‘8 then none else some (xâœ &&& ((-1#8) <<< xâœÂ¹ ^^^ -1#8)))
    [Meta.check] [0.001378] âœ…ï¸ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (match
            if xâœÂ¹ â‰¥ â†‘8 then none
            else
              (Option.map (fun div => xâœ - div * 1#8 <<< xâœÂ¹)
                    (if (1#8 <<< xâœÂ¹ == 0 || 8 != 1 && xâœ == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == -1) = true then none
                    else some (xâœ.sdiv (1#8 <<< xâœÂ¹)))).bind
                fun x' => some (BitVec.ofBool (0#8 >â‚› x')) with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } =>
            if xâœÂ¹ â‰¥ â†‘8 then none
            else
              (Option.map (fun div => xâœ - div * 1#8 <<< xâœÂ¹)
                    (if (1#8 <<< xâœÂ¹ == 0 || 8 != 1 && xâœ == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == -1) = true then none
                    else some (xâœ.sdiv (1#8 <<< xâœÂ¹)))).bind
                fun x' => if xâœÂ¹ â‰¥ â†‘8 then none else some (x' + 1#8 <<< xâœÂ¹)
          | some { toFin := âŸ¨0, â‹¯âŸ© } =>
            if xâœÂ¹ â‰¥ â†‘8 then none
            else
              Option.map (fun div => xâœ - div * 1#8 <<< xâœÂ¹)
                (if (1#8 <<< xâœÂ¹ == 0 || 8 != 1 && xâœ == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == -1) = true then none
                else some (xâœ.sdiv (1#8 <<< xâœÂ¹))))
          (if True âˆ§ ((-1#8) <<< xâœÂ¹).sshiftRight xâœÂ¹.toNat = -1#8 then none
          else if xâœÂ¹ â‰¥ â†‘8 then none else some (xâœ &&& ((-1#8) <<< xâœÂ¹ ^^^ -1#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      xâœÂ¹ xâœ : BitVec 8
      aâœ :
        Â¬(match
              if xâœÂ¹ â‰¥ â†‘8 then none
              else
                (Option.map (fun div => xâœ - div * 1#8 <<< xâœÂ¹)
                      (if (1#8 <<< xâœÂ¹ == 0 || 8 != 1 && xâœ == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == -1) = true then none
                      else some (xâœ.sdiv (1#8 <<< xâœÂ¹)))).bind
                  fun x' => some (BitVec.ofBool (0#8 >â‚› x')) with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              if xâœÂ¹ â‰¥ â†‘8 then none
              else
                (Option.map (fun div => xâœ - div * 1#8 <<< xâœÂ¹)
                      (if (1#8 <<< xâœÂ¹ == 0 || 8 != 1 && xâœ == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == -1) = true then none
                      else some (xâœ.sdiv (1#8 <<< xâœÂ¹)))).bind
                  fun x' => if xâœÂ¹ â‰¥ â†‘8 then none else some (x' + 1#8 <<< xâœÂ¹)
            | some { toFin := âŸ¨0, â‹¯âŸ© } =>
              if xâœÂ¹ â‰¥ â†‘8 then none
              else
                Option.map (fun div => xâœ - div * 1#8 <<< xâœÂ¹)
                  (if (1#8 <<< xâœÂ¹ == 0 || 8 != 1 && xâœ == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == -1) = true then none
                  else some (xâœ.sdiv (1#8 <<< xâœÂ¹)))) âŠ‘
            if True âˆ§ ((-1#8) <<< xâœÂ¹).sshiftRight xâœÂ¹.toNat = -1#8 then none
            else if xâœÂ¹ â‰¥ â†‘8 then none else some (xâœ &&& ((-1#8) <<< xâœÂ¹ ^^^ -1#8))
      âŠ¢ False
  [Meta.isDefEq] [0.001245] âœ…ï¸ ?hâ‚ =?= congrArg (fun x => x = true)
        (Eq.trans
          (congrArg (fun x => 1#8 <<< xâœÂ¹ == 0#8 || x && 1#8 <<< xâœÂ¹ == 255#8) (Bool.true_and (xâœ == BitVec.intMin 8)))
          (Std.Tactic.BVDecide.Normalize.Bool.or_elim (1#8 <<< xâœÂ¹ == 0#8)
            (xâœ == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == 255#8)))
    [Meta.isDefEq.assign] [0.001242] âœ…ï¸ ?hâ‚ := congrArg (fun x => x = true)
          (Eq.trans
            (congrArg (fun x => 1#8 <<< xâœÂ¹ == 0#8 || x && 1#8 <<< xâœÂ¹ == 255#8)
              (Bool.true_and (xâœ == BitVec.intMin 8)))
            (Std.Tactic.BVDecide.Normalize.Bool.or_elim (1#8 <<< xâœÂ¹ == 0#8)
              (xâœ == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == 255#8)))
      [Meta.isDefEq.assign.checkTypes] [0.001231] âœ…ï¸ (?hâ‚ : ((1#8 <<< xâœÂ¹ == 0 ||
                8 != 1 && xâœ == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == -1) =
              true) =
            ((!(!1#8 <<< xâœÂ¹ == 0#8 && !(xâœ == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == 255#8))) =
              true)) := (congrArg (fun x => x = true)
            (Eq.trans
              (congrArg (fun x => 1#8 <<< xâœÂ¹ == 0#8 || x && 1#8 <<< xâœÂ¹ == 255#8)
                (Bool.true_and (xâœ == BitVec.intMin 8)))
              (Std.Tactic.BVDecide.Normalize.Bool.or_elim (1#8 <<< xâœÂ¹ == 0#8)
                (xâœ == BitVec.intMin 8 &&
                  1#8 <<< xâœÂ¹ ==
                    255#8))) : ((1#8 <<< xâœÂ¹ == 0#8 || true && xâœ == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == 255#8) = true) =
            ((!(!1#8 <<< xâœÂ¹ == 0#8 && !(xâœ == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == 255#8))) = true))
        [Meta.isDefEq] [0.001228] âœ…ï¸ ((1#8 <<< xâœÂ¹ == 0 || 8 != 1 && xâœ == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == -1) =
                true) =
              ((!(!1#8 <<< xâœÂ¹ == 0#8 && !(xâœ == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == 255#8))) =
                true) =?= ((1#8 <<< xâœÂ¹ == 0#8 || true && xâœ == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == 255#8) = true) =
              ((!(!1#8 <<< xâœÂ¹ == 0#8 && !(xâœ == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == 255#8))) = true)
          [Meta.isDefEq] [0.001211] âœ…ï¸ (1#8 <<< xâœÂ¹ == 0 || 8 != 1 && xâœ == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == -1) =
                true =?= (1#8 <<< xâœÂ¹ == 0#8 || true && xâœ == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == 255#8) = true
            [Meta.isDefEq] [0.001197] âœ…ï¸ 1#8 <<< xâœÂ¹ == 0 ||
                  8 != 1 && xâœ == BitVec.intMin 8 &&
                    1#8 <<< xâœÂ¹ == -1 =?= 1#8 <<< xâœÂ¹ == 0#8 || true && xâœ == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == 255#8
              [Meta.isDefEq.delta] [0.001184] âœ…ï¸ 1#8 <<< xâœÂ¹ == 0 ||
                    8 != 1 && xâœ == BitVec.intMin 8 &&
                      1#8 <<< xâœÂ¹ == -1 =?= 1#8 <<< xâœÂ¹ == 0#8 || true && xâœ == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == 255#8
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      xâœÂ¹ xâœ : BitVec 8
      aâœ :
        Â¬(match
              if (!8#8 >áµ¤ xâœÂ¹) = true then none
              else
                (Option.map (fun div => xâœ + (~~~(div * 1#8 <<< xâœÂ¹) + 1#8))
                      (if (!(!1#8 <<< xâœÂ¹ == 0#8 && !(xâœ == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == 255#8))) = true then none
                      else
                        some
                          (if xâœ.getLsbD 7 = true then
                            if (1#8 <<< xâœÂ¹).getLsbD 7 = true then (~~~xâœ + 1#8) / (~~~(1#8 <<< xâœÂ¹) + 1#8)
                            else ~~~((~~~xâœ + 1#8) / 1#8 <<< xâœÂ¹) + 1#8
                          else
                            if (1#8 <<< xâœÂ¹).getLsbD 7 = true then ~~~(xâœ / (~~~(1#8 <<< xâœÂ¹) + 1#8)) + 1#8
                            else xâœ / 1#8 <<< xâœÂ¹))).bind
                  fun a => some (if (!a.getLsbD 7 == (0#8 >áµ¤ a)) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              if (!8#8 >áµ¤ xâœÂ¹) = true then none
              else
                (Option.map (fun div => xâœ + (~~~(div * 1#8 <<< xâœÂ¹) + 1#8))
                      (if (!(!1#8 <<< xâœÂ¹ == 0#8 && !(xâœ == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == 255#8))) = true then none
                      else
                        some
                          (if xâœ.getLsbD 7 = true then
                            if (1#8 <<< xâœÂ¹).getLsbD 7 = true then (~~~xâœ + 1#8) / (~~~(1#8 <<< xâœÂ¹) + 1#8)
                            else ~~~((~~~xâœ + 1#8) / 1#8 <<< xâœÂ¹) + 1#8
                          else
                            if (1#8 <<< xâœÂ¹).getLsbD 7 = true then ~~~(xâœ / (~~~(1#8 <<< xâœÂ¹) + 1#8)) + 1#8
                            else xâœ / 1#8 <<< xâœÂ¹))).bind
                  fun a => if (!8#8 >áµ¤ xâœÂ¹) = true then none else some (a + 1#8 <<< xâœÂ¹)
            | some { toFin := âŸ¨0, â‹¯âŸ© } =>
              if (!8#8 >áµ¤ xâœÂ¹) = true then none
              else
                Option.map (fun div => xâœ + (~~~(div * 1#8 <<< xâœÂ¹) + 1#8))
                  (if (!(!1#8 <<< xâœÂ¹ == 0#8 && !(xâœ == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == 255#8))) = true then none
                  else
                    some
                      (if xâœ.getLsbD 7 = true then
                        if (1#8 <<< xâœÂ¹).getLsbD 7 = true then (~~~xâœ + 1#8) / (~~~(1#8 <<< xâœÂ¹) + 1#8)
                        else ~~~((~~~xâœ + 1#8) / 1#8 <<< xâœÂ¹) + 1#8
                      else
                        if (1#8 <<< xâœÂ¹).getLsbD 7 = true then ~~~(xâœ / (~~~(1#8 <<< xâœÂ¹) + 1#8)) + 1#8
                        else xâœ / 1#8 <<< xâœÂ¹))) âŠ‘
            if ((255#8 <<< xâœÂ¹).sshiftRight xâœÂ¹.toNat == 255#8) = true then none
            else if (!8#8 >áµ¤ xâœÂ¹) = true then none else some (xâœ &&& (255#8 <<< xâœÂ¹ ^^^ 255#8))
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:207:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:200:8: error: (kernel) declaration has metavariables 'rem_euclid_pow2_true_arm_folded_thm'
[bv] [0.068375] Normalizing goal
  [Meta.synthInstance] [0.001618] âœ…ï¸ Decidable
        ((match
            (Option.map (fun div => xâœ - div * 2#32)
                  (if (2#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 2#32 == -1) = true then none
                  else some (xâœ.sdiv 2#32))).bind
              fun x' => some (BitVec.ofBool (0#32 >â‚› x')) with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } => some 1#32
          | some { toFin := âŸ¨0, â‹¯âŸ© } =>
            Option.map (fun div => xâœ - div * 2#32)
              (if (2#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 2#32 == -1) = true then none
              else some (xâœ.sdiv 2#32))) âŠ‘
          some (xâœ &&& 1#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(match
              (Option.map (fun div => xâœ - div * 2#32)
                    (if (2#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 2#32 == -1) = true then none
                    else some (xâœ.sdiv 2#32))).bind
                fun x' => some (BitVec.ofBool (0#32 >â‚› x')) with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some 1#32
            | some { toFin := âŸ¨0, â‹¯âŸ© } =>
              Option.map (fun div => xâœ - div * 2#32)
                (if (2#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 2#32 == -1) = true then none
                else some (xâœ.sdiv 2#32))) âŠ‘
            some (xâœ &&& 1#32)
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(match
              (Option.map (fun div => xâœ + (~~~(div * 2#32) + 1#32))
                    (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 2#32) + 1#32 else xâœ / 2#32))).bind
                fun a => some (if (!a.getLsbD 31 == (0#32 >áµ¤ a)) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some 1#32
            | some { toFin := âŸ¨0, â‹¯âŸ© } =>
              Option.map (fun div => xâœ + (~~~(div * 2#32) + 1#32))
                (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 2#32) + 1#32 else xâœ / 2#32))) âŠ‘
            some (xâœ &&& 1#32)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:218:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:211:8: error: (kernel) declaration has metavariables 'rem_euclid_pow2_false_arm_folded_thm'
[bv] [0.069251] Normalizing goal
  [Meta.synthInstance] [0.001630] âœ…ï¸ Decidable
        ((match
            (Option.map (fun div => xâœ - div * 2#32)
                  (if (2#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 2#32 == -1) = true then none
                  else some (xâœ.sdiv 2#32))).bind
              fun x' => some (BitVec.ofBool (x' â‰¥â‚› 0#32)) with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } =>
            Option.map (fun div => xâœ - div * 2#32)
              (if (2#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 2#32 == -1) = true then none
              else some (xâœ.sdiv 2#32))
          | some { toFin := âŸ¨0, â‹¯âŸ© } => some 1#32) âŠ‘
          some (xâœ &&& 1#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(match
              (Option.map (fun div => xâœ - div * 2#32)
                    (if (2#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 2#32 == -1) = true then none
                    else some (xâœ.sdiv 2#32))).bind
                fun x' => some (BitVec.ofBool (x' â‰¥â‚› 0#32)) with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              Option.map (fun div => xâœ - div * 2#32)
                (if (2#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 2#32 == -1) = true then none
                else some (xâœ.sdiv 2#32))
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some 1#32) âŠ‘
            some (xâœ &&& 1#32)
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(match
              (Option.map (fun div => xâœ + (~~~(div * 2#32) + 1#32))
                    (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 2#32) + 1#32 else xâœ / 2#32))).bind
                fun a => some (if (a.getLsbD 31 == (0#32 >áµ¤ a)) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              Option.map (fun div => xâœ + (~~~(div * 2#32) + 1#32))
                (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 2#32) + 1#32 else xâœ / 2#32))
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some 1#32) âŠ‘
            some (xâœ &&& 1#32)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:235:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:235:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthdivrem_proof.lean:222:8: error: (kernel) declaration has metavariables 'pr89516_thm'
[bv] [0.196814] Normalizing goal
  [Meta.synthInstance] [0.002488] âœ…ï¸ Decidable
        ((match some (BitVec.ofBool (0#8 >â‚› xâœ)) with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } =>
            if True âˆ§ 1#8 <<< xâœÂ¹ >>> xâœÂ¹ = 1#8 then none
            else
              if xâœÂ¹ â‰¥ â†‘8 then none
              else
                (Option.map (fun div => 1#8 - div * 1#8 <<< xâœÂ¹)
                      (if (1#8 <<< xâœÂ¹ == 0 || 8 != 1 && 1#8 == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == -1) = true then none
                      else some ((1#8).sdiv (1#8 <<< xâœÂ¹)))).bind
                  fun x' =>
                  if True âˆ§ 1#8 <<< xâœÂ¹ >>> xâœÂ¹ = 1#8 then none
                  else
                    if xâœÂ¹ â‰¥ â†‘8 then none
                    else
                      if True âˆ§ (x' + 1#8 <<< xâœÂ¹ < x' âˆ¨ x' + 1#8 <<< xâœÂ¹ < 1#8 <<< xâœÂ¹) then none
                      else some (x' + 1#8 <<< xâœÂ¹)
          | some { toFin := âŸ¨0, â‹¯âŸ© } =>
            if True âˆ§ 1#8 <<< xâœÂ¹ >>> xâœÂ¹ = 1#8 then none
            else
              if xâœÂ¹ â‰¥ â†‘8 then none
              else
                Option.map (fun div => 1#8 - div * 1#8 <<< xâœÂ¹)
                  (if (1#8 <<< xâœÂ¹ == 0 || 8 != 1 && 1#8 == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == -1) = true then none
                  else some ((1#8).sdiv (1#8 <<< xâœÂ¹)))) âŠ‘
          if True âˆ§ 1#8 <<< xâœÂ¹ >>> xâœÂ¹ = 1#8 then none
          else
            if xâœÂ¹ â‰¥ â†‘8 then none
            else
              (Option.map (fun div => 1#8 - div * 1#8 <<< xâœÂ¹)
                    (if (1#8 <<< xâœÂ¹ == 0 || 8 != 1 && 1#8 == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == -1) = true then none
                    else some ((1#8).sdiv (1#8 <<< xâœÂ¹)))).bind
                fun a =>
                Option.bind
                  (match some (BitVec.ofBool (0#8 >â‚› xâœ)) with
                  | none => none
                  | some { toFin := âŸ¨1, â‹¯âŸ© } =>
                    if True âˆ§ 1#8 <<< xâœÂ¹ >>> xâœÂ¹ = 1#8 then none else if xâœÂ¹ â‰¥ â†‘8 then none else some (1#8 <<< xâœÂ¹)
                  | some { toFin := âŸ¨0, â‹¯âŸ© } => some 0#8)
                  fun y' => if True âˆ§ (a + y' < a âˆ¨ a + y' < y') then none else some (a + y'))
    [Meta.check] [0.001589] âœ…ï¸ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (match some (BitVec.ofBool (0#8 >â‚› xâœ)) with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } =>
            if True âˆ§ 1#8 <<< xâœÂ¹ >>> xâœÂ¹ = 1#8 then none
            else
              if xâœÂ¹ â‰¥ â†‘8 then none
              else
                (Option.map (fun div => 1#8 - div * 1#8 <<< xâœÂ¹)
                      (if (1#8 <<< xâœÂ¹ == 0 || 8 != 1 && 1#8 == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == -1) = true then none
                      else some ((1#8).sdiv (1#8 <<< xâœÂ¹)))).bind
                  fun x' =>
                  if True âˆ§ 1#8 <<< xâœÂ¹ >>> xâœÂ¹ = 1#8 then none
                  else
                    if xâœÂ¹ â‰¥ â†‘8 then none
                    else
                      if True âˆ§ (x' + 1#8 <<< xâœÂ¹ < x' âˆ¨ x' + 1#8 <<< xâœÂ¹ < 1#8 <<< xâœÂ¹) then none
                      else some (x' + 1#8 <<< xâœÂ¹)
          | some { toFin := âŸ¨0, â‹¯âŸ© } =>
            if True âˆ§ 1#8 <<< xâœÂ¹ >>> xâœÂ¹ = 1#8 then none
            else
              if xâœÂ¹ â‰¥ â†‘8 then none
              else
                Option.map (fun div => 1#8 - div * 1#8 <<< xâœÂ¹)
                  (if (1#8 <<< xâœÂ¹ == 0 || 8 != 1 && 1#8 == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == -1) = true then none
                  else some ((1#8).sdiv (1#8 <<< xâœÂ¹))))
          (if True âˆ§ 1#8 <<< xâœÂ¹ >>> xâœÂ¹ = 1#8 then none
          else
            if xâœÂ¹ â‰¥ â†‘8 then none
            else
              (Option.map (fun div => 1#8 - div * 1#8 <<< xâœÂ¹)
                    (if (1#8 <<< xâœÂ¹ == 0 || 8 != 1 && 1#8 == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == -1) = true then none
                    else some ((1#8).sdiv (1#8 <<< xâœÂ¹)))).bind
                fun a =>
                Option.bind
                  (match some (BitVec.ofBool (0#8 >â‚› xâœ)) with
                  | none => none
                  | some { toFin := âŸ¨1, â‹¯âŸ© } =>
                    if True âˆ§ 1#8 <<< xâœÂ¹ >>> xâœÂ¹ = 1#8 then none else if xâœÂ¹ â‰¥ â†‘8 then none else some (1#8 <<< xâœÂ¹)
                  | some { toFin := âŸ¨0, â‹¯âŸ© } => some 0#8)
                  fun y' => if True âˆ§ (a + y' < a âˆ¨ a + y' < y') then none else some (a + y'))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      xâœÂ¹ xâœ : BitVec 8
      aâœ :
        Â¬(match some (BitVec.ofBool (0#8 >â‚› xâœ)) with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              if True âˆ§ 1#8 <<< xâœÂ¹ >>> xâœÂ¹ = 1#8 then none
              else
                if xâœÂ¹ â‰¥ â†‘8 then none
                else
                  (Option.map (fun div => 1#8 - div * 1#8 <<< xâœÂ¹)
                        (if (1#8 <<< xâœÂ¹ == 0 || 8 != 1 && 1#8 == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == -1) = true then none
                        else some ((1#8).sdiv (1#8 <<< xâœÂ¹)))).bind
                    fun x' =>
                    if True âˆ§ 1#8 <<< xâœÂ¹ >>> xâœÂ¹ = 1#8 then none
                    else
                      if xâœÂ¹ â‰¥ â†‘8 then none
                      else
                        if True âˆ§ (x' + 1#8 <<< xâœÂ¹ < x' âˆ¨ x' + 1#8 <<< xâœÂ¹ < 1#8 <<< xâœÂ¹) then none
                        else some (x' + 1#8 <<< xâœÂ¹)
            | some { toFin := âŸ¨0, â‹¯âŸ© } =>
              if True âˆ§ 1#8 <<< xâœÂ¹ >>> xâœÂ¹ = 1#8 then none
              else
                if xâœÂ¹ â‰¥ â†‘8 then none
                else
                  Option.map (fun div => 1#8 - div * 1#8 <<< xâœÂ¹)
                    (if (1#8 <<< xâœÂ¹ == 0 || 8 != 1 && 1#8 == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == -1) = true then none
                    else some ((1#8).sdiv (1#8 <<< xâœÂ¹)))) âŠ‘
            if True âˆ§ 1#8 <<< xâœÂ¹ >>> xâœÂ¹ = 1#8 then none
            else
              if xâœÂ¹ â‰¥ â†‘8 then none
              else
                (Option.map (fun div => 1#8 - div * 1#8 <<< xâœÂ¹)
                      (if (1#8 <<< xâœÂ¹ == 0 || 8 != 1 && 1#8 == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == -1) = true then none
                      else some ((1#8).sdiv (1#8 <<< xâœÂ¹)))).bind
                  fun a =>
                  Option.bind
                    (match some (BitVec.ofBool (0#8 >â‚› xâœ)) with
                    | none => none
                    | some { toFin := âŸ¨1, â‹¯âŸ© } =>
                      if True âˆ§ 1#8 <<< xâœÂ¹ >>> xâœÂ¹ = 1#8 then none else if xâœÂ¹ â‰¥ â†‘8 then none else some (1#8 <<< xâœÂ¹)
                    | some { toFin := âŸ¨0, â‹¯âŸ© } => some 0#8)
                    fun y' => if True âˆ§ (a + y' < a âˆ¨ a + y' < y') then none else some (a + y')
      âŠ¢ False
  [Meta.isDefEq] [0.001076] âœ…ï¸ ?hâ‚ =?= congrArg (fun x => x = true)
        (Eq.trans
          (congrArg (fun x => 1#8 <<< xâœÂ¹ == 0#8 || x && 1#8 <<< xâœÂ¹ == 255#8) (Bool.true_and (1#8 == BitVec.intMin 8)))
          (Std.Tactic.BVDecide.Normalize.Bool.or_elim (1#8 <<< xâœÂ¹ == 0#8)
            (1#8 == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == 255#8)))
    [Meta.isDefEq.assign] [0.001073] âœ…ï¸ ?hâ‚ := congrArg (fun x => x = true)
          (Eq.trans
            (congrArg (fun x => 1#8 <<< xâœÂ¹ == 0#8 || x && 1#8 <<< xâœÂ¹ == 255#8)
              (Bool.true_and (1#8 == BitVec.intMin 8)))
            (Std.Tactic.BVDecide.Normalize.Bool.or_elim (1#8 <<< xâœÂ¹ == 0#8)
              (1#8 == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == 255#8)))
      [Meta.isDefEq.assign.checkTypes] [0.001063] âœ…ï¸ (?hâ‚ : ((1#8 <<< xâœÂ¹ == 0 ||
                8 != 1 && 1#8 == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == -1) =
              true) =
            ((!(!1#8 <<< xâœÂ¹ == 0#8 && !(1#8 == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == 255#8))) =
              true)) := (congrArg (fun x => x = true)
            (Eq.trans
              (congrArg (fun x => 1#8 <<< xâœÂ¹ == 0#8 || x && 1#8 <<< xâœÂ¹ == 255#8)
                (Bool.true_and (1#8 == BitVec.intMin 8)))
              (Std.Tactic.BVDecide.Normalize.Bool.or_elim (1#8 <<< xâœÂ¹ == 0#8)
                (1#8 == BitVec.intMin 8 &&
                  1#8 <<< xâœÂ¹ ==
                    255#8))) : ((1#8 <<< xâœÂ¹ == 0#8 || true && 1#8 == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == 255#8) = true) =
            ((!(!1#8 <<< xâœÂ¹ == 0#8 && !(1#8 == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == 255#8))) = true))
        [Meta.isDefEq] [0.001059] âœ…ï¸ ((1#8 <<< xâœÂ¹ == 0 || 8 != 1 && 1#8 == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == -1) =
                true) =
              ((!(!1#8 <<< xâœÂ¹ == 0#8 && !(1#8 == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == 255#8))) =
                true) =?= ((1#8 <<< xâœÂ¹ == 0#8 || true && 1#8 == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == 255#8) = true) =
              ((!(!1#8 <<< xâœÂ¹ == 0#8 && !(1#8 == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == 255#8))) = true)
          [Meta.isDefEq] [0.001043] âœ…ï¸ (1#8 <<< xâœÂ¹ == 0 || 8 != 1 && 1#8 == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == -1) =
                true =?= (1#8 <<< xâœÂ¹ == 0#8 || true && 1#8 == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == 255#8) = true
            [Meta.isDefEq] [0.001029] âœ…ï¸ 1#8 <<< xâœÂ¹ == 0 ||
                  8 != 1 && 1#8 == BitVec.intMin 8 &&
                    1#8 <<< xâœÂ¹ == -1 =?= 1#8 <<< xâœÂ¹ == 0#8 || true && 1#8 == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == 255#8
              [Meta.isDefEq.delta] [0.001015] âœ…ï¸ 1#8 <<< xâœÂ¹ == 0 ||
                    8 != 1 && 1#8 == BitVec.intMin 8 &&
                      1#8 <<< xâœÂ¹ == -1 =?= 1#8 <<< xâœÂ¹ == 0#8 || true && 1#8 == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == 255#8
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      xâœÂ¹ xâœ : BitVec 8
      aâœ :
        Â¬(match some (if (!xâœ.getLsbD 7 == (0#8 >áµ¤ xâœ)) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } =>
              if (1#8 <<< xâœÂ¹ >>> xâœÂ¹ == 1#8) = true then none
              else
                if (!8#8 >áµ¤ xâœÂ¹) = true then none
                else
                  (Option.map (fun div => 2#8 + ~~~(div * 1#8 <<< xâœÂ¹))
                        (if (!(!1#8 <<< xâœÂ¹ == 0#8 && !(1#8 == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == 255#8))) = true then
                          none
                        else
                          some
                            (if (1#8 <<< xâœÂ¹).getLsbD 7 = true then ~~~(1#8 / (~~~(1#8 <<< xâœÂ¹) + 1#8)) + 1#8
                            else 1#8 / 1#8 <<< xâœÂ¹))).bind
                    fun a =>
                    if (1#8 <<< xâœÂ¹ >>> xâœÂ¹ == 1#8) = true then none
                    else
                      if (!8#8 >áµ¤ xâœÂ¹) = true then none
                      else
                        if (!((!a >áµ¤ a + 1#8 <<< xâœÂ¹) && !1#8 <<< xâœÂ¹ >áµ¤ a + 1#8 <<< xâœÂ¹)) = true then none
                        else some (a + 1#8 <<< xâœÂ¹)
            | some { toFin := âŸ¨0, â‹¯âŸ© } =>
              if (1#8 <<< xâœÂ¹ >>> xâœÂ¹ == 1#8) = true then none
              else
                if (!8#8 >áµ¤ xâœÂ¹) = true then none
                else
                  Option.map (fun div => 2#8 + ~~~(div * 1#8 <<< xâœÂ¹))
                    (if (!(!1#8 <<< xâœÂ¹ == 0#8 && !(1#8 == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == 255#8))) = true then none
                    else
                      some
                        (if (1#8 <<< xâœÂ¹).getLsbD 7 = true then ~~~(1#8 / (~~~(1#8 <<< xâœÂ¹) + 1#8)) + 1#8
                        else 1#8 / 1#8 <<< xâœÂ¹))) âŠ‘
            if (1#8 <<< xâœÂ¹ >>> xâœÂ¹ == 1#8) = true then none
            else
              if (!8#8 >áµ¤ xâœÂ¹) = true then none
              else
                (Option.map (fun div => 2#8 + ~~~(div * 1#8 <<< xâœÂ¹))
                      (if (!(!1#8 <<< xâœÂ¹ == 0#8 && !(1#8 == BitVec.intMin 8 && 1#8 <<< xâœÂ¹ == 255#8))) = true then none
                      else
                        some
                          (if (1#8 <<< xâœÂ¹).getLsbD 7 = true then ~~~(1#8 / (~~~(1#8 <<< xâœÂ¹) + 1#8)) + 1#8
                          else 1#8 / 1#8 <<< xâœÂ¹))).bind
                  fun a =>
                  Option.bind
                    (match some (if (!xâœ.getLsbD 7 == (0#8 >áµ¤ xâœ)) = true then 1#1 else 0#1) with
                    | none => none
                    | some { toFin := âŸ¨1, â‹¯âŸ© } =>
                      if (1#8 <<< xâœÂ¹ >>> xâœÂ¹ == 1#8) = true then none
                      else if (!8#8 >áµ¤ xâœÂ¹) = true then none else some (1#8 <<< xâœÂ¹)
                    | some { toFin := âŸ¨0, â‹¯âŸ© } => some 0#8)
                    fun a_1 => if (!((!a >áµ¤ a + a_1) && !a_1 >áµ¤ a + a_1)) = true then none else some (a + a_1)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
