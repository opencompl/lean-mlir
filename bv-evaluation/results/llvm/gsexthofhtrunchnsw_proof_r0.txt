⚠ [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
⚠ [878/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [881/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
⚠ [887/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
⚠ [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsexthofhtrunchnsw_proof.lean:18:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsexthofhtrunchnsw_proof.lean:11:8: error: (kernel) declaration has metavariables 'narrow_source_matching_signbits_thm'
[bv] [0.044631] Normalizing goal
  [Meta.synthInstance] [0.001342] ✅️ Decidable
        ((if True ∧ ((-1#32) <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat = -1#32 then none
          else
            if x✝ &&& 7#32 ≥ ↑32 then none
            else some (BitVec.signExtend 64 (BitVec.truncate 8 ((-1#32) <<< (x✝ &&& 7#32))))) ⊑
          if True ∧ ((-1#32) <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat = -1#32 then none
          else if x✝ &&& 7#32 ≥ ↑32 then none else some (BitVec.signExtend 64 ((-1#32) <<< (x✝ &&& 7#32))))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if True ∧ ((-1#32) <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat = -1#32 then none
            else
              if x✝ &&& 7#32 ≥ ↑32 then none
              else some (BitVec.signExtend 64 (BitVec.truncate 8 ((-1#32) <<< (x✝ &&& 7#32))))) ⊑
            if True ∧ ((-1#32) <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat = -1#32 then none
            else if x✝ &&& 7#32 ≥ ↑32 then none else some (BitVec.signExtend 64 ((-1#32) <<< (x✝ &&& 7#32)))
      ⊢ False
  [Meta.isDefEq] [0.001041] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Std.Tactic.BVDecide.Normalize.BitVec.eq_to_beq
            ((4294967295#32 <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat) 4294967295#32))
        (true_and (((4294967295#32 <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat == 4294967295#32) = true))
    [Meta.isDefEq.assign] [0.001038] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Std.Tactic.BVDecide.Normalize.BitVec.eq_to_beq
              ((4294967295#32 <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat) 4294967295#32))
          (true_and (((4294967295#32 <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat == 4294967295#32) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001021] ✅️ (?h₁ : (True ∧
              ((-1#32) <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat = -1#32) =
            (((4294967295#32 <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat == 4294967295#32) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Std.Tactic.BVDecide.Normalize.BitVec.eq_to_beq
                ((4294967295#32 <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat) 4294967295#32))
            (true_and
              (((4294967295#32 <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat == 4294967295#32) =
                true)) : (True ∧ (4294967295#32 <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat = 4294967295#32) =
            (((4294967295#32 <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat == 4294967295#32) = true))
        [Meta.isDefEq] [0.001015] ✅️ (True ∧ ((-1#32) <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat = -1#32) =
              (((4294967295#32 <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat == 4294967295#32) =
                true) =?= (True ∧ (4294967295#32 <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat = 4294967295#32) =
              (((4294967295#32 <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat == 4294967295#32) = true)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if ((4294967295#32 <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat == 4294967295#32) = true then none
            else
              if (!32#32 >ᵤ x✝ &&& 7#32) = true then none
              else some (BitVec.signExtend 64 (BitVec.zeroExtend 8 (4294967295#32 <<< (x✝ &&& 7#32))))) ⊑
            if ((4294967295#32 <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat == 4294967295#32) = true then none
            else
              if (!32#32 >ᵤ x✝ &&& 7#32) = true then none
              else some (BitVec.signExtend 64 (4294967295#32 <<< (x✝ &&& 7#32)))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsexthofhtrunchnsw_proof.lean:29:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsexthofhtrunchnsw_proof.lean:22:8: error: (kernel) declaration has metavariables 'wide_source_matching_signbits_thm'
[bv] [0.041915] Normalizing goal
  [Meta.synthInstance] [0.001652] ✅️ Decidable
        ((if True ∧ ((-1#32) <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat = -1#32 then none
          else
            if x✝ &&& 7#32 ≥ ↑32 then none
            else some (BitVec.signExtend 24 (BitVec.truncate 8 ((-1#32) <<< (x✝ &&& 7#32))))) ⊑
          if True ∧ ((-1#32) <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat = -1#32 then none
          else if x✝ &&& 7#32 ≥ ↑32 then none else some (BitVec.truncate 24 ((-1#32) <<< (x✝ &&& 7#32))))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if True ∧ ((-1#32) <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat = -1#32 then none
            else
              if x✝ &&& 7#32 ≥ ↑32 then none
              else some (BitVec.signExtend 24 (BitVec.truncate 8 ((-1#32) <<< (x✝ &&& 7#32))))) ⊑
            if True ∧ ((-1#32) <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat = -1#32 then none
            else if x✝ &&& 7#32 ≥ ↑32 then none else some (BitVec.truncate 24 ((-1#32) <<< (x✝ &&& 7#32)))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if ((4294967295#32 <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat == 4294967295#32) = true then none
            else
              if (!32#32 >ᵤ x✝ &&& 7#32) = true then none
              else some (BitVec.signExtend 24 (BitVec.zeroExtend 8 (4294967295#32 <<< (x✝ &&& 7#32))))) ⊑
            if ((4294967295#32 <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat == 4294967295#32) = true then none
            else
              if (!32#32 >ᵤ x✝ &&& 7#32) = true then none
              else some (BitVec.zeroExtend 24 (4294967295#32 <<< (x✝ &&& 7#32)))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsexthofhtrunchnsw_proof.lean:40:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsexthofhtrunchnsw_proof.lean:33:8: error: (kernel) declaration has metavariables 'same_source_matching_signbits_thm'
[bv] [0.053785] Normalizing goal
  [Meta.synthInstance] [0.001988] ✅️ Decidable
        ((if True ∧ ((-1#32) <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat = -1#32 then none
          else
            if x✝ &&& 7#32 ≥ ↑32 then none
            else some (BitVec.signExtend 32 (BitVec.truncate 8 ((-1#32) <<< (x✝ &&& 7#32))))) ⊑
          if True ∧ ((-1#32) <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat = -1#32 then none
          else if x✝ &&& 7#32 ≥ ↑32 then none else some ((-1#32) <<< (x✝ &&& 7#32)))
    [Meta.check] [0.001016] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if True ∧ ((-1#32) <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat = -1#32 then none
          else
            if x✝ &&& 7#32 ≥ ↑32 then none
            else some (BitVec.signExtend 32 (BitVec.truncate 8 ((-1#32) <<< (x✝ &&& 7#32)))))
          (if True ∧ ((-1#32) <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat = -1#32 then none
          else if x✝ &&& 7#32 ≥ ↑32 then none else some ((-1#32) <<< (x✝ &&& 7#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if True ∧ ((-1#32) <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat = -1#32 then none
            else
              if x✝ &&& 7#32 ≥ ↑32 then none
              else some (BitVec.signExtend 32 (BitVec.truncate 8 ((-1#32) <<< (x✝ &&& 7#32))))) ⊑
            if True ∧ ((-1#32) <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat = -1#32 then none
            else if x✝ &&& 7#32 ≥ ↑32 then none else some ((-1#32) <<< (x✝ &&& 7#32))
      ⊢ False
  [Meta.isDefEq] [0.001309] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Std.Tactic.BVDecide.Normalize.BitVec.eq_to_beq
            ((4294967295#32 <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat) 4294967295#32))
        (true_and (((4294967295#32 <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat == 4294967295#32) = true))
    [Meta.isDefEq.assign] [0.001305] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Std.Tactic.BVDecide.Normalize.BitVec.eq_to_beq
              ((4294967295#32 <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat) 4294967295#32))
          (true_and (((4294967295#32 <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat == 4294967295#32) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001283] ✅️ (?h₁ : (True ∧
              ((-1#32) <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat = -1#32) =
            (((4294967295#32 <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat == 4294967295#32) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Std.Tactic.BVDecide.Normalize.BitVec.eq_to_beq
                ((4294967295#32 <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat) 4294967295#32))
            (true_and
              (((4294967295#32 <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat == 4294967295#32) =
                true)) : (True ∧ (4294967295#32 <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat = 4294967295#32) =
            (((4294967295#32 <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat == 4294967295#32) = true))
        [Meta.isDefEq] [0.001278] ✅️ (True ∧ ((-1#32) <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat = -1#32) =
              (((4294967295#32 <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat == 4294967295#32) =
                true) =?= (True ∧ (4294967295#32 <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat = 4294967295#32) =
              (((4294967295#32 <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat == 4294967295#32) = true)
          [Meta.isDefEq] [0.001246] ✅️ True ∧
                ((-1#32) <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat =
                  -1#32 =?= True ∧ (4294967295#32 <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat = 4294967295#32
            [Meta.isDefEq] [0.001215] ✅️ ((-1#32) <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat =
                  -1#32 =?= (4294967295#32 <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat = 4294967295#32
              [Meta.isDefEq] [0.001179] ✅️ ((-1#32) <<< (x✝ &&& 7#32)).sshiftRight
                    (x✝ &&& 7#32).toNat =?= (4294967295#32 <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat
                [Meta.isDefEq.delta] [0.001161] ✅️ ((-1#32) <<< (x✝ &&& 7#32)).sshiftRight
                      (x✝ &&& 7#32).toNat =?= (4294967295#32 <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat
                  [Meta.isDefEq] [0.001131] ✅️ (-1#32) <<< (x✝ &&& 7#32) =?= 4294967295#32 <<< (x✝ &&& 7#32)
                    [Meta.isDefEq] [0.001097] ✅️ BitVec.instHShiftLeft.1 (-1#32)
                          (x✝ &&& 7#32) =?= BitVec.instHShiftLeft.1 (4294967295#32) (x✝ &&& 7#32)
                      [Meta.isDefEq] [0.001020] ✅️ (-1#32) <<<
                            (x✝ &&& 7#32).toNat =?= 4294967295#32 <<< (x✝ &&& 7#32).toNat
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if ((4294967295#32 <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat == 4294967295#32) = true then none
            else
              if (!32#32 >ᵤ x✝ &&& 7#32) = true then none
              else some (BitVec.signExtend 32 (BitVec.zeroExtend 8 (4294967295#32 <<< (x✝ &&& 7#32))))) ⊑
            if ((4294967295#32 <<< (x✝ &&& 7#32)).sshiftRight (x✝ &&& 7#32).toNat == 4294967295#32) = true then none
            else if (!32#32 >ᵤ x✝ &&& 7#32) = true then none else some (4294967295#32 <<< (x✝ &&& 7#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsexthofhtrunchnsw_proof.lean:51:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsexthofhtrunchnsw_proof.lean:44:8: error: (kernel) declaration has metavariables 'same_source_not_matching_signbits_thm'
[bv] [0.031371] Normalizing goal
  [Meta.synthInstance] [0.001358] ✅️ Decidable
        ((if True ∧ ((-1#32) <<< (x✝ &&& 8#32)).sshiftRight (x✝ &&& 8#32).toNat = -1#32 then none
          else
            if x✝ &&& 8#32 ≥ ↑32 then none
            else some (BitVec.signExtend 32 (BitVec.truncate 8 ((-1#32) <<< (x✝ &&& 8#32))))) ⊑
          if x✝ &&& 8#32 ≥ ↑32 then none
          else if 24#32 ≥ ↑32 then none else some ((4278190080#32 <<< (x✝ &&& 8#32)).sshiftRight (24#32).toNat))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if True ∧ ((-1#32) <<< (x✝ &&& 8#32)).sshiftRight (x✝ &&& 8#32).toNat = -1#32 then none
            else
              if x✝ &&& 8#32 ≥ ↑32 then none
              else some (BitVec.signExtend 32 (BitVec.truncate 8 ((-1#32) <<< (x✝ &&& 8#32))))) ⊑
            if x✝ &&& 8#32 ≥ ↑32 then none
            else if 24#32 ≥ ↑32 then none else some ((4278190080#32 <<< (x✝ &&& 8#32)).sshiftRight (24#32).toNat)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if ((4294967295#32 <<< (x✝ &&& 8#32)).sshiftRight (x✝ &&& 8#32).toNat == 4294967295#32) = true then none
            else
              if (!32#32 >ᵤ x✝ &&& 8#32) = true then none
              else some (BitVec.signExtend 32 (BitVec.zeroExtend 8 (4294967295#32 <<< (x✝ &&& 8#32))))) ⊑
            if (!32#32 >ᵤ x✝ &&& 8#32) = true then none else some ((4278190080#32 <<< (x✝ &&& 8#32)).sshiftRight 24)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
