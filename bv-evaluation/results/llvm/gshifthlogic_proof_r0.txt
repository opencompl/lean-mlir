⚠ [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
⚠ [878/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [881/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
⚠ [887/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
⚠ [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthlogic_proof.lean:17:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthlogic_proof.lean:17:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthlogic_proof.lean:11:8: error: (kernel) declaration has metavariables 'shl_and_thm'
[bv] [0.025910] Normalizing goal
  [Meta.synthInstance] [0.002028] ✅️ Decidable
        ((if 3#8 ≥ ↑8 then none else if 2#8 ≥ ↑8 then none else some ((x✝ <<< 3#8 &&& x✝¹) <<< 2#8)) ⊑
          if 5#8 ≥ ↑8 then none else if 2#8 ≥ ↑8 then none else some (x✝ <<< 5#8 &&& x✝¹ <<< 2#8))
    [Meta.check] [0.001116] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if 3#8 ≥ ↑8 then none else if 2#8 ≥ ↑8 then none else some ((x✝ <<< 3#8 &&& x✝¹) <<< 2#8))
          (if 5#8 ≥ ↑8 then none else if 2#8 ≥ ↑8 then none else some (x✝ <<< 5#8 &&& x✝¹ <<< 2#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if 3#8 ≥ ↑8 then none else if 2#8 ≥ ↑8 then none else some ((x✝ <<< 3#8 &&& x✝¹) <<< 2#8)) ⊑
            if 5#8 ≥ ↑8 then none else if 2#8 ≥ ↑8 then none else some (x✝ <<< 5#8 &&& x✝¹ <<< 2#8)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ : ¬some ((x✝ <<< 3 &&& x✝¹) <<< 2) ⊑ some (x✝ <<< 5 &&& x✝¹ <<< 2)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthlogic_proof.lean:29:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthlogic_proof.lean:21:8: error: (kernel) declaration has metavariables 'shl_or_thm'
[bv] [0.100875] Normalizing goal
  [Meta.synthInstance] [0.003047] ✅️ Decidable
        (((Option.map (fun div => x✝ - div * 42#16)
                (if (42#16 == 0 || 16 != 1 && x✝ == BitVec.intMin 16 && 42#16 == -1) = true then none
                else some (x✝.sdiv 42#16))).bind
            fun x => if 5#16 ≥ ↑16 then none else if 7#16 ≥ ↑16 then none else some ((x ||| x✝¹ <<< 5#16) <<< 7#16)) ⊑
          if 12#16 ≥ ↑16 then none
          else
            (Option.map (fun div => x✝ - div * 42#16)
                  (if (42#16 == 0 || 16 != 1 && x✝ == BitVec.intMin 16 && 42#16 == -1) = true then none
                  else some (x✝.sdiv 42#16))).bind
              fun x =>
              if True ∧ (x <<< 7#16).sshiftRight (7#16).toNat = x then none
              else if 7#16 ≥ ↑16 then none else some (x✝¹ <<< 12#16 ||| x <<< 7#16))
    [Meta.check] [0.002084] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          ((Option.map (fun div => x✝ - div * 42#16)
                (if (42#16 == 0 || 16 != 1 && x✝ == BitVec.intMin 16 && 42#16 == -1) = true then none
                else some (x✝.sdiv 42#16))).bind
            fun x => if 5#16 ≥ ↑16 then none else if 7#16 ≥ ↑16 then none else some ((x ||| x✝¹ <<< 5#16) <<< 7#16))
          (if 12#16 ≥ ↑16 then none
          else
            (Option.map (fun div => x✝ - div * 42#16)
                  (if (42#16 == 0 || 16 != 1 && x✝ == BitVec.intMin 16 && 42#16 == -1) = true then none
                  else some (x✝.sdiv 42#16))).bind
              fun x =>
              if True ∧ (x <<< 7#16).sshiftRight (7#16).toNat = x then none
              else if 7#16 ≥ ↑16 then none else some (x✝¹ <<< 12#16 ||| x <<< 7#16))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 16
      x✝¹ x✝ : BitVec 16
      a✝ :
        ¬((Option.map (fun div => x✝ - div * 42#16)
                  (if (42#16 == 0 || 16 != 1 && x✝ == BitVec.intMin 16 && 42#16 == -1) = true then none
                  else some (x✝.sdiv 42#16))).bind
              fun x => if 5#16 ≥ ↑16 then none else if 7#16 ≥ ↑16 then none else some ((x ||| x✝¹ <<< 5#16) <<< 7#16)) ⊑
            if 12#16 ≥ ↑16 then none
            else
              (Option.map (fun div => x✝ - div * 42#16)
                    (if (42#16 == 0 || 16 != 1 && x✝ == BitVec.intMin 16 && 42#16 == -1) = true then none
                    else some (x✝.sdiv 42#16))).bind
                fun x =>
                if True ∧ (x <<< 7#16).sshiftRight (7#16).toNat = x then none
                else if 7#16 ≥ ↑16 then none else some (x✝¹ <<< 12#16 ||| x <<< 7#16)
      ⊢ False
  [Meta.isDefEq] [0.001077] ✅️ ?hf =?= fun a a_1 =>
        Eq.trans
          (ite_cond_eq_false none (if 7#16 ≥ ↑16 then none else some ((a ||| x✝¹ <<< 5#16) <<< 7#16))
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 16#16 5#16)
                (Eq.trans
                  (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 5#16 16#16) (eq_self true)))
                  Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
          (ite_cond_eq_false none (some ((a ||| x✝¹ <<< 5#16) <<< 7#16))
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 16#16 7#16)
                (Eq.trans
                  (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 7#16 16#16) (eq_self true)))
                  Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
    [Meta.isDefEq.assign] [0.001073] ✅️ ?hf := fun a a_1 =>
          Eq.trans
            (ite_cond_eq_false none (if 7#16 ≥ ↑16 then none else some ((a ||| x✝¹ <<< 5#16) <<< 7#16))
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 16#16 5#16)
                  (Eq.trans
                    (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 5#16 16#16) (eq_self true)))
                    Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
            (ite_cond_eq_false none (some ((a ||| x✝¹ <<< 5#16) <<< 7#16))
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 16#16 7#16)
                  (Eq.trans
                    (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 7#16 16#16) (eq_self true)))
                    Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
      [Meta.isDefEq.assign.checkTypes] [0.001020] ✅️ (?hf : ∀
            a ∈
              Option.map (fun div => x✝ + (~~~(div * 42#16) + 1#16))
                (some (if x✝.getLsbD 15 = true then ~~~((~~~x✝ + 1#16) / 42#16) + 1#16 else x✝ / 42#16)),
            (if 5#16 ≥ ↑16 then none else if 7#16 ≥ ↑16 then none else some ((a ||| x✝¹ <<< 5#16) <<< 7#16)) =
              some
                ((a ||| x✝¹ <<< 5) <<<
                  7)) := (fun a a_1 =>
            Eq.trans
              (ite_cond_eq_false none (if 7#16 ≥ ↑16 then none else some ((a ||| x✝¹ <<< 5#16) <<< 7#16))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 16#16 5#16)
                    (Eq.trans
                      (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 5#16 16#16) (eq_self true)))
                      Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
              (ite_cond_eq_false none (some ((a ||| x✝¹ <<< 5#16) <<< 7#16))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 16#16 7#16)
                    (Eq.trans
                      (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 7#16 16#16) (eq_self true)))
                      Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))) : ∀
            a ∈
              Option.map (fun div => x✝ + (~~~(div * 42#16) + 1#16))
                (some (if x✝.getLsbD 15 = true then ~~~((~~~x✝ + 1#16) / 42#16) + 1#16 else x✝ / 42#16)),
            (if 5#16 ≥ ↑16 then none else if 7#16 ≥ ↑16 then none else some ((a ||| x✝¹ <<< 5#16) <<< 7#16)) =
              some ((a ||| x✝¹ <<< 5#16) <<< 7#16))
        [Meta.isDefEq] [0.001011] ✅️ ∀
              a ∈
                Option.map (fun div => x✝ + (~~~(div * 42#16) + 1#16))
                  (some (if x✝.getLsbD 15 = true then ~~~((~~~x✝ + 1#16) / 42#16) + 1#16 else x✝ / 42#16)),
              (if 5#16 ≥ ↑16 then none else if 7#16 ≥ ↑16 then none else some ((a ||| x✝¹ <<< 5#16) <<< 7#16)) =
                some
                  ((a ||| x✝¹ <<< 5) <<<
                    7) =?= ∀
              a ∈
                Option.map (fun div => x✝ + (~~~(div * 42#16) + 1#16))
                  (some (if x✝.getLsbD 15 = true then ~~~((~~~x✝ + 1#16) / 42#16) + 1#16 else x✝ / 42#16)),
              (if 5#16 ≥ ↑16 then none else if 7#16 ≥ ↑16 then none else some ((a ||| x✝¹ <<< 5#16) <<< 7#16)) =
                some ((a ||| x✝¹ <<< 5#16) <<< 7#16)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 16
      x✝¹ x✝ : BitVec 16
      a✝ :
        ¬((Option.map (fun div => x✝ + (~~~(div * 42#16) + 1#16))
                  (some (if x✝.getLsbD 15 = true then ~~~((~~~x✝ + 1#16) / 42#16) + 1#16 else x✝ / 42#16))).bind
              fun a => some ((a ||| x✝¹ <<< 5) <<< 7)) ⊑
            (Option.map (fun div => x✝ + (~~~(div * 42#16) + 1#16))
                  (some (if x✝.getLsbD 15 = true then ~~~((~~~x✝ + 1#16) / 42#16) + 1#16 else x✝ / 42#16))).bind
              fun a => if ((a <<< 7).sshiftRight 7 == a) = true then none else some (x✝¹ <<< 12 ||| a <<< 7)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthlogic_proof.lean:40:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthlogic_proof.lean:40:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthlogic_proof.lean:33:8: error: (kernel) declaration has metavariables 'shl_xor_thm'
[bv] [0.013650] Normalizing goal
  [Meta.synthInstance] [0.001124] ✅️ Decidable
        ((if 5#32 ≥ ↑32 then none else if 7#32 ≥ ↑32 then none else some ((x✝ <<< 5#32 ^^^ x✝¹) <<< 7#32)) ⊑
          if 12#32 ≥ ↑32 then none else if 7#32 ≥ ↑32 then none else some (x✝ <<< 12#32 ^^^ x✝¹ <<< 7#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if 5#32 ≥ ↑32 then none else if 7#32 ≥ ↑32 then none else some ((x✝ <<< 5#32 ^^^ x✝¹) <<< 7#32)) ⊑
            if 12#32 ≥ ↑32 then none else if 7#32 ≥ ↑32 then none else some (x✝ <<< 12#32 ^^^ x✝¹ <<< 7#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ : ¬some ((x✝ <<< 5 ^^^ x✝¹) <<< 7) ⊑ some (x✝ <<< 12 ^^^ x✝¹ <<< 7)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthlogic_proof.lean:51:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthlogic_proof.lean:44:8: error: (kernel) declaration has metavariables 'lshr_and_thm'
[bv] [0.057305] Normalizing goal
  [Meta.synthInstance] [0.001693] ✅️ Decidable
        (((Option.map (fun div => x✝ - div * 42#64)
                (if (42#64 == 0 || 64 != 1 && x✝ == BitVec.intMin 64 && 42#64 == -1) = true then none
                else some (x✝.sdiv 42#64))).bind
            fun x => if 5#64 ≥ ↑64 then none else if 7#64 ≥ ↑64 then none else some ((x &&& x✝¹ >>> 5#64) >>> 7#64)) ⊑
          if 12#64 ≥ ↑64 then none
          else
            (Option.map (fun div => x✝ - div * 42#64)
                  (if (42#64 == 0 || 64 != 1 && x✝ == BitVec.intMin 64 && 42#64 == -1) = true then none
                  else some (x✝.sdiv 42#64))).bind
              fun x => if 7#64 ≥ ↑64 then none else some (x✝¹ >>> 12#64 &&& x >>> 7#64))
    [Meta.check] [0.001084] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          ((Option.map (fun div => x✝ - div * 42#64)
                (if (42#64 == 0 || 64 != 1 && x✝ == BitVec.intMin 64 && 42#64 == -1) = true then none
                else some (x✝.sdiv 42#64))).bind
            fun x => if 5#64 ≥ ↑64 then none else if 7#64 ≥ ↑64 then none else some ((x &&& x✝¹ >>> 5#64) >>> 7#64))
          (if 12#64 ≥ ↑64 then none
          else
            (Option.map (fun div => x✝ - div * 42#64)
                  (if (42#64 == 0 || 64 != 1 && x✝ == BitVec.intMin 64 && 42#64 == -1) = true then none
                  else some (x✝.sdiv 42#64))).bind
              fun x => if 7#64 ≥ ↑64 then none else some (x✝¹ >>> 12#64 &&& x >>> 7#64))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 64
      x✝¹ x✝ : BitVec 64
      a✝ :
        ¬((Option.map (fun div => x✝ - div * 42#64)
                  (if (42#64 == 0 || 64 != 1 && x✝ == BitVec.intMin 64 && 42#64 == -1) = true then none
                  else some (x✝.sdiv 42#64))).bind
              fun x => if 5#64 ≥ ↑64 then none else if 7#64 ≥ ↑64 then none else some ((x &&& x✝¹ >>> 5#64) >>> 7#64)) ⊑
            if 12#64 ≥ ↑64 then none
            else
              (Option.map (fun div => x✝ - div * 42#64)
                    (if (42#64 == 0 || 64 != 1 && x✝ == BitVec.intMin 64 && 42#64 == -1) = true then none
                    else some (x✝.sdiv 42#64))).bind
                fun x => if 7#64 ≥ ↑64 then none else some (x✝¹ >>> 12#64 &&& x >>> 7#64)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 64
      x✝¹ x✝ : BitVec 64
      a✝ :
        ¬((Option.map (fun div => x✝ + (~~~(div * 42#64) + 1#64))
                  (some (if x✝.getLsbD 63 = true then ~~~((~~~x✝ + 1#64) / 42#64) + 1#64 else x✝ / 42#64))).bind
              fun a => some ((a &&& x✝¹ >>> 5) >>> 7)) ⊑
            (Option.map (fun div => x✝ + (~~~(div * 42#64) + 1#64))
                  (some (if x✝.getLsbD 63 = true then ~~~((~~~x✝ + 1#64) / 42#64) + 1#64 else x✝ / 42#64))).bind
              fun a => some (x✝¹ >>> 12 &&& a >>> 7)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthlogic_proof.lean:62:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthlogic_proof.lean:55:8: error: (kernel) declaration has metavariables 'ashr_xor_thm'
[bv] [0.051602] Normalizing goal
  [Meta.synthInstance] [0.001707] ✅️ Decidable
        (((Option.map (fun div => x✝ - div * 42#32)
                (if (42#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 42#32 == -1) = true then none
                else some (x✝.sdiv 42#32))).bind
            fun x =>
            if 5#32 ≥ ↑32 then none
            else if 7#32 ≥ ↑32 then none else some ((x ^^^ x✝¹.sshiftRight (5#32).toNat).sshiftRight (7#32).toNat)) ⊑
          if 12#32 ≥ ↑32 then none
          else
            (Option.map (fun div => x✝ - div * 42#32)
                  (if (42#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 42#32 == -1) = true then none
                  else some (x✝.sdiv 42#32))).bind
              fun x => if 7#32 ≥ ↑32 then none else some (x✝¹.sshiftRight (12#32).toNat ^^^ x.sshiftRight (7#32).toNat))
    [Meta.check] [0.001071] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          ((Option.map (fun div => x✝ - div * 42#32)
                (if (42#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 42#32 == -1) = true then none
                else some (x✝.sdiv 42#32))).bind
            fun x =>
            if 5#32 ≥ ↑32 then none
            else if 7#32 ≥ ↑32 then none else some ((x ^^^ x✝¹.sshiftRight (5#32).toNat).sshiftRight (7#32).toNat))
          (if 12#32 ≥ ↑32 then none
          else
            (Option.map (fun div => x✝ - div * 42#32)
                  (if (42#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 42#32 == -1) = true then none
                  else some (x✝.sdiv 42#32))).bind
              fun x => if 7#32 ≥ ↑32 then none else some (x✝¹.sshiftRight (12#32).toNat ^^^ x.sshiftRight (7#32).toNat))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬((Option.map (fun div => x✝ - div * 42#32)
                  (if (42#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 42#32 == -1) = true then none
                  else some (x✝.sdiv 42#32))).bind
              fun x =>
              if 5#32 ≥ ↑32 then none
              else if 7#32 ≥ ↑32 then none else some ((x ^^^ x✝¹.sshiftRight (5#32).toNat).sshiftRight (7#32).toNat)) ⊑
            if 12#32 ≥ ↑32 then none
            else
              (Option.map (fun div => x✝ - div * 42#32)
                    (if (42#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 42#32 == -1) = true then none
                    else some (x✝.sdiv 42#32))).bind
                fun x =>
                if 7#32 ≥ ↑32 then none else some (x✝¹.sshiftRight (12#32).toNat ^^^ x.sshiftRight (7#32).toNat)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬((Option.map (fun div => x✝ + (~~~(div * 42#32) + 1#32))
                  (some (if x✝.getLsbD 31 = true then ~~~((~~~x✝ + 1#32) / 42#32) + 1#32 else x✝ / 42#32))).bind
              fun a => some ((a ^^^ x✝¹.sshiftRight 5).sshiftRight 7)) ⊑
            (Option.map (fun div => x✝ + (~~~(div * 42#32) + 1#32))
                  (some (if x✝.getLsbD 31 = true then ~~~((~~~x✝ + 1#32) / 42#32) + 1#32 else x✝ / 42#32))).bind
              fun a => some (x✝¹.sshiftRight 12 ^^^ a.sshiftRight 7)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthlogic_proof.lean:73:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthlogic_proof.lean:66:8: error: (kernel) declaration has metavariables 'lshr_mul_thm'
[bv] [0.050383] Normalizing goal
  [Meta.synthInstance] [0.001793] ✅️ Decidable
        ((if
              True ∧
                BitVec.zeroExtend (2 * 64) x✝ * BitVec.zeroExtend (2 * 64) 52#64 ≥
                  BitVec.twoPow (2 * 64) (64 - 1) <<< 1 then
            none
          else if 2#64 ≥ ↑64 then none else some ((x✝ * 52#64) >>> 2#64)) ⊑
          if
              True ∧
                (BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 13#64 <
                    BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ∨
                  BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 13#64 ≥
                    BitVec.twoPow (2 * 64) (64 - 1)) then
            none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 64) x✝ * BitVec.zeroExtend (2 * 64) 13#64 ≥
                    BitVec.twoPow (2 * 64) (64 - 1) <<< 1 then
              none
            else some (x✝ * 13#64))
    [Meta.check] [0.001130] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if
              True ∧
                BitVec.zeroExtend (2 * 64) x✝ * BitVec.zeroExtend (2 * 64) 52#64 ≥
                  BitVec.twoPow (2 * 64) (64 - 1) <<< 1 then
            none
          else if 2#64 ≥ ↑64 then none else some ((x✝ * 52#64) >>> 2#64))
          (if
              True ∧
                (BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 13#64 <
                    BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ∨
                  BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 13#64 ≥
                    BitVec.twoPow (2 * 64) (64 - 1)) then
            none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 64) x✝ * BitVec.zeroExtend (2 * 64) 13#64 ≥
                    BitVec.twoPow (2 * 64) (64 - 1) <<< 1 then
              none
            else some (x✝ * 13#64))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      x✝ : BitVec 64
      a✝ :
        ¬(if
                True ∧
                  BitVec.zeroExtend (2 * 64) x✝ * BitVec.zeroExtend (2 * 64) 52#64 ≥
                    BitVec.twoPow (2 * 64) (64 - 1) <<< 1 then
              none
            else if 2#64 ≥ ↑64 then none else some ((x✝ * 52#64) >>> 2#64)) ⊑
            if
                True ∧
                  (BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 13#64 <
                      BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ∨
                    BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 13#64 ≥
                      BitVec.twoPow (2 * 64) (64 - 1)) then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 64) x✝ * BitVec.zeroExtend (2 * 64) 13#64 ≥
                      BitVec.twoPow (2 * 64) (64 - 1) <<< 1 then
                none
              else some (x✝ * 13#64)
      ⊢ False
  [Meta.isDefEq] [0.001384] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 128 63 <<< 1)
                (BitVec.zeroExtend 128 x✝ * 52#128))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 128 x✝ * 52#128)
                      (BitVec.twoPow 128 63 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 52#128) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 52#128)))))))
        (true_and ((!BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 52#128) = true))
    [Meta.isDefEq.assign] [0.001382] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 128 63 <<< 1)
                  (BitVec.zeroExtend 128 x✝ * 52#128))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 128 x✝ * 52#128)
                        (BitVec.twoPow 128 63 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 52#128) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 52#128)))))))
          (true_and ((!BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 52#128) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001369] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 64) x✝ * BitVec.zeroExtend (2 * 64) 52#64 ≥
                BitVec.twoPow (2 * 64) (64 - 1) <<< 1) =
            ((!BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 52#128) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 128 63 <<< 1)
                    (BitVec.zeroExtend 128 x✝ * 52#128))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 128 x✝ * 52#128)
                          (BitVec.twoPow 128 63 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 52#128) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 52#128)))))))
            (true_and
              ((!BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 52#128) =
                true)) : (True ∧ BitVec.zeroExtend 128 x✝ * 52#128 ≥ BitVec.twoPow 128 63 <<< 1) =
            ((!BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 52#128) = true))
        [Meta.isDefEq] [0.001366] ✅️ (True ∧
                BitVec.zeroExtend (2 * 64) x✝ * BitVec.zeroExtend (2 * 64) 52#64 ≥
                  BitVec.twoPow (2 * 64) (64 - 1) <<< 1) =
              ((!BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 52#128) =
                true) =?= (True ∧ BitVec.zeroExtend 128 x✝ * 52#128 ≥ BitVec.twoPow 128 63 <<< 1) =
              ((!BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 52#128) = true)
          [Meta.isDefEq] [0.001346] ✅️ True ∧
                BitVec.zeroExtend (2 * 64) x✝ * BitVec.zeroExtend (2 * 64) 52#64 ≥
                  BitVec.twoPow (2 * 64) (64 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 128 x✝ * 52#128 ≥ BitVec.twoPow 128 63 <<< 1
            [Meta.isDefEq] [0.001331] ✅️ BitVec.zeroExtend (2 * 64) x✝ * BitVec.zeroExtend (2 * 64) 52#64 ≥
                  BitVec.twoPow (2 * 64) (64 - 1) <<<
                    1 =?= BitVec.zeroExtend 128 x✝ * 52#128 ≥ BitVec.twoPow 128 63 <<< 1
              [Meta.isDefEq.delta] [0.001311] ✅️ BitVec.zeroExtend (2 * 64) x✝ * BitVec.zeroExtend (2 * 64) 52#64 ≥
                    BitVec.twoPow (2 * 64) (64 - 1) <<<
                      1 =?= BitVec.zeroExtend 128 x✝ * 52#128 ≥ BitVec.twoPow 128 63 <<< 1
  [Meta.isDefEq] [0.001493] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 128 x✝ * 13#128)
                    (BitVec.signExtend 128 (BitVec.twoPow 64 63))))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 128 63)
                      (BitVec.signExtend 128 x✝ * 13#128))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 128 x✝ * 13#128)
                            (BitVec.twoPow 128 63)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128) true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true (BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 13#128)
                !BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 13#128)
                  !BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128)
                (congrArg
                  (fun x => !((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 13#128) && x))
                  (Bool.not_not (BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128)))))))
        (true_and
          ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 13#128) &&
                BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128)) =
            true))
    [Meta.isDefEq.assign] [0.001490] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 128 x✝ * 13#128)
                      (BitVec.signExtend 128 (BitVec.twoPow 64 63))))
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 128 63)
                        (BitVec.signExtend 128 x✝ * 13#128))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 128 x✝ * 13#128)
                              (BitVec.twoPow 128 63)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128) true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true (BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 13#128)
                  !BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 13#128)
                    !BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128)
                  (congrArg
                    (fun x =>
                      !((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 13#128) && x))
                    (Bool.not_not (BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128)))))))
          (true_and
            ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 13#128) &&
                  BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.001464] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 13#64 <
                  BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ∨
                BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 13#64 ≥ BitVec.twoPow (2 * 64) (64 - 1))) =
            ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 13#128) &&
                  BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 128 x✝ * 13#128)
                        (BitVec.signExtend 128 (BitVec.twoPow 64 63))))
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 128 63)
                          (BitVec.signExtend 128 x✝ * 13#128))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 128 x✝ * 13#128)
                                (BitVec.twoPow 128 63)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128) true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true (BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 13#128)
                    !BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 13#128)
                      !BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128)
                    (congrArg
                      (fun x =>
                        !((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 13#128) && x))
                      (Bool.not_not (BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128)))))))
            (true_and
              ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 13#128) &&
                    BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128)) =
                true)) : (True ∧
              (BitVec.signExtend 128 x✝ * 13#128 < BitVec.signExtend 128 (BitVec.twoPow 64 63) ∨
                BitVec.signExtend 128 x✝ * 13#128 ≥ BitVec.twoPow 128 63)) =
            ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 13#128) &&
                  BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128)) =
              true))
        [Meta.isDefEq] [0.001460] ✅️ (True ∧
                (BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 13#64 <
                    BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ∨
                  BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 13#64 ≥ BitVec.twoPow (2 * 64) (64 - 1))) =
              ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 13#128) &&
                    BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128)) =
                true) =?= (True ∧
                (BitVec.signExtend 128 x✝ * 13#128 < BitVec.signExtend 128 (BitVec.twoPow 64 63) ∨
                  BitVec.signExtend 128 x✝ * 13#128 ≥ BitVec.twoPow 128 63)) =
              ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 13#128) &&
                    BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128)) =
                true)
          [Meta.isDefEq] [0.001437] ✅️ True ∧
                (BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 13#64 <
                    BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ∨
                  BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 13#64 ≥
                    BitVec.twoPow (2 * 64)
                      (64 -
                        1)) =?= True ∧
                (BitVec.signExtend 128 x✝ * 13#128 < BitVec.signExtend 128 (BitVec.twoPow 64 63) ∨
                  BitVec.signExtend 128 x✝ * 13#128 ≥ BitVec.twoPow 128 63)
            [Meta.isDefEq] [0.001427] ✅️ BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 13#64 <
                    BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ∨
                  BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 13#64 ≥
                    BitVec.twoPow (2 * 64)
                      (64 -
                        1) =?= BitVec.signExtend 128 x✝ * 13#128 < BitVec.signExtend 128 (BitVec.twoPow 64 63) ∨
                  BitVec.signExtend 128 x✝ * 13#128 ≥ BitVec.twoPow 128 63
              [Meta.isDefEq] [0.001328] ✅️ BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 13#64 <
                    BitVec.signExtend (2 * 64)
                      (BitVec.twoPow 64
                        (64 - 1)) =?= BitVec.signExtend 128 x✝ * 13#128 < BitVec.signExtend 128 (BitVec.twoPow 64 63)
                [Meta.isDefEq] [0.001310] ✅️ instLTBitVec.1
                      (BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 13#64)
                      (BitVec.signExtend (2 * 64)
                        (BitVec.twoPow 64
                          (64 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 128 x✝ * 13#128)
                      (BitVec.signExtend 128 (BitVec.twoPow 64 63))
                  [Meta.isDefEq] [0.001262] ✅️ (BitVec.signExtend (2 * 64) x✝ *
                            BitVec.signExtend (2 * 64) 13#64).toNat <
                        (BitVec.signExtend (2 * 64)
                            (BitVec.twoPow 64
                              (64 -
                                1))).toNat =?= (BitVec.signExtend 128 x✝ * 13#128).toNat <
                        (BitVec.signExtend 128 (BitVec.twoPow 64 63)).toNat
                    [Meta.isDefEq] [0.001249] ✅️ instLTNat.1
                          (BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 13#64).toNat
                          (BitVec.signExtend (2 * 64)
                              (BitVec.twoPow 64
                                (64 -
                                  1))).toNat =?= instLTNat.1 (BitVec.signExtend 128 x✝ * 13#128).toNat
                          (BitVec.signExtend 128 (BitVec.twoPow 64 63)).toNat
                      [Meta.isDefEq] [0.001222] ✅️ (BitVec.signExtend (2 * 64) x✝ *
                                  BitVec.signExtend (2 * 64) 13#64).toNat.lt
                            (BitVec.signExtend (2 * 64)
                                (BitVec.twoPow 64
                                  (64 -
                                    1))).toNat =?= (BitVec.signExtend 128 x✝ * 13#128).toNat.lt
                            (BitVec.signExtend 128 (BitVec.twoPow 64 63)).toNat
                        [Meta.isDefEq.delta] [0.001211] ✅️ (BitVec.signExtend (2 * 64) x✝ *
                                    BitVec.signExtend (2 * 64) 13#64).toNat.lt
                              (BitVec.signExtend (2 * 64)
                                  (BitVec.twoPow 64
                                    (64 -
                                      1))).toNat =?= (BitVec.signExtend 128 x✝ * 13#128).toNat.lt
                              (BitVec.signExtend 128 (BitVec.twoPow 64 63)).toNat
                          [Meta.isDefEq] [0.001127] ✅️ (BitVec.signExtend (2 * 64) x✝ *
                                  BitVec.signExtend (2 * 64) 13#64).toNat =?= (BitVec.signExtend 128 x✝ * 13#128).toNat
                            [Meta.isDefEq.delta] [0.001116] ✅️ (BitVec.signExtend (2 * 64) x✝ *
                                    BitVec.signExtend (2 * 64)
                                      13#64).toNat =?= (BitVec.signExtend 128 x✝ * 13#128).toNat
                              [Meta.isDefEq] [0.001096] ✅️ BitVec.signExtend (2 * 64) x✝ *
                                    BitVec.signExtend (2 * 64) 13#64 =?= BitVec.signExtend 128 x✝ * 13#128
                                [Meta.isDefEq] [0.001079] ✅️ instHMul.1 (BitVec.signExtend (2 * 64) x✝)
                                      (BitVec.signExtend (2 * 64)
                                        13#64) =?= instHMul.1 (BitVec.signExtend 128 x✝) 13#128
                                  [Meta.isDefEq] [0.001052] ✅️ Mul.mul (BitVec.signExtend (2 * 64) x✝)
                                        (BitVec.signExtend (2 * 64) 13#64) =?= Mul.mul (BitVec.signExtend 128 x✝) 13#128
                                    [Meta.isDefEq] [0.001036] ✅️ BitVec.instMul.1 (BitVec.signExtend (2 * 64) x✝)
                                          (BitVec.signExtend (2 * 64)
                                            13#64) =?= BitVec.instMul.1 (BitVec.signExtend 128 x✝) 13#128
                                      [Meta.isDefEq] [0.001013] ✅️ (BitVec.signExtend (2 * 64) x✝).mul
                                            (BitVec.signExtend (2 * 64) 13#64) =?= (BitVec.signExtend 128 x✝).mul 13#128
                                        [Meta.isDefEq.delta] [0.001002] ✅️ (BitVec.signExtend (2 * 64) x✝).mul
                                              (BitVec.signExtend (2 * 64)
                                                13#64) =?= (BitVec.signExtend 128 x✝).mul 13#128
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      x✝ : BitVec 64
      a✝ :
        ¬(if (!BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 52#128) = true then none
            else some ((x✝ * 52#64) >>> 2)) ⊑
            if
                (!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 13#128) &&
                      BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128)) =
                  true then
              none
            else
              if (!BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 13#128) = true then none
              else some (x✝ * 13#64)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthlogic_proof.lean:84:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthlogic_proof.lean:77:8: error: (kernel) declaration has metavariables 'lshr_mul_nuw_nsw_thm'
[bv] [0.071312] Normalizing goal
  [Meta.synthInstance] [0.001918] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 52#64 <
                    BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ∨
                  BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 52#64 ≥
                    BitVec.twoPow (2 * 64) (64 - 1)) then
            none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 64) x✝ * BitVec.zeroExtend (2 * 64) 52#64 ≥
                    BitVec.twoPow (2 * 64) (64 - 1) <<< 1 then
              none
            else if 2#64 ≥ ↑64 then none else some ((x✝ * 52#64) >>> 2#64)) ⊑
          if
              True ∧
                (BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 13#64 <
                    BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ∨
                  BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 13#64 ≥
                    BitVec.twoPow (2 * 64) (64 - 1)) then
            none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 64) x✝ * BitVec.zeroExtend (2 * 64) 13#64 ≥
                    BitVec.twoPow (2 * 64) (64 - 1) <<< 1 then
              none
            else some (x✝ * 13#64))
    [Meta.check] [0.001258] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if
              True ∧
                (BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 52#64 <
                    BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ∨
                  BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 52#64 ≥
                    BitVec.twoPow (2 * 64) (64 - 1)) then
            none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 64) x✝ * BitVec.zeroExtend (2 * 64) 52#64 ≥
                    BitVec.twoPow (2 * 64) (64 - 1) <<< 1 then
              none
            else if 2#64 ≥ ↑64 then none else some ((x✝ * 52#64) >>> 2#64))
          (if
              True ∧
                (BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 13#64 <
                    BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ∨
                  BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 13#64 ≥
                    BitVec.twoPow (2 * 64) (64 - 1)) then
            none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 64) x✝ * BitVec.zeroExtend (2 * 64) 13#64 ≥
                    BitVec.twoPow (2 * 64) (64 - 1) <<< 1 then
              none
            else some (x✝ * 13#64))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      x✝ : BitVec 64
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 52#64 <
                      BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ∨
                    BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 52#64 ≥
                      BitVec.twoPow (2 * 64) (64 - 1)) then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 64) x✝ * BitVec.zeroExtend (2 * 64) 52#64 ≥
                      BitVec.twoPow (2 * 64) (64 - 1) <<< 1 then
                none
              else if 2#64 ≥ ↑64 then none else some ((x✝ * 52#64) >>> 2#64)) ⊑
            if
                True ∧
                  (BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 13#64 <
                      BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ∨
                    BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 13#64 ≥
                      BitVec.twoPow (2 * 64) (64 - 1)) then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 64) x✝ * BitVec.zeroExtend (2 * 64) 13#64 ≥
                      BitVec.twoPow (2 * 64) (64 - 1) <<< 1 then
                none
              else some (x✝ * 13#64)
      ⊢ False
  [Meta.isDefEq] [0.002202] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 128 x✝ * 52#128)
                    (BitVec.signExtend 128 (BitVec.twoPow 64 63))))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 128 63)
                      (BitVec.signExtend 128 x✝ * 52#128))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 128 x✝ * 52#128)
                            (BitVec.twoPow 128 63)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 52#128) true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true (BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 52#128)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 52#128)
                !BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 52#128))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 52#128)
                  !BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 52#128)
                (congrArg
                  (fun x => !((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 52#128) && x))
                  (Bool.not_not (BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 52#128)))))))
        (true_and
          ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 52#128) &&
                BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 52#128)) =
            true))
    [Meta.isDefEq.assign] [0.002199] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 128 x✝ * 52#128)
                      (BitVec.signExtend 128 (BitVec.twoPow 64 63))))
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 128 63)
                        (BitVec.signExtend 128 x✝ * 52#128))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 128 x✝ * 52#128)
                              (BitVec.twoPow 128 63)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 52#128) true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true (BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 52#128)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 52#128)
                  !BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 52#128))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 52#128)
                    !BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 52#128)
                  (congrArg
                    (fun x =>
                      !((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 52#128) && x))
                    (Bool.not_not (BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 52#128)))))))
          (true_and
            ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 52#128) &&
                  BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 52#128)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.002165] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 52#64 <
                  BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ∨
                BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 52#64 ≥ BitVec.twoPow (2 * 64) (64 - 1))) =
            ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 52#128) &&
                  BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 52#128)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 128 x✝ * 52#128)
                        (BitVec.signExtend 128 (BitVec.twoPow 64 63))))
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 128 63)
                          (BitVec.signExtend 128 x✝ * 52#128))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 128 x✝ * 52#128)
                                (BitVec.twoPow 128 63)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 52#128) true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true (BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 52#128)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 52#128)
                    !BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 52#128))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 52#128)
                      !BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 52#128)
                    (congrArg
                      (fun x =>
                        !((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 52#128) && x))
                      (Bool.not_not (BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 52#128)))))))
            (true_and
              ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 52#128) &&
                    BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 52#128)) =
                true)) : (True ∧
              (BitVec.signExtend 128 x✝ * 52#128 < BitVec.signExtend 128 (BitVec.twoPow 64 63) ∨
                BitVec.signExtend 128 x✝ * 52#128 ≥ BitVec.twoPow 128 63)) =
            ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 52#128) &&
                  BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 52#128)) =
              true))
        [Meta.isDefEq] [0.002161] ✅️ (True ∧
                (BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 52#64 <
                    BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ∨
                  BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 52#64 ≥ BitVec.twoPow (2 * 64) (64 - 1))) =
              ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 52#128) &&
                    BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 52#128)) =
                true) =?= (True ∧
                (BitVec.signExtend 128 x✝ * 52#128 < BitVec.signExtend 128 (BitVec.twoPow 64 63) ∨
                  BitVec.signExtend 128 x✝ * 52#128 ≥ BitVec.twoPow 128 63)) =
              ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 52#128) &&
                    BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 52#128)) =
                true)
          [Meta.isDefEq] [0.002136] ✅️ True ∧
                (BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 52#64 <
                    BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ∨
                  BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 52#64 ≥
                    BitVec.twoPow (2 * 64)
                      (64 -
                        1)) =?= True ∧
                (BitVec.signExtend 128 x✝ * 52#128 < BitVec.signExtend 128 (BitVec.twoPow 64 63) ∨
                  BitVec.signExtend 128 x✝ * 52#128 ≥ BitVec.twoPow 128 63)
            [Meta.isDefEq] [0.002116] ✅️ BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 52#64 <
                    BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ∨
                  BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 52#64 ≥
                    BitVec.twoPow (2 * 64)
                      (64 -
                        1) =?= BitVec.signExtend 128 x✝ * 52#128 < BitVec.signExtend 128 (BitVec.twoPow 64 63) ∨
                  BitVec.signExtend 128 x✝ * 52#128 ≥ BitVec.twoPow 128 63
              [Meta.isDefEq] [0.001999] ✅️ BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 52#64 <
                    BitVec.signExtend (2 * 64)
                      (BitVec.twoPow 64
                        (64 - 1)) =?= BitVec.signExtend 128 x✝ * 52#128 < BitVec.signExtend 128 (BitVec.twoPow 64 63)
                [Meta.isDefEq] [0.001969] ✅️ instLTBitVec.1
                      (BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 52#64)
                      (BitVec.signExtend (2 * 64)
                        (BitVec.twoPow 64
                          (64 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 128 x✝ * 52#128)
                      (BitVec.signExtend 128 (BitVec.twoPow 64 63))
                  [Meta.isDefEq] [0.001894] ✅️ (BitVec.signExtend (2 * 64) x✝ *
                            BitVec.signExtend (2 * 64) 52#64).toNat <
                        (BitVec.signExtend (2 * 64)
                            (BitVec.twoPow 64
                              (64 -
                                1))).toNat =?= (BitVec.signExtend 128 x✝ * 52#128).toNat <
                        (BitVec.signExtend 128 (BitVec.twoPow 64 63)).toNat
                    [Meta.isDefEq] [0.001875] ✅️ instLTNat.1
                          (BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 52#64).toNat
                          (BitVec.signExtend (2 * 64)
                              (BitVec.twoPow 64
                                (64 -
                                  1))).toNat =?= instLTNat.1 (BitVec.signExtend 128 x✝ * 52#128).toNat
                          (BitVec.signExtend 128 (BitVec.twoPow 64 63)).toNat
                      [Meta.isDefEq] [0.001827] ✅️ (BitVec.signExtend (2 * 64) x✝ *
                                  BitVec.signExtend (2 * 64) 52#64).toNat.lt
                            (BitVec.signExtend (2 * 64)
                                (BitVec.twoPow 64
                                  (64 -
                                    1))).toNat =?= (BitVec.signExtend 128 x✝ * 52#128).toNat.lt
                            (BitVec.signExtend 128 (BitVec.twoPow 64 63)).toNat
                        [Meta.isDefEq.delta] [0.001811] ✅️ (BitVec.signExtend (2 * 64) x✝ *
                                    BitVec.signExtend (2 * 64) 52#64).toNat.lt
                              (BitVec.signExtend (2 * 64)
                                  (BitVec.twoPow 64
                                    (64 -
                                      1))).toNat =?= (BitVec.signExtend 128 x✝ * 52#128).toNat.lt
                              (BitVec.signExtend 128 (BitVec.twoPow 64 63)).toNat
                          [Meta.isDefEq] [0.001710] ✅️ (BitVec.signExtend (2 * 64) x✝ *
                                  BitVec.signExtend (2 * 64) 52#64).toNat =?= (BitVec.signExtend 128 x✝ * 52#128).toNat
                            [Meta.isDefEq.delta] [0.001686] ✅️ (BitVec.signExtend (2 * 64) x✝ *
                                    BitVec.signExtend (2 * 64)
                                      52#64).toNat =?= (BitVec.signExtend 128 x✝ * 52#128).toNat
                              [Meta.isDefEq] [0.001659] ✅️ BitVec.signExtend (2 * 64) x✝ *
                                    BitVec.signExtend (2 * 64) 52#64 =?= BitVec.signExtend 128 x✝ * 52#128
                                [Meta.isDefEq] [0.001623] ✅️ instHMul.1 (BitVec.signExtend (2 * 64) x✝)
                                      (BitVec.signExtend (2 * 64)
                                        52#64) =?= instHMul.1 (BitVec.signExtend 128 x✝) 52#128
                                  [Meta.isDefEq] [0.001550] ✅️ Mul.mul (BitVec.signExtend (2 * 64) x✝)
                                        (BitVec.signExtend (2 * 64) 52#64) =?= Mul.mul (BitVec.signExtend 128 x✝) 52#128
                                    [Meta.isDefEq] [0.001521] ✅️ BitVec.instMul.1 (BitVec.signExtend (2 * 64) x✝)
                                          (BitVec.signExtend (2 * 64)
                                            52#64) =?= BitVec.instMul.1 (BitVec.signExtend 128 x✝) 52#128
                                      [Meta.isDefEq] [0.001465] ✅️ (BitVec.signExtend (2 * 64) x✝).mul
                                            (BitVec.signExtend (2 * 64) 52#64) =?= (BitVec.signExtend 128 x✝).mul 52#128
                                        [Meta.isDefEq.delta] [0.001451] ✅️ (BitVec.signExtend (2 * 64) x✝).mul
                                              (BitVec.signExtend (2 * 64)
                                                52#64) =?= (BitVec.signExtend 128 x✝).mul 52#128
                                          [Meta.isDefEq] [0.001349] ✅️ BitVec.signExtend (2 * 64) 52#64 =?= 52#128
                                            [Meta.isDefEq] [0.001325] ✅️ BitVec.ofInt (2 * 64) (52#64).toInt =?= 52#128
                                              [Meta.isDefEq] [0.001305] ✅️ ((52#64).toInt %
                                                        Int.ofNat (2 ^ (2 * 64))).toNat#'⋯ =?= 52#128
                                                [Meta.isDefEq] [0.001280] ✅️ ((52#64).toInt %
                                                          Int.ofNat
                                                            (2 ^
                                                              (2 *
                                                                64))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 128) 52 }
                                                  [Meta.isDefEq] [0.001258] ✅️ {
                                                        toFin :=
                                                          ⟨((52#64).toInt % Int.ofNat (2 ^ (2 * 64))).toNat,
                                                            ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 128) 52 }
                                                    [Meta.isDefEq] [0.001218] ✅️ ⟨((52#64).toInt %
                                                              Int.ofNat (2 ^ (2 * 64))).toNat,
                                                          ⋯⟩ =?= Fin.ofNat' (2 ^ 128) 52
                                                      [Meta.isDefEq] [0.001197] ✅️ ⟨((52#64).toInt %
                                                                Int.ofNat (2 ^ (2 * 64))).toNat,
                                                            ⋯⟩ =?= ⟨52 % 2 ^ 128, ⋯⟩
                                                        [Meta.isDefEq] [0.001062] ✅️ ((52#64).toInt %
                                                                Int.ofNat (2 ^ (2 * 64))).toNat =?= 52 % 2 ^ 128
  [Meta.isDefEq] [0.001076] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 128 63 <<< 1)
                (BitVec.zeroExtend 128 x✝ * 52#128))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 128 x✝ * 52#128)
                      (BitVec.twoPow 128 63 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 52#128) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 52#128)))))))
        (true_and ((!BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 52#128) = true))
    [Meta.isDefEq.assign] [0.001073] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 128 63 <<< 1)
                  (BitVec.zeroExtend 128 x✝ * 52#128))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 128 x✝ * 52#128)
                        (BitVec.twoPow 128 63 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 52#128) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 52#128)))))))
          (true_and ((!BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 52#128) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001058] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 64) x✝ * BitVec.zeroExtend (2 * 64) 52#64 ≥
                BitVec.twoPow (2 * 64) (64 - 1) <<< 1) =
            ((!BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 52#128) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 128 63 <<< 1)
                    (BitVec.zeroExtend 128 x✝ * 52#128))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 128 x✝ * 52#128)
                          (BitVec.twoPow 128 63 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 52#128) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 52#128)))))))
            (true_and
              ((!BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 52#128) =
                true)) : (True ∧ BitVec.zeroExtend 128 x✝ * 52#128 ≥ BitVec.twoPow 128 63 <<< 1) =
            ((!BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 52#128) = true))
        [Meta.isDefEq] [0.001055] ✅️ (True ∧
                BitVec.zeroExtend (2 * 64) x✝ * BitVec.zeroExtend (2 * 64) 52#64 ≥
                  BitVec.twoPow (2 * 64) (64 - 1) <<< 1) =
              ((!BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 52#128) =
                true) =?= (True ∧ BitVec.zeroExtend 128 x✝ * 52#128 ≥ BitVec.twoPow 128 63 <<< 1) =
              ((!BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 52#128) = true)
          [Meta.isDefEq] [0.001033] ✅️ True ∧
                BitVec.zeroExtend (2 * 64) x✝ * BitVec.zeroExtend (2 * 64) 52#64 ≥
                  BitVec.twoPow (2 * 64) (64 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 128 x✝ * 52#128 ≥ BitVec.twoPow 128 63 <<< 1
            [Meta.isDefEq] [0.001022] ✅️ BitVec.zeroExtend (2 * 64) x✝ * BitVec.zeroExtend (2 * 64) 52#64 ≥
                  BitVec.twoPow (2 * 64) (64 - 1) <<<
                    1 =?= BitVec.zeroExtend 128 x✝ * 52#128 ≥ BitVec.twoPow 128 63 <<< 1
              [Meta.isDefEq.delta] [0.001003] ✅️ BitVec.zeroExtend (2 * 64) x✝ * BitVec.zeroExtend (2 * 64) 52#64 ≥
                    BitVec.twoPow (2 * 64) (64 - 1) <<<
                      1 =?= BitVec.zeroExtend 128 x✝ * 52#128 ≥ BitVec.twoPow 128 63 <<< 1
  [Meta.isDefEq] [0.001290] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 128 x✝ * 13#128)
                    (BitVec.signExtend 128 (BitVec.twoPow 64 63))))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 128 63)
                      (BitVec.signExtend 128 x✝ * 13#128))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 128 x✝ * 13#128)
                            (BitVec.twoPow 128 63)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128) true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true (BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 13#128)
                !BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 13#128)
                  !BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128)
                (congrArg
                  (fun x => !((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 13#128) && x))
                  (Bool.not_not (BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128)))))))
        (true_and
          ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 13#128) &&
                BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128)) =
            true))
    [Meta.isDefEq.assign] [0.001288] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 128 x✝ * 13#128)
                      (BitVec.signExtend 128 (BitVec.twoPow 64 63))))
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 128 63)
                        (BitVec.signExtend 128 x✝ * 13#128))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 128 x✝ * 13#128)
                              (BitVec.twoPow 128 63)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128) true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true (BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 13#128)
                  !BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 13#128)
                    !BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128)
                  (congrArg
                    (fun x =>
                      !((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 13#128) && x))
                    (Bool.not_not (BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128)))))))
          (true_and
            ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 13#128) &&
                  BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.001254] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 13#64 <
                  BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ∨
                BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 13#64 ≥ BitVec.twoPow (2 * 64) (64 - 1))) =
            ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 13#128) &&
                  BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 128 x✝ * 13#128)
                        (BitVec.signExtend 128 (BitVec.twoPow 64 63))))
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 128 63)
                          (BitVec.signExtend 128 x✝ * 13#128))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 128 x✝ * 13#128)
                                (BitVec.twoPow 128 63)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128) true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true (BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 13#128)
                    !BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 13#128)
                      !BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128)
                    (congrArg
                      (fun x =>
                        !((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 13#128) && x))
                      (Bool.not_not (BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128)))))))
            (true_and
              ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 13#128) &&
                    BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128)) =
                true)) : (True ∧
              (BitVec.signExtend 128 x✝ * 13#128 < BitVec.signExtend 128 (BitVec.twoPow 64 63) ∨
                BitVec.signExtend 128 x✝ * 13#128 ≥ BitVec.twoPow 128 63)) =
            ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 13#128) &&
                  BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128)) =
              true))
        [Meta.isDefEq] [0.001249] ✅️ (True ∧
                (BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 13#64 <
                    BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ∨
                  BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 13#64 ≥ BitVec.twoPow (2 * 64) (64 - 1))) =
              ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 13#128) &&
                    BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128)) =
                true) =?= (True ∧
                (BitVec.signExtend 128 x✝ * 13#128 < BitVec.signExtend 128 (BitVec.twoPow 64 63) ∨
                  BitVec.signExtend 128 x✝ * 13#128 ≥ BitVec.twoPow 128 63)) =
              ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 13#128) &&
                    BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128)) =
                true)
          [Meta.isDefEq] [0.001224] ✅️ True ∧
                (BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 13#64 <
                    BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ∨
                  BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 13#64 ≥
                    BitVec.twoPow (2 * 64)
                      (64 -
                        1)) =?= True ∧
                (BitVec.signExtend 128 x✝ * 13#128 < BitVec.signExtend 128 (BitVec.twoPow 64 63) ∨
                  BitVec.signExtend 128 x✝ * 13#128 ≥ BitVec.twoPow 128 63)
            [Meta.isDefEq] [0.001210] ✅️ BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 13#64 <
                    BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ∨
                  BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 13#64 ≥
                    BitVec.twoPow (2 * 64)
                      (64 -
                        1) =?= BitVec.signExtend 128 x✝ * 13#128 < BitVec.signExtend 128 (BitVec.twoPow 64 63) ∨
                  BitVec.signExtend 128 x✝ * 13#128 ≥ BitVec.twoPow 128 63
              [Meta.isDefEq] [0.001107] ✅️ BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 13#64 <
                    BitVec.signExtend (2 * 64)
                      (BitVec.twoPow 64
                        (64 - 1)) =?= BitVec.signExtend 128 x✝ * 13#128 < BitVec.signExtend 128 (BitVec.twoPow 64 63)
                [Meta.isDefEq] [0.001082] ✅️ instLTBitVec.1
                      (BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 13#64)
                      (BitVec.signExtend (2 * 64)
                        (BitVec.twoPow 64
                          (64 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 128 x✝ * 13#128)
                      (BitVec.signExtend 128 (BitVec.twoPow 64 63))
                  [Meta.isDefEq] [0.001037] ✅️ (BitVec.signExtend (2 * 64) x✝ *
                            BitVec.signExtend (2 * 64) 13#64).toNat <
                        (BitVec.signExtend (2 * 64)
                            (BitVec.twoPow 64
                              (64 -
                                1))).toNat =?= (BitVec.signExtend 128 x✝ * 13#128).toNat <
                        (BitVec.signExtend 128 (BitVec.twoPow 64 63)).toNat
                    [Meta.isDefEq] [0.001016] ✅️ instLTNat.1
                          (BitVec.signExtend (2 * 64) x✝ * BitVec.signExtend (2 * 64) 13#64).toNat
                          (BitVec.signExtend (2 * 64)
                              (BitVec.twoPow 64
                                (64 -
                                  1))).toNat =?= instLTNat.1 (BitVec.signExtend 128 x✝ * 13#128).toNat
                          (BitVec.signExtend 128 (BitVec.twoPow 64 63)).toNat
  [Meta.isDefEq] [0.001101] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 128 63 <<< 1)
                (BitVec.zeroExtend 128 x✝ * 13#128))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 128 x✝ * 13#128)
                      (BitVec.twoPow 128 63 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 13#128) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 13#128)))))))
        (true_and ((!BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 13#128) = true))
    [Meta.isDefEq.assign] [0.001097] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 128 63 <<< 1)
                  (BitVec.zeroExtend 128 x✝ * 13#128))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 128 x✝ * 13#128)
                        (BitVec.twoPow 128 63 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 13#128) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 13#128)))))))
          (true_and ((!BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 13#128) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001077] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 64) x✝ * BitVec.zeroExtend (2 * 64) 13#64 ≥
                BitVec.twoPow (2 * 64) (64 - 1) <<< 1) =
            ((!BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 13#128) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 128 63 <<< 1)
                    (BitVec.zeroExtend 128 x✝ * 13#128))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 128 x✝ * 13#128)
                          (BitVec.twoPow 128 63 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 13#128) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 13#128)))))))
            (true_and
              ((!BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 13#128) =
                true)) : (True ∧ BitVec.zeroExtend 128 x✝ * 13#128 ≥ BitVec.twoPow 128 63 <<< 1) =
            ((!BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 13#128) = true))
        [Meta.isDefEq] [0.001073] ✅️ (True ∧
                BitVec.zeroExtend (2 * 64) x✝ * BitVec.zeroExtend (2 * 64) 13#64 ≥
                  BitVec.twoPow (2 * 64) (64 - 1) <<< 1) =
              ((!BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 13#128) =
                true) =?= (True ∧ BitVec.zeroExtend 128 x✝ * 13#128 ≥ BitVec.twoPow 128 63 <<< 1) =
              ((!BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 13#128) = true)
          [Meta.isDefEq] [0.001044] ✅️ True ∧
                BitVec.zeroExtend (2 * 64) x✝ * BitVec.zeroExtend (2 * 64) 13#64 ≥
                  BitVec.twoPow (2 * 64) (64 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 128 x✝ * 13#128 ≥ BitVec.twoPow 128 63 <<< 1
            [Meta.isDefEq] [0.001028] ✅️ BitVec.zeroExtend (2 * 64) x✝ * BitVec.zeroExtend (2 * 64) 13#64 ≥
                  BitVec.twoPow (2 * 64) (64 - 1) <<<
                    1 =?= BitVec.zeroExtend 128 x✝ * 13#128 ≥ BitVec.twoPow 128 63 <<< 1
              [Meta.isDefEq.delta] [0.001001] ✅️ BitVec.zeroExtend (2 * 64) x✝ * BitVec.zeroExtend (2 * 64) 13#64 ≥
                    BitVec.twoPow (2 * 64) (64 - 1) <<<
                      1 =?= BitVec.zeroExtend 128 x✝ * 13#128 ≥ BitVec.twoPow 128 63 <<< 1
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      x✝ : BitVec 64
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 52#128) &&
                      BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 52#128)) =
                  true then
              none
            else
              if (!BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 52#128) = true then none
              else some ((x✝ * 52#64) >>> 2)) ⊑
            if
                (!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >ᵤ BitVec.signExtend 128 x✝ * 13#128) &&
                      BitVec.twoPow 128 63 >ᵤ BitVec.signExtend 128 x✝ * 13#128)) =
                  true then
              none
            else
              if (!BitVec.twoPow 128 63 <<< 1 >ᵤ BitVec.zeroExtend 128 x✝ * 13#128) = true then none
              else some (x✝ * 13#64)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthlogic_proof.lean:94:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthlogic_proof.lean:94:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthlogic_proof.lean:88:8: error: (kernel) declaration has metavariables 'shl_add_thm'
[bv] [0.019665] Normalizing goal
  [Meta.synthInstance] [0.001143] ✅️ Decidable
        ((if 3#8 ≥ ↑8 then none else if 2#8 ≥ ↑8 then none else some ((x✝ <<< 3#8 + x✝¹) <<< 2#8)) ⊑
          if 5#8 ≥ ↑8 then none else if 2#8 ≥ ↑8 then none else some (x✝ <<< 5#8 + x✝¹ <<< 2#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if 3#8 ≥ ↑8 then none else if 2#8 ≥ ↑8 then none else some ((x✝ <<< 3#8 + x✝¹) <<< 2#8)) ⊑
            if 5#8 ≥ ↑8 then none else if 2#8 ≥ ↑8 then none else some (x✝ <<< 5#8 + x✝¹ <<< 2#8)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ : ¬some ((x✝ <<< 3 + x✝¹) <<< 2) ⊑ some (x✝ <<< 5 + x✝¹ <<< 2)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthlogic_proof.lean:104:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthlogic_proof.lean:104:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthlogic_proof.lean:98:8: error: (kernel) declaration has metavariables 'shl_sub_thm'
[bv] [0.024668] Normalizing goal
  [Meta.synthInstance] [0.001152] ✅️ Decidable
        ((if 3#8 ≥ ↑8 then none else if 2#8 ≥ ↑8 then none else some ((x✝ <<< 3#8 - x✝¹) <<< 2#8)) ⊑
          if 5#8 ≥ ↑8 then none else if 2#8 ≥ ↑8 then none else some (x✝ <<< 5#8 - x✝¹ <<< 2#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if 3#8 ≥ ↑8 then none else if 2#8 ≥ ↑8 then none else some ((x✝ <<< 3#8 - x✝¹) <<< 2#8)) ⊑
            if 5#8 ≥ ↑8 then none else if 2#8 ≥ ↑8 then none else some (x✝ <<< 5#8 - x✝¹ <<< 2#8)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ : ¬some ((x✝ <<< 3 + (~~~x✝¹ + 1#8)) <<< 2) ⊑ some (x✝ <<< 5 + (~~~(x✝¹ <<< 2) + 1#8))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthlogic_proof.lean:114:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshifthlogic_proof.lean:108:8: error: (kernel) declaration has metavariables 'shl_sub_no_commute_thm'
[bv] [0.025646] Normalizing goal
  [Meta.synthInstance] [0.001306] ✅️ Decidable
        ((if 3#8 ≥ ↑8 then none else if 2#8 ≥ ↑8 then none else some ((x✝ - x✝¹ <<< 3#8) <<< 2#8)) ⊑
          if 2#8 ≥ ↑8 then none else if 5#8 ≥ ↑8 then none else some (x✝ <<< 2#8 - x✝¹ <<< 5#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if 3#8 ≥ ↑8 then none else if 2#8 ≥ ↑8 then none else some ((x✝ - x✝¹ <<< 3#8) <<< 2#8)) ⊑
            if 2#8 ≥ ↑8 then none else if 5#8 ≥ ↑8 then none else some (x✝ <<< 2#8 - x✝¹ <<< 5#8)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ : ¬some ((x✝ + (~~~(x✝¹ <<< 3) + 1#8)) <<< 2) ⊑ some (x✝ <<< 2 + (~~~(x✝¹ <<< 5) + 1#8))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
