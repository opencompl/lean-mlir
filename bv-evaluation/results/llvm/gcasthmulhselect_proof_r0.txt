⚠ [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
⚠ [879/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [882/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
⚠ [887/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
⚠ [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
Bitwuzla proved the goal after 78.845650ms, solving context: 6.000000ms
LeanSAT proved the goal after 622.333069ms: rewriting 13.736491ms, bitblasting 4.729350ms, SAT solving 309.144049ms, LRAT trimming 131.733079ms, LRAT checking 144.961790ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcasthmulhselect_proof.lean:28:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcasthmulhselect_proof.lean:28:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcasthmulhselect_proof.lean:28:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcasthmulhselect_proof.lean:28:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcasthmulhselect_proof.lean:28:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcasthmulhselect_proof.lean:28:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcasthmulhselect_proof.lean:21:8: error: (kernel) declaration has metavariables 'select1_thm'
[bv] [0.078871] Normalizing goal
  [Meta.synthInstance] [0.002339] ✅️ Decidable
        ((Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.truncate 8 x✝¹)
            | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.truncate 8 x✝² + BitVec.truncate 8 x✝³))
            fun x' => some (BitVec.zeroExtend 32 x')) ⊑
          Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝² + x✝³))
            fun x' => some (x' &&& 255#32))
    [Meta.check] [0.001379] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.truncate 8 x✝¹)
            | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.truncate 8 x✝² + BitVec.truncate 8 x✝³))
            fun x' => some (BitVec.zeroExtend 32 x'))
          (Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝² + x✝³))
            fun x' => some (x' &&& 255#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      e_3 : LLVM.IntW 1
      x✝³ x✝² x✝¹ : BitVec 32
      x✝ : BitVec 1
      a✝ :
        ¬(Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.truncate 8 x✝¹)
              | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.truncate 8 x✝² + BitVec.truncate 8 x✝³))
              fun x' => some (BitVec.zeroExtend 32 x')) ⊑
            Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝² + x✝³))
              fun x' => some (x' &&& 255#32)
      ⊢ False
  [Meta.isDefEq] [0.001197] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.truncate 8 x✝¹)
      | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.truncate 8 x✝² + BitVec.truncate 8 x✝³)
  [Meta.isDefEq] [0.001218] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.truncate 8 x✝¹)
      | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.truncate 8 x✝² + BitVec.truncate 8 x✝³)
  [Meta.isDefEq] [0.001377] ✅️ ?hx =?= Eq.refl
        (match some x✝ with
        | none => none
        | some { toFin := ⟨1, .(Fin.ofNat'.proof_1 (2 ^ 1) 1)⟩ } => some (BitVec.zeroExtend 8 x✝¹)
        | some { toFin := ⟨0, .(Fin.ofNat'.proof_1 (2 ^ 1) 0)⟩ } =>
          some (BitVec.zeroExtend 8 x✝² + BitVec.zeroExtend 8 x✝³))
    [Meta.isDefEq.assign] [0.001373] ✅️ ?hx := Eq.refl
          (match some x✝ with
          | none => none
          | some { toFin := ⟨1, .(Fin.ofNat'.proof_1 (2 ^ 1) 1)⟩ } => some (BitVec.zeroExtend 8 x✝¹)
          | some { toFin := ⟨0, .(Fin.ofNat'.proof_1 (2 ^ 1) 0)⟩ } =>
            some (BitVec.zeroExtend 8 x✝² + BitVec.zeroExtend 8 x✝³))
      [Meta.isDefEq.assign.checkTypes] [0.001360] ✅️ (?hx : (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.truncate 8 x✝¹)
            | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.truncate 8 x✝² + BitVec.truncate 8 x✝³)) =
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.zeroExtend 8 x✝¹)
            | some { toFin := ⟨0, ⋯⟩ } =>
              some (BitVec.zeroExtend 8 x✝² + BitVec.zeroExtend 8 x✝³)) := (Eq.refl
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, .(Fin.ofNat'.proof_1 (2 ^ 1) 1)⟩ } => some (BitVec.zeroExtend 8 x✝¹)
            | some { toFin := ⟨0, .(Fin.ofNat'.proof_1 (2 ^ 1) 0)⟩ } =>
              some (BitVec.zeroExtend 8 x✝² + BitVec.zeroExtend 8 x✝³)) : (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.zeroExtend 8 x✝¹)
            | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.zeroExtend 8 x✝² + BitVec.zeroExtend 8 x✝³)) =
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.zeroExtend 8 x✝¹)
            | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.zeroExtend 8 x✝² + BitVec.zeroExtend 8 x✝³))
        [Meta.isDefEq] [0.001356] ✅️ (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.truncate 8 x✝¹)
              | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.truncate 8 x✝² + BitVec.truncate 8 x✝³)) =
              match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.zeroExtend 8 x✝¹)
              | some { toFin := ⟨0, ⋯⟩ } =>
                some (BitVec.zeroExtend 8 x✝² + BitVec.zeroExtend 8 x✝³) =?= (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.zeroExtend 8 x✝¹)
              | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.zeroExtend 8 x✝² + BitVec.zeroExtend 8 x✝³)) =
              match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.zeroExtend 8 x✝¹)
              | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.zeroExtend 8 x✝² + BitVec.zeroExtend 8 x✝³)
          [Meta.isDefEq] [0.001314] ✅️ match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.truncate 8 x✝¹)
              | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.truncate 8 x✝² + BitVec.truncate 8 x✝³) =?= match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.zeroExtend 8 x✝¹)
              | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.zeroExtend 8 x✝² + BitVec.zeroExtend 8 x✝³)
  [Meta.isDefEq] [0.001127] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝² + x✝³)
  [Meta.isDefEq] [0.001213] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝² + x✝³)
  [Meta.isDefEq] [0.001196] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝² + x✝³)
  [Meta.isDefEq] [0.002002] ✅️ ?hf =?= fun a a_1 => Eq.refl (some (a &&& 255#32))
    [Meta.isDefEq.assign] [0.001998] ✅️ ?hf := fun a a_1 => Eq.refl (some (a &&& 255#32))
      [Meta.isDefEq.assign.checkTypes] [0.001959] ✅️ (?hf : ∀
            a ∈
              match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝² + x✝³),
            some (a &&& 255#32) =
              some (a &&& 255#32)) := (fun a a_1 => Eq.refl (some (a &&& 255#32)) : ∀
            a ∈
              match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝² + x✝³),
            some (a &&& 255#32) = some (a &&& 255#32))
        [Meta.isDefEq] [0.001954] ✅️ ∀
              a ∈
                match some x✝ with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
                | some { toFin := ⟨0, ⋯⟩ } => some (x✝² + x✝³),
              some (a &&& 255#32) = some (a &&& 255#32) =?= ∀
              a ∈
                match some x✝ with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
                | some { toFin := ⟨0, ⋯⟩ } => some (x✝² + x✝³),
              some (a &&& 255#32) = some (a &&& 255#32)
          [Meta.isDefEq] [0.001882] ✅️ a ∈
                match some x✝ with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
                | some { toFin := ⟨0, ⋯⟩ } => some (x✝² + x✝³) =?= a ∈
                match some x✝ with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
                | some { toFin := ⟨0, ⋯⟩ } => some (x✝² + x✝³)
  [Meta.isDefEq] [0.001102] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.zeroExtend 8 x✝¹)
      | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.zeroExtend 8 x✝² + BitVec.zeroExtend 8 x✝³)
  [Meta.isDefEq] [0.001242] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.zeroExtend 8 x✝¹)
      | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.zeroExtend 8 x✝² + BitVec.zeroExtend 8 x✝³)
  [Meta.isDefEq] [0.001200] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.zeroExtend 8 x✝¹)
      | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.zeroExtend 8 x✝² + BitVec.zeroExtend 8 x✝³)
  [Meta.isDefEq] [0.001087] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝² + x✝³)
  [Meta.isDefEq] [0.001198] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝² + x✝³)
  [Meta.isDefEq] [0.001178] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝² + x✝³)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      e_3 : LLVM.IntW 1
      x✝³ x✝² x✝¹ : BitVec 32
      x✝ : BitVec 1
      a✝ :
        ¬(Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.zeroExtend 8 x✝¹)
              | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.zeroExtend 8 x✝² + BitVec.zeroExtend 8 x✝³))
              fun x' => some (BitVec.zeroExtend 32 x')) ⊑
            Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝² + x✝³))
              fun x' => some (x' &&& 255#32)
      ⊢ False
  [Meta.isDefEq] [0.001087] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.zeroExtend 8 x✝¹)
      | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.zeroExtend 8 x✝² + BitVec.zeroExtend 8 x✝³)
  [Meta.isDefEq] [0.001204] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.zeroExtend 8 x✝¹)
      | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.zeroExtend 8 x✝² + BitVec.zeroExtend 8 x✝³)
  [Meta.isDefEq] [0.001185] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.zeroExtend 8 x✝¹)
      | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.zeroExtend 8 x✝² + BitVec.zeroExtend 8 x✝³)
  [Meta.isDefEq] [0.001074] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝² + x✝³)
  [Meta.isDefEq] [0.001220] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝² + x✝³)
  [Meta.isDefEq] [0.001176] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝² + x✝³)
  [Meta.isDefEq] [0.001102] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.zeroExtend 8 x✝¹)
      | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.zeroExtend 8 x✝² + BitVec.zeroExtend 8 x✝³)
  [Meta.isDefEq] [0.001187] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.zeroExtend 8 x✝¹)
      | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.zeroExtend 8 x✝² + BitVec.zeroExtend 8 x✝³)
  [Meta.isDefEq] [0.001189] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.zeroExtend 8 x✝¹)
      | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.zeroExtend 8 x✝² + BitVec.zeroExtend 8 x✝³)
  [Meta.isDefEq] [0.001021] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝² + x✝³)
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcasthmulhselect_proof.lean:38:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcasthmulhselect_proof.lean:38:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcasthmulhselect_proof.lean:38:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcasthmulhselect_proof.lean:38:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcasthmulhselect_proof.lean:38:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcasthmulhselect_proof.lean:38:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcasthmulhselect_proof.lean:32:8: error: (kernel) declaration has metavariables 'select2_thm'
[bv] [0.063973] Normalizing goal
  [Meta.synthInstance] [0.002420] ✅️ Decidable
        ((Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.zeroExtend 32 x✝¹)
            | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.zeroExtend 32 x✝² + BitVec.zeroExtend 32 x✝³))
            fun x' => some (BitVec.truncate 8 x')) ⊑
          match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝² + x✝³))
    [Meta.check] [0.001185] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.zeroExtend 32 x✝¹)
            | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.zeroExtend 32 x✝² + BitVec.zeroExtend 32 x✝³))
            fun x' => some (BitVec.truncate 8 x'))
          (match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝² + x✝³))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      e_3 : LLVM.IntW 1
      x✝³ x✝² x✝¹ : BitVec 8
      x✝ : BitVec 1
      a✝ :
        ¬(Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.zeroExtend 32 x✝¹)
              | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.zeroExtend 32 x✝² + BitVec.zeroExtend 32 x✝³))
              fun x' => some (BitVec.truncate 8 x')) ⊑
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝² + x✝³)
      ⊢ False
  [Meta.isDefEq] [0.001093] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.zeroExtend 32 x✝¹)
      | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.zeroExtend 32 x✝² + BitVec.zeroExtend 32 x✝³)
  [Meta.isDefEq] [0.001210] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.zeroExtend 32 x✝¹)
      | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.zeroExtend 32 x✝² + BitVec.zeroExtend 32 x✝³)
  [Meta.isDefEq] [0.001169] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.zeroExtend 32 x✝¹)
      | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.zeroExtend 32 x✝² + BitVec.zeroExtend 32 x✝³)
  [Meta.isDefEq] [0.001243] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝² + x✝³)
  [Meta.isDefEq] [0.001095] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝² + x✝³)
  [Meta.isDefEq] [0.001088] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.zeroExtend 32 x✝¹)
      | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.zeroExtend 32 x✝² + BitVec.zeroExtend 32 x✝³)
  [Meta.isDefEq] [0.001173] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.zeroExtend 32 x✝¹)
      | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.zeroExtend 32 x✝² + BitVec.zeroExtend 32 x✝³)
  [Meta.isDefEq] [0.001176] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.zeroExtend 32 x✝¹)
      | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.zeroExtend 32 x✝² + BitVec.zeroExtend 32 x✝³)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      e_3 : LLVM.IntW 1
      x✝³ x✝² x✝¹ : BitVec 8
      x✝ : BitVec 1
      a✝ :
        ¬(Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.zeroExtend 32 x✝¹)
              | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.zeroExtend 32 x✝² + BitVec.zeroExtend 32 x✝³))
              fun a => some (BitVec.zeroExtend 8 a)) ⊑
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝² + x✝³)
      ⊢ False
  [Meta.isDefEq] [0.001070] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.zeroExtend 32 x✝¹)
      | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.zeroExtend 32 x✝² + BitVec.zeroExtend 32 x✝³)
  [Meta.isDefEq] [0.001187] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.zeroExtend 32 x✝¹)
      | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.zeroExtend 32 x✝² + BitVec.zeroExtend 32 x✝³)
  [Meta.isDefEq] [0.001144] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.zeroExtend 32 x✝¹)
      | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.zeroExtend 32 x✝² + BitVec.zeroExtend 32 x✝³)
  [Meta.isDefEq] [0.001078] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝² + x✝³)
  [Meta.isDefEq] [0.001140] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝² + x✝³)
  [Meta.isDefEq] [0.001157] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝² + x✝³)
  [Meta.isDefEq] [0.001134] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.zeroExtend 32 x✝¹)
      | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.zeroExtend 32 x✝² + BitVec.zeroExtend 32 x✝³)
  [Meta.isDefEq] [0.001208] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.zeroExtend 32 x✝¹)
      | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.zeroExtend 32 x✝² + BitVec.zeroExtend 32 x✝³)
  [Meta.isDefEq] [0.001187] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (BitVec.zeroExtend 32 x✝¹)
      | some { toFin := ⟨0, ⋯⟩ } => some (BitVec.zeroExtend 32 x✝² + BitVec.zeroExtend 32 x✝³)
  [Meta.isDefEq] [0.003005] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝² + x✝³)
    [Meta.isDefEq] [0.002400] ❌️ ?h_1 () =?= match some x✝ with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
        | some { toFin := ⟨0, ⋯⟩ } => some (x✝² + x✝³)
      [Meta.whnf] [0.002317] Non-easy whnf: match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝² + x✝³)
        [Meta.whnf] [0.002081] Non-easy whnf: (fun motive c? h_1 h_2 h_3 =>
                Option.casesOn c? (h_1 ()) fun val =>
                  BitVec.casesOn val fun toFin =>
                    Fin.casesOn toFin fun val isLt =>
                      Nat.casesOn (motive := fun x => (isLt : x < 2 ^ 1) → motive (some { toFin := ⟨x, isLt⟩ })) val
                        (fun isLt => h_3 ())
                        (fun n isLt =>
                          Nat.casesOn (motive := fun x =>
                            (isLt : x.succ < 2 ^ 1) → motive (some { toFin := ⟨x.succ, isLt⟩ })) n (fun isLt => h_2 ())
                            (fun n isLt => ⋯.elim) isLt)
                        isLt)
              (fun c? => LLVM.IntW 8) (some x✝) h_1 h_2 h_3
  [Meta.isDefEq] [0.001150] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝² + x✝³)
  [Meta.isDefEq] [0.001169] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝² + x✝³)
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcasthmulhselect_proof.lean:46:4: error: maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
