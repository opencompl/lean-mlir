âš  [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
âš  [878/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
âš  [881/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
âš  [887/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
âš  [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:18:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:11:8: error: (kernel) declaration has metavariables 'src_srem_shl_demand_max_signbit_thm'
[bv] [0.157768] Normalizing goal
  [Meta.synthInstance] [0.002693] âœ…ï¸ Decidable
        (((Option.map (fun div => xâœ - div * 2#32)
                (if (2#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 2#32 == -1) = true then none
                else some (xâœ.sdiv 2#32))).bind
            fun x => if 30#32 â‰¥ â†‘32 then none else some (x <<< 30#32 &&& 2147483648#32)) âŠ‘
          (Option.map (fun div => xâœ - div * 2#32)
                (if (2#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 2#32 == -1) = true then none
                else some (xâœ.sdiv 2#32))).bind
            fun x' => some (x' &&& 2147483648#32))
    [Meta.check] [0.001591] âœ…ï¸ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          ((Option.map (fun div => xâœ - div * 2#32)
                (if (2#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 2#32 == -1) = true then none
                else some (xâœ.sdiv 2#32))).bind
            fun x => if 30#32 â‰¥ â†‘32 then none else some (x <<< 30#32 &&& 2147483648#32))
          ((Option.map (fun div => xâœ - div * 2#32)
                (if (2#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 2#32 == -1) = true then none
                else some (xâœ.sdiv 2#32))).bind
            fun x' => some (x' &&& 2147483648#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬((Option.map (fun div => xâœ - div * 2#32)
                  (if (2#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 2#32 == -1) = true then none
                  else some (xâœ.sdiv 2#32))).bind
              fun x => if 30#32 â‰¥ â†‘32 then none else some (x <<< 30#32 &&& 2147483648#32)) âŠ‘
            (Option.map (fun div => xâœ - div * 2#32)
                  (if (2#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 2#32 == -1) = true then none
                  else some (xâœ.sdiv 2#32))).bind
              fun x' => some (x' &&& 2147483648#32)
      âŠ¢ False
  [Meta.appBuilder] [0.001537] âœ…ï¸ f: Complement.complement, xs: [div * 2#32]
  [Meta.appBuilder] [0.001044] âœ…ï¸ f: HAdd.hAdd, xs: [~~~(div * 2#32), 1#32]
  [Meta.isDefEq] [0.004308] âŒï¸ ?a == ?a =?= 2#32 == 0#32
    [Meta.isDefEq.onFailure] [0.003810] âŒï¸ ?a == ?a =?= 2#32 == 0#32
      [Meta.synthInstance] [0.003776] ğŸ’¥ï¸ BEq ?Î±
        [Meta.synthInstance] [0.003662] new goal BEq ?Î±
  [Meta.whnf] [0.001758] Non-easy whnf: HDiv Î± Î² Î³
  [Meta.whnf] [0.001746] Non-easy whnf: Div Î±
  [Meta.isDefEq] [0.001072] âœ…ï¸ ?hf =?= fun a a_1 =>
        ite_cond_eq_false none (some (a <<< 30#32 &&& 2147483648#32))
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 32#32 30#32)
              (Eq.trans
                (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 30#32 32#32) (eq_self true)))
                Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))
    [Meta.isDefEq.assign] [0.001065] âœ…ï¸ ?hf := fun a a_1 =>
          ite_cond_eq_false none (some (a <<< 30#32 &&& 2147483648#32))
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 32#32 30#32)
                (Eq.trans
                  (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 30#32 32#32) (eq_self true)))
                  Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))
      [Meta.isDefEq.assign.checkTypes] [0.001001] âœ…ï¸ (?hf : âˆ€
            a âˆˆ
              Option.map (fun div => xâœ + (~~~(div * 2#32) + 1#32))
                (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 2#32) + 1#32 else xâœ / 2#32)),
            (if 30#32 â‰¥ â†‘32 then none else some (a <<< 30#32 &&& 2147483648#32)) =
              some
                (a <<< 30 &&&
                  2147483648#32)) := (fun a a_1 =>
            ite_cond_eq_false none (some (a <<< 30#32 &&& 2147483648#32))
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 32#32 30#32)
                  (Eq.trans
                    (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 30#32 32#32) (eq_self true)))
                    Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))) : âˆ€
            a âˆˆ
              Option.map (fun div => xâœ + (~~~(div * 2#32) + 1#32))
                (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 2#32) + 1#32 else xâœ / 2#32)),
            (if 30#32 â‰¥ â†‘32 then none else some (a <<< 30#32 &&& 2147483648#32)) = some (a <<< 30#32 &&& 2147483648#32))
  [Meta.isDefEq] [0.004222] âœ…ï¸ ?hf =?= fun a a_1 => Eq.refl (some (a &&& 2147483648#32))
    [Meta.isDefEq.assign] [0.004217] âœ…ï¸ ?hf := fun a a_1 => Eq.refl (some (a &&& 2147483648#32))
      [Meta.isDefEq.assign.checkTypes] [0.004196] âœ…ï¸ (?hf : âˆ€
            a âˆˆ
              Option.map (fun div => xâœ + (~~~(div * 2#32) + 1#32))
                (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 2#32) + 1#32 else xâœ / 2#32)),
            some (a &&& 2147483648#32) =
              some
                (a &&&
                  2147483648#32)) := (fun a a_1 =>
            Eq.refl
              (some
                (a &&&
                  2147483648#32)) : âˆ€
            a âˆˆ
              Option.map (fun div => xâœ + (~~~(div * 2#32) + 1#32))
                (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 2#32) + 1#32 else xâœ / 2#32)),
            some (a &&& 2147483648#32) = some (a &&& 2147483648#32))
        [Meta.isDefEq] [0.004185] âœ…ï¸ âˆ€
              a âˆˆ
                Option.map (fun div => xâœ + (~~~(div * 2#32) + 1#32))
                  (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 2#32) + 1#32 else xâœ / 2#32)),
              some (a &&& 2147483648#32) =
                some
                  (a &&&
                    2147483648#32) =?= âˆ€
              a âˆˆ
                Option.map (fun div => xâœ + (~~~(div * 2#32) + 1#32))
                  (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 2#32) + 1#32 else xâœ / 2#32)),
              some (a &&& 2147483648#32) = some (a &&& 2147483648#32)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬((Option.map (fun div => xâœ + (~~~(div * 2#32) + 1#32))
                  (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 2#32) + 1#32 else xâœ / 2#32))).bind
              fun a => some (a <<< 30 &&& 2147483648#32)) âŠ‘
            (Option.map (fun div => xâœ + (~~~(div * 2#32) + 1#32))
                  (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 2#32) + 1#32 else xâœ / 2#32))).bind
              fun a => some (a &&& 2147483648#32)
      âŠ¢ False
  [Meta.isDefEq] [0.004480] âŒï¸ ~~~?a + ?a =?= ~~~(div * 2#32) + 1#32
    [Meta.isDefEq] [0.004214] âŒï¸ instHAdd =?= instHAdd
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:29:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:22:8: error: (kernel) declaration has metavariables 'src_srem_shl_demand_min_signbit_thm'
[bv] [0.063538] Normalizing goal
  [Meta.synthInstance] [0.002141] âœ…ï¸ Decidable
        (((Option.map (fun div => xâœ - div * 1073741823#32)
                (if (1073741823#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 1073741823#32 == -1) = true then none
                else some (xâœ.sdiv 1073741823#32))).bind
            fun x => if 1#32 â‰¥ â†‘32 then none else some (x <<< 1#32 &&& 2147483648#32)) âŠ‘
          (Option.map (fun div => xâœ - div * 1073741823#32)
                (if (1073741823#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 1073741823#32 == -1) = true then none
                else some (xâœ.sdiv 1073741823#32))).bind
            fun x' => some (x' &&& 2147483648#32))
    [Meta.check] [0.001304] âœ…ï¸ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          ((Option.map (fun div => xâœ - div * 1073741823#32)
                (if (1073741823#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 1073741823#32 == -1) = true then none
                else some (xâœ.sdiv 1073741823#32))).bind
            fun x => if 1#32 â‰¥ â†‘32 then none else some (x <<< 1#32 &&& 2147483648#32))
          ((Option.map (fun div => xâœ - div * 1073741823#32)
                (if (1073741823#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 1073741823#32 == -1) = true then none
                else some (xâœ.sdiv 1073741823#32))).bind
            fun x' => some (x' &&& 2147483648#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬((Option.map (fun div => xâœ - div * 1073741823#32)
                  (if (1073741823#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 1073741823#32 == -1) = true then none
                  else some (xâœ.sdiv 1073741823#32))).bind
              fun x => if 1#32 â‰¥ â†‘32 then none else some (x <<< 1#32 &&& 2147483648#32)) âŠ‘
            (Option.map (fun div => xâœ - div * 1073741823#32)
                  (if (1073741823#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 1073741823#32 == -1) = true then none
                  else some (xâœ.sdiv 1073741823#32))).bind
              fun x' => some (x' &&& 2147483648#32)
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬((Option.map (fun div => xâœ + (~~~(div * 1073741823#32) + 1#32))
                  (some
                    (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 1073741823#32) + 1#32
                    else xâœ / 1073741823#32))).bind
              fun a => some (a <<< 1 &&& 2147483648#32)) âŠ‘
            (Option.map (fun div => xâœ + (~~~(div * 1073741823#32) + 1#32))
                  (some
                    (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 1073741823#32) + 1#32
                    else xâœ / 1073741823#32))).bind
              fun a => some (a &&& 2147483648#32)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:40:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:33:8: error: (kernel) declaration has metavariables 'src_srem_shl_demand_max_mask_thm'
[bv] [0.075051] Normalizing goal
  [Meta.synthInstance] [0.002498] âœ…ï¸ Decidable
        (((Option.map (fun div => xâœ - div * 2#32)
                (if (2#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 2#32 == -1) = true then none
                else some (xâœ.sdiv 2#32))).bind
            fun x => if 1#32 â‰¥ â†‘32 then none else some (x <<< 1#32 &&& 4294967292#32)) âŠ‘
          (Option.map (fun div => xâœ - div * 2#32)
                (if (2#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 2#32 == -1) = true then none
                else some (xâœ.sdiv 2#32))).bind
            fun x' => some (x' &&& 4294967292#32))
    [Meta.check] [0.001529] âœ…ï¸ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          ((Option.map (fun div => xâœ - div * 2#32)
                (if (2#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 2#32 == -1) = true then none
                else some (xâœ.sdiv 2#32))).bind
            fun x => if 1#32 â‰¥ â†‘32 then none else some (x <<< 1#32 &&& 4294967292#32))
          ((Option.map (fun div => xâœ - div * 2#32)
                (if (2#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 2#32 == -1) = true then none
                else some (xâœ.sdiv 2#32))).bind
            fun x' => some (x' &&& 4294967292#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬((Option.map (fun div => xâœ - div * 2#32)
                  (if (2#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 2#32 == -1) = true then none
                  else some (xâœ.sdiv 2#32))).bind
              fun x => if 1#32 â‰¥ â†‘32 then none else some (x <<< 1#32 &&& 4294967292#32)) âŠ‘
            (Option.map (fun div => xâœ - div * 2#32)
                  (if (2#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 2#32 == -1) = true then none
                  else some (xâœ.sdiv 2#32))).bind
              fun x' => some (x' &&& 4294967292#32)
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬((Option.map (fun div => xâœ + (~~~(div * 2#32) + 1#32))
                  (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 2#32) + 1#32 else xâœ / 2#32))).bind
              fun a => some (a <<< 1 &&& 4294967292#32)) âŠ‘
            (Option.map (fun div => xâœ + (~~~(div * 2#32) + 1#32))
                  (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 2#32) + 1#32 else xâœ / 2#32))).bind
              fun a => some (a &&& 4294967292#32)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:52:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:44:8: error: (kernel) declaration has metavariables 'src_srem_shl_demand_max_signbit_mask_hit_first_demand_thm'
[bv] [0.065879] Normalizing goal
  [Meta.synthInstance] [0.001617] âœ…ï¸ Decidable
        (((Option.map (fun div => xâœ - div * 4#32)
                (if (4#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 4#32 == -1) = true then none
                else some (xâœ.sdiv 4#32))).bind
            fun x => if 29#32 â‰¥ â†‘32 then none else some (x <<< 29#32 &&& 3221225472#32)) âŠ‘
          (Option.map (fun div => xâœ - div * 4#32)
                (if (4#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 4#32 == -1) = true then none
                else some (xâœ.sdiv 4#32))).bind
            fun x =>
            if True âˆ§ (x <<< 29#32).sshiftRight (29#32).toNat = x then none
            else if 29#32 â‰¥ â†‘32 then none else some (x <<< 29#32 &&& 3221225472#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬((Option.map (fun div => xâœ - div * 4#32)
                  (if (4#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 4#32 == -1) = true then none
                  else some (xâœ.sdiv 4#32))).bind
              fun x => if 29#32 â‰¥ â†‘32 then none else some (x <<< 29#32 &&& 3221225472#32)) âŠ‘
            (Option.map (fun div => xâœ - div * 4#32)
                  (if (4#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 4#32 == -1) = true then none
                  else some (xâœ.sdiv 4#32))).bind
              fun x =>
              if True âˆ§ (x <<< 29#32).sshiftRight (29#32).toNat = x then none
              else if 29#32 â‰¥ â†‘32 then none else some (x <<< 29#32 &&& 3221225472#32)
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬((Option.map (fun div => xâœ + (~~~(div * 4#32) + 1#32))
                  (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 4#32) + 1#32 else xâœ / 4#32))).bind
              fun a => some (a <<< 29 &&& 3221225472#32)) âŠ‘
            (Option.map (fun div => xâœ + (~~~(div * 4#32) + 1#32))
                  (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 4#32) + 1#32 else xâœ / 4#32))).bind
              fun a => if ((a <<< 29).sshiftRight 29 == a) = true then none else some (a <<< 29 &&& 3221225472#32)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:64:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:56:8: error: (kernel) declaration has metavariables 'src_srem_shl_demand_min_signbit_mask_hit_last_demand_thm'
[bv] [0.227857] Normalizing goal
  [Meta.synthInstance] [0.001566] âœ…ï¸ Decidable
        (((Option.map (fun div => xâœ - div * 536870912#32)
                (if (536870912#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 536870912#32 == -1) = true then none
                else some (xâœ.sdiv 536870912#32))).bind
            fun x => if 1#32 â‰¥ â†‘32 then none else some (x <<< 1#32 &&& 3221225474#32)) âŠ‘
          (Option.map (fun div => xâœ - div * 536870912#32)
                (if (536870912#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 536870912#32 == -1) = true then none
                else some (xâœ.sdiv 536870912#32))).bind
            fun x =>
            if True âˆ§ (x <<< 1#32).sshiftRight (1#32).toNat = x then none
            else if 1#32 â‰¥ â†‘32 then none else some (x <<< 1#32 &&& 3221225474#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬((Option.map (fun div => xâœ - div * 536870912#32)
                  (if (536870912#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 536870912#32 == -1) = true then none
                  else some (xâœ.sdiv 536870912#32))).bind
              fun x => if 1#32 â‰¥ â†‘32 then none else some (x <<< 1#32 &&& 3221225474#32)) âŠ‘
            (Option.map (fun div => xâœ - div * 536870912#32)
                  (if (536870912#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 536870912#32 == -1) = true then none
                  else some (xâœ.sdiv 536870912#32))).bind
              fun x =>
              if True âˆ§ (x <<< 1#32).sshiftRight (1#32).toNat = x then none
              else if 1#32 â‰¥ â†‘32 then none else some (x <<< 1#32 &&& 3221225474#32)
      âŠ¢ False
  [Meta.appBuilder] [0.015320] âœ…ï¸ f: Complement.complement, xs: [div * 536870912#32]
    [Meta.synthInstance] [0.011685] âœ…ï¸ Complement (BitVec 32)
      [Meta.synthInstance] [0.009838] âœ…ï¸ apply @BitVec.instComplement to Complement (BitVec 32)
        [Meta.whnf] [0.002121] Non-easy whnf: Complement (BitVec ?m.47387)
        [Meta.synthInstance.tryResolve] [0.007656] âœ…ï¸ Complement (BitVec 32) â‰Ÿ Complement (BitVec 32)
          [Meta.isDefEq] [0.007623] âœ…ï¸ Complement (BitVec 32) =?= Complement (BitVec ?m.47387)
            [Meta.isDefEq] [0.007579] âœ…ï¸ BitVec 32 =?= BitVec ?m.47387
              [Meta.isDefEq] [0.005665] âœ…ï¸ 32 =?= ?m.47387
                [Meta.isDefEq.assign] [0.005655] âœ…ï¸ ?m.47387 := 32
  [Meta.appBuilder] [0.002826] âœ…ï¸ f: HAdd.hAdd, xs: [~~~(div * 536870912#32), 1#32]
    [Meta.synthInstance] [0.002674] âœ…ï¸ HAdd (BitVec 32) (BitVec 32) (BitVec 32)
      [Meta.synthInstance] [0.002050] âœ…ï¸ apply @BitVec.instAdd to Add (BitVec 32)
  [Meta.isDefEq] [0.002236] âŒï¸ ?a + ?a =?= ~~~(div * 536870912#32) + 1#32
  [Meta.isDefEq] [0.002109] âŒï¸ ~~~?a + ?a =?= ~~~(div * 536870912#32) + 1#32
    [Meta.isDefEq] [0.001907] âœ…ï¸ ~~~?a =?= ~~~(div * 536870912#32)
      [Meta.isDefEq] [0.001844] âœ…ï¸ BitVec.instComplement =?= BitVec.instComplement
  [Meta.isDefEq] [0.004440] âŒï¸ ?a == ?a =?= 536870912#32 == 0#32
    [Meta.isDefEq.onFailure] [0.004110] âŒï¸ ?a == ?a =?= 536870912#32 == 0#32
      [Meta.synthInstance] [0.004084] ğŸ’¥ï¸ BEq ?Î±
        [Meta.synthInstance] [0.002113] new goal BEq ?Î±
        [Meta.synthInstance] [0.001932] ğŸ’¥ï¸ apply Nat.Linear.instBEqPolyCnstr to BEq ?Î±
  [Meta.appBuilder] [0.002073] âœ…ï¸ f: Subsingleton.elim, xs: [hâœ, h]
    [Meta.synthInstance] [0.002022] âœ…ï¸ Subsingleton (Decidable câœ)
      [Meta.synthInstance] [0.001939] âœ…ï¸ apply instSubsingletonDecidable to Subsingleton (Decidable câœ)
        [Meta.synthInstance.tryResolve] [0.001911] âœ…ï¸ Subsingleton (Decidable câœ) â‰Ÿ Subsingleton (Decidable câœ)
          [Meta.isDefEq] [0.001890] âœ…ï¸ Subsingleton (Decidable câœ) =?= Subsingleton (Decidable ?m.48124)
            [Meta.isDefEq] [0.001870] âœ…ï¸ Decidable câœ =?= Decidable ?m.48124
  [Meta.whnf] [0.001850] Non-easy whnf: LT Î±
  [Meta.isDefEq] [0.001941] âœ…ï¸ ?x > ?y =?= 1#32 < 32#32
  [Meta.isDefEq] [0.004656] âœ…ï¸ ?hf =?= fun a a_1 =>
        ite_cond_eq_false none (some (a <<< 1#32 &&& 3221225474#32))
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 32#32 1#32)
              (Eq.trans
                (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 1#32 32#32) (eq_self true)))
                Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))
    [Meta.isDefEq.assign] [0.004653] âœ…ï¸ ?hf := fun a a_1 =>
          ite_cond_eq_false none (some (a <<< 1#32 &&& 3221225474#32))
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 32#32 1#32)
                (Eq.trans
                  (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 1#32 32#32) (eq_self true)))
                  Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))
      [Meta.isDefEq.assign.checkTypes] [0.004615] âœ…ï¸ (?hf : âˆ€
            a âˆˆ
              Option.map (fun div => xâœ + (~~~(div * 536870912#32) + 1#32))
                (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 536870912#32) + 1#32 else xâœ / 536870912#32)),
            (if 1#32 â‰¥ â†‘32 then none else some (a <<< 1#32 &&& 3221225474#32)) =
              some
                (a <<< 1 &&&
                  3221225474#32)) := (fun a a_1 =>
            ite_cond_eq_false none (some (a <<< 1#32 &&& 3221225474#32))
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 32#32 1#32)
                  (Eq.trans
                    (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 1#32 32#32) (eq_self true)))
                    Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))) : âˆ€
            a âˆˆ
              Option.map (fun div => xâœ + (~~~(div * 536870912#32) + 1#32))
                (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 536870912#32) + 1#32 else xâœ / 536870912#32)),
            (if 1#32 â‰¥ â†‘32 then none else some (a <<< 1#32 &&& 3221225474#32)) = some (a <<< 1#32 &&& 3221225474#32))
        [Meta.isDefEq] [0.004612] âœ…ï¸ âˆ€
              a âˆˆ
                Option.map (fun div => xâœ + (~~~(div * 536870912#32) + 1#32))
                  (some
                    (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 536870912#32) + 1#32 else xâœ / 536870912#32)),
              (if 1#32 â‰¥ â†‘32 then none else some (a <<< 1#32 &&& 3221225474#32)) =
                some
                  (a <<< 1 &&&
                    3221225474#32) =?= âˆ€
              a âˆˆ
                Option.map (fun div => xâœ + (~~~(div * 536870912#32) + 1#32))
                  (some
                    (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 536870912#32) + 1#32 else xâœ / 536870912#32)),
              (if 1#32 â‰¥ â†‘32 then none else some (a <<< 1#32 &&& 3221225474#32)) = some (a <<< 1#32 &&& 3221225474#32)
          [Meta.isDefEq] [0.004566] âœ…ï¸ (if 1#32 â‰¥ â†‘32 then none else some (a <<< 1#32 &&& 3221225474#32)) =
                some
                  (a <<< 1 &&&
                    3221225474#32) =?= (if 1#32 â‰¥ â†‘32 then none else some (a <<< 1#32 &&& 3221225474#32)) =
                some (a <<< 1#32 &&& 3221225474#32)
            [Meta.isDefEq] [0.004538] âœ…ï¸ some (a <<< 1 &&& 3221225474#32) =?= some (a <<< 1#32 &&& 3221225474#32)
              [Meta.isDefEq] [0.004515] âœ…ï¸ a <<< 1 &&& 3221225474#32 =?= a <<< 1#32 &&& 3221225474#32
                [Meta.isDefEq] [0.004484] âœ…ï¸ instHAndOfAndOp.1 (a <<< 1)
                      3221225474#32 =?= instHAndOfAndOp.1 (a <<< 1#32) 3221225474#32
                  [Meta.isDefEq] [0.004418] âœ…ï¸ AndOp.and (a <<< 1)
                        3221225474#32 =?= AndOp.and (a <<< 1#32) 3221225474#32
                    [Meta.isDefEq] [0.002427] âœ…ï¸ BitVec.instAndOp.1 (a <<< 1)
                          3221225474#32 =?= BitVec.instAndOp.1 (a <<< 1#32) 3221225474#32
                      [Meta.isDefEq] [0.002362] âœ…ï¸ (a <<< 1).and 3221225474#32 =?= (a <<< 1#32).and 3221225474#32
                        [Meta.isDefEq.delta] [0.002350] âœ…ï¸ (a <<< 1).and
                              3221225474#32 =?= (a <<< 1#32).and 3221225474#32
                          [Meta.isDefEq] [0.002322] âœ…ï¸ a <<< 1 =?= a <<< 1#32
                            [Meta.isDefEq] [0.002295] âœ…ï¸ BitVec.instHShiftLeftNat.1 a
                                  1 =?= BitVec.instHShiftLeft.1 a 1#32
                              [Meta.isDefEq] [0.002237] âœ…ï¸ a.shiftLeft 1 =?= a <<< (1#32).toNat
                                [Meta.isDefEq] [0.002214] âœ…ï¸ a.shiftLeft 1 =?= a.shiftLeft (1#32).toNat
                                  [Meta.isDefEq.delta] [0.002200] âœ…ï¸ a.shiftLeft 1 =?= a.shiftLeft (1#32).toNat
                                    [Meta.isDefEq] [0.002175] âœ…ï¸ 1 =?= (1#32).toNat
                                      [Meta.whnf] [0.001959] Non-easy whnf: instOfNatNat 1
                                        [Meta.whnf] [0.001946] Non-easy whnf: { ofNat := 1 }
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬((Option.map (fun div => xâœ + (~~~(div * 536870912#32) + 1#32))
                  (some
                    (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 536870912#32) + 1#32
                    else xâœ / 536870912#32))).bind
              fun a => some (a <<< 1 &&& 3221225474#32)) âŠ‘
            (Option.map (fun div => xâœ + (~~~(div * 536870912#32) + 1#32))
                  (some
                    (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 536870912#32) + 1#32
                    else xâœ / 536870912#32))).bind
              fun a => if ((a <<< 1).sshiftRight 1 == a) = true then none else some (a <<< 1 &&& 3221225474#32)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:76:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:68:8: error: (kernel) declaration has metavariables 'src_srem_shl_demand_eliminate_signbit_thm'
[bv] [0.109722] Normalizing goal
  [Meta.synthInstance] [0.002692] âœ…ï¸ Decidable
        (((Option.map (fun div => xâœ - div * 1073741824#32)
                (if (1073741824#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 1073741824#32 == -1) = true then none
                else some (xâœ.sdiv 1073741824#32))).bind
            fun x => if 1#32 â‰¥ â†‘32 then none else some (x <<< 1#32 &&& 2#32)) âŠ‘
          (Option.map (fun div => xâœ - div * 1073741824#32)
                (if (1073741824#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 1073741824#32 == -1) = true then none
                else some (xâœ.sdiv 1073741824#32))).bind
            fun x =>
            if True âˆ§ (x <<< 1#32).sshiftRight (1#32).toNat = x then none
            else if 1#32 â‰¥ â†‘32 then none else some (x <<< 1#32 &&& 2#32))
    [Meta.check] [0.001683] âœ…ï¸ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          ((Option.map (fun div => xâœ - div * 1073741824#32)
                (if (1073741824#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 1073741824#32 == -1) = true then none
                else some (xâœ.sdiv 1073741824#32))).bind
            fun x => if 1#32 â‰¥ â†‘32 then none else some (x <<< 1#32 &&& 2#32))
          ((Option.map (fun div => xâœ - div * 1073741824#32)
                (if (1073741824#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 1073741824#32 == -1) = true then none
                else some (xâœ.sdiv 1073741824#32))).bind
            fun x =>
            if True âˆ§ (x <<< 1#32).sshiftRight (1#32).toNat = x then none
            else if 1#32 â‰¥ â†‘32 then none else some (x <<< 1#32 &&& 2#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬((Option.map (fun div => xâœ - div * 1073741824#32)
                  (if (1073741824#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 1073741824#32 == -1) = true then none
                  else some (xâœ.sdiv 1073741824#32))).bind
              fun x => if 1#32 â‰¥ â†‘32 then none else some (x <<< 1#32 &&& 2#32)) âŠ‘
            (Option.map (fun div => xâœ - div * 1073741824#32)
                  (if (1073741824#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 1073741824#32 == -1) = true then none
                  else some (xâœ.sdiv 1073741824#32))).bind
              fun x =>
              if True âˆ§ (x <<< 1#32).sshiftRight (1#32).toNat = x then none
              else if 1#32 â‰¥ â†‘32 then none else some (x <<< 1#32 &&& 2#32)
      âŠ¢ False
  [Meta.isDefEq] [0.001050] âŒï¸ ?a == ?a =?= 1073741824#32 == 0#32
  [Meta.synthInstance] [0.002836] âœ…ï¸ Decidable (((a <<< 1).sshiftRight 1 == a) = true)
    [Meta.synthInstance] [0.002491] âœ…ï¸ apply instDecidableEqBool to Decidable (((a <<< 1).sshiftRight 1 == a) = true)
      [Meta.synthInstance.tryResolve] [0.002439] âœ…ï¸ Decidable
            (((a <<< 1).sshiftRight 1 == a) = true) â‰Ÿ Decidable (((a <<< 1).sshiftRight 1 == a) = true)
        [Meta.isDefEq] [0.002340] âœ…ï¸ ?m.61213 =?= instDecidableEqBool ((a <<< 1).sshiftRight 1 == a) true
          [Meta.isDefEq.assign] [0.002332] âœ…ï¸ ?m.61213 := instDecidableEqBool ((a <<< 1).sshiftRight 1 == a) true
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬((Option.map (fun div => xâœ + (~~~(div * 1073741824#32) + 1#32))
                  (some
                    (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 1073741824#32) + 1#32
                    else xâœ / 1073741824#32))).bind
              fun a => some (a <<< 1 &&& 2#32)) âŠ‘
            (Option.map (fun div => xâœ + (~~~(div * 1073741824#32) + 1#32))
                  (some
                    (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 1073741824#32) + 1#32
                    else xâœ / 1073741824#32))).bind
              fun a => if ((a <<< 1).sshiftRight 1 == a) = true then none else some (a <<< 1 &&& 2#32)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:87:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:80:8: error: (kernel) declaration has metavariables 'src_srem_shl_demand_max_mask_hit_demand_thm'
[bv] [0.066992] Normalizing goal
  [Meta.synthInstance] [0.001597] âœ…ï¸ Decidable
        (((Option.map (fun div => xâœ - div * 4#32)
                (if (4#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 4#32 == -1) = true then none
                else some (xâœ.sdiv 4#32))).bind
            fun x => if 1#32 â‰¥ â†‘32 then none else some (x <<< 1#32 &&& 4294967292#32)) âŠ‘
          (Option.map (fun div => xâœ - div * 4#32)
                (if (4#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 4#32 == -1) = true then none
                else some (xâœ.sdiv 4#32))).bind
            fun x =>
            if True âˆ§ (x <<< 1#32).sshiftRight (1#32).toNat = x then none
            else if 1#32 â‰¥ â†‘32 then none else some (x <<< 1#32 &&& 4294967292#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬((Option.map (fun div => xâœ - div * 4#32)
                  (if (4#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 4#32 == -1) = true then none
                  else some (xâœ.sdiv 4#32))).bind
              fun x => if 1#32 â‰¥ â†‘32 then none else some (x <<< 1#32 &&& 4294967292#32)) âŠ‘
            (Option.map (fun div => xâœ - div * 4#32)
                  (if (4#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 4#32 == -1) = true then none
                  else some (xâœ.sdiv 4#32))).bind
              fun x =>
              if True âˆ§ (x <<< 1#32).sshiftRight (1#32).toNat = x then none
              else if 1#32 â‰¥ â†‘32 then none else some (x <<< 1#32 &&& 4294967292#32)
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬((Option.map (fun div => xâœ + (~~~(div * 4#32) + 1#32))
                  (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 4#32) + 1#32 else xâœ / 4#32))).bind
              fun a => some (a <<< 1 &&& 4294967292#32)) âŠ‘
            (Option.map (fun div => xâœ + (~~~(div * 4#32) + 1#32))
                  (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 4#32) + 1#32 else xâœ / 4#32))).bind
              fun a => if ((a <<< 1).sshiftRight 1 == a) = true then none else some (a <<< 1 &&& 4294967292#32)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:97:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:91:8: error: (kernel) declaration has metavariables 'sext_shl_trunc_same_size_thm'
[bv] [0.019533] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      e_1 : LLVM.IntW 16
      xâœÂ¹ : BitVec 32
      xâœ : BitVec 16
      aâœ :
        Â¬(if xâœÂ¹ â‰¥ â†‘32 then none else some (BitVec.truncate 16 (BitVec.signExtend 32 xâœ <<< xâœÂ¹))) âŠ‘
            if xâœÂ¹ â‰¥ â†‘32 then none else some (BitVec.truncate 16 (BitVec.zeroExtend 32 xâœ <<< xâœÂ¹))
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      e_1 : LLVM.IntW 16
      xâœÂ¹ : BitVec 32
      xâœ : BitVec 16
      aâœ :
        Â¬(if (!32#32 >áµ¤ xâœÂ¹) = true then none else some (BitVec.zeroExtend 16 (BitVec.signExtend 32 xâœ <<< xâœÂ¹))) âŠ‘
            if (!32#32 >áµ¤ xâœÂ¹) = true then none else some (BitVec.zeroExtend 16 (BitVec.zeroExtend 32 xâœ <<< xâœÂ¹))
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:107:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:101:8: error: (kernel) declaration has metavariables 'sext_shl_trunc_smaller_thm'
[bv] [0.024243] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      e_1 : LLVM.IntW 16
      xâœÂ¹ : BitVec 32
      xâœ : BitVec 16
      aâœ :
        Â¬(if xâœÂ¹ â‰¥ â†‘32 then none else some (BitVec.truncate 5 (BitVec.signExtend 32 xâœ <<< xâœÂ¹))) âŠ‘
            if xâœÂ¹ â‰¥ â†‘32 then none else some (BitVec.truncate 5 (BitVec.zeroExtend 32 xâœ <<< xâœÂ¹))
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      e_1 : LLVM.IntW 16
      xâœÂ¹ : BitVec 32
      xâœ : BitVec 16
      aâœ :
        Â¬(if (!32#32 >áµ¤ xâœÂ¹) = true then none else some (BitVec.zeroExtend 5 (BitVec.signExtend 32 xâœ <<< xâœÂ¹))) âŠ‘
            if (!32#32 >áµ¤ xâœÂ¹) = true then none else some (BitVec.zeroExtend 5 (BitVec.zeroExtend 32 xâœ <<< xâœÂ¹))
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:117:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:111:8: error: (kernel) declaration has metavariables 'sext_shl_mask_thm'
[bv] [0.019847] Normalizing goal
  [Meta.synthInstance] [0.001012] âœ…ï¸ Decidable
        ((if xâœÂ¹ â‰¥ â†‘32 then none else some (BitVec.signExtend 32 xâœ <<< xâœÂ¹ &&& 65535#32)) âŠ‘
          if xâœÂ¹ â‰¥ â†‘32 then none else some (BitVec.zeroExtend 32 xâœ <<< xâœÂ¹ &&& 65535#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      e_1 : LLVM.IntW 16
      xâœÂ¹ : BitVec 32
      xâœ : BitVec 16
      aâœ :
        Â¬(if xâœÂ¹ â‰¥ â†‘32 then none else some (BitVec.signExtend 32 xâœ <<< xâœÂ¹ &&& 65535#32)) âŠ‘
            if xâœÂ¹ â‰¥ â†‘32 then none else some (BitVec.zeroExtend 32 xâœ <<< xâœÂ¹ &&& 65535#32)
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      e_1 : LLVM.IntW 16
      xâœÂ¹ : BitVec 32
      xâœ : BitVec 16
      aâœ :
        Â¬(if (!32#32 >áµ¤ xâœÂ¹) = true then none else some (BitVec.signExtend 32 xâœ <<< xâœÂ¹ &&& 65535#32)) âŠ‘
            if (!32#32 >áµ¤ xâœÂ¹) = true then none else some (BitVec.zeroExtend 32 xâœ <<< xâœÂ¹ &&& 65535#32)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:128:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:121:8: error: (kernel) declaration has metavariables 'set_shl_mask_thm'
[bv] [0.034117] Normalizing goal
  [Meta.synthInstance] [0.001760] âœ…ï¸ Decidable
        ((if xâœÂ¹ â‰¥ â†‘32 then none else some ((xâœ ||| 196609#32) <<< xâœÂ¹ &&& 65536#32)) âŠ‘
          if xâœÂ¹ â‰¥ â†‘32 then none else some ((xâœ ||| 65537#32) <<< xâœÂ¹ &&& 65536#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      xâœÂ¹ xâœ : BitVec 32
      aâœ :
        Â¬(if xâœÂ¹ â‰¥ â†‘32 then none else some ((xâœ ||| 196609#32) <<< xâœÂ¹ &&& 65536#32)) âŠ‘
            if xâœÂ¹ â‰¥ â†‘32 then none else some ((xâœ ||| 65537#32) <<< xâœÂ¹ &&& 65536#32)
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      xâœÂ¹ xâœ : BitVec 32
      aâœ :
        Â¬(if (!32#32 >áµ¤ xâœÂ¹) = true then none else some ((xâœ ||| 196609#32) <<< xâœÂ¹ &&& 65536#32)) âŠ‘
            if (!32#32 >áµ¤ xâœÂ¹) = true then none else some ((xâœ ||| 65537#32) <<< xâœÂ¹ &&& 65536#32)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:138:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:132:8: error: (kernel) declaration has metavariables 'must_drop_poison_thm'
[bv] [0.065110] Normalizing goal
  [Meta.synthInstance] [0.002112] âœ…ï¸ Decidable
        ((if True âˆ§ ((xâœ &&& 255#32) <<< xâœÂ¹).sshiftRight xâœÂ¹.toNat = xâœ &&& 255#32 then none
          else
            if True âˆ§ (xâœ &&& 255#32) <<< xâœÂ¹ >>> xâœÂ¹ = xâœ &&& 255#32 then none
            else if xâœÂ¹ â‰¥ â†‘32 then none else some (BitVec.truncate 8 ((xâœ &&& 255#32) <<< xâœÂ¹))) âŠ‘
          if xâœÂ¹ â‰¥ â†‘32 then none else some (BitVec.truncate 8 (xâœ <<< xâœÂ¹)))
    [Meta.check] [0.001053] âœ…ï¸ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if True âˆ§ ((xâœ &&& 255#32) <<< xâœÂ¹).sshiftRight xâœÂ¹.toNat = xâœ &&& 255#32 then none
          else
            if True âˆ§ (xâœ &&& 255#32) <<< xâœÂ¹ >>> xâœÂ¹ = xâœ &&& 255#32 then none
            else if xâœÂ¹ â‰¥ â†‘32 then none else some (BitVec.truncate 8 ((xâœ &&& 255#32) <<< xâœÂ¹)))
          (if xâœÂ¹ â‰¥ â†‘32 then none else some (BitVec.truncate 8 (xâœ <<< xâœÂ¹)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      xâœÂ¹ xâœ : BitVec 32
      aâœ :
        Â¬(if True âˆ§ ((xâœ &&& 255#32) <<< xâœÂ¹).sshiftRight xâœÂ¹.toNat = xâœ &&& 255#32 then none
            else
              if True âˆ§ (xâœ &&& 255#32) <<< xâœÂ¹ >>> xâœÂ¹ = xâœ &&& 255#32 then none
              else if xâœÂ¹ â‰¥ â†‘32 then none else some (BitVec.truncate 8 ((xâœ &&& 255#32) <<< xâœÂ¹))) âŠ‘
            if xâœÂ¹ â‰¥ â†‘32 then none else some (BitVec.truncate 8 (xâœ <<< xâœÂ¹))
      âŠ¢ False
  [Meta.whnf] [0.001825] Non-easy whnf: BEq Î±
  [Meta.isDefEq] [0.001021] âŒï¸ ?a == ?a =?= ((xâœ &&& 255#32) <<< xâœÂ¹).sshiftRight xâœÂ¹.toNat == xâœ &&& 255#32
  [Meta.isDefEq] [0.001930] âœ…ï¸ ?x > ?y =?= xâœÂ¹ < 32#32
  [Meta.isDefEq] [0.001919] âŒï¸ ?a == ?a =?= (32#32 >áµ¤ xâœÂ¹) == true
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      xâœÂ¹ xâœ : BitVec 32
      aâœ :
        Â¬(if (((xâœ &&& 255#32) <<< xâœÂ¹).sshiftRight xâœÂ¹.toNat == xâœ &&& 255#32) = true then none
            else
              if ((xâœ &&& 255#32) <<< xâœÂ¹ >>> xâœÂ¹ == xâœ &&& 255#32) = true then none
              else if (!32#32 >áµ¤ xâœÂ¹) = true then none else some (BitVec.zeroExtend 8 ((xâœ &&& 255#32) <<< xâœÂ¹))) âŠ‘
            if (!32#32 >áµ¤ xâœÂ¹) = true then none else some (BitVec.zeroExtend 8 (xâœ <<< xâœÂ¹))
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:149:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:142:8: error: (kernel) declaration has metavariables 'f_t15_t01_t09_thm'
[bv] [0.024964] Normalizing goal
  [Meta.synthInstance] [0.002144] âœ…ï¸ Decidable
        ((if 31#40 â‰¥ â†‘40 then none
          else if 16#32 â‰¥ â†‘32 then none else some (BitVec.truncate 32 (xâœ.sshiftRight (31#40).toNat) <<< 16#32)) âŠ‘
          if 15#40 â‰¥ â†‘40 then none else some (BitVec.truncate 32 (xâœ.sshiftRight (15#40).toNat) &&& 4294901760#32))
    [Meta.check] [0.001199] âœ…ï¸ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if 31#40 â‰¥ â†‘40 then none
          else if 16#32 â‰¥ â†‘32 then none else some (BitVec.truncate 32 (xâœ.sshiftRight (31#40).toNat) <<< 16#32))
          (if 15#40 â‰¥ â†‘40 then none else some (BitVec.truncate 32 (xâœ.sshiftRight (15#40).toNat) &&& 4294901760#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 40
      xâœ : BitVec 40
      aâœ :
        Â¬(if 31#40 â‰¥ â†‘40 then none
            else if 16#32 â‰¥ â†‘32 then none else some (BitVec.truncate 32 (xâœ.sshiftRight (31#40).toNat) <<< 16#32)) âŠ‘
            if 15#40 â‰¥ â†‘40 then none else some (BitVec.truncate 32 (xâœ.sshiftRight (15#40).toNat) &&& 4294901760#32)
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 40
      xâœ : BitVec 40
      aâœ :
        Â¬some (BitVec.zeroExtend 32 (xâœ.sshiftRight 31) <<< 16) âŠ‘
            some (BitVec.zeroExtend 32 (xâœ.sshiftRight 15) &&& 4294901760#32)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
