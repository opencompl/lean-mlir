⚠ [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
⚠ [878/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [881/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
⚠ [887/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
⚠ [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:18:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:11:8: error: (kernel) declaration has metavariables 'src_srem_shl_demand_max_signbit_thm'
[bv] [0.157768] Normalizing goal
  [Meta.synthInstance] [0.002693] ✅️ Decidable
        (((Option.map (fun div => x✝ - div * 2#32)
                (if (2#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 2#32 == -1) = true then none
                else some (x✝.sdiv 2#32))).bind
            fun x => if 30#32 ≥ ↑32 then none else some (x <<< 30#32 &&& 2147483648#32)) ⊑
          (Option.map (fun div => x✝ - div * 2#32)
                (if (2#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 2#32 == -1) = true then none
                else some (x✝.sdiv 2#32))).bind
            fun x' => some (x' &&& 2147483648#32))
    [Meta.check] [0.001591] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          ((Option.map (fun div => x✝ - div * 2#32)
                (if (2#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 2#32 == -1) = true then none
                else some (x✝.sdiv 2#32))).bind
            fun x => if 30#32 ≥ ↑32 then none else some (x <<< 30#32 &&& 2147483648#32))
          ((Option.map (fun div => x✝ - div * 2#32)
                (if (2#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 2#32 == -1) = true then none
                else some (x✝.sdiv 2#32))).bind
            fun x' => some (x' &&& 2147483648#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬((Option.map (fun div => x✝ - div * 2#32)
                  (if (2#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 2#32 == -1) = true then none
                  else some (x✝.sdiv 2#32))).bind
              fun x => if 30#32 ≥ ↑32 then none else some (x <<< 30#32 &&& 2147483648#32)) ⊑
            (Option.map (fun div => x✝ - div * 2#32)
                  (if (2#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 2#32 == -1) = true then none
                  else some (x✝.sdiv 2#32))).bind
              fun x' => some (x' &&& 2147483648#32)
      ⊢ False
  [Meta.appBuilder] [0.001537] ✅️ f: Complement.complement, xs: [div * 2#32]
  [Meta.appBuilder] [0.001044] ✅️ f: HAdd.hAdd, xs: [~~~(div * 2#32), 1#32]
  [Meta.isDefEq] [0.004308] ❌️ ?a == ?a =?= 2#32 == 0#32
    [Meta.isDefEq.onFailure] [0.003810] ❌️ ?a == ?a =?= 2#32 == 0#32
      [Meta.synthInstance] [0.003776] 💥️ BEq ?α
        [Meta.synthInstance] [0.003662] new goal BEq ?α
  [Meta.whnf] [0.001758] Non-easy whnf: HDiv α β γ
  [Meta.whnf] [0.001746] Non-easy whnf: Div α
  [Meta.isDefEq] [0.001072] ✅️ ?hf =?= fun a a_1 =>
        ite_cond_eq_false none (some (a <<< 30#32 &&& 2147483648#32))
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 32#32 30#32)
              (Eq.trans
                (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 30#32 32#32) (eq_self true)))
                Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))
    [Meta.isDefEq.assign] [0.001065] ✅️ ?hf := fun a a_1 =>
          ite_cond_eq_false none (some (a <<< 30#32 &&& 2147483648#32))
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 32#32 30#32)
                (Eq.trans
                  (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 30#32 32#32) (eq_self true)))
                  Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))
      [Meta.isDefEq.assign.checkTypes] [0.001001] ✅️ (?hf : ∀
            a ∈
              Option.map (fun div => x✝ + (~~~(div * 2#32) + 1#32))
                (some (if x✝.getLsbD 31 = true then ~~~((~~~x✝ + 1#32) / 2#32) + 1#32 else x✝ / 2#32)),
            (if 30#32 ≥ ↑32 then none else some (a <<< 30#32 &&& 2147483648#32)) =
              some
                (a <<< 30 &&&
                  2147483648#32)) := (fun a a_1 =>
            ite_cond_eq_false none (some (a <<< 30#32 &&& 2147483648#32))
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 32#32 30#32)
                  (Eq.trans
                    (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 30#32 32#32) (eq_self true)))
                    Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))) : ∀
            a ∈
              Option.map (fun div => x✝ + (~~~(div * 2#32) + 1#32))
                (some (if x✝.getLsbD 31 = true then ~~~((~~~x✝ + 1#32) / 2#32) + 1#32 else x✝ / 2#32)),
            (if 30#32 ≥ ↑32 then none else some (a <<< 30#32 &&& 2147483648#32)) = some (a <<< 30#32 &&& 2147483648#32))
  [Meta.isDefEq] [0.004222] ✅️ ?hf =?= fun a a_1 => Eq.refl (some (a &&& 2147483648#32))
    [Meta.isDefEq.assign] [0.004217] ✅️ ?hf := fun a a_1 => Eq.refl (some (a &&& 2147483648#32))
      [Meta.isDefEq.assign.checkTypes] [0.004196] ✅️ (?hf : ∀
            a ∈
              Option.map (fun div => x✝ + (~~~(div * 2#32) + 1#32))
                (some (if x✝.getLsbD 31 = true then ~~~((~~~x✝ + 1#32) / 2#32) + 1#32 else x✝ / 2#32)),
            some (a &&& 2147483648#32) =
              some
                (a &&&
                  2147483648#32)) := (fun a a_1 =>
            Eq.refl
              (some
                (a &&&
                  2147483648#32)) : ∀
            a ∈
              Option.map (fun div => x✝ + (~~~(div * 2#32) + 1#32))
                (some (if x✝.getLsbD 31 = true then ~~~((~~~x✝ + 1#32) / 2#32) + 1#32 else x✝ / 2#32)),
            some (a &&& 2147483648#32) = some (a &&& 2147483648#32))
        [Meta.isDefEq] [0.004185] ✅️ ∀
              a ∈
                Option.map (fun div => x✝ + (~~~(div * 2#32) + 1#32))
                  (some (if x✝.getLsbD 31 = true then ~~~((~~~x✝ + 1#32) / 2#32) + 1#32 else x✝ / 2#32)),
              some (a &&& 2147483648#32) =
                some
                  (a &&&
                    2147483648#32) =?= ∀
              a ∈
                Option.map (fun div => x✝ + (~~~(div * 2#32) + 1#32))
                  (some (if x✝.getLsbD 31 = true then ~~~((~~~x✝ + 1#32) / 2#32) + 1#32 else x✝ / 2#32)),
              some (a &&& 2147483648#32) = some (a &&& 2147483648#32)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬((Option.map (fun div => x✝ + (~~~(div * 2#32) + 1#32))
                  (some (if x✝.getLsbD 31 = true then ~~~((~~~x✝ + 1#32) / 2#32) + 1#32 else x✝ / 2#32))).bind
              fun a => some (a <<< 30 &&& 2147483648#32)) ⊑
            (Option.map (fun div => x✝ + (~~~(div * 2#32) + 1#32))
                  (some (if x✝.getLsbD 31 = true then ~~~((~~~x✝ + 1#32) / 2#32) + 1#32 else x✝ / 2#32))).bind
              fun a => some (a &&& 2147483648#32)
      ⊢ False
  [Meta.isDefEq] [0.004480] ❌️ ~~~?a + ?a =?= ~~~(div * 2#32) + 1#32
    [Meta.isDefEq] [0.004214] ❌️ instHAdd =?= instHAdd
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:29:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:22:8: error: (kernel) declaration has metavariables 'src_srem_shl_demand_min_signbit_thm'
[bv] [0.063538] Normalizing goal
  [Meta.synthInstance] [0.002141] ✅️ Decidable
        (((Option.map (fun div => x✝ - div * 1073741823#32)
                (if (1073741823#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 1073741823#32 == -1) = true then none
                else some (x✝.sdiv 1073741823#32))).bind
            fun x => if 1#32 ≥ ↑32 then none else some (x <<< 1#32 &&& 2147483648#32)) ⊑
          (Option.map (fun div => x✝ - div * 1073741823#32)
                (if (1073741823#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 1073741823#32 == -1) = true then none
                else some (x✝.sdiv 1073741823#32))).bind
            fun x' => some (x' &&& 2147483648#32))
    [Meta.check] [0.001304] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          ((Option.map (fun div => x✝ - div * 1073741823#32)
                (if (1073741823#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 1073741823#32 == -1) = true then none
                else some (x✝.sdiv 1073741823#32))).bind
            fun x => if 1#32 ≥ ↑32 then none else some (x <<< 1#32 &&& 2147483648#32))
          ((Option.map (fun div => x✝ - div * 1073741823#32)
                (if (1073741823#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 1073741823#32 == -1) = true then none
                else some (x✝.sdiv 1073741823#32))).bind
            fun x' => some (x' &&& 2147483648#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬((Option.map (fun div => x✝ - div * 1073741823#32)
                  (if (1073741823#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 1073741823#32 == -1) = true then none
                  else some (x✝.sdiv 1073741823#32))).bind
              fun x => if 1#32 ≥ ↑32 then none else some (x <<< 1#32 &&& 2147483648#32)) ⊑
            (Option.map (fun div => x✝ - div * 1073741823#32)
                  (if (1073741823#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 1073741823#32 == -1) = true then none
                  else some (x✝.sdiv 1073741823#32))).bind
              fun x' => some (x' &&& 2147483648#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬((Option.map (fun div => x✝ + (~~~(div * 1073741823#32) + 1#32))
                  (some
                    (if x✝.getLsbD 31 = true then ~~~((~~~x✝ + 1#32) / 1073741823#32) + 1#32
                    else x✝ / 1073741823#32))).bind
              fun a => some (a <<< 1 &&& 2147483648#32)) ⊑
            (Option.map (fun div => x✝ + (~~~(div * 1073741823#32) + 1#32))
                  (some
                    (if x✝.getLsbD 31 = true then ~~~((~~~x✝ + 1#32) / 1073741823#32) + 1#32
                    else x✝ / 1073741823#32))).bind
              fun a => some (a &&& 2147483648#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:40:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:33:8: error: (kernel) declaration has metavariables 'src_srem_shl_demand_max_mask_thm'
[bv] [0.075051] Normalizing goal
  [Meta.synthInstance] [0.002498] ✅️ Decidable
        (((Option.map (fun div => x✝ - div * 2#32)
                (if (2#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 2#32 == -1) = true then none
                else some (x✝.sdiv 2#32))).bind
            fun x => if 1#32 ≥ ↑32 then none else some (x <<< 1#32 &&& 4294967292#32)) ⊑
          (Option.map (fun div => x✝ - div * 2#32)
                (if (2#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 2#32 == -1) = true then none
                else some (x✝.sdiv 2#32))).bind
            fun x' => some (x' &&& 4294967292#32))
    [Meta.check] [0.001529] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          ((Option.map (fun div => x✝ - div * 2#32)
                (if (2#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 2#32 == -1) = true then none
                else some (x✝.sdiv 2#32))).bind
            fun x => if 1#32 ≥ ↑32 then none else some (x <<< 1#32 &&& 4294967292#32))
          ((Option.map (fun div => x✝ - div * 2#32)
                (if (2#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 2#32 == -1) = true then none
                else some (x✝.sdiv 2#32))).bind
            fun x' => some (x' &&& 4294967292#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬((Option.map (fun div => x✝ - div * 2#32)
                  (if (2#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 2#32 == -1) = true then none
                  else some (x✝.sdiv 2#32))).bind
              fun x => if 1#32 ≥ ↑32 then none else some (x <<< 1#32 &&& 4294967292#32)) ⊑
            (Option.map (fun div => x✝ - div * 2#32)
                  (if (2#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 2#32 == -1) = true then none
                  else some (x✝.sdiv 2#32))).bind
              fun x' => some (x' &&& 4294967292#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬((Option.map (fun div => x✝ + (~~~(div * 2#32) + 1#32))
                  (some (if x✝.getLsbD 31 = true then ~~~((~~~x✝ + 1#32) / 2#32) + 1#32 else x✝ / 2#32))).bind
              fun a => some (a <<< 1 &&& 4294967292#32)) ⊑
            (Option.map (fun div => x✝ + (~~~(div * 2#32) + 1#32))
                  (some (if x✝.getLsbD 31 = true then ~~~((~~~x✝ + 1#32) / 2#32) + 1#32 else x✝ / 2#32))).bind
              fun a => some (a &&& 4294967292#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:52:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:44:8: error: (kernel) declaration has metavariables 'src_srem_shl_demand_max_signbit_mask_hit_first_demand_thm'
[bv] [0.065879] Normalizing goal
  [Meta.synthInstance] [0.001617] ✅️ Decidable
        (((Option.map (fun div => x✝ - div * 4#32)
                (if (4#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 4#32 == -1) = true then none
                else some (x✝.sdiv 4#32))).bind
            fun x => if 29#32 ≥ ↑32 then none else some (x <<< 29#32 &&& 3221225472#32)) ⊑
          (Option.map (fun div => x✝ - div * 4#32)
                (if (4#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 4#32 == -1) = true then none
                else some (x✝.sdiv 4#32))).bind
            fun x =>
            if True ∧ (x <<< 29#32).sshiftRight (29#32).toNat = x then none
            else if 29#32 ≥ ↑32 then none else some (x <<< 29#32 &&& 3221225472#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬((Option.map (fun div => x✝ - div * 4#32)
                  (if (4#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 4#32 == -1) = true then none
                  else some (x✝.sdiv 4#32))).bind
              fun x => if 29#32 ≥ ↑32 then none else some (x <<< 29#32 &&& 3221225472#32)) ⊑
            (Option.map (fun div => x✝ - div * 4#32)
                  (if (4#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 4#32 == -1) = true then none
                  else some (x✝.sdiv 4#32))).bind
              fun x =>
              if True ∧ (x <<< 29#32).sshiftRight (29#32).toNat = x then none
              else if 29#32 ≥ ↑32 then none else some (x <<< 29#32 &&& 3221225472#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬((Option.map (fun div => x✝ + (~~~(div * 4#32) + 1#32))
                  (some (if x✝.getLsbD 31 = true then ~~~((~~~x✝ + 1#32) / 4#32) + 1#32 else x✝ / 4#32))).bind
              fun a => some (a <<< 29 &&& 3221225472#32)) ⊑
            (Option.map (fun div => x✝ + (~~~(div * 4#32) + 1#32))
                  (some (if x✝.getLsbD 31 = true then ~~~((~~~x✝ + 1#32) / 4#32) + 1#32 else x✝ / 4#32))).bind
              fun a => if ((a <<< 29).sshiftRight 29 == a) = true then none else some (a <<< 29 &&& 3221225472#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:64:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:56:8: error: (kernel) declaration has metavariables 'src_srem_shl_demand_min_signbit_mask_hit_last_demand_thm'
[bv] [0.227857] Normalizing goal
  [Meta.synthInstance] [0.001566] ✅️ Decidable
        (((Option.map (fun div => x✝ - div * 536870912#32)
                (if (536870912#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 536870912#32 == -1) = true then none
                else some (x✝.sdiv 536870912#32))).bind
            fun x => if 1#32 ≥ ↑32 then none else some (x <<< 1#32 &&& 3221225474#32)) ⊑
          (Option.map (fun div => x✝ - div * 536870912#32)
                (if (536870912#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 536870912#32 == -1) = true then none
                else some (x✝.sdiv 536870912#32))).bind
            fun x =>
            if True ∧ (x <<< 1#32).sshiftRight (1#32).toNat = x then none
            else if 1#32 ≥ ↑32 then none else some (x <<< 1#32 &&& 3221225474#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬((Option.map (fun div => x✝ - div * 536870912#32)
                  (if (536870912#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 536870912#32 == -1) = true then none
                  else some (x✝.sdiv 536870912#32))).bind
              fun x => if 1#32 ≥ ↑32 then none else some (x <<< 1#32 &&& 3221225474#32)) ⊑
            (Option.map (fun div => x✝ - div * 536870912#32)
                  (if (536870912#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 536870912#32 == -1) = true then none
                  else some (x✝.sdiv 536870912#32))).bind
              fun x =>
              if True ∧ (x <<< 1#32).sshiftRight (1#32).toNat = x then none
              else if 1#32 ≥ ↑32 then none else some (x <<< 1#32 &&& 3221225474#32)
      ⊢ False
  [Meta.appBuilder] [0.015320] ✅️ f: Complement.complement, xs: [div * 536870912#32]
    [Meta.synthInstance] [0.011685] ✅️ Complement (BitVec 32)
      [Meta.synthInstance] [0.009838] ✅️ apply @BitVec.instComplement to Complement (BitVec 32)
        [Meta.whnf] [0.002121] Non-easy whnf: Complement (BitVec ?m.47387)
        [Meta.synthInstance.tryResolve] [0.007656] ✅️ Complement (BitVec 32) ≟ Complement (BitVec 32)
          [Meta.isDefEq] [0.007623] ✅️ Complement (BitVec 32) =?= Complement (BitVec ?m.47387)
            [Meta.isDefEq] [0.007579] ✅️ BitVec 32 =?= BitVec ?m.47387
              [Meta.isDefEq] [0.005665] ✅️ 32 =?= ?m.47387
                [Meta.isDefEq.assign] [0.005655] ✅️ ?m.47387 := 32
  [Meta.appBuilder] [0.002826] ✅️ f: HAdd.hAdd, xs: [~~~(div * 536870912#32), 1#32]
    [Meta.synthInstance] [0.002674] ✅️ HAdd (BitVec 32) (BitVec 32) (BitVec 32)
      [Meta.synthInstance] [0.002050] ✅️ apply @BitVec.instAdd to Add (BitVec 32)
  [Meta.isDefEq] [0.002236] ❌️ ?a + ?a =?= ~~~(div * 536870912#32) + 1#32
  [Meta.isDefEq] [0.002109] ❌️ ~~~?a + ?a =?= ~~~(div * 536870912#32) + 1#32
    [Meta.isDefEq] [0.001907] ✅️ ~~~?a =?= ~~~(div * 536870912#32)
      [Meta.isDefEq] [0.001844] ✅️ BitVec.instComplement =?= BitVec.instComplement
  [Meta.isDefEq] [0.004440] ❌️ ?a == ?a =?= 536870912#32 == 0#32
    [Meta.isDefEq.onFailure] [0.004110] ❌️ ?a == ?a =?= 536870912#32 == 0#32
      [Meta.synthInstance] [0.004084] 💥️ BEq ?α
        [Meta.synthInstance] [0.002113] new goal BEq ?α
        [Meta.synthInstance] [0.001932] 💥️ apply Nat.Linear.instBEqPolyCnstr to BEq ?α
  [Meta.appBuilder] [0.002073] ✅️ f: Subsingleton.elim, xs: [h✝, h]
    [Meta.synthInstance] [0.002022] ✅️ Subsingleton (Decidable c✝)
      [Meta.synthInstance] [0.001939] ✅️ apply instSubsingletonDecidable to Subsingleton (Decidable c✝)
        [Meta.synthInstance.tryResolve] [0.001911] ✅️ Subsingleton (Decidable c✝) ≟ Subsingleton (Decidable c✝)
          [Meta.isDefEq] [0.001890] ✅️ Subsingleton (Decidable c✝) =?= Subsingleton (Decidable ?m.48124)
            [Meta.isDefEq] [0.001870] ✅️ Decidable c✝ =?= Decidable ?m.48124
  [Meta.whnf] [0.001850] Non-easy whnf: LT α
  [Meta.isDefEq] [0.001941] ✅️ ?x > ?y =?= 1#32 < 32#32
  [Meta.isDefEq] [0.004656] ✅️ ?hf =?= fun a a_1 =>
        ite_cond_eq_false none (some (a <<< 1#32 &&& 3221225474#32))
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 32#32 1#32)
              (Eq.trans
                (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 1#32 32#32) (eq_self true)))
                Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))
    [Meta.isDefEq.assign] [0.004653] ✅️ ?hf := fun a a_1 =>
          ite_cond_eq_false none (some (a <<< 1#32 &&& 3221225474#32))
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 32#32 1#32)
                (Eq.trans
                  (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 1#32 32#32) (eq_self true)))
                  Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2)))
      [Meta.isDefEq.assign.checkTypes] [0.004615] ✅️ (?hf : ∀
            a ∈
              Option.map (fun div => x✝ + (~~~(div * 536870912#32) + 1#32))
                (some (if x✝.getLsbD 31 = true then ~~~((~~~x✝ + 1#32) / 536870912#32) + 1#32 else x✝ / 536870912#32)),
            (if 1#32 ≥ ↑32 then none else some (a <<< 1#32 &&& 3221225474#32)) =
              some
                (a <<< 1 &&&
                  3221225474#32)) := (fun a a_1 =>
            ite_cond_eq_false none (some (a <<< 1#32 &&& 3221225474#32))
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 32#32 1#32)
                  (Eq.trans
                    (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 1#32 32#32) (eq_self true)))
                    Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))) : ∀
            a ∈
              Option.map (fun div => x✝ + (~~~(div * 536870912#32) + 1#32))
                (some (if x✝.getLsbD 31 = true then ~~~((~~~x✝ + 1#32) / 536870912#32) + 1#32 else x✝ / 536870912#32)),
            (if 1#32 ≥ ↑32 then none else some (a <<< 1#32 &&& 3221225474#32)) = some (a <<< 1#32 &&& 3221225474#32))
        [Meta.isDefEq] [0.004612] ✅️ ∀
              a ∈
                Option.map (fun div => x✝ + (~~~(div * 536870912#32) + 1#32))
                  (some
                    (if x✝.getLsbD 31 = true then ~~~((~~~x✝ + 1#32) / 536870912#32) + 1#32 else x✝ / 536870912#32)),
              (if 1#32 ≥ ↑32 then none else some (a <<< 1#32 &&& 3221225474#32)) =
                some
                  (a <<< 1 &&&
                    3221225474#32) =?= ∀
              a ∈
                Option.map (fun div => x✝ + (~~~(div * 536870912#32) + 1#32))
                  (some
                    (if x✝.getLsbD 31 = true then ~~~((~~~x✝ + 1#32) / 536870912#32) + 1#32 else x✝ / 536870912#32)),
              (if 1#32 ≥ ↑32 then none else some (a <<< 1#32 &&& 3221225474#32)) = some (a <<< 1#32 &&& 3221225474#32)
          [Meta.isDefEq] [0.004566] ✅️ (if 1#32 ≥ ↑32 then none else some (a <<< 1#32 &&& 3221225474#32)) =
                some
                  (a <<< 1 &&&
                    3221225474#32) =?= (if 1#32 ≥ ↑32 then none else some (a <<< 1#32 &&& 3221225474#32)) =
                some (a <<< 1#32 &&& 3221225474#32)
            [Meta.isDefEq] [0.004538] ✅️ some (a <<< 1 &&& 3221225474#32) =?= some (a <<< 1#32 &&& 3221225474#32)
              [Meta.isDefEq] [0.004515] ✅️ a <<< 1 &&& 3221225474#32 =?= a <<< 1#32 &&& 3221225474#32
                [Meta.isDefEq] [0.004484] ✅️ instHAndOfAndOp.1 (a <<< 1)
                      3221225474#32 =?= instHAndOfAndOp.1 (a <<< 1#32) 3221225474#32
                  [Meta.isDefEq] [0.004418] ✅️ AndOp.and (a <<< 1)
                        3221225474#32 =?= AndOp.and (a <<< 1#32) 3221225474#32
                    [Meta.isDefEq] [0.002427] ✅️ BitVec.instAndOp.1 (a <<< 1)
                          3221225474#32 =?= BitVec.instAndOp.1 (a <<< 1#32) 3221225474#32
                      [Meta.isDefEq] [0.002362] ✅️ (a <<< 1).and 3221225474#32 =?= (a <<< 1#32).and 3221225474#32
                        [Meta.isDefEq.delta] [0.002350] ✅️ (a <<< 1).and
                              3221225474#32 =?= (a <<< 1#32).and 3221225474#32
                          [Meta.isDefEq] [0.002322] ✅️ a <<< 1 =?= a <<< 1#32
                            [Meta.isDefEq] [0.002295] ✅️ BitVec.instHShiftLeftNat.1 a
                                  1 =?= BitVec.instHShiftLeft.1 a 1#32
                              [Meta.isDefEq] [0.002237] ✅️ a.shiftLeft 1 =?= a <<< (1#32).toNat
                                [Meta.isDefEq] [0.002214] ✅️ a.shiftLeft 1 =?= a.shiftLeft (1#32).toNat
                                  [Meta.isDefEq.delta] [0.002200] ✅️ a.shiftLeft 1 =?= a.shiftLeft (1#32).toNat
                                    [Meta.isDefEq] [0.002175] ✅️ 1 =?= (1#32).toNat
                                      [Meta.whnf] [0.001959] Non-easy whnf: instOfNatNat 1
                                        [Meta.whnf] [0.001946] Non-easy whnf: { ofNat := 1 }
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬((Option.map (fun div => x✝ + (~~~(div * 536870912#32) + 1#32))
                  (some
                    (if x✝.getLsbD 31 = true then ~~~((~~~x✝ + 1#32) / 536870912#32) + 1#32
                    else x✝ / 536870912#32))).bind
              fun a => some (a <<< 1 &&& 3221225474#32)) ⊑
            (Option.map (fun div => x✝ + (~~~(div * 536870912#32) + 1#32))
                  (some
                    (if x✝.getLsbD 31 = true then ~~~((~~~x✝ + 1#32) / 536870912#32) + 1#32
                    else x✝ / 536870912#32))).bind
              fun a => if ((a <<< 1).sshiftRight 1 == a) = true then none else some (a <<< 1 &&& 3221225474#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:76:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:68:8: error: (kernel) declaration has metavariables 'src_srem_shl_demand_eliminate_signbit_thm'
[bv] [0.109722] Normalizing goal
  [Meta.synthInstance] [0.002692] ✅️ Decidable
        (((Option.map (fun div => x✝ - div * 1073741824#32)
                (if (1073741824#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 1073741824#32 == -1) = true then none
                else some (x✝.sdiv 1073741824#32))).bind
            fun x => if 1#32 ≥ ↑32 then none else some (x <<< 1#32 &&& 2#32)) ⊑
          (Option.map (fun div => x✝ - div * 1073741824#32)
                (if (1073741824#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 1073741824#32 == -1) = true then none
                else some (x✝.sdiv 1073741824#32))).bind
            fun x =>
            if True ∧ (x <<< 1#32).sshiftRight (1#32).toNat = x then none
            else if 1#32 ≥ ↑32 then none else some (x <<< 1#32 &&& 2#32))
    [Meta.check] [0.001683] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          ((Option.map (fun div => x✝ - div * 1073741824#32)
                (if (1073741824#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 1073741824#32 == -1) = true then none
                else some (x✝.sdiv 1073741824#32))).bind
            fun x => if 1#32 ≥ ↑32 then none else some (x <<< 1#32 &&& 2#32))
          ((Option.map (fun div => x✝ - div * 1073741824#32)
                (if (1073741824#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 1073741824#32 == -1) = true then none
                else some (x✝.sdiv 1073741824#32))).bind
            fun x =>
            if True ∧ (x <<< 1#32).sshiftRight (1#32).toNat = x then none
            else if 1#32 ≥ ↑32 then none else some (x <<< 1#32 &&& 2#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬((Option.map (fun div => x✝ - div * 1073741824#32)
                  (if (1073741824#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 1073741824#32 == -1) = true then none
                  else some (x✝.sdiv 1073741824#32))).bind
              fun x => if 1#32 ≥ ↑32 then none else some (x <<< 1#32 &&& 2#32)) ⊑
            (Option.map (fun div => x✝ - div * 1073741824#32)
                  (if (1073741824#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 1073741824#32 == -1) = true then none
                  else some (x✝.sdiv 1073741824#32))).bind
              fun x =>
              if True ∧ (x <<< 1#32).sshiftRight (1#32).toNat = x then none
              else if 1#32 ≥ ↑32 then none else some (x <<< 1#32 &&& 2#32)
      ⊢ False
  [Meta.isDefEq] [0.001050] ❌️ ?a == ?a =?= 1073741824#32 == 0#32
  [Meta.synthInstance] [0.002836] ✅️ Decidable (((a <<< 1).sshiftRight 1 == a) = true)
    [Meta.synthInstance] [0.002491] ✅️ apply instDecidableEqBool to Decidable (((a <<< 1).sshiftRight 1 == a) = true)
      [Meta.synthInstance.tryResolve] [0.002439] ✅️ Decidable
            (((a <<< 1).sshiftRight 1 == a) = true) ≟ Decidable (((a <<< 1).sshiftRight 1 == a) = true)
        [Meta.isDefEq] [0.002340] ✅️ ?m.61213 =?= instDecidableEqBool ((a <<< 1).sshiftRight 1 == a) true
          [Meta.isDefEq.assign] [0.002332] ✅️ ?m.61213 := instDecidableEqBool ((a <<< 1).sshiftRight 1 == a) true
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬((Option.map (fun div => x✝ + (~~~(div * 1073741824#32) + 1#32))
                  (some
                    (if x✝.getLsbD 31 = true then ~~~((~~~x✝ + 1#32) / 1073741824#32) + 1#32
                    else x✝ / 1073741824#32))).bind
              fun a => some (a <<< 1 &&& 2#32)) ⊑
            (Option.map (fun div => x✝ + (~~~(div * 1073741824#32) + 1#32))
                  (some
                    (if x✝.getLsbD 31 = true then ~~~((~~~x✝ + 1#32) / 1073741824#32) + 1#32
                    else x✝ / 1073741824#32))).bind
              fun a => if ((a <<< 1).sshiftRight 1 == a) = true then none else some (a <<< 1 &&& 2#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:87:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:80:8: error: (kernel) declaration has metavariables 'src_srem_shl_demand_max_mask_hit_demand_thm'
[bv] [0.066992] Normalizing goal
  [Meta.synthInstance] [0.001597] ✅️ Decidable
        (((Option.map (fun div => x✝ - div * 4#32)
                (if (4#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 4#32 == -1) = true then none
                else some (x✝.sdiv 4#32))).bind
            fun x => if 1#32 ≥ ↑32 then none else some (x <<< 1#32 &&& 4294967292#32)) ⊑
          (Option.map (fun div => x✝ - div * 4#32)
                (if (4#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 4#32 == -1) = true then none
                else some (x✝.sdiv 4#32))).bind
            fun x =>
            if True ∧ (x <<< 1#32).sshiftRight (1#32).toNat = x then none
            else if 1#32 ≥ ↑32 then none else some (x <<< 1#32 &&& 4294967292#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬((Option.map (fun div => x✝ - div * 4#32)
                  (if (4#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 4#32 == -1) = true then none
                  else some (x✝.sdiv 4#32))).bind
              fun x => if 1#32 ≥ ↑32 then none else some (x <<< 1#32 &&& 4294967292#32)) ⊑
            (Option.map (fun div => x✝ - div * 4#32)
                  (if (4#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 4#32 == -1) = true then none
                  else some (x✝.sdiv 4#32))).bind
              fun x =>
              if True ∧ (x <<< 1#32).sshiftRight (1#32).toNat = x then none
              else if 1#32 ≥ ↑32 then none else some (x <<< 1#32 &&& 4294967292#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬((Option.map (fun div => x✝ + (~~~(div * 4#32) + 1#32))
                  (some (if x✝.getLsbD 31 = true then ~~~((~~~x✝ + 1#32) / 4#32) + 1#32 else x✝ / 4#32))).bind
              fun a => some (a <<< 1 &&& 4294967292#32)) ⊑
            (Option.map (fun div => x✝ + (~~~(div * 4#32) + 1#32))
                  (some (if x✝.getLsbD 31 = true then ~~~((~~~x✝ + 1#32) / 4#32) + 1#32 else x✝ / 4#32))).bind
              fun a => if ((a <<< 1).sshiftRight 1 == a) = true then none else some (a <<< 1 &&& 4294967292#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:97:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:91:8: error: (kernel) declaration has metavariables 'sext_shl_trunc_same_size_thm'
[bv] [0.019533] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      e_1 : LLVM.IntW 16
      x✝¹ : BitVec 32
      x✝ : BitVec 16
      a✝ :
        ¬(if x✝¹ ≥ ↑32 then none else some (BitVec.truncate 16 (BitVec.signExtend 32 x✝ <<< x✝¹))) ⊑
            if x✝¹ ≥ ↑32 then none else some (BitVec.truncate 16 (BitVec.zeroExtend 32 x✝ <<< x✝¹))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      e_1 : LLVM.IntW 16
      x✝¹ : BitVec 32
      x✝ : BitVec 16
      a✝ :
        ¬(if (!32#32 >ᵤ x✝¹) = true then none else some (BitVec.zeroExtend 16 (BitVec.signExtend 32 x✝ <<< x✝¹))) ⊑
            if (!32#32 >ᵤ x✝¹) = true then none else some (BitVec.zeroExtend 16 (BitVec.zeroExtend 32 x✝ <<< x✝¹))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:107:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:101:8: error: (kernel) declaration has metavariables 'sext_shl_trunc_smaller_thm'
[bv] [0.024243] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      e_1 : LLVM.IntW 16
      x✝¹ : BitVec 32
      x✝ : BitVec 16
      a✝ :
        ¬(if x✝¹ ≥ ↑32 then none else some (BitVec.truncate 5 (BitVec.signExtend 32 x✝ <<< x✝¹))) ⊑
            if x✝¹ ≥ ↑32 then none else some (BitVec.truncate 5 (BitVec.zeroExtend 32 x✝ <<< x✝¹))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      e_1 : LLVM.IntW 16
      x✝¹ : BitVec 32
      x✝ : BitVec 16
      a✝ :
        ¬(if (!32#32 >ᵤ x✝¹) = true then none else some (BitVec.zeroExtend 5 (BitVec.signExtend 32 x✝ <<< x✝¹))) ⊑
            if (!32#32 >ᵤ x✝¹) = true then none else some (BitVec.zeroExtend 5 (BitVec.zeroExtend 32 x✝ <<< x✝¹))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:117:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:111:8: error: (kernel) declaration has metavariables 'sext_shl_mask_thm'
[bv] [0.019847] Normalizing goal
  [Meta.synthInstance] [0.001012] ✅️ Decidable
        ((if x✝¹ ≥ ↑32 then none else some (BitVec.signExtend 32 x✝ <<< x✝¹ &&& 65535#32)) ⊑
          if x✝¹ ≥ ↑32 then none else some (BitVec.zeroExtend 32 x✝ <<< x✝¹ &&& 65535#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      e_1 : LLVM.IntW 16
      x✝¹ : BitVec 32
      x✝ : BitVec 16
      a✝ :
        ¬(if x✝¹ ≥ ↑32 then none else some (BitVec.signExtend 32 x✝ <<< x✝¹ &&& 65535#32)) ⊑
            if x✝¹ ≥ ↑32 then none else some (BitVec.zeroExtend 32 x✝ <<< x✝¹ &&& 65535#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      e_1 : LLVM.IntW 16
      x✝¹ : BitVec 32
      x✝ : BitVec 16
      a✝ :
        ¬(if (!32#32 >ᵤ x✝¹) = true then none else some (BitVec.signExtend 32 x✝ <<< x✝¹ &&& 65535#32)) ⊑
            if (!32#32 >ᵤ x✝¹) = true then none else some (BitVec.zeroExtend 32 x✝ <<< x✝¹ &&& 65535#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:128:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:121:8: error: (kernel) declaration has metavariables 'set_shl_mask_thm'
[bv] [0.034117] Normalizing goal
  [Meta.synthInstance] [0.001760] ✅️ Decidable
        ((if x✝¹ ≥ ↑32 then none else some ((x✝ ||| 196609#32) <<< x✝¹ &&& 65536#32)) ⊑
          if x✝¹ ≥ ↑32 then none else some ((x✝ ||| 65537#32) <<< x✝¹ &&& 65536#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if x✝¹ ≥ ↑32 then none else some ((x✝ ||| 196609#32) <<< x✝¹ &&& 65536#32)) ⊑
            if x✝¹ ≥ ↑32 then none else some ((x✝ ||| 65537#32) <<< x✝¹ &&& 65536#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!32#32 >ᵤ x✝¹) = true then none else some ((x✝ ||| 196609#32) <<< x✝¹ &&& 65536#32)) ⊑
            if (!32#32 >ᵤ x✝¹) = true then none else some ((x✝ ||| 65537#32) <<< x✝¹ &&& 65536#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:138:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:132:8: error: (kernel) declaration has metavariables 'must_drop_poison_thm'
[bv] [0.065110] Normalizing goal
  [Meta.synthInstance] [0.002112] ✅️ Decidable
        ((if True ∧ ((x✝ &&& 255#32) <<< x✝¹).sshiftRight x✝¹.toNat = x✝ &&& 255#32 then none
          else
            if True ∧ (x✝ &&& 255#32) <<< x✝¹ >>> x✝¹ = x✝ &&& 255#32 then none
            else if x✝¹ ≥ ↑32 then none else some (BitVec.truncate 8 ((x✝ &&& 255#32) <<< x✝¹))) ⊑
          if x✝¹ ≥ ↑32 then none else some (BitVec.truncate 8 (x✝ <<< x✝¹)))
    [Meta.check] [0.001053] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if True ∧ ((x✝ &&& 255#32) <<< x✝¹).sshiftRight x✝¹.toNat = x✝ &&& 255#32 then none
          else
            if True ∧ (x✝ &&& 255#32) <<< x✝¹ >>> x✝¹ = x✝ &&& 255#32 then none
            else if x✝¹ ≥ ↑32 then none else some (BitVec.truncate 8 ((x✝ &&& 255#32) <<< x✝¹)))
          (if x✝¹ ≥ ↑32 then none else some (BitVec.truncate 8 (x✝ <<< x✝¹)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if True ∧ ((x✝ &&& 255#32) <<< x✝¹).sshiftRight x✝¹.toNat = x✝ &&& 255#32 then none
            else
              if True ∧ (x✝ &&& 255#32) <<< x✝¹ >>> x✝¹ = x✝ &&& 255#32 then none
              else if x✝¹ ≥ ↑32 then none else some (BitVec.truncate 8 ((x✝ &&& 255#32) <<< x✝¹))) ⊑
            if x✝¹ ≥ ↑32 then none else some (BitVec.truncate 8 (x✝ <<< x✝¹))
      ⊢ False
  [Meta.whnf] [0.001825] Non-easy whnf: BEq α
  [Meta.isDefEq] [0.001021] ❌️ ?a == ?a =?= ((x✝ &&& 255#32) <<< x✝¹).sshiftRight x✝¹.toNat == x✝ &&& 255#32
  [Meta.isDefEq] [0.001930] ✅️ ?x > ?y =?= x✝¹ < 32#32
  [Meta.isDefEq] [0.001919] ❌️ ?a == ?a =?= (32#32 >ᵤ x✝¹) == true
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (((x✝ &&& 255#32) <<< x✝¹).sshiftRight x✝¹.toNat == x✝ &&& 255#32) = true then none
            else
              if ((x✝ &&& 255#32) <<< x✝¹ >>> x✝¹ == x✝ &&& 255#32) = true then none
              else if (!32#32 >ᵤ x✝¹) = true then none else some (BitVec.zeroExtend 8 ((x✝ &&& 255#32) <<< x✝¹))) ⊑
            if (!32#32 >ᵤ x✝¹) = true then none else some (BitVec.zeroExtend 8 (x✝ <<< x✝¹))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:149:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhdemand_proof.lean:142:8: error: (kernel) declaration has metavariables 'f_t15_t01_t09_thm'
[bv] [0.024964] Normalizing goal
  [Meta.synthInstance] [0.002144] ✅️ Decidable
        ((if 31#40 ≥ ↑40 then none
          else if 16#32 ≥ ↑32 then none else some (BitVec.truncate 32 (x✝.sshiftRight (31#40).toNat) <<< 16#32)) ⊑
          if 15#40 ≥ ↑40 then none else some (BitVec.truncate 32 (x✝.sshiftRight (15#40).toNat) &&& 4294901760#32))
    [Meta.check] [0.001199] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if 31#40 ≥ ↑40 then none
          else if 16#32 ≥ ↑32 then none else some (BitVec.truncate 32 (x✝.sshiftRight (31#40).toNat) <<< 16#32))
          (if 15#40 ≥ ↑40 then none else some (BitVec.truncate 32 (x✝.sshiftRight (15#40).toNat) &&& 4294901760#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 40
      x✝ : BitVec 40
      a✝ :
        ¬(if 31#40 ≥ ↑40 then none
            else if 16#32 ≥ ↑32 then none else some (BitVec.truncate 32 (x✝.sshiftRight (31#40).toNat) <<< 16#32)) ⊑
            if 15#40 ≥ ↑40 then none else some (BitVec.truncate 32 (x✝.sshiftRight (15#40).toNat) &&& 4294901760#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 40
      x✝ : BitVec 40
      a✝ :
        ¬some (BitVec.zeroExtend 32 (x✝.sshiftRight 31) <<< 16) ⊑
            some (BitVec.zeroExtend 32 (x✝.sshiftRight 15) &&& 4294901760#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
