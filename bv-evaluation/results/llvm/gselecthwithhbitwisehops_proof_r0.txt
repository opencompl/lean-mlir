⚠ [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
⚠ [878/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [881/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
⚠ [887/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
⚠ [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:18:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:18:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:11:8: error: (kernel) declaration has metavariables 'select_icmp_eq_and_1_0_or_2_thm'
[bv] [0.056989] Normalizing goal
  [Meta.synthInstance] [0.002665] ✅️ Decidable
        ((match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2#32)) ⊑
          if 1#32 ≥ ↑32 then none else some (x✝¹ ||| x✝ <<< 1#32 &&& 2#32))
    [Meta.check] [0.001223] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2#32))
          (if 1#32 ≥ ↑32 then none else some (x✝¹ ||| x✝ <<< 1#32 &&& 2#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2#32)) ⊑
            if 1#32 ≥ ↑32 then none else some (x✝¹ ||| x✝ <<< 1#32 &&& 2#32)
      ⊢ False
  [Meta.isDefEq] [0.001557] ❌️ ?a == ?a =?= x✝ &&& 1#32 == 0#32
    [Meta.isDefEq] [0.001299] ✅️ ?a =?= x✝ &&& 1#32
      [Meta.isDefEq.assign] [0.001293] ✅️ ?a := x✝ &&& 1#32
        [Meta.isDefEq.assign.checkTypes] [0.001278] ✅️ (?a : BitVec 32) := (x✝ &&& 1#32 : BitVec 32)
  [Meta.isDefEq] [0.001173] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 1#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2#32)
  [Meta.isDefEq] [0.001272] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 1#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2#32)
  [Meta.isDefEq] [0.001247] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 1#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2#32)
  [Meta.isDefEq] [0.001145] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 1#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2#32)
  [Meta.isDefEq] [0.001051] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 1#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2#32)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (if (x✝ &&& 1#32 == 0#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2#32)) ⊑
            some (x✝¹ ||| x✝ <<< 1 &&& 2#32)
      ⊢ False
  [Meta.isDefEq] [0.001145] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 1#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2#32)
  [Meta.isDefEq] [0.001269] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 1#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2#32)
  [Meta.isDefEq] [0.001025] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 1#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2#32)
  [Meta.isDefEq] [0.001164] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 1#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2#32)
  [Meta.isDefEq] [0.001292] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 1#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2#32)
  [Meta.isDefEq] [0.001252] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 1#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2#32)
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:29:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:29:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:22:8: error: (kernel) declaration has metavariables 'select_icmp_eq_and_1_0_xor_2_thm'
[bv] [0.036824] Normalizing goal
  [Meta.synthInstance] [0.001653] ✅️ Decidable
        ((match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 2#32)) ⊑
          if 1#32 ≥ ↑32 then none else some (x✝¹ ^^^ x✝ <<< 1#32 &&& 2#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 2#32)) ⊑
            if 1#32 ≥ ↑32 then none else some (x✝¹ ^^^ x✝ <<< 1#32 &&& 2#32)
      ⊢ False
  [Meta.isDefEq] [0.001581] ✅️ ?x > ?y =?= 1#32 < 32#32
    [Meta.isDefEq] [0.001545] ✅️ ?y < ?x =?= 1#32 < 32#32
      [Meta.isDefEq] [0.001441] ✅️ ?inst✝ =?= instLTBitVec
        [Meta.isDefEq.assign] [0.001437] ✅️ ?inst✝ := instLTBitVec
          [Meta.isDefEq.assign.checkTypes] [0.001428] ✅️ (?inst✝ : LT (BitVec 32)) := (instLTBitVec : LT (BitVec 32))
            [Meta.isDefEq] [0.001418] ✅️ LT (BitVec 32) =?= LT (BitVec 32)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (if (x✝ &&& 1#32 == 0#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 2#32)) ⊑
            some (x✝¹ ^^^ x✝ <<< 1 &&& 2#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:40:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:40:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:33:8: error: (kernel) declaration has metavariables 'select_icmp_eq_and_32_0_or_8_thm'
[bv] [0.035974] Normalizing goal
  [Meta.synthInstance] [0.001631] ✅️ Decidable
        ((match some (BitVec.ofBool (x✝ &&& 32#32 == 0#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 8#32)) ⊑
          if 2#32 ≥ ↑32 then none else some (x✝¹ ||| x✝ >>> 2#32 &&& 8#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (BitVec.ofBool (x✝ &&& 32#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 8#32)) ⊑
            if 2#32 ≥ ↑32 then none else some (x✝¹ ||| x✝ >>> 2#32 &&& 8#32)
      ⊢ False
  [Meta.isDefEq] [0.001241] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 32#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 8#32)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (if (x✝ &&& 32#32 == 0#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 8#32)) ⊑
            some (x✝¹ ||| x✝ >>> 2 &&& 8#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:51:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:51:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:44:8: error: (kernel) declaration has metavariables 'select_icmp_eq_and_32_0_xor_8_thm'
[bv] [0.056065] Normalizing goal
  [Meta.synthInstance] [0.002438] ✅️ Decidable
        ((match some (BitVec.ofBool (x✝ &&& 32#32 == 0#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 8#32)) ⊑
          if 2#32 ≥ ↑32 then none else some (x✝¹ ^^^ x✝ >>> 2#32 &&& 8#32))
    [Meta.check] [0.001191] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (match some (BitVec.ofBool (x✝ &&& 32#32 == 0#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 8#32))
          (if 2#32 ≥ ↑32 then none else some (x✝¹ ^^^ x✝ >>> 2#32 &&& 8#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (BitVec.ofBool (x✝ &&& 32#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 8#32)) ⊑
            if 2#32 ≥ ↑32 then none else some (x✝¹ ^^^ x✝ >>> 2#32 &&& 8#32)
      ⊢ False
  [Meta.isDefEq] [0.001211] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 32#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 8#32)
  [Meta.isDefEq] [0.001255] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 32#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 8#32)
  [Meta.isDefEq] [0.001245] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 32#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 8#32)
  [Meta.isDefEq] [0.001180] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 32#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 8#32)
  [Meta.isDefEq] [0.001229] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 32#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 8#32)
  [Meta.isDefEq] [0.001166] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 32#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 8#32)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (if (x✝ &&& 32#32 == 0#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 8#32)) ⊑
            some (x✝¹ ^^^ x✝ >>> 2 &&& 8#32)
      ⊢ False
  [Meta.isDefEq] [0.001209] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 32#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 8#32)
  [Meta.isDefEq] [0.001288] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 32#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 8#32)
  [Meta.isDefEq] [0.001240] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 32#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 8#32)
  [Meta.isDefEq] [0.001170] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 32#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 8#32)
  [Meta.isDefEq] [0.001261] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 32#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 8#32)
  [Meta.isDefEq] [0.001247] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 32#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 8#32)
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:62:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:62:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:55:8: error: (kernel) declaration has metavariables 'select_icmp_ne_0_and_4096_or_4096_thm'
[bv] [0.052519] Normalizing goal
  [Meta.synthInstance] [0.002286] ✅️ Decidable
        ((match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32)) ⊑
          some (x✝¹ ||| x✝ &&& 4096#32 ^^^ 4096#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32)) ⊑
            some (x✝¹ ||| x✝ &&& 4096#32 ^^^ 4096#32)
      ⊢ False
  [Meta.isDefEq] [0.001157] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32)
  [Meta.isDefEq] [0.001262] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32)
  [Meta.isDefEq] [0.001265] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32)
  [Meta.isDefEq] [0.001150] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32)
  [Meta.isDefEq] [0.001279] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32)
  [Meta.isDefEq] [0.001216] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32)) ⊑
            some (x✝¹ ||| x✝ &&& 4096#32 ^^^ 4096#32)
      ⊢ False
  [Meta.isDefEq] [0.001165] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32)
  [Meta.isDefEq] [0.001253] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32)
  [Meta.isDefEq] [0.001259] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32)
  [Meta.isDefEq] [0.001148] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32)
  [Meta.isDefEq] [0.001263] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32)
  [Meta.isDefEq] [0.001263] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32)
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:73:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:73:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:66:8: error: (kernel) declaration has metavariables 'select_icmp_ne_0_and_4096_xor_4096_thm'
[bv] [0.029789] Normalizing goal
  [Meta.synthInstance] [0.001330] ✅️ Decidable
        ((match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32)) ⊑
          some (x✝ &&& 4096#32 ^^^ x✝¹ ^^^ 4096#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32)) ⊑
            some (x✝ &&& 4096#32 ^^^ x✝¹ ^^^ 4096#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32)) ⊑
            some (x✝ &&& 4096#32 ^^^ x✝¹ ^^^ 4096#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:85:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:85:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:77:8: error: (kernel) declaration has metavariables 'select_icmp_ne_0_and_4096_and_not_4096_thm'
[bv] [0.048720] Normalizing goal
  [Meta.synthInstance] [0.001698] ✅️ Decidable
        ((match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 4294963199#32)) ⊑
          match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 4294963199#32)
          | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 4294963199#32)) ⊑
            match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 4294963199#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 4294963199#32)) ⊑
            match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 4294963199#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
      ⊢ False
  [Meta.isDefEq] [0.002346] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 4294963199#32)
      | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
    [Meta.whnf] [0.001727] Non-easy whnf: (fun motive c? h_1 h_2 h_3 =>
            Option.casesOn c? (h_1 ()) fun val =>
              BitVec.casesOn val fun toFin =>
                Fin.casesOn toFin fun val isLt =>
                  Nat.casesOn (motive := fun x => (isLt : x < 2 ^ 1) → motive (some { toFin := ⟨x, isLt⟩ })) val
                    (fun isLt => h_3 ())
                    (fun n isLt =>
                      Nat.casesOn (motive := fun x =>
                        (isLt : x.succ < 2 ^ 1) → motive (some { toFin := ⟨x.succ, isLt⟩ })) n (fun isLt => h_2 ())
                        (fun n isLt => ⋯.elim) isLt)
                    isLt)
          ?motive (some { toFin := ⟨1, ⋯⟩ }) h_1 h_2 h_3
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:96:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:96:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:89:8: error: (kernel) declaration has metavariables 'select_icmp_eq_and_4096_0_or_4096_thm'
[bv] [0.028949] Normalizing goal
  [Meta.synthInstance] [0.001307] ✅️ Decidable
        ((match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32)) ⊑
          some (x✝¹ ||| x✝ &&& 4096#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32)) ⊑
            some (x✝¹ ||| x✝ &&& 4096#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32)) ⊑
            some (x✝¹ ||| x✝ &&& 4096#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:107:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:107:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:100:8: error: (kernel) declaration has metavariables 'select_icmp_eq_and_4096_0_xor_4096_thm'
[bv] [0.050020] Normalizing goal
  [Meta.synthInstance] [0.002160] ✅️ Decidable
        ((match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32)) ⊑
          some (x✝¹ ^^^ x✝ &&& 4096#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32)) ⊑
            some (x✝¹ ^^^ x✝ &&& 4096#32)
      ⊢ False
  [Meta.isDefEq] [0.001146] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32)
  [Meta.isDefEq] [0.001231] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32)
  [Meta.isDefEq] [0.001249] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32)
  [Meta.isDefEq] [0.001094] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32)
  [Meta.isDefEq] [0.001229] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32)
  [Meta.isDefEq] [0.001198] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32)) ⊑
            some (x✝¹ ^^^ x✝ &&& 4096#32)
      ⊢ False
  [Meta.isDefEq] [0.002098] ❌️ if ?c then ?a else ?a =?= if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1
    [Meta.isDefEq] [0.001833] ✅️ ?α =?= BitVec 1
      [Meta.isDefEq.assign] [0.001827] ✅️ ?α := BitVec 1
        [Meta.isDefEq.assign.checkTypes] [0.001816] ✅️ (?α : Sort ?u.94523) := (BitVec 1 : Type)
  [Meta.isDefEq] [0.001157] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32)
  [Meta.isDefEq] [0.001233] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32)
  [Meta.isDefEq] [0.001253] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32)
  [Meta.isDefEq] [0.001146] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32)
  [Meta.isDefEq] [0.001249] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32)
  [Meta.isDefEq] [0.001240] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32)
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:118:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:118:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:111:8: error: (kernel) declaration has metavariables 'select_icmp_eq_0_and_1_or_1_thm'
[bv] [0.031759] Normalizing goal
  [Meta.synthInstance] [0.001376] ✅️ Decidable
        ((match some (BitVec.ofBool (x✝ &&& 1#64 == 0#64)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 1#32)) ⊑
          some (x✝¹ ||| BitVec.truncate 32 x✝ &&& 1#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      e_1 : LLVM.IntW 64
      x✝¹ : BitVec 32
      x✝ : BitVec 64
      a✝ :
        ¬(match some (BitVec.ofBool (x✝ &&& 1#64 == 0#64)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 1#32)) ⊑
            some (x✝¹ ||| BitVec.truncate 32 x✝ &&& 1#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      e_1 : LLVM.IntW 64
      x✝¹ : BitVec 32
      x✝ : BitVec 64
      a✝ :
        ¬(match some (if (x✝ &&& 1#64 == 0#64) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 1#32)) ⊑
            some (x✝¹ ||| BitVec.zeroExtend 32 x✝ &&& 1#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:129:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:129:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:122:8: error: (kernel) declaration has metavariables 'select_icmp_eq_0_and_1_xor_1_thm'
[bv] [0.032197] Normalizing goal
  [Meta.synthInstance] [0.001411] ✅️ Decidable
        ((match some (BitVec.ofBool (x✝ &&& 1#64 == 0#64)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 1#32)) ⊑
          some (x✝¹ ^^^ BitVec.truncate 32 x✝ &&& 1#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      e_1 : LLVM.IntW 64
      x✝¹ : BitVec 32
      x✝ : BitVec 64
      a✝ :
        ¬(match some (BitVec.ofBool (x✝ &&& 1#64 == 0#64)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 1#32)) ⊑
            some (x✝¹ ^^^ BitVec.truncate 32 x✝ &&& 1#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      e_1 : LLVM.IntW 64
      x✝¹ : BitVec 32
      x✝ : BitVec 64
      a✝ :
        ¬(match some (if (x✝ &&& 1#64 == 0#64) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 1#32)) ⊑
            some (x✝¹ ^^^ BitVec.zeroExtend 32 x✝ &&& 1#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:140:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:140:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:133:8: error: (kernel) declaration has metavariables 'select_icmp_ne_0_and_4096_or_32_thm'
[bv] [0.060864] Normalizing goal
  [Meta.synthInstance] [0.002742] ✅️ Decidable
        ((match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 32#32)) ⊑
          if 7#32 ≥ ↑32 then none else some (x✝¹ ||| x✝ >>> 7#32 &&& 32#32 ^^^ 32#32))
    [Meta.check] [0.001358] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 32#32))
          (if 7#32 ≥ ↑32 then none else some (x✝¹ ||| x✝ >>> 7#32 &&& 32#32 ^^^ 32#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 32#32)) ⊑
            if 7#32 ≥ ↑32 then none else some (x✝¹ ||| x✝ >>> 7#32 &&& 32#32 ^^^ 32#32)
      ⊢ False
  [Meta.isDefEq] [0.001162] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 32#32)
  [Meta.isDefEq] [0.001279] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 32#32)
  [Meta.isDefEq] [0.001274] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 32#32)
  [Meta.isDefEq] [0.001155] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 32#32)
  [Meta.isDefEq] [0.001282] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 32#32)
  [Meta.isDefEq] [0.001255] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 32#32)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 32#32)) ⊑
            some (x✝¹ ||| x✝ >>> 7 &&& 32#32 ^^^ 32#32)
      ⊢ False
  [Meta.isDefEq] [0.001178] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 32#32)
  [Meta.isDefEq] [0.001273] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 32#32)
  [Meta.isDefEq] [0.001262] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 32#32)
  [Meta.isDefEq] [0.001151] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 32#32)
  [Meta.isDefEq] [0.001264] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 32#32)
  [Meta.isDefEq] [0.001249] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 32#32)
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:151:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:151:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:144:8: error: (kernel) declaration has metavariables 'select_icmp_ne_0_and_4096_xor_32_thm'
[bv] [0.035108] Normalizing goal
  [Meta.synthInstance] [0.001526] ✅️ Decidable
        ((match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 32#32)) ⊑
          if 7#32 ≥ ↑32 then none else some (x✝ >>> 7#32 &&& 32#32 ^^^ x✝¹ ^^^ 32#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 32#32)) ⊑
            if 7#32 ≥ ↑32 then none else some (x✝ >>> 7#32 &&& 32#32 ^^^ x✝¹ ^^^ 32#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 32#32)) ⊑
            some (x✝ >>> 7 &&& 32#32 ^^^ x✝¹ ^^^ 32#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:163:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:163:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:155:8: error: (kernel) declaration has metavariables 'select_icmp_ne_0_and_4096_and_not_32_thm'
[bv] [0.046964] Normalizing goal
  [Meta.synthInstance] [0.001589] ✅️ Decidable
        ((match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 4294967263#32)) ⊑
          match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 4294967263#32)
          | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 4294967263#32)) ⊑
            match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 4294967263#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 4294967263#32)) ⊑
            match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 4294967263#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:174:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:174:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:167:8: error: (kernel) declaration has metavariables 'select_icmp_ne_0_and_32_or_4096_thm'
[bv] [0.035741] Normalizing goal
  [Meta.synthInstance] [0.001627] ✅️ Decidable
        ((match some (BitVec.ofBool (0#32 != x✝ &&& 32#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32)) ⊑
          if 7#32 ≥ ↑32 then none else some (x✝¹ ||| x✝ <<< 7#32 &&& 4096#32 ^^^ 4096#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (BitVec.ofBool (0#32 != x✝ &&& 32#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32)) ⊑
            if 7#32 ≥ ↑32 then none else some (x✝¹ ||| x✝ <<< 7#32 &&& 4096#32 ^^^ 4096#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (if (!0#32 == x✝ &&& 32#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32)) ⊑
            some (x✝¹ ||| x✝ <<< 7 &&& 4096#32 ^^^ 4096#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:185:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:185:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:178:8: error: (kernel) declaration has metavariables 'select_icmp_ne_0_and_32_xor_4096_thm'
[bv] [0.035339] Normalizing goal
  [Meta.synthInstance] [0.001544] ✅️ Decidable
        ((match some (BitVec.ofBool (0#32 != x✝ &&& 32#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32)) ⊑
          if 7#32 ≥ ↑32 then none else some (x✝ <<< 7#32 &&& 4096#32 ^^^ x✝¹ ^^^ 4096#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (BitVec.ofBool (0#32 != x✝ &&& 32#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32)) ⊑
            if 7#32 ≥ ↑32 then none else some (x✝ <<< 7#32 &&& 4096#32 ^^^ x✝¹ ^^^ 4096#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (if (!0#32 == x✝ &&& 32#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32)) ⊑
            some (x✝ <<< 7 &&& 4096#32 ^^^ x✝¹ ^^^ 4096#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:197:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:197:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:189:8: error: (kernel) declaration has metavariables 'select_icmp_ne_0_and_32_and_not_4096_thm'
[bv] [0.050925] Normalizing goal
  [Meta.synthInstance] [0.001579] ✅️ Decidable
        ((match some (BitVec.ofBool (0#32 != x✝ &&& 32#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 4294963199#32)) ⊑
          match some (BitVec.ofBool (x✝ &&& 32#32 == 0#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 4294963199#32)
          | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (BitVec.ofBool (0#32 != x✝ &&& 32#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 4294963199#32)) ⊑
            match some (BitVec.ofBool (x✝ &&& 32#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 4294963199#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
      ⊢ False
  [Meta.isDefEq] [0.001803] ❌️ if ?c then ?a else ?a =?= if (!0#32 == x✝ &&& 32#32) = true then 1#1 else 0#1
    [Meta.isDefEq] [0.001619] ✅️ ?α =?= BitVec 1
      [Meta.isDefEq.assign] [0.001613] ✅️ ?α := BitVec 1
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (if (!0#32 == x✝ &&& 32#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 4294963199#32)) ⊑
            match some (if (x✝ &&& 32#32 == 0#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 4294963199#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:209:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:209:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:201:8: error: (kernel) declaration has metavariables 'select_icmp_ne_0_and_1073741824_or_8_thm'
[bv] [0.045789] Normalizing goal
  [Meta.synthInstance] [0.001609] ✅️ Decidable
        ((match some (BitVec.ofBool (0#32 != x✝ &&& 1073741824#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 8#8)) ⊑
          match some (BitVec.ofBool (x✝ &&& 1073741824#32 == 0#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ||| 8#8)
          | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 32
      x✝¹ : BitVec 8
      x✝ : BitVec 32
      a✝ :
        ¬(match some (BitVec.ofBool (0#32 != x✝ &&& 1073741824#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 8#8)) ⊑
            match some (BitVec.ofBool (x✝ &&& 1073741824#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ||| 8#8)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 32
      x✝¹ : BitVec 8
      x✝ : BitVec 32
      a✝ :
        ¬(match some (if (!0#32 == x✝ &&& 1073741824#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 8#8)) ⊑
            match some (if (x✝ &&& 1073741824#32 == 0#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ||| 8#8)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:221:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:221:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:213:8: error: (kernel) declaration has metavariables 'select_icmp_ne_0_and_1073741824_xor_8_thm'
[bv] [0.046238] Normalizing goal
  [Meta.synthInstance] [0.001688] ✅️ Decidable
        ((match some (BitVec.ofBool (0#32 != x✝ &&& 1073741824#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 8#8)) ⊑
          match some (BitVec.ofBool (x✝ &&& 1073741824#32 == 0#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ^^^ 8#8)
          | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 32
      x✝¹ : BitVec 8
      x✝ : BitVec 32
      a✝ :
        ¬(match some (BitVec.ofBool (0#32 != x✝ &&& 1073741824#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 8#8)) ⊑
            match some (BitVec.ofBool (x✝ &&& 1073741824#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ^^^ 8#8)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 32
      x✝¹ : BitVec 8
      x✝ : BitVec 32
      a✝ :
        ¬(match some (if (!0#32 == x✝ &&& 1073741824#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 8#8)) ⊑
            match some (if (x✝ &&& 1073741824#32 == 0#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ^^^ 8#8)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:233:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:233:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:225:8: error: (kernel) declaration has metavariables 'select_icmp_ne_0_and_1073741824_and_not_8_thm'
[bv] [0.047670] Normalizing goal
  [Meta.synthInstance] [0.001602] ✅️ Decidable
        ((match some (BitVec.ofBool (0#32 != x✝ &&& 1073741824#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 247#8)) ⊑
          match some (BitVec.ofBool (x✝ &&& 1073741824#32 == 0#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 247#8)
          | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 32
      x✝¹ : BitVec 8
      x✝ : BitVec 32
      a✝ :
        ¬(match some (BitVec.ofBool (0#32 != x✝ &&& 1073741824#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 247#8)) ⊑
            match some (BitVec.ofBool (x✝ &&& 1073741824#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 247#8)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
      ⊢ False
  [Meta.isDefEq] [0.001724] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } =>
        ?h_3 () =?= match some (if (!0#32 == x✝ &&& 1073741824#32) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 247#8)
    [Meta.isDefEq] [0.001255] ❌️ ?h_2
          () =?= match some (if (!0#32 == x✝ &&& 1073741824#32) = true then 1#1 else 0#1) with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
        | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 247#8)
      [Meta.isDefEq.assign] [0.001028] ❌️ ?h_2
            () := match some (if (!0#32 == x✝ &&& 1073741824#32) = true then 1#1 else 0#1) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 247#8)
        [Meta.isDefEq] [0.001020] ❌️ () =?= fun _ => some (x✝¹ &&& 247#8)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 32
      x✝¹ : BitVec 8
      x✝ : BitVec 32
      a✝ :
        ¬(match some (if (!0#32 == x✝ &&& 1073741824#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 247#8)) ⊑
            match some (if (x✝ &&& 1073741824#32 == 0#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 247#8)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
      ⊢ False
  [Meta.isDefEq] [0.001827] ❌️ ?a == ?a =?= 0#32 == x✝ &&& 1073741824#32
    [Meta.isDefEq.onFailure] [0.001596] ❌️ ?a == ?a =?= 0#32 == x✝ &&& 1073741824#32
      [Meta.synthInstance] [0.001577] 💥️ BEq ?α
        [Meta.synthInstance] [0.001507] new goal BEq ?α
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:244:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:244:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:237:8: error: (kernel) declaration has metavariables 'select_icmp_ne_0_and_8_or_1073741824_thm'
[bv] [0.047873] Normalizing goal
  [Meta.synthInstance] [0.001623] ✅️ Decidable
        ((match some (BitVec.ofBool (0#8 != x✝ &&& 8#8)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 1073741824#32)) ⊑
          match some (BitVec.ofBool (x✝ &&& 8#8 == 0#8)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ||| 1073741824#32)
          | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      e_1 : LLVM.IntW 8
      x✝¹ : BitVec 32
      x✝ : BitVec 8
      a✝ :
        ¬(match some (BitVec.ofBool (0#8 != x✝ &&& 8#8)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 1073741824#32)) ⊑
            match some (BitVec.ofBool (x✝ &&& 8#8 == 0#8)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ||| 1073741824#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      e_1 : LLVM.IntW 8
      x✝¹ : BitVec 32
      x✝ : BitVec 8
      a✝ :
        ¬(match some (if (!0#8 == x✝ &&& 8#8) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 1073741824#32)) ⊑
            match some (if (x✝ &&& 8#8 == 0#8) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ||| 1073741824#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:256:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:256:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:248:8: error: (kernel) declaration has metavariables 'select_icmp_ne_0_and_8_xor_1073741824_thm'
[bv] [0.046723] Normalizing goal
  [Meta.synthInstance] [0.001630] ✅️ Decidable
        ((match some (BitVec.ofBool (0#8 != x✝ &&& 8#8)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 1073741824#32)) ⊑
          match some (BitVec.ofBool (x✝ &&& 8#8 == 0#8)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ^^^ 1073741824#32)
          | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      e_1 : LLVM.IntW 8
      x✝¹ : BitVec 32
      x✝ : BitVec 8
      a✝ :
        ¬(match some (BitVec.ofBool (0#8 != x✝ &&& 8#8)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 1073741824#32)) ⊑
            match some (BitVec.ofBool (x✝ &&& 8#8 == 0#8)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ^^^ 1073741824#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      e_1 : LLVM.IntW 8
      x✝¹ : BitVec 32
      x✝ : BitVec 8
      a✝ :
        ¬(match some (if (!0#8 == x✝ &&& 8#8) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 1073741824#32)) ⊑
            match some (if (x✝ &&& 8#8 == 0#8) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ^^^ 1073741824#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:268:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:268:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:260:8: error: (kernel) declaration has metavariables 'select_icmp_ne_0_and_8_and_not_1073741824_thm'
[bv] [0.045218] Normalizing goal
  [Meta.synthInstance] [0.001599] ✅️ Decidable
        ((match some (BitVec.ofBool (0#8 != x✝ &&& 8#8)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 3221225471#32)) ⊑
          match some (BitVec.ofBool (x✝ &&& 8#8 == 0#8)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 3221225471#32)
          | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      e_1 : LLVM.IntW 8
      x✝¹ : BitVec 32
      x✝ : BitVec 8
      a✝ :
        ¬(match some (BitVec.ofBool (0#8 != x✝ &&& 8#8)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 3221225471#32)) ⊑
            match some (BitVec.ofBool (x✝ &&& 8#8 == 0#8)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 3221225471#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      e_1 : LLVM.IntW 8
      x✝¹ : BitVec 32
      x✝ : BitVec 8
      a✝ :
        ¬(match some (if (!0#8 == x✝ &&& 8#8) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 3221225471#32)) ⊑
            match some (if (x✝ &&& 8#8 == 0#8) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 3221225471#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:279:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:272:8: error: (kernel) declaration has metavariables 'select_icmp_and_8_ne_0_xor_8_thm'
[bv] [0.029854] Normalizing goal
  [Meta.synthInstance] [0.001857] ✅️ Decidable
        ((match some (BitVec.ofBool (x✝ &&& 8#32 == 0#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝ ^^^ 8#32)) ⊑
          some (x✝ &&& 4294967287#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(match some (BitVec.ofBool (x✝ &&& 8#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝ ^^^ 8#32)) ⊑
            some (x✝ &&& 4294967287#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(match some (if (x✝ &&& 8#32 == 0#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝ ^^^ 8#32)) ⊑
            some (x✝ &&& 4294967287#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:290:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:283:8: error: (kernel) declaration has metavariables 'select_icmp_and_8_eq_0_xor_8_thm'
[bv] [0.029836] Normalizing goal
  [Meta.synthInstance] [0.001485] ✅️ Decidable
        ((match some (BitVec.ofBool (x✝ &&& 8#32 == 0#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some (x✝ ^^^ 8#32)
          | some { toFin := ⟨0, ⋯⟩ } => some x✝) ⊑
          some (x✝ ||| 8#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(match some (BitVec.ofBool (x✝ &&& 8#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝ ^^^ 8#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝) ⊑
            some (x✝ ||| 8#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(match some (if (x✝ &&& 8#32 == 0#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝ ^^^ 8#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝) ⊑
            some (x✝ ||| 8#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:301:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:301:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:294:8: error: (kernel) declaration has metavariables 'select_icmp_x_and_8_eq_0_y_xor_8_thm'
[bv] [0.030004] Normalizing goal
  [Meta.synthInstance] [0.001327] ✅️ Decidable
        ((match some (BitVec.ofBool (x✝ &&& 8#32 == 0#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 8#64)) ⊑
          some (x✝¹ ^^^ BitVec.zeroExtend 64 (x✝ &&& 8#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      e_1 : LLVM.IntW 32
      x✝¹ : BitVec 64
      x✝ : BitVec 32
      a✝ :
        ¬(match some (BitVec.ofBool (x✝ &&& 8#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 8#64)) ⊑
            some (x✝¹ ^^^ BitVec.zeroExtend 64 (x✝ &&& 8#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      e_1 : LLVM.IntW 32
      x✝¹ : BitVec 64
      x✝ : BitVec 32
      a✝ :
        ¬(match some (if (x✝ &&& 8#32 == 0#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 8#64)) ⊑
            some (x✝¹ ^^^ BitVec.zeroExtend 64 (x✝ &&& 8#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:312:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:312:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:305:8: error: (kernel) declaration has metavariables 'select_icmp_x_and_8_ne_0_y_xor_8_thm'
[bv] [0.030456] Normalizing goal
  [Meta.synthInstance] [0.001371] ✅️ Decidable
        ((match some (BitVec.ofBool (x✝ &&& 8#32 == 0#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ^^^ 8#64)
          | some { toFin := ⟨0, ⋯⟩ } => some x✝¹) ⊑
          some (x✝¹ ^^^ BitVec.zeroExtend 64 (x✝ &&& 8#32 ^^^ 8#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      e_1 : LLVM.IntW 32
      x✝¹ : BitVec 64
      x✝ : BitVec 32
      a✝ :
        ¬(match some (BitVec.ofBool (x✝ &&& 8#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ^^^ 8#64)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹) ⊑
            some (x✝¹ ^^^ BitVec.zeroExtend 64 (x✝ &&& 8#32 ^^^ 8#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      e_1 : LLVM.IntW 32
      x✝¹ : BitVec 64
      x✝ : BitVec 32
      a✝ :
        ¬(match some (if (x✝ &&& 8#32 == 0#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ^^^ 8#64)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹) ⊑
            some (x✝¹ ^^^ BitVec.zeroExtend 64 (x✝ &&& 8#32 ^^^ 8#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:323:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:323:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:316:8: error: (kernel) declaration has metavariables 'select_icmp_x_and_8_ne_0_y_or_8_thm'
[bv] [0.030173] Normalizing goal
  [Meta.synthInstance] [0.001374] ✅️ Decidable
        ((match some (BitVec.ofBool (x✝ &&& 8#32 == 0#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ||| 8#64)
          | some { toFin := ⟨0, ⋯⟩ } => some x✝¹) ⊑
          some (x✝¹ ||| BitVec.zeroExtend 64 (x✝ &&& 8#32 ^^^ 8#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      e_1 : LLVM.IntW 32
      x✝¹ : BitVec 64
      x✝ : BitVec 32
      a✝ :
        ¬(match some (BitVec.ofBool (x✝ &&& 8#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ||| 8#64)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹) ⊑
            some (x✝¹ ||| BitVec.zeroExtend 64 (x✝ &&& 8#32 ^^^ 8#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      e_1 : LLVM.IntW 32
      x✝¹ : BitVec 64
      x✝ : BitVec 32
      a✝ :
        ¬(match some (if (x✝ &&& 8#32 == 0#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ||| 8#64)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹) ⊑
            some (x✝¹ ||| BitVec.zeroExtend 64 (x✝ &&& 8#32 ^^^ 8#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:335:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:327:8: error: (kernel) declaration has metavariables 'select_icmp_and_2147483648_ne_0_xor_2147483648_thm'
[bv] [0.030027] Normalizing goal
  [Meta.synthInstance] [0.001518] ✅️ Decidable
        ((match some (BitVec.ofBool (x✝ &&& 2147483648#32 == 0#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝ ^^^ 2147483648#32)) ⊑
          some (x✝ &&& 2147483647#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(match some (BitVec.ofBool (x✝ &&& 2147483648#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝ ^^^ 2147483648#32)) ⊑
            some (x✝ &&& 2147483647#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(match some (if (x✝ &&& 2147483648#32 == 0#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝ ^^^ 2147483648#32)) ⊑
            some (x✝ &&& 2147483647#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:347:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:339:8: error: (kernel) declaration has metavariables 'select_icmp_and_2147483648_eq_0_xor_2147483648_thm'
[bv] [0.030116] Normalizing goal
  [Meta.synthInstance] [0.001596] ✅️ Decidable
        ((match some (BitVec.ofBool (x✝ &&& 2147483648#32 == 0#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some (x✝ ^^^ 2147483648#32)
          | some { toFin := ⟨0, ⋯⟩ } => some x✝) ⊑
          some (x✝ ||| 2147483648#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(match some (BitVec.ofBool (x✝ &&& 2147483648#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝ ^^^ 2147483648#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝) ⊑
            some (x✝ ||| 2147483648#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(match some (if (x✝ &&& 2147483648#32 == 0#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝ ^^^ 2147483648#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝) ⊑
            some (x✝ ||| 2147483648#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:359:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:351:8: error: (kernel) declaration has metavariables 'select_icmp_x_and_2147483648_ne_0_or_2147483648_thm'
[bv] [0.028636] Normalizing goal
  [Meta.synthInstance] [0.001462] ✅️ Decidable
        ((match some (BitVec.ofBool (x✝ &&& 2147483648#32 == 0#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some (x✝ ||| 2147483648#32)
          | some { toFin := ⟨0, ⋯⟩ } => some x✝) ⊑
          some (x✝ ||| 2147483648#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(match some (BitVec.ofBool (x✝ &&& 2147483648#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝ ||| 2147483648#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝) ⊑
            some (x✝ ||| 2147483648#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(match some (if (x✝ &&& 2147483648#32 == 0#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝ ||| 2147483648#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝) ⊑
            some (x✝ ||| 2147483648#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:370:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:370:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:363:8: error: (kernel) declaration has metavariables 'test68_thm'
[bv] [0.033909] Normalizing goal
  [Meta.synthInstance] [0.001569] ✅️ Decidable
        ((match some (BitVec.ofBool (x✝ &&& 128#32 == 0#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2#32)) ⊑
          if 6#32 ≥ ↑32 then none else some (x✝¹ ||| x✝ >>> 6#32 &&& 2#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (BitVec.ofBool (x✝ &&& 128#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2#32)) ⊑
            if 6#32 ≥ ↑32 then none else some (x✝¹ ||| x✝ >>> 6#32 &&& 2#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (if (x✝ &&& 128#32 == 0#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2#32)) ⊑
            some (x✝¹ ||| x✝ >>> 6 &&& 2#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:381:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:381:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:374:8: error: (kernel) declaration has metavariables 'test68_xor_thm'
[bv] [0.033941] Normalizing goal
  [Meta.synthInstance] [0.001569] ✅️ Decidable
        ((match some (BitVec.ofBool (x✝ &&& 128#32 == 0#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 2#32)) ⊑
          if 6#32 ≥ ↑32 then none else some (x✝¹ ^^^ x✝ >>> 6#32 &&& 2#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (BitVec.ofBool (x✝ &&& 128#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 2#32)) ⊑
            if 6#32 ≥ ↑32 then none else some (x✝¹ ^^^ x✝ >>> 6#32 &&& 2#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (if (x✝ &&& 128#32 == 0#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 2#32)) ⊑
            some (x✝¹ ^^^ x✝ >>> 6 &&& 2#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:392:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:392:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:385:8: error: (kernel) declaration has metavariables 'test69_thm'
[bv] [0.035730] Normalizing goal
  [Meta.synthInstance] [0.001675] ✅️ Decidable
        ((match some (BitVec.ofBool (x✝ &&& 128#32 != 0#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2#32)) ⊑
          if 6#32 ≥ ↑32 then none else some (x✝¹ ||| x✝ >>> 6#32 &&& 2#32 ^^^ 2#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (BitVec.ofBool (x✝ &&& 128#32 != 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2#32)) ⊑
            if 6#32 ≥ ↑32 then none else some (x✝¹ ||| x✝ >>> 6#32 &&& 2#32 ^^^ 2#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (if (!x✝ &&& 128#32 == 0#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2#32)) ⊑
            some (x✝¹ ||| x✝ >>> 6 &&& 2#32 ^^^ 2#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:403:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:403:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:396:8: error: (kernel) declaration has metavariables 'test69_xor_thm'
[bv] [0.034599] Normalizing goal
  [Meta.synthInstance] [0.001505] ✅️ Decidable
        ((match some (BitVec.ofBool (x✝ &&& 128#32 != 0#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 2#32)) ⊑
          if 6#32 ≥ ↑32 then none else some (x✝ >>> 6#32 &&& 2#32 ^^^ x✝¹ ^^^ 2#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (BitVec.ofBool (x✝ &&& 128#32 != 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 2#32)) ⊑
            if 6#32 ≥ ↑32 then none else some (x✝ >>> 6#32 &&& 2#32 ^^^ x✝¹ ^^^ 2#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (if (!x✝ &&& 128#32 == 0#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 2#32)) ⊑
            some (x✝ >>> 6 &&& 2#32 ^^^ x✝¹ ^^^ 2#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:414:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:414:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:407:8: error: (kernel) declaration has metavariables 'test69_and_thm'
[bv] [0.043559] Normalizing goal
  [Meta.synthInstance] [0.001564] ✅️ Decidable
        ((match some (BitVec.ofBool (x✝ &&& 128#32 != 0#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 2#32)) ⊑
          match some (BitVec.ofBool (x✝ &&& 128#32 == 0#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 2#32)
          | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (BitVec.ofBool (x✝ &&& 128#32 != 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 2#32)) ⊑
            match some (BitVec.ofBool (x✝ &&& 128#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 2#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(match some (if (!x✝ &&& 128#32 == 0#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 2#32)) ⊑
            match some (if (x✝ &&& 128#32 == 0#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 2#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:425:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:425:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:418:8: error: (kernel) declaration has metavariables 'test70_thm'
[bv] [0.035695] Normalizing goal
  [Meta.synthInstance] [0.001529] ✅️ Decidable
        ((match some (BitVec.ofBool (0#8 >ₛ x✝)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ||| 2#8)
          | some { toFin := ⟨0, ⋯⟩ } => some x✝¹) ⊑
          if 6#8 ≥ ↑8 then none else some (x✝¹ ||| x✝ >>> 6#8 &&& 2#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(match some (BitVec.ofBool (0#8 >ₛ x✝)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ||| 2#8)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹) ⊑
            if 6#8 ≥ ↑8 then none else some (x✝¹ ||| x✝ >>> 6#8 &&& 2#8)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(match some (if (!x✝.getLsbD 7 == (0#8 >ᵤ x✝)) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ||| 2#8)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹) ⊑
            some (x✝¹ ||| x✝ >>> 6 &&& 2#8)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:437:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:429:8: error: (kernel) declaration has metavariables 'shift_no_xor_multiuse_or_thm'
[bv] [0.039717] Normalizing goal
  [Meta.synthInstance] [0.001490] ✅️ Decidable
        ((Option.bind
            (match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2#32))
            fun x' => some (x' * (x✝¹ ||| 2#32))) ⊑
          if 1#32 ≥ ↑32 then none else some ((x✝¹ ||| x✝ <<< 1#32 &&& 2#32) * (x✝¹ ||| 2#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2#32))
              fun x' => some (x' * (x✝¹ ||| 2#32))) ⊑
            if 1#32 ≥ ↑32 then none else some ((x✝¹ ||| x✝ <<< 1#32 &&& 2#32) * (x✝¹ ||| 2#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (if (x✝ &&& 1#32 == 0#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2#32))
              fun a => some (a * (x✝¹ ||| 2#32))) ⊑
            some ((x✝¹ ||| x✝ <<< 1 &&& 2#32) * (x✝¹ ||| 2#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:449:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:441:8: error: (kernel) declaration has metavariables 'shift_no_xor_multiuse_xor_thm'
[bv] [0.039446] Normalizing goal
  [Meta.synthInstance] [0.001443] ✅️ Decidable
        ((Option.bind
            (match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 2#32))
            fun x' => some (x' * (x✝¹ ^^^ 2#32))) ⊑
          if 1#32 ≥ ↑32 then none else some ((x✝¹ ^^^ x✝ <<< 1#32 &&& 2#32) * (x✝¹ ^^^ 2#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 2#32))
              fun x' => some (x' * (x✝¹ ^^^ 2#32))) ⊑
            if 1#32 ≥ ↑32 then none else some ((x✝¹ ^^^ x✝ <<< 1#32 &&& 2#32) * (x✝¹ ^^^ 2#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (if (x✝ &&& 1#32 == 0#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 2#32))
              fun a => some (a * (x✝¹ ^^^ 2#32))) ⊑
            some ((x✝¹ ^^^ x✝ <<< 1 &&& 2#32) * (x✝¹ ^^^ 2#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:461:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:453:8: error: (kernel) declaration has metavariables 'no_shift_no_xor_multiuse_or_thm'
[bv] [0.034261] Normalizing goal
  [Meta.synthInstance] [0.001282] ✅️ Decidable
        ((Option.bind
            (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32))
            fun x' => some (x' * (x✝¹ ||| 4096#32))) ⊑
          some ((x✝¹ ||| x✝ &&& 4096#32) * (x✝¹ ||| 4096#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32))
              fun x' => some (x' * (x✝¹ ||| 4096#32))) ⊑
            some ((x✝¹ ||| x✝ &&& 4096#32) * (x✝¹ ||| 4096#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32))
              fun a => some (a * (x✝¹ ||| 4096#32))) ⊑
            some ((x✝¹ ||| x✝ &&& 4096#32) * (x✝¹ ||| 4096#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:473:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:465:8: error: (kernel) declaration has metavariables 'no_shift_no_xor_multiuse_xor_thm'
[bv] [0.034297] Normalizing goal
  [Meta.synthInstance] [0.001263] ✅️ Decidable
        ((Option.bind
            (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32))
            fun x' => some (x' * (x✝¹ ^^^ 4096#32))) ⊑
          some ((x✝¹ ^^^ x✝ &&& 4096#32) * (x✝¹ ^^^ 4096#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32))
              fun x' => some (x' * (x✝¹ ^^^ 4096#32))) ⊑
            some ((x✝¹ ^^^ x✝ &&& 4096#32) * (x✝¹ ^^^ 4096#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32))
              fun a => some (a * (x✝¹ ^^^ 4096#32))) ⊑
            some ((x✝¹ ^^^ x✝ &&& 4096#32) * (x✝¹ ^^^ 4096#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:485:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:477:8: error: (kernel) declaration has metavariables 'no_shift_xor_multiuse_or_thm'
[bv] [0.035639] Normalizing goal
  [Meta.synthInstance] [0.001313] ✅️ Decidable
        ((Option.bind
            (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32))
            fun x' => some (x' * (x✝¹ ||| 4096#32))) ⊑
          some ((x✝¹ ||| x✝ &&& 4096#32 ^^^ 4096#32) * (x✝¹ ||| 4096#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32))
              fun x' => some (x' * (x✝¹ ||| 4096#32))) ⊑
            some ((x✝¹ ||| x✝ &&& 4096#32 ^^^ 4096#32) * (x✝¹ ||| 4096#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32))
              fun a => some (a * (x✝¹ ||| 4096#32))) ⊑
            some ((x✝¹ ||| x✝ &&& 4096#32 ^^^ 4096#32) * (x✝¹ ||| 4096#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:497:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:489:8: error: (kernel) declaration has metavariables 'no_shift_xor_multiuse_xor_thm'
[bv] [0.035211] Normalizing goal
  [Meta.synthInstance] [0.001271] ✅️ Decidable
        ((Option.bind
            (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32))
            fun x' => some (x' * (x✝¹ ^^^ 4096#32))) ⊑
          some ((x✝ &&& 4096#32 ^^^ x✝¹ ^^^ 4096#32) * (x✝¹ ^^^ 4096#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32))
              fun x' => some (x' * (x✝¹ ^^^ 4096#32))) ⊑
            some ((x✝ &&& 4096#32 ^^^ x✝¹ ^^^ 4096#32) * (x✝¹ ^^^ 4096#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32))
              fun a => some (a * (x✝¹ ^^^ 4096#32))) ⊑
            some ((x✝ &&& 4096#32 ^^^ x✝¹ ^^^ 4096#32) * (x✝¹ ^^^ 4096#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:510:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:501:8: error: (kernel) declaration has metavariables 'no_shift_xor_multiuse_and_thm'
[bv] [0.054049] Normalizing goal
  [Meta.synthInstance] [0.001336] ✅️ Decidable
        ((Option.bind
            (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 4294963199#32))
            fun x' => some (x' * (x✝¹ &&& 4294963199#32))) ⊑
          Option.bind
            (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 4294963199#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
            fun x' => some (x' * (x✝¹ &&& 4294963199#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 4294963199#32))
              fun x' => some (x' * (x✝¹ &&& 4294963199#32))) ⊑
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 4294963199#32)
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun x' => some (x' * (x✝¹ &&& 4294963199#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 4294963199#32))
              fun a => some (a * (x✝¹ &&& 4294963199#32))) ⊑
            Option.bind
              (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 4294963199#32)
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun a => some (a * (x✝¹ &&& 4294963199#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:523:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:514:8: error: (kernel) declaration has metavariables 'shift_xor_multiuse_or_thm'
[bv] [0.054336] Normalizing goal
  [Meta.synthInstance] [0.001414] ✅️ Decidable
        ((Option.bind
            (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2048#32))
            fun x' => some (x' * (x✝¹ ||| 2048#32))) ⊑
          Option.bind
            (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ||| 2048#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
            fun x' => some (x' * (x✝¹ ||| 2048#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2048#32))
              fun x' => some (x' * (x✝¹ ||| 2048#32))) ⊑
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ||| 2048#32)
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun x' => some (x' * (x✝¹ ||| 2048#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2048#32))
              fun a => some (a * (x✝¹ ||| 2048#32))) ⊑
            Option.bind
              (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ||| 2048#32)
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun a => some (a * (x✝¹ ||| 2048#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:536:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:527:8: error: (kernel) declaration has metavariables 'shift_xor_multiuse_xor_thm'
[bv] [0.053973] Normalizing goal
  [Meta.synthInstance] [0.001392] ✅️ Decidable
        ((Option.bind
            (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 2048#32))
            fun x' => some (x' * (x✝¹ ^^^ 2048#32))) ⊑
          Option.bind
            (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ^^^ 2048#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
            fun x' => some (x' * (x✝¹ ^^^ 2048#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 2048#32))
              fun x' => some (x' * (x✝¹ ^^^ 2048#32))) ⊑
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ^^^ 2048#32)
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun x' => some (x' * (x✝¹ ^^^ 2048#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 2048#32))
              fun a => some (a * (x✝¹ ^^^ 2048#32))) ⊑
            Option.bind
              (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ^^^ 2048#32)
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun a => some (a * (x✝¹ ^^^ 2048#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:549:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:540:8: error: (kernel) declaration has metavariables 'shift_xor_multiuse_and_thm'
[bv] [0.053559] Normalizing goal
  [Meta.synthInstance] [0.001297] ✅️ Decidable
        ((Option.bind
            (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 4294965247#32))
            fun x' => some (x' * (x✝¹ &&& 4294965247#32))) ⊑
          Option.bind
            (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 4294965247#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
            fun x' => some (x' * (x✝¹ &&& 4294965247#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 4294965247#32))
              fun x' => some (x' * (x✝¹ &&& 4294965247#32))) ⊑
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 4294965247#32)
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun x' => some (x' * (x✝¹ &&& 4294965247#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 4294965247#32))
              fun a => some (a * (x✝¹ &&& 4294965247#32))) ⊑
            Option.bind
              (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 4294965247#32)
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun a => some (a * (x✝¹ &&& 4294965247#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:562:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:562:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:562:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:562:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:562:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:562:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:562:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:562:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:553:8: error: (kernel) declaration has metavariables 'shift_no_xor_multiuse_cmp_thm'
[bv] [0.077205] Normalizing goal
  [Meta.synthInstance] [0.001617] ✅️ Decidable
        ((Option.bind
            (match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2#32))
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
              fun y' => some (a * y')) ⊑
          if True ∧ ((x✝ &&& 1#32) <<< 1#32).sshiftRight (1#32).toNat = x✝ &&& 1#32 then none
          else
            if True ∧ (x✝ &&& 1#32) <<< 1#32 >>> 1#32 = x✝ &&& 1#32 then none
            else
              if 1#32 ≥ ↑32 then none
              else
                Option.bind
                  (match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
                  | none => none
                  | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                  | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                  fun y' => some ((x✝¹ ||| (x✝ &&& 1#32) <<< 1#32) * y'))
    [Meta.check] [0.001049] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (Option.bind
            (match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2#32))
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
              fun y' => some (a * y'))
          (if True ∧ ((x✝ &&& 1#32) <<< 1#32).sshiftRight (1#32).toNat = x✝ &&& 1#32 then none
          else
            if True ∧ (x✝ &&& 1#32) <<< 1#32 >>> 1#32 = x✝ &&& 1#32 then none
            else
              if 1#32 ≥ ↑32 then none
              else
                Option.bind
                  (match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
                  | none => none
                  | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                  | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                  fun y' => some ((x✝¹ ||| (x✝ &&& 1#32) <<< 1#32) * y'))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2#32))
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun y' => some (a * y')) ⊑
            if True ∧ ((x✝ &&& 1#32) <<< 1#32).sshiftRight (1#32).toNat = x✝ &&& 1#32 then none
            else
              if True ∧ (x✝ &&& 1#32) <<< 1#32 >>> 1#32 = x✝ &&& 1#32 then none
              else
                if 1#32 ≥ ↑32 then none
                else
                  Option.bind
                    (match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
                    | none => none
                    | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                    | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                    fun y' => some ((x✝¹ ||| (x✝ &&& 1#32) <<< 1#32) * y')
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (if (x✝ &&& 1#32 == 0#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2#32))
              fun a =>
              Option.bind
                (match some (if (x✝ &&& 1#32 == 0#32) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun a_1 => some (a * a_1)) ⊑
            if (((x✝ &&& 1#32) <<< 1).sshiftRight 1 == x✝ &&& 1#32) = true then none
            else
              if ((x✝ &&& 1#32) <<< 1 >>> 1 == x✝ &&& 1#32) = true then none
              else
                Option.bind
                  (match some (if (x✝ &&& 1#32 == 0#32) = true then 1#1 else 0#1) with
                  | none => none
                  | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                  | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                  fun a => some ((x✝¹ ||| (x✝ &&& 1#32) <<< 1) * a)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:575:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:575:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:575:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:575:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:575:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:575:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:575:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:575:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:566:8: error: (kernel) declaration has metavariables 'shift_no_xor_multiuse_cmp_with_xor_thm'
[bv] [0.078744] Normalizing goal
  [Meta.synthInstance] [0.001661] ✅️ Decidable
        ((Option.bind
            (match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 2#32))
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
              fun y' => some (a * y')) ⊑
          if True ∧ ((x✝ &&& 1#32) <<< 1#32).sshiftRight (1#32).toNat = x✝ &&& 1#32 then none
          else
            if True ∧ (x✝ &&& 1#32) <<< 1#32 >>> 1#32 = x✝ &&& 1#32 then none
            else
              if 1#32 ≥ ↑32 then none
              else
                Option.bind
                  (match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
                  | none => none
                  | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                  | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                  fun y' => some ((x✝¹ ^^^ (x✝ &&& 1#32) <<< 1#32) * y'))
    [Meta.check] [0.001075] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (Option.bind
            (match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 2#32))
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
              fun y' => some (a * y'))
          (if True ∧ ((x✝ &&& 1#32) <<< 1#32).sshiftRight (1#32).toNat = x✝ &&& 1#32 then none
          else
            if True ∧ (x✝ &&& 1#32) <<< 1#32 >>> 1#32 = x✝ &&& 1#32 then none
            else
              if 1#32 ≥ ↑32 then none
              else
                Option.bind
                  (match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
                  | none => none
                  | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                  | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                  fun y' => some ((x✝¹ ^^^ (x✝ &&& 1#32) <<< 1#32) * y'))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 2#32))
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun y' => some (a * y')) ⊑
            if True ∧ ((x✝ &&& 1#32) <<< 1#32).sshiftRight (1#32).toNat = x✝ &&& 1#32 then none
            else
              if True ∧ (x✝ &&& 1#32) <<< 1#32 >>> 1#32 = x✝ &&& 1#32 then none
              else
                if 1#32 ≥ ↑32 then none
                else
                  Option.bind
                    (match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
                    | none => none
                    | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                    | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                    fun y' => some ((x✝¹ ^^^ (x✝ &&& 1#32) <<< 1#32) * y')
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (if (x✝ &&& 1#32 == 0#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 2#32))
              fun a =>
              Option.bind
                (match some (if (x✝ &&& 1#32 == 0#32) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun a_1 => some (a * a_1)) ⊑
            if (((x✝ &&& 1#32) <<< 1).sshiftRight 1 == x✝ &&& 1#32) = true then none
            else
              if ((x✝ &&& 1#32) <<< 1 >>> 1 == x✝ &&& 1#32) = true then none
              else
                Option.bind
                  (match some (if (x✝ &&& 1#32 == 0#32) = true then 1#1 else 0#1) with
                  | none => none
                  | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                  | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                  fun a => some ((x✝¹ ^^^ (x✝ &&& 1#32) <<< 1) * a)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:588:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:588:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:588:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:588:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:588:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:588:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:588:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:588:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:579:8: error: (kernel) declaration has metavariables 'no_shift_no_xor_multiuse_cmp_thm'
[bv] [0.058015] Normalizing goal
  [Meta.synthInstance] [0.001231] ✅️ Decidable
        ((Option.bind
            (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32))
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
              fun y' => some (a * y')) ⊑
          Option.bind
            (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
            fun y' => some ((x✝¹ ||| x✝ &&& 4096#32) * y'))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32))
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun y' => some (a * y')) ⊑
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
              fun y' => some ((x✝¹ ||| x✝ &&& 4096#32) * y')
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32))
              fun a =>
              Option.bind
                (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun a_1 => some (a * a_1)) ⊑
            Option.bind
              (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
              fun a => some ((x✝¹ ||| x✝ &&& 4096#32) * a)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:601:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:601:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:601:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:601:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:601:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:601:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:601:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:601:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:592:8: error: (kernel) declaration has metavariables 'no_shift_no_xor_multiuse_cmp_with_xor_thm'
[bv] [0.058697] Normalizing goal
  [Meta.synthInstance] [0.001243] ✅️ Decidable
        ((Option.bind
            (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32))
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
              fun y' => some (a * y')) ⊑
          Option.bind
            (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
            fun y' => some ((x✝¹ ^^^ x✝ &&& 4096#32) * y'))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32))
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun y' => some (a * y')) ⊑
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
              fun y' => some ((x✝¹ ^^^ x✝ &&& 4096#32) * y')
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32))
              fun a =>
              Option.bind
                (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun a_1 => some (a * a_1)) ⊑
            Option.bind
              (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
              fun a => some ((x✝¹ ^^^ x✝ &&& 4096#32) * a)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:614:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:614:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:614:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:614:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:614:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:614:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:614:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:614:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:605:8: error: (kernel) declaration has metavariables 'no_shift_xor_multiuse_cmp_thm'
[bv] [0.076069] Normalizing goal
  [Meta.synthInstance] [0.001417] ✅️ Decidable
        ((Option.bind
            (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32))
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
              fun y' => some (a * y')) ⊑
          Option.bind
            (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝³
            | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
            fun y' => some ((x✝¹ ||| x✝ &&& 4096#32 ^^^ 4096#32) * y'))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32))
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun y' => some (a * y')) ⊑
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝³
              | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
              fun y' => some ((x✝¹ ||| x✝ &&& 4096#32 ^^^ 4096#32) * y')
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32))
              fun a =>
              Option.bind
                (match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun a_1 => some (a * a_1)) ⊑
            Option.bind
              (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝³
              | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
              fun a => some ((x✝¹ ||| x✝ &&& 4096#32 ^^^ 4096#32) * a)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:627:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:627:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:627:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:627:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:627:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:627:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:627:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:627:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:618:8: error: (kernel) declaration has metavariables 'no_shift_xor_multiuse_cmp_with_xor_thm'
[bv] [0.075721] Normalizing goal
  [Meta.synthInstance] [0.001370] ✅️ Decidable
        ((Option.bind
            (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32))
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
              fun y' => some (a * y')) ⊑
          Option.bind
            (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝³
            | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
            fun y' => some ((x✝ &&& 4096#32 ^^^ x✝¹ ^^^ 4096#32) * y'))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32))
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun y' => some (a * y')) ⊑
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝³
              | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
              fun y' => some ((x✝ &&& 4096#32 ^^^ x✝¹ ^^^ 4096#32) * y')
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32))
              fun a =>
              Option.bind
                (match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun a_1 => some (a * a_1)) ⊑
            Option.bind
              (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝³
              | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
              fun a => some ((x✝ &&& 4096#32 ^^^ x✝¹ ^^^ 4096#32) * a)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:644:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:644:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:644:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:644:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:644:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:644:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:644:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:644:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:631:8: error: (kernel) declaration has metavariables 'no_shift_xor_multiuse_cmp_with_and_thm'
[bv] [0.094125] Normalizing goal
  [Meta.synthInstance] [0.001448] ✅️ Decidable
        ((Option.bind
            (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 4294963199#32))
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
              fun y' => some (a * y')) ⊑
          Option.bind
            (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 4294963199#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝³
              | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
              fun y' => some (a * y'))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 4294963199#32))
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun y' => some (a * y')) ⊑
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 4294963199#32)
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝³
                | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
                fun y' => some (a * y')
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 4294963199#32))
              fun a =>
              Option.bind
                (match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun a_1 => some (a * a_1)) ⊑
            Option.bind
              (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 4294963199#32)
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun a =>
              Option.bind
                (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝³
                | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
                fun a_1 => some (a * a_1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:657:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:657:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:657:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:657:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:657:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:657:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:657:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:657:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:648:8: error: (kernel) declaration has metavariables 'shift_xor_multiuse_cmp_thm'
[bv] [0.094658] Normalizing goal
  [Meta.synthInstance] [0.001461] ✅️ Decidable
        ((Option.bind
            (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2048#32))
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
              fun y' => some (a * y')) ⊑
          Option.bind
            (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ||| 2048#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝³
              | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
              fun y' => some (a * y'))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2048#32))
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun y' => some (a * y')) ⊑
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ||| 2048#32)
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝³
                | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
                fun y' => some (a * y')
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2048#32))
              fun a =>
              Option.bind
                (match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun a_1 => some (a * a_1)) ⊑
            Option.bind
              (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ||| 2048#32)
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun a =>
              Option.bind
                (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝³
                | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
                fun a_1 => some (a * a_1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:671:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:671:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:671:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:671:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:671:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:671:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:671:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:671:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:661:8: error: (kernel) declaration has metavariables 'shift_xor_multiuse_cmp_with_xor_thm'
[bv] [0.093984] Normalizing goal
  [Meta.synthInstance] [0.001466] ✅️ Decidable
        ((Option.bind
            (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 2048#32))
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
              fun y' => some (a * y')) ⊑
          Option.bind
            (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ^^^ 2048#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝³
              | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
              fun y' => some (a * y'))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 2048#32))
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun y' => some (a * y')) ⊑
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ^^^ 2048#32)
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝³
                | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
                fun y' => some (a * y')
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 2048#32))
              fun a =>
              Option.bind
                (match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun a_1 => some (a * a_1)) ⊑
            Option.bind
              (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ^^^ 2048#32)
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun a =>
              Option.bind
                (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝³
                | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
                fun a_1 => some (a * a_1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:688:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:688:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:688:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:688:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:688:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:688:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:688:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:688:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:675:8: error: (kernel) declaration has metavariables 'shift_xor_multiuse_cmp_with_and_thm'
[bv] [0.093985] Normalizing goal
  [Meta.synthInstance] [0.001431] ✅️ Decidable
        ((Option.bind
            (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 4294965247#32))
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
              fun y' => some (a * y')) ⊑
          Option.bind
            (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 4294965247#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝³
              | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
              fun y' => some (a * y'))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 4294965247#32))
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun y' => some (a * y')) ⊑
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 4294965247#32)
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝³
                | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
                fun y' => some (a * y')
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 4294965247#32))
              fun a =>
              Option.bind
                (match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun a_1 => some (a * a_1)) ⊑
            Option.bind
              (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 4294965247#32)
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun a =>
              Option.bind
                (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝³
                | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
                fun a_1 => some (a * a_1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:706:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:706:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:706:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:706:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:692:8: error: (kernel) declaration has metavariables 'no_shift_no_xor_multiuse_cmp_or_thm'
[bv] [0.061065] Normalizing goal
  [Meta.synthInstance] [0.001225] ✅️ Decidable
        ((Option.bind
            (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32))
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
              fun a_1 => some (a * a_1 * (x✝¹ ||| 4096#32))) ⊑
          Option.bind
            (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
            fun a => some ((x✝¹ ||| x✝ &&& 4096#32) * a * (x✝¹ ||| 4096#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32))
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun a_1 => some (a * a_1 * (x✝¹ ||| 4096#32))) ⊑
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
              fun a => some ((x✝¹ ||| x✝ &&& 4096#32) * a * (x✝¹ ||| 4096#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32))
              fun a =>
              Option.bind
                (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun a_1 => some (a * a_1 * (x✝¹ ||| 4096#32))) ⊑
            Option.bind
              (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
              fun a => some ((x✝¹ ||| x✝ &&& 4096#32) * a * (x✝¹ ||| 4096#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:725:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:725:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:725:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:725:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:710:8: error: (kernel) declaration has metavariables 'no_shift_no_xor_multiuse_cmp_xor_thm'
[bv] [0.061143] Normalizing goal
  [Meta.synthInstance] [0.001240] ✅️ Decidable
        ((Option.bind
            (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32))
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
              fun a_1 => some (a * a_1 * (x✝¹ ^^^ 4096#32))) ⊑
          Option.bind
            (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
            fun a => some ((x✝¹ ^^^ x✝ &&& 4096#32) * a * (x✝¹ ^^^ 4096#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32))
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun a_1 => some (a * a_1 * (x✝¹ ^^^ 4096#32))) ⊑
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
              fun a => some ((x✝¹ ^^^ x✝ &&& 4096#32) * a * (x✝¹ ^^^ 4096#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32))
              fun a =>
              Option.bind
                (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun a_1 => some (a * a_1 * (x✝¹ ^^^ 4096#32))) ⊑
            Option.bind
              (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
              fun a => some ((x✝¹ ^^^ x✝ &&& 4096#32) * a * (x✝¹ ^^^ 4096#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:744:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:744:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:744:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:744:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:729:8: error: (kernel) declaration has metavariables 'no_shift_xor_multiuse_cmp_or_thm'
[bv] [0.097949] Normalizing goal
  [Meta.synthInstance] [0.001464] ✅️ Decidable
        ((Option.bind
            (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32))
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
              fun a_1 => some (a * a_1 * (x✝¹ ||| 4096#32))) ⊑
          Option.bind
            (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ||| 4096#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝³
              | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
              fun a_1 => some (a * a_1 * (x✝¹ ||| 4096#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32))
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun a_1 => some (a * a_1 * (x✝¹ ||| 4096#32))) ⊑
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ||| 4096#32)
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝³
                | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
                fun a_1 => some (a * a_1 * (x✝¹ ||| 4096#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 4096#32))
              fun a =>
              Option.bind
                (match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun a_1 => some (a * a_1 * (x✝¹ ||| 4096#32))) ⊑
            Option.bind
              (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ||| 4096#32)
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun a =>
              Option.bind
                (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝³
                | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
                fun a_1 => some (a * a_1 * (x✝¹ ||| 4096#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:765:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:765:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:765:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:765:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:748:8: error: (kernel) declaration has metavariables 'no_shift_xor_multiuse_cmp_xor_thm'
[bv] [0.098073] Normalizing goal
  [Meta.synthInstance] [0.001465] ✅️ Decidable
        ((Option.bind
            (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32))
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
              fun a_1 => some (a * a_1 * (x✝¹ ^^^ 4096#32))) ⊑
          Option.bind
            (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ^^^ 4096#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝³
              | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
              fun a_1 => some (a * a_1 * (x✝¹ ^^^ 4096#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32))
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun a_1 => some (a * a_1 * (x✝¹ ^^^ 4096#32))) ⊑
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ^^^ 4096#32)
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝³
                | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
                fun a_1 => some (a * a_1 * (x✝¹ ^^^ 4096#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 4096#32))
              fun a =>
              Option.bind
                (match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun a_1 => some (a * a_1 * (x✝¹ ^^^ 4096#32))) ⊑
            Option.bind
              (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ^^^ 4096#32)
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun a =>
              Option.bind
                (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝³
                | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
                fun a_1 => some (a * a_1 * (x✝¹ ^^^ 4096#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:786:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:786:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:786:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:786:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:769:8: error: (kernel) declaration has metavariables 'no_shift_xor_multiuse_cmp_and_thm'
[bv] [0.098724] Normalizing goal
  [Meta.synthInstance] [0.001438] ✅️ Decidable
        ((Option.bind
            (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 4294963199#32))
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
              fun a_1 => some (a * a_1 * (x✝¹ &&& 4294963199#32))) ⊑
          Option.bind
            (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 4294963199#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝³
              | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
              fun a_1 => some (a * a_1 * (x✝¹ &&& 4294963199#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 4294963199#32))
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun a_1 => some (a * a_1 * (x✝¹ &&& 4294963199#32))) ⊑
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 4294963199#32)
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝³
                | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
                fun a_1 => some (a * a_1 * (x✝¹ &&& 4294963199#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 4294963199#32))
              fun a =>
              Option.bind
                (match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun a_1 => some (a * a_1 * (x✝¹ &&& 4294963199#32))) ⊑
            Option.bind
              (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 4294963199#32)
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun a =>
              Option.bind
                (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝³
                | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
                fun a_1 => some (a * a_1 * (x✝¹ &&& 4294963199#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:805:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:805:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:805:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:805:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:790:8: error: (kernel) declaration has metavariables 'shift_xor_multiuse_cmp_or_thm'
[bv] [0.098209] Normalizing goal
  [Meta.synthInstance] [0.001490] ✅️ Decidable
        ((Option.bind
            (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2048#32))
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
              fun a_1 => some (a * a_1 * (x✝¹ ||| 2048#32))) ⊑
          Option.bind
            (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ||| 2048#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝³
              | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
              fun a_1 => some (a * a_1 * (x✝¹ ||| 2048#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2048#32))
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun a_1 => some (a * a_1 * (x✝¹ ||| 2048#32))) ⊑
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ||| 2048#32)
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝³
                | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
                fun a_1 => some (a * a_1 * (x✝¹ ||| 2048#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ||| 2048#32))
              fun a =>
              Option.bind
                (match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun a_1 => some (a * a_1 * (x✝¹ ||| 2048#32))) ⊑
            Option.bind
              (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ||| 2048#32)
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun a =>
              Option.bind
                (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝³
                | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
                fun a_1 => some (a * a_1 * (x✝¹ ||| 2048#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:826:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:826:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:826:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:826:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:809:8: error: (kernel) declaration has metavariables 'shift_xor_multiuse_cmp_xor_thm'
[bv] [0.098092] Normalizing goal
  [Meta.synthInstance] [0.001469] ✅️ Decidable
        ((Option.bind
            (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 2048#32))
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
              fun a_1 => some (a * a_1 * (x✝¹ ^^^ 2048#32))) ⊑
          Option.bind
            (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ^^^ 2048#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝³
              | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
              fun a_1 => some (a * a_1 * (x✝¹ ^^^ 2048#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 2048#32))
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun a_1 => some (a * a_1 * (x✝¹ ^^^ 2048#32))) ⊑
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ^^^ 2048#32)
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝³
                | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
                fun a_1 => some (a * a_1 * (x✝¹ ^^^ 2048#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ ^^^ 2048#32))
              fun a =>
              Option.bind
                (match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun a_1 => some (a * a_1 * (x✝¹ ^^^ 2048#32))) ⊑
            Option.bind
              (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ^^^ 2048#32)
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun a =>
              Option.bind
                (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝³
                | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
                fun a_1 => some (a * a_1 * (x✝¹ ^^^ 2048#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:847:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:847:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:847:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:847:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:830:8: error: (kernel) declaration has metavariables 'shift_xor_multiuse_cmp_and_thm'
[bv] [0.098428] Normalizing goal
  [Meta.synthInstance] [0.001423] ✅️ Decidable
        ((Option.bind
            (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 2048#32))
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
              fun a_1 => some (a * a_1 * (x✝¹ &&& 2048#32))) ⊑
          Option.bind
            (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 2048#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝³
              | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
              fun a_1 => some (a * a_1 * (x✝¹ &&& 2048#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 2048#32))
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (0#32 != x✝ &&& 4096#32)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun a_1 => some (a * a_1 * (x✝¹ &&& 2048#32))) ⊑
            Option.bind
              (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 2048#32)
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (x✝ &&& 4096#32 == 0#32)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝³
                | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
                fun a_1 => some (a * a_1 * (x✝¹ &&& 2048#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 2048#32))
              fun a =>
              Option.bind
                (match some (if (!0#32 == x✝ &&& 4096#32) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun a_1 => some (a * a_1 * (x✝¹ &&& 2048#32))) ⊑
            Option.bind
              (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ &&& 2048#32)
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun a =>
              Option.bind
                (match some (if (x✝ &&& 4096#32 == 0#32) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝³
                | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
                fun a_1 => some (a * a_1 * (x✝¹ &&& 2048#32))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:858:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:858:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:851:8: error: (kernel) declaration has metavariables 'set_bits_thm'
[bv] [0.034486] Normalizing goal
  [Meta.synthInstance] [0.001418] ✅️ Decidable
        ((match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ||| 5#8)
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 250#8)) ⊑
          Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 5#8
            | some { toFin := ⟨0, ⋯⟩ } => some 0#8)
            fun y' => some (x✝¹ &&& 250#8 ||| y'))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 1
      x✝¹ : BitVec 8
      x✝ : BitVec 1
      a✝ :
        ¬(match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ||| 5#8)
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 250#8)) ⊑
            Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 5#8
              | some { toFin := ⟨0, ⋯⟩ } => some 0#8)
              fun y' => some (x✝¹ &&& 250#8 ||| y')
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 1
      x✝¹ : BitVec 8
      x✝ : BitVec 1
      a✝ :
        ¬(match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ||| 5#8)
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ &&& 250#8)) ⊑
            Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 5#8
              | some { toFin := ⟨0, ⋯⟩ } => some 0#8)
              fun y' => some (x✝¹ &&& 250#8 ||| y')
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:870:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:870:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:862:8: error: (kernel) declaration has metavariables 'xor_i8_to_i64_shl_save_and_ne_thm'
[bv] [0.033696] Normalizing goal
  [Meta.synthInstance] [0.001552] ✅️ Decidable
        ((match some (BitVec.ofBool (x✝ &&& 1#8 != 0#8)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ^^^ 9223372036854775808#64)
          | some { toFin := ⟨0, ⋯⟩ } => some x✝¹) ⊑
          if 63#64 ≥ ↑64 then none else some (x✝¹ ^^^ BitVec.zeroExtend 64 x✝ <<< 63#64))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      e_1 : LLVM.IntW 8
      x✝¹ : BitVec 64
      x✝ : BitVec 8
      a✝ :
        ¬(match some (BitVec.ofBool (x✝ &&& 1#8 != 0#8)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ^^^ 9223372036854775808#64)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹) ⊑
            if 63#64 ≥ ↑64 then none else some (x✝¹ ^^^ BitVec.zeroExtend 64 x✝ <<< 63#64)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      e_1 : LLVM.IntW 8
      x✝¹ : BitVec 64
      x✝ : BitVec 8
      a✝ :
        ¬(match some (if (!x✝ &&& 1#8 == 0#8) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ ^^^ 9223372036854775808#64)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹) ⊑
            some (x✝¹ ^^^ BitVec.zeroExtend 64 x✝ <<< 63)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:881:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:881:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:874:8: error: (kernel) declaration has metavariables 'select_icmp_eq_and_1_0_lshr_fv_thm'
[bv] [0.047369] Normalizing goal
  [Meta.synthInstance] [0.001647] ✅️ Decidable
        ((match some (BitVec.ofBool (x✝ &&& 1#8 == 0#8)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => if 2#8 ≥ ↑8 then none else some (x✝¹ >>> 2#8)) ⊑
          if 1#8 ≥ ↑8 then none else if x✝ <<< 1#8 &&& 2#8 ≥ ↑8 then none else some (x✝¹ >>> (x✝ <<< 1#8 &&& 2#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(match some (BitVec.ofBool (x✝ &&& 1#8 == 0#8)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => if 2#8 ≥ ↑8 then none else some (x✝¹ >>> 2#8)) ⊑
            if 1#8 ≥ ↑8 then none else if x✝ <<< 1#8 &&& 2#8 ≥ ↑8 then none else some (x✝¹ >>> (x✝ <<< 1#8 &&& 2#8))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(match some (if (x✝ &&& 1#8 == 0#8) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ >>> 2)) ⊑
            if (!8#8 >ᵤ x✝ <<< 1 &&& 2#8) = true then none else some (x✝¹ >>> (x✝ <<< 1 &&& 2#8))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:892:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:892:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gselecthwithhbitwisehops_proof.lean:885:8: error: (kernel) declaration has metavariables 'select_icmp_eq_and_1_0_lshr_tv_thm'
[bv] [0.047400] Normalizing goal
  [Meta.synthInstance] [0.001647] ✅️ Decidable
        ((match some (BitVec.ofBool (x✝ &&& 1#8 != 0#8)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => if 2#8 ≥ ↑8 then none else some (x✝¹ >>> 2#8)
          | some { toFin := ⟨0, ⋯⟩ } => some x✝¹) ⊑
          if 1#8 ≥ ↑8 then none else if x✝ <<< 1#8 &&& 2#8 ≥ ↑8 then none else some (x✝¹ >>> (x✝ <<< 1#8 &&& 2#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(match some (BitVec.ofBool (x✝ &&& 1#8 != 0#8)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => if 2#8 ≥ ↑8 then none else some (x✝¹ >>> 2#8)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹) ⊑
            if 1#8 ≥ ↑8 then none else if x✝ <<< 1#8 &&& 2#8 ≥ ↑8 then none else some (x✝¹ >>> (x✝ <<< 1#8 &&& 2#8))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(match some (if (!x✝ &&& 1#8 == 0#8) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (x✝¹ >>> 2)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹) ⊑
            if (!8#8 >ᵤ x✝ <<< 1 &&& 2#8) = true then none else some (x✝¹ >>> (x✝ <<< 1 &&& 2#8))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
