⚠ [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
⚠ [878/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [881/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
⚠ [887/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
⚠ [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gudivremhchangehwidth_proof.lean:16:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gudivremhchangehwidth_proof.lean:11:8: error: (kernel) declaration has metavariables 'udiv_i8_thm'
[bv] [0.029656] Normalizing goal
  [Meta.synthInstance] [0.001500] ✅️ Decidable
        ((if BitVec.zeroExtend 32 x✝¹ = 0 then none
          else some (BitVec.truncate 8 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹))) ⊑
          if x✝¹ = 0 then none else some (x✝ / x✝¹))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if BitVec.zeroExtend 32 x✝¹ = 0 then none
            else some (BitVec.truncate 8 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹))) ⊑
            if x✝¹ = 0 then none else some (x✝ / x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if (BitVec.zeroExtend 32 x✝¹ == 0#32) = true then none
            else some (BitVec.zeroExtend 8 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹))) ⊑
            if (x✝¹ == 0#8) = true then none else some (x✝ / x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gudivremhchangehwidth_proof.lean:25:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gudivremhchangehwidth_proof.lean:20:8: error: (kernel) declaration has metavariables 'urem_i8_thm'
[bv] [0.036855] Normalizing goal
  [Meta.synthInstance] [0.001772] ✅️ Decidable
        ((if BitVec.zeroExtend 32 x✝¹ = 0 then none
          else some (BitVec.truncate 8 (BitVec.zeroExtend 32 x✝ % BitVec.zeroExtend 32 x✝¹))) ⊑
          if x✝¹ = 0 then none else some (x✝ % x✝¹))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if BitVec.zeroExtend 32 x✝¹ = 0 then none
            else some (BitVec.truncate 8 (BitVec.zeroExtend 32 x✝ % BitVec.zeroExtend 32 x✝¹))) ⊑
            if x✝¹ = 0 then none else some (x✝ % x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if (BitVec.zeroExtend 32 x✝¹ == 0#32) = true then none
            else some (BitVec.zeroExtend 8 (BitVec.zeroExtend 32 x✝ % BitVec.zeroExtend 32 x✝¹))) ⊑
            if (x✝¹ == 0#8) = true then none else some (x✝ % x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gudivremhchangehwidth_proof.lean:34:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gudivremhchangehwidth_proof.lean:29:8: error: (kernel) declaration has metavariables 'udiv_i32_thm'
[bv] [0.025182] Normalizing goal
  [Meta.synthInstance] [0.001341] ✅️ Decidable
        ((if BitVec.zeroExtend 32 x✝¹ = 0 then none else some (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹)) ⊑
          if x✝¹ = 0 then none else some (BitVec.zeroExtend 32 (x✝ / x✝¹)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if BitVec.zeroExtend 32 x✝¹ = 0 then none else some (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹)) ⊑
            if x✝¹ = 0 then none else some (BitVec.zeroExtend 32 (x✝ / x✝¹))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if (BitVec.zeroExtend 32 x✝¹ == 0#32) = true then none
            else some (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹)) ⊑
            if (x✝¹ == 0#8) = true then none else some (BitVec.zeroExtend 32 (x✝ / x✝¹))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gudivremhchangehwidth_proof.lean:46:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gudivremhchangehwidth_proof.lean:38:8: error: (kernel) declaration has metavariables 'udiv_i32_multiuse_thm'
[bv] [0.123346] Normalizing goal
  [Meta.synthInstance] [0.003466] ✅️ Decidable
        ((if BitVec.zeroExtend 32 x✝¹ = 0 then none
          else
            some
              (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹ *
                (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))) ⊑
          if BitVec.zeroExtend 32 x✝¹ = 0 then none
          else
            if
                True ∧
                  (BitVec.zeroExtend 32 x✝).msb = (BitVec.zeroExtend 32 x✝¹).msb ∧
                    (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹).msb ≠ (BitVec.zeroExtend 32 x✝).msb then
              none
            else
              if
                  True ∧
                    (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹ < BitVec.zeroExtend 32 x✝ ∨
                      BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹ < BitVec.zeroExtend 32 x✝¹) then
                none
              else
                if
                    True ∧
                      (BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                            BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) <
                          BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                        BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                            BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                          BitVec.twoPow (2 * 32) (32 - 1)) then
                  none
                else
                  if
                      True ∧
                        BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                            BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                          BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                    none
                  else
                    some
                      (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹ *
                        (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)))
    [Meta.check] [0.002409] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if BitVec.zeroExtend 32 x✝¹ = 0 then none
          else
            some
              (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹ *
                (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)))
          (if BitVec.zeroExtend 32 x✝¹ = 0 then none
          else
            if
                True ∧
                  (BitVec.zeroExtend 32 x✝).msb = (BitVec.zeroExtend 32 x✝¹).msb ∧
                    (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹).msb ≠ (BitVec.zeroExtend 32 x✝).msb then
              none
            else
              if
                  True ∧
                    (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹ < BitVec.zeroExtend 32 x✝ ∨
                      BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹ < BitVec.zeroExtend 32 x✝¹) then
                none
              else
                if
                    True ∧
                      (BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                            BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) <
                          BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                        BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                            BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                          BitVec.twoPow (2 * 32) (32 - 1)) then
                  none
                else
                  if
                      True ∧
                        BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                            BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                          BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                    none
                  else
                    some
                      (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹ *
                        (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if BitVec.zeroExtend 32 x✝¹ = 0 then none
            else
              some
                (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹ *
                  (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))) ⊑
            if BitVec.zeroExtend 32 x✝¹ = 0 then none
            else
              if
                  True ∧
                    (BitVec.zeroExtend 32 x✝).msb = (BitVec.zeroExtend 32 x✝¹).msb ∧
                      (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹).msb ≠ (BitVec.zeroExtend 32 x✝).msb then
                none
              else
                if
                    True ∧
                      (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹ < BitVec.zeroExtend 32 x✝ ∨
                        BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹ < BitVec.zeroExtend 32 x✝¹) then
                  none
                else
                  if
                      True ∧
                        (BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                              BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) <
                            BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                          BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                              BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                            BitVec.twoPow (2 * 32) (32 - 1)) then
                    none
                  else
                    if
                        True ∧
                          BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                              BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                            BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                      none
                    else
                      some
                        (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹ *
                          (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
      ⊢ False
  [Meta.isDefEq] [0.001256] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                    (BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                      BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                    (BitVec.signExtend 64 (BitVec.twoPow 32 31))))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31)
                      (BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                        BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                            (BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                              BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                            (BitVec.twoPow 64 31)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 64 31 >ᵤ
                            BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                              BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                          true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true
                          (BitVec.twoPow 64 31 >ᵤ
                            BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                              BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                  BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                    BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                !BitVec.twoPow 64 31 >ᵤ
                    BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                      BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                    BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                      BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                  !BitVec.twoPow 64 31 >ᵤ
                      BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                        BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                (congrArg
                  (fun x =>
                    !((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                            BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                              BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) &&
                        x))
                  (Bool.not_not
                    (BitVec.twoPow 64 31 >ᵤ
                      BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                        BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))))))))
        (true_and
          ((!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                    BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                      BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) &&
                BitVec.twoPow 64 31 >ᵤ
                  BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                    BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))) =
            true))
    [Meta.isDefEq.assign] [0.001252] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                      (BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                        BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                      (BitVec.signExtend 64 (BitVec.twoPow 32 31))))
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31)
                        (BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                          BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                              (BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                              (BitVec.twoPow 64 31)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 64 31 >ᵤ
                              BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                            true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true
                            (BitVec.twoPow 64 31 >ᵤ
                              BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                    BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                      BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                  !BitVec.twoPow 64 31 >ᵤ
                      BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                        BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                      BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                        BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                    !BitVec.twoPow 64 31 >ᵤ
                        BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                          BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                  (congrArg
                    (fun x =>
                      !((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                              BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) &&
                          x))
                    (Bool.not_not
                      (BitVec.twoPow 64 31 >ᵤ
                        BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                          BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))))))))
          (true_and
            ((!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                      BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                        BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) &&
                  BitVec.twoPow 64 31 >ᵤ
                    BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                      BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.001209] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                    BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) <
                  BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                    BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                  BitVec.twoPow (2 * 32) (32 - 1))) =
            ((!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                      BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                        BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) &&
                  BitVec.twoPow 64 31 >ᵤ
                    BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                      BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                        (BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                          BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                        (BitVec.signExtend 64 (BitVec.twoPow 32 31))))
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31)
                          (BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                            BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                                (BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                  BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                                (BitVec.twoPow 64 31)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 64 31 >ᵤ
                                BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                  BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                              true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true
                              (BitVec.twoPow 64 31 >ᵤ
                                BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                  BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                      BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                        BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                    !BitVec.twoPow 64 31 >ᵤ
                        BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                          BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                        BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                          BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                      !BitVec.twoPow 64 31 >ᵤ
                          BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                            BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                    (congrArg
                      (fun x =>
                        !((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                                BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                  BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) &&
                            x))
                      (Bool.not_not
                        (BitVec.twoPow 64 31 >ᵤ
                          BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                            BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))))))))
            (true_and
              ((!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                        BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                          BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) &&
                    BitVec.twoPow 64 31 >ᵤ
                      BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                        BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))) =
                true)) : (True ∧
              (BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                    BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) <
                  BitVec.signExtend 64 (BitVec.twoPow 32 31) ∨
                BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                    BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                  BitVec.twoPow 64 31)) =
            ((!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                      BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                        BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) &&
                  BitVec.twoPow 64 31 >ᵤ
                    BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                      BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))) =
              true))
        [Meta.isDefEq] [0.001197] ✅️ (True ∧
                (BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                      BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) <
                    BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                  BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                      BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                    BitVec.twoPow (2 * 32) (32 - 1))) =
              ((!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                        BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                          BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) &&
                    BitVec.twoPow 64 31 >ᵤ
                      BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                        BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))) =
                true) =?= (True ∧
                (BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                      BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) <
                    BitVec.signExtend 64 (BitVec.twoPow 32 31) ∨
                  BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                      BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                    BitVec.twoPow 64 31)) =
              ((!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                        BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                          BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) &&
                    BitVec.twoPow 64 31 >ᵤ
                      BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                        BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))) =
                true)
          [Meta.isDefEq] [0.001160] ✅️ True ∧
                (BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                      BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) <
                    BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                  BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                      BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                    BitVec.twoPow (2 * 32)
                      (32 -
                        1)) =?= True ∧
                (BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                      BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) <
                    BitVec.signExtend 64 (BitVec.twoPow 32 31) ∨
                  BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                      BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                    BitVec.twoPow 64 31)
            [Meta.isDefEq] [0.001130] ✅️ BitVec.signExtend (2 * 32)
                        (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                      BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) <
                    BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                  BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                      BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                    BitVec.twoPow (2 * 32)
                      (32 -
                        1) =?= BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                      BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) <
                    BitVec.signExtend 64 (BitVec.twoPow 32 31) ∨
                  BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                      BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                    BitVec.twoPow 64 31
  [Meta.isDefEq] [0.001230] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                (BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                  BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                      (BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                        BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                      (BitVec.twoPow 64 31 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 64 31 <<< 1 >ᵤ
                      BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                        BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                    true))
                (congrArg (fun x => (!x) = true)
                  (beq_true
                    (BitVec.twoPow 64 31 <<< 1 >ᵤ
                      BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                        BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))))))))
        (true_and
          ((!BitVec.twoPow 64 31 <<< 1 >ᵤ
                BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                  BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) =
            true))
    [Meta.isDefEq.assign] [0.001226] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                  (BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                    BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                        (BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                          BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                        (BitVec.twoPow 64 31 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 64 31 <<< 1 >ᵤ
                        BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                          BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                      true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true
                      (BitVec.twoPow 64 31 <<< 1 >ᵤ
                        BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                          BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))))))))
          (true_and
            ((!BitVec.twoPow 64 31 <<< 1 >ᵤ
                  BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                    BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.001202] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                  BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                BitVec.twoPow (2 * 32) (32 - 1) <<< 1) =
            ((!BitVec.twoPow 64 31 <<< 1 >ᵤ
                  BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                    BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                    (BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                      BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                          (BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                            BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                          (BitVec.twoPow 64 31 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 64 31 <<< 1 >ᵤ
                          BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                            BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                        true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true
                        (BitVec.twoPow 64 31 <<< 1 >ᵤ
                          BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                            BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))))))))
            (true_and
              ((!BitVec.twoPow 64 31 <<< 1 >ᵤ
                    BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                      BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) =
                true)) : (True ∧
              BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                  BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                BitVec.twoPow 64 31 <<< 1) =
            ((!BitVec.twoPow 64 31 <<< 1 >ᵤ
                  BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                    BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) =
              true))
        [Meta.isDefEq] [0.001198] ✅️ (True ∧
                BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                    BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1) =
              ((!BitVec.twoPow 64 31 <<< 1 >ᵤ
                    BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                      BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) =
                true) =?= (True ∧
                BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                    BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                  BitVec.twoPow 64 31 <<< 1) =
              ((!BitVec.twoPow 64 31 <<< 1 >ᵤ
                    BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                      BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) =
                true)
          [Meta.isDefEq] [0.001153] ✅️ True ∧
                BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                    BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<<
                    1 =?= True ∧
                BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                    BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                  BitVec.twoPow 64 31 <<< 1
            [Meta.isDefEq] [0.001135] ✅️ BitVec.zeroExtend (2 * 32)
                      (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                    BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<<
                    1 =?= BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                    BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                  BitVec.twoPow 64 31 <<< 1
              [Meta.isDefEq.delta] [0.001104] ✅️ BitVec.zeroExtend (2 * 32)
                        (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                      BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<<
                      1 =?= BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                      BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                    BitVec.twoPow 64 31 <<< 1
  [Meta.isDefEq] [0.006436] ✅️ ?h₃ =?= fun a =>
        ite_congr
          (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)
                        (BitVec.zeroExtend 32 x✝)))
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)
                      (BitVec.zeroExtend 32 x✝¹)))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.zeroExtend 32 x✝ >ᵤ BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)
                    (BitVec.zeroExtend 32 x✝¹ >ᵤ BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)))
                (congrArg (fun x => x = true)
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.zeroExtend 32 x✝ >ᵤ BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)
                    (BitVec.zeroExtend 32 x✝¹ >ᵤ BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)))))
            (true_and
              ((!((!BitVec.zeroExtend 32 x✝ >ᵤ BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) &&
                    !BitVec.zeroExtend 32 x✝¹ >ᵤ BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) =
                true)))
          (fun a => Eq.refl none) fun a =>
          ite_congr
            (Eq.trans
              (congrArg (And True)
                (Eq.trans
                  (Eq.trans
                    (congr
                      (congrArg Or
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                          (BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                            BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                          (BitVec.signExtend 64 (BitVec.twoPow 32 31))))
                      (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                        (Eq.trans
                          (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31)
                            (BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                              BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)))
                          (Eq.trans
                            (Eq.trans
                              (congrArg Not
                                (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                                  (BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                    BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                                  (BitVec.twoPow 64 31)))
                              (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                                (BitVec.twoPow 64 31 >ᵤ
                                  BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                    BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                                true))
                            (congrArg (fun x => (!x) = true)
                              (beq_true
                                (BitVec.twoPow 64 31 >ᵤ
                                  BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                    BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))))))))
                    (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                      (BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                        BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                          BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                      !BitVec.twoPow 64 31 >ᵤ
                          BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                            BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)))
                  (congrArg (fun x => x = true)
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                        (BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                          BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                            BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                        !BitVec.twoPow 64 31 >ᵤ
                            BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                              BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                      (congrArg
                        (fun x =>
                          !((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                                  BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                    BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) &&
                              x))
                        (Bool.not_not
                          (BitVec.twoPow 64 31 >ᵤ
                            BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                              BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))))))))
              (true_and
                ((!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                          BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                            BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) &&
                      BitVec.twoPow 64 31 >ᵤ
                        BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                          BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))) =
                  true)))
            (fun a => Eq.refl none) fun a =>
            ite_congr
              (Eq.trans
                (congrArg (And True)
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                        (BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                          BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                              (BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                              (BitVec.twoPow 64 31 <<< 1)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 64 31 <<< 1 >ᵤ
                              BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                            true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true
                            (BitVec.twoPow 64 31 <<< 1 >ᵤ
                              BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))))))))
                (true_and
                  ((!BitVec.twoPow 64 31 <<< 1 >ᵤ
                        BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                          BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) =
                    true)))
              (fun a => Eq.refl none) fun a =>
              Eq.refl
                (some
                  (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹ *
                    (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)))
    [Meta.isDefEq.assign] [0.006430] ✅️ ?h₃ := fun a =>
          ite_congr
            (Eq.trans
              (congrArg (And True)
                (Eq.trans
                  (Eq.trans
                    (congr
                      (congrArg Or
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                          (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) (BitVec.zeroExtend 32 x✝)))
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)
                        (BitVec.zeroExtend 32 x✝¹)))
                    (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                      (BitVec.zeroExtend 32 x✝ >ᵤ BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)
                      (BitVec.zeroExtend 32 x✝¹ >ᵤ BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)))
                  (congrArg (fun x => x = true)
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.zeroExtend 32 x✝ >ᵤ BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)
                      (BitVec.zeroExtend 32 x✝¹ >ᵤ BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)))))
              (true_and
                ((!((!BitVec.zeroExtend 32 x✝ >ᵤ BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) &&
                      !BitVec.zeroExtend 32 x✝¹ >ᵤ BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) =
                  true)))
            (fun a => Eq.refl none) fun a =>
            ite_congr
              (Eq.trans
                (congrArg (And True)
                  (Eq.trans
                    (Eq.trans
                      (congr
                        (congrArg Or
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                            (BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                              BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                            (BitVec.signExtend 64 (BitVec.twoPow 32 31))))
                        (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                          (Eq.trans
                            (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31)
                              (BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)))
                            (Eq.trans
                              (Eq.trans
                                (congrArg Not
                                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                                    (BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                      BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                                    (BitVec.twoPow 64 31)))
                                (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                                  (BitVec.twoPow 64 31 >ᵤ
                                    BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                      BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                                  true))
                              (congrArg (fun x => (!x) = true)
                                (beq_true
                                  (BitVec.twoPow 64 31 >ᵤ
                                    BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                      BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))))))))
                      (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                        (BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                          BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                            BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                        !BitVec.twoPow 64 31 >ᵤ
                            BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                              BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)))
                    (congrArg (fun x => x = true)
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                          (BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                            BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                              BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                          !BitVec.twoPow 64 31 >ᵤ
                              BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                        (congrArg
                          (fun x =>
                            !((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                                    BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                      BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) &&
                                x))
                          (Bool.not_not
                            (BitVec.twoPow 64 31 >ᵤ
                              BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))))))))
                (true_and
                  ((!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                            BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                              BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) &&
                        BitVec.twoPow 64 31 >ᵤ
                          BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                            BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))) =
                    true)))
              (fun a => Eq.refl none) fun a =>
              ite_congr
                (Eq.trans
                  (congrArg (And True)
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                          (BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                            BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                                (BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                  BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                                (BitVec.twoPow 64 31 <<< 1)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 64 31 <<< 1 >ᵤ
                                BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                  BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                              true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true
                              (BitVec.twoPow 64 31 <<< 1 >ᵤ
                                BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                  BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))))))))
                  (true_and
                    ((!BitVec.twoPow 64 31 <<< 1 >ᵤ
                          BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                            BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) =
                      true)))
                (fun a => Eq.refl none) fun a =>
                Eq.refl
                  (some
                    (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹ *
                      (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)))
      [Meta.isDefEq.assign.checkTypes] [0.006271] ✅️ (?h₃ : ¬((BitVec.zeroExtend 32 x✝).getLsbD 31 ==
                    (BitVec.zeroExtend 32 x✝¹).getLsbD 31 &&
                  !(BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹).getLsbD 31 ==
                      (BitVec.zeroExtend 32 x✝).getLsbD 31) =
                true →
            (if
                  True ∧
                    (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹ < BitVec.zeroExtend 32 x✝ ∨
                      BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹ < BitVec.zeroExtend 32 x✝¹) then
                none
              else
                if
                    True ∧
                      (BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                            BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) <
                          BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                        BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                            BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                          BitVec.twoPow (2 * 32) (32 - 1)) then
                  none
                else
                  if
                      True ∧
                        BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                            BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                          BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                    none
                  else
                    some
                      (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹ *
                        (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))) =
              if
                  (!((!BitVec.zeroExtend 32 x✝ >ᵤ BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) &&
                        !BitVec.zeroExtend 32 x✝¹ >ᵤ BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) =
                    true then
                none
              else
                if
                    (!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                              BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) &&
                          BitVec.twoPow 64 31 >ᵤ
                            BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                              BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))) =
                      true then
                  none
                else
                  if
                      (!BitVec.twoPow 64 31 <<< 1 >ᵤ
                            BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                              BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) =
                        true then
                    none
                  else
                    some
                      (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹ *
                        (BitVec.zeroExtend 32 x✝ +
                          BitVec.zeroExtend 32
                            x✝¹))) := (fun a =>
            ite_congr
              (Eq.trans
                (congrArg (And True)
                  (Eq.trans
                    (Eq.trans
                      (congr
                        (congrArg Or
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                            (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) (BitVec.zeroExtend 32 x✝)))
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                          (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) (BitVec.zeroExtend 32 x✝¹)))
                      (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                        (BitVec.zeroExtend 32 x✝ >ᵤ BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)
                        (BitVec.zeroExtend 32 x✝¹ >ᵤ BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)))
                    (congrArg (fun x => x = true)
                      (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                        (BitVec.zeroExtend 32 x✝ >ᵤ BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)
                        (BitVec.zeroExtend 32 x✝¹ >ᵤ BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)))))
                (true_and
                  ((!((!BitVec.zeroExtend 32 x✝ >ᵤ BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) &&
                        !BitVec.zeroExtend 32 x✝¹ >ᵤ BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) =
                    true)))
              (fun a => Eq.refl none) fun a =>
              ite_congr
                (Eq.trans
                  (congrArg (And True)
                    (Eq.trans
                      (Eq.trans
                        (congr
                          (congrArg Or
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                              (BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                              (BitVec.signExtend 64 (BitVec.twoPow 32 31))))
                          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                            (Eq.trans
                              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31)
                                (BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                  BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)))
                              (Eq.trans
                                (Eq.trans
                                  (congrArg Not
                                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                                      (BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                        BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                                      (BitVec.twoPow 64 31)))
                                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                                    (BitVec.twoPow 64 31 >ᵤ
                                      BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                        BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                                    true))
                                (congrArg (fun x => (!x) = true)
                                  (beq_true
                                    (BitVec.twoPow 64 31 >ᵤ
                                      BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                        BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))))))))
                        (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                          (BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                            BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                              BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                          !BitVec.twoPow 64 31 >ᵤ
                              BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)))
                      (congrArg (fun x => x = true)
                        (Eq.trans
                          (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                            (BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                              BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                            !BitVec.twoPow 64 31 >ᵤ
                                BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                  BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                          (congrArg
                            (fun x =>
                              !((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                                      BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                        BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) &&
                                  x))
                            (Bool.not_not
                              (BitVec.twoPow 64 31 >ᵤ
                                BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                  BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))))))))
                  (true_and
                    ((!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                              BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) &&
                          BitVec.twoPow 64 31 >ᵤ
                            BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                              BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))) =
                      true)))
                (fun a => Eq.refl none) fun a =>
                ite_congr
                  (Eq.trans
                    (congrArg (And True)
                      (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                        (Eq.trans
                          (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                            (BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                              BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)))
                          (Eq.trans
                            (Eq.trans
                              (congrArg Not
                                (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                                  (BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                    BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                                  (BitVec.twoPow 64 31 <<< 1)))
                              (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                                (BitVec.twoPow 64 31 <<< 1 >ᵤ
                                  BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                    BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
                                true))
                            (congrArg (fun x => (!x) = true)
                              (beq_true
                                (BitVec.twoPow 64 31 <<< 1 >ᵤ
                                  BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                    BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))))))))
                    (true_and
                      ((!BitVec.twoPow 64 31 <<< 1 >ᵤ
                            BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                              BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) =
                        true)))
                  (fun a => Eq.refl none) fun a =>
                  Eq.refl
                    (some
                      (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹ *
                        (BitVec.zeroExtend 32 x✝ +
                          BitVec.zeroExtend 32
                            x✝¹))) : ¬((BitVec.zeroExtend 32 x✝).getLsbD 31 == (BitVec.zeroExtend 32 x✝¹).getLsbD 31 &&
                  !(BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹).getLsbD 31 ==
                      (BitVec.zeroExtend 32 x✝).getLsbD 31) =
                true →
            (if
                  True ∧
                    (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹ < BitVec.zeroExtend 32 x✝ ∨
                      BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹ < BitVec.zeroExtend 32 x✝¹) then
                none
              else
                if
                    True ∧
                      (BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                            BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) <
                          BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                        BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                            BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                          BitVec.twoPow (2 * 32) (32 - 1)) then
                  none
                else
                  if
                      True ∧
                        BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                            BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                          BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                    none
                  else
                    some
                      (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹ *
                        (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))) =
              if
                  (!((!BitVec.zeroExtend 32 x✝ >ᵤ BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) &&
                        !BitVec.zeroExtend 32 x✝¹ >ᵤ BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) =
                    true then
                none
              else
                if
                    (!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                              BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) &&
                          BitVec.twoPow 64 31 >ᵤ
                            BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                              BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))) =
                      true then
                  none
                else
                  if
                      (!BitVec.twoPow 64 31 <<< 1 >ᵤ
                            BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                              BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) =
                        true then
                    none
                  else
                    some
                      (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹ *
                        (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)))
        [Meta.isDefEq] [0.006263] ✅️ ¬((BitVec.zeroExtend 32 x✝).getLsbD 31 == (BitVec.zeroExtend 32 x✝¹).getLsbD 31 &&
                    !(BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹).getLsbD 31 ==
                        (BitVec.zeroExtend 32 x✝).getLsbD 31) =
                  true →
              (if
                    True ∧
                      (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹ < BitVec.zeroExtend 32 x✝ ∨
                        BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹ < BitVec.zeroExtend 32 x✝¹) then
                  none
                else
                  if
                      True ∧
                        (BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                              BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) <
                            BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                          BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                              BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                            BitVec.twoPow (2 * 32) (32 - 1)) then
                    none
                  else
                    if
                        True ∧
                          BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                              BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                            BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                      none
                    else
                      some
                        (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹ *
                          (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))) =
                if
                    (!((!BitVec.zeroExtend 32 x✝ >ᵤ BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) &&
                          !BitVec.zeroExtend 32 x✝¹ >ᵤ BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) =
                      true then
                  none
                else
                  if
                      (!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                                BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                  BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) &&
                            BitVec.twoPow 64 31 >ᵤ
                              BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))) =
                        true then
                    none
                  else
                    if
                        (!BitVec.twoPow 64 31 <<< 1 >ᵤ
                              BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) =
                          true then
                      none
                    else
                      some
                        (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹ *
                          (BitVec.zeroExtend 32 x✝ +
                            BitVec.zeroExtend 32
                              x✝¹)) =?= ¬((BitVec.zeroExtend 32 x✝).getLsbD 31 ==
                      (BitVec.zeroExtend 32 x✝¹).getLsbD 31 &&
                    !(BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹).getLsbD 31 ==
                        (BitVec.zeroExtend 32 x✝).getLsbD 31) =
                  true →
              (if
                    True ∧
                      (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹ < BitVec.zeroExtend 32 x✝ ∨
                        BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹ < BitVec.zeroExtend 32 x✝¹) then
                  none
                else
                  if
                      True ∧
                        (BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                              BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) <
                            BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                          BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                              BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                            BitVec.twoPow (2 * 32) (32 - 1)) then
                    none
                  else
                    if
                        True ∧
                          BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                              BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                            BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                      none
                    else
                      some
                        (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹ *
                          (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))) =
                if
                    (!((!BitVec.zeroExtend 32 x✝ >ᵤ BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) &&
                          !BitVec.zeroExtend 32 x✝¹ >ᵤ BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) =
                      true then
                  none
                else
                  if
                      (!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                                BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                  BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) &&
                            BitVec.twoPow 64 31 >ᵤ
                              BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))) =
                        true then
                    none
                  else
                    if
                        (!BitVec.twoPow 64 31 <<< 1 >ᵤ
                              BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) =
                          true then
                      none
                    else
                      some
                        (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹ *
                          (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if (BitVec.zeroExtend 32 x✝¹ == 0#32) = true then none
            else
              some
                (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹ *
                  (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))) ⊑
            if (BitVec.zeroExtend 32 x✝¹ == 0#32) = true then none
            else
              if
                  ((BitVec.zeroExtend 32 x✝).getLsbD 31 == (BitVec.zeroExtend 32 x✝¹).getLsbD 31 &&
                      !(BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹).getLsbD 31 ==
                          (BitVec.zeroExtend 32 x✝).getLsbD 31) =
                    true then
                none
              else
                if
                    (!((!BitVec.zeroExtend 32 x✝ >ᵤ BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) &&
                          !BitVec.zeroExtend 32 x✝¹ >ᵤ BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) =
                      true then
                  none
                else
                  if
                      (!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                                BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                  BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) &&
                            BitVec.twoPow 64 31 >ᵤ
                              BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))) =
                        true then
                    none
                  else
                    if
                        (!BitVec.twoPow 64 31 <<< 1 >ᵤ
                              BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹) *
                                BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) =
                          true then
                      none
                    else
                      some
                        (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹ *
                          (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gudivremhchangehwidth_proof.lean:55:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gudivremhchangehwidth_proof.lean:50:8: error: (kernel) declaration has metavariables 'udiv_illegal_type_thm'
[bv] [0.027962] Normalizing goal
  [Meta.synthInstance] [0.001245] ✅️ Decidable
        ((if BitVec.zeroExtend 32 x✝¹ = 0 then none else some (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹)) ⊑
          if x✝¹ = 0 then none else some (BitVec.zeroExtend 32 (x✝ / x✝¹)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 9
      x✝¹ x✝ : BitVec 9
      a✝ :
        ¬(if BitVec.zeroExtend 32 x✝¹ = 0 then none else some (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹)) ⊑
            if x✝¹ = 0 then none else some (BitVec.zeroExtend 32 (x✝ / x✝¹))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 9
      x✝¹ x✝ : BitVec 9
      a✝ :
        ¬(if (BitVec.zeroExtend 32 x✝¹ == 0#32) = true then none
            else some (BitVec.zeroExtend 32 x✝ / BitVec.zeroExtend 32 x✝¹)) ⊑
            if (x✝¹ == 0#9) = true then none else some (BitVec.zeroExtend 32 (x✝ / x✝¹))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gudivremhchangehwidth_proof.lean:64:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gudivremhchangehwidth_proof.lean:59:8: error: (kernel) declaration has metavariables 'urem_i32_thm'
[bv] [0.037269] Normalizing goal
  [Meta.synthInstance] [0.001890] ✅️ Decidable
        ((if BitVec.zeroExtend 32 x✝¹ = 0 then none else some (BitVec.zeroExtend 32 x✝ % BitVec.zeroExtend 32 x✝¹)) ⊑
          if x✝¹ = 0 then none else some (BitVec.zeroExtend 32 (x✝ % x✝¹)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if BitVec.zeroExtend 32 x✝¹ = 0 then none else some (BitVec.zeroExtend 32 x✝ % BitVec.zeroExtend 32 x✝¹)) ⊑
            if x✝¹ = 0 then none else some (BitVec.zeroExtend 32 (x✝ % x✝¹))
      ⊢ False
  [Meta.isDefEq] [0.001044] ❌️ ?a == ?a =?= BitVec.zeroExtend 32 x✝¹ == 0#32
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if (BitVec.zeroExtend 32 x✝¹ == 0#32) = true then none
            else some (BitVec.zeroExtend 32 x✝ % BitVec.zeroExtend 32 x✝¹)) ⊑
            if (x✝¹ == 0#8) = true then none else some (BitVec.zeroExtend 32 (x✝ % x✝¹))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gudivremhchangehwidth_proof.lean:76:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gudivremhchangehwidth_proof.lean:68:8: error: (kernel) declaration has metavariables 'urem_i32_multiuse_thm'
[bv] [0.070233] Normalizing goal
  [Meta.synthInstance] [0.001941] ✅️ Decidable
        ((if BitVec.zeroExtend 32 x✝¹ = 0 then none
          else
            some
              (BitVec.zeroExtend 32 x✝ % BitVec.zeroExtend 32 x✝¹ *
                (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))) ⊑
          if BitVec.zeroExtend 32 x✝¹ = 0 then none
          else
            if
                True ∧
                  (BitVec.zeroExtend 32 x✝).msb = (BitVec.zeroExtend 32 x✝¹).msb ∧
                    (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹).msb ≠ (BitVec.zeroExtend 32 x✝).msb then
              none
            else
              if
                  True ∧
                    (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹ < BitVec.zeroExtend 32 x✝ ∨
                      BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹ < BitVec.zeroExtend 32 x✝¹) then
                none
              else
                if
                    True ∧
                      (BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ % BitVec.zeroExtend 32 x✝¹) *
                            BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) <
                          BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                        BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ % BitVec.zeroExtend 32 x✝¹) *
                            BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                          BitVec.twoPow (2 * 32) (32 - 1)) then
                  none
                else
                  if
                      True ∧
                        BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝ % BitVec.zeroExtend 32 x✝¹) *
                            BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                          BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                    none
                  else
                    some
                      (BitVec.zeroExtend 32 x✝ % BitVec.zeroExtend 32 x✝¹ *
                        (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)))
    [Meta.check] [0.001316] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if BitVec.zeroExtend 32 x✝¹ = 0 then none
          else
            some
              (BitVec.zeroExtend 32 x✝ % BitVec.zeroExtend 32 x✝¹ *
                (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)))
          (if BitVec.zeroExtend 32 x✝¹ = 0 then none
          else
            if
                True ∧
                  (BitVec.zeroExtend 32 x✝).msb = (BitVec.zeroExtend 32 x✝¹).msb ∧
                    (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹).msb ≠ (BitVec.zeroExtend 32 x✝).msb then
              none
            else
              if
                  True ∧
                    (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹ < BitVec.zeroExtend 32 x✝ ∨
                      BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹ < BitVec.zeroExtend 32 x✝¹) then
                none
              else
                if
                    True ∧
                      (BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ % BitVec.zeroExtend 32 x✝¹) *
                            BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) <
                          BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                        BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ % BitVec.zeroExtend 32 x✝¹) *
                            BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                          BitVec.twoPow (2 * 32) (32 - 1)) then
                  none
                else
                  if
                      True ∧
                        BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝ % BitVec.zeroExtend 32 x✝¹) *
                            BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                          BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                    none
                  else
                    some
                      (BitVec.zeroExtend 32 x✝ % BitVec.zeroExtend 32 x✝¹ *
                        (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if BitVec.zeroExtend 32 x✝¹ = 0 then none
            else
              some
                (BitVec.zeroExtend 32 x✝ % BitVec.zeroExtend 32 x✝¹ *
                  (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))) ⊑
            if BitVec.zeroExtend 32 x✝¹ = 0 then none
            else
              if
                  True ∧
                    (BitVec.zeroExtend 32 x✝).msb = (BitVec.zeroExtend 32 x✝¹).msb ∧
                      (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹).msb ≠ (BitVec.zeroExtend 32 x✝).msb then
                none
              else
                if
                    True ∧
                      (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹ < BitVec.zeroExtend 32 x✝ ∨
                        BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹ < BitVec.zeroExtend 32 x✝¹) then
                  none
                else
                  if
                      True ∧
                        (BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ % BitVec.zeroExtend 32 x✝¹) *
                              BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) <
                            BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                          BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ % BitVec.zeroExtend 32 x✝¹) *
                              BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                            BitVec.twoPow (2 * 32) (32 - 1)) then
                    none
                  else
                    if
                        True ∧
                          BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝ % BitVec.zeroExtend 32 x✝¹) *
                              BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) ≥
                            BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                      none
                    else
                      some
                        (BitVec.zeroExtend 32 x✝ % BitVec.zeroExtend 32 x✝¹ *
                          (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if (BitVec.zeroExtend 32 x✝¹ == 0#32) = true then none
            else
              some
                (BitVec.zeroExtend 32 x✝ % BitVec.zeroExtend 32 x✝¹ *
                  (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))) ⊑
            if (BitVec.zeroExtend 32 x✝¹ == 0#32) = true then none
            else
              if
                  ((BitVec.zeroExtend 32 x✝).getLsbD 31 == (BitVec.zeroExtend 32 x✝¹).getLsbD 31 &&
                      !(BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹).getLsbD 31 ==
                          (BitVec.zeroExtend 32 x✝).getLsbD 31) =
                    true then
                none
              else
                if
                    (!((!BitVec.zeroExtend 32 x✝ >ᵤ BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹) &&
                          !BitVec.zeroExtend 32 x✝¹ >ᵤ BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) =
                      true then
                  none
                else
                  if
                      (!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                                BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ % BitVec.zeroExtend 32 x✝¹) *
                                  BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) &&
                            BitVec.twoPow 64 31 >ᵤ
                              BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ % BitVec.zeroExtend 32 x✝¹) *
                                BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))) =
                        true then
                    none
                  else
                    if
                        (!BitVec.twoPow 64 31 <<< 1 >ᵤ
                              BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ % BitVec.zeroExtend 32 x✝¹) *
                                BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹)) =
                          true then
                      none
                    else
                      some
                        (BitVec.zeroExtend 32 x✝ % BitVec.zeroExtend 32 x✝¹ *
                          (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝¹))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gudivremhchangehwidth_proof.lean:85:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gudivremhchangehwidth_proof.lean:80:8: error: (kernel) declaration has metavariables 'urem_illegal_type_thm'
[bv] [0.021665] Normalizing goal
  [Meta.synthInstance] [0.001055] ✅️ Decidable
        ((if BitVec.zeroExtend 32 x✝¹ = 0 then none else some (BitVec.zeroExtend 32 x✝ % BitVec.zeroExtend 32 x✝¹)) ⊑
          if x✝¹ = 0 then none else some (BitVec.zeroExtend 32 (x✝ % x✝¹)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 9
      x✝¹ x✝ : BitVec 9
      a✝ :
        ¬(if BitVec.zeroExtend 32 x✝¹ = 0 then none else some (BitVec.zeroExtend 32 x✝ % BitVec.zeroExtend 32 x✝¹)) ⊑
            if x✝¹ = 0 then none else some (BitVec.zeroExtend 32 (x✝ % x✝¹))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 9
      x✝¹ x✝ : BitVec 9
      a✝ :
        ¬(if (BitVec.zeroExtend 32 x✝¹ == 0#32) = true then none
            else some (BitVec.zeroExtend 32 x✝ % BitVec.zeroExtend 32 x✝¹)) ⊑
            if (x✝¹ == 0#9) = true then none else some (BitVec.zeroExtend 32 (x✝ % x✝¹))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gudivremhchangehwidth_proof.lean:94:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gudivremhchangehwidth_proof.lean:89:8: error: (kernel) declaration has metavariables 'udiv_i32_c_thm'
[bv] [0.009220] Normalizing goal
  [Meta.synthInstance] [0.001014] ✅️ Decidable
        ((if 10#32 = 0 then none else some (BitVec.zeroExtend 32 x✝ / 10#32)) ⊑
          if 10#8 = 0 then none else some (BitVec.zeroExtend 32 (x✝ / 10#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if 10#32 = 0 then none else some (BitVec.zeroExtend 32 x✝ / 10#32)) ⊑
            if 10#8 = 0 then none else some (BitVec.zeroExtend 32 (x✝ / 10#8))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ : ¬some (BitVec.zeroExtend 32 x✝ / 10#32) ⊑ some (BitVec.zeroExtend 32 (x✝ / 10#8))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gudivremhchangehwidth_proof.lean:105:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gudivremhchangehwidth_proof.lean:98:8: error: (kernel) declaration has metavariables 'udiv_i32_c_multiuse_thm'
[bv] [0.046815] Normalizing goal
  [Meta.synthInstance] [0.001876] ✅️ Decidable
        ((if 10#32 = 0 then none else some (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝ / 10#32)) ⊑
          if 10#32 = 0 then none
          else
            if
                True ∧
                  (BitVec.zeroExtend 32 x✝ / 10#32).msb = (BitVec.zeroExtend 32 x✝).msb ∧
                    (BitVec.zeroExtend 32 x✝ / 10#32 + BitVec.zeroExtend 32 x✝).msb ≠
                      (BitVec.zeroExtend 32 x✝ / 10#32).msb then
              none
            else
              if
                  True ∧
                    (BitVec.zeroExtend 32 x✝ / 10#32 + BitVec.zeroExtend 32 x✝ < BitVec.zeroExtend 32 x✝ / 10#32 ∨
                      BitVec.zeroExtend 32 x✝ / 10#32 + BitVec.zeroExtend 32 x✝ < BitVec.zeroExtend 32 x✝) then
                none
              else some (BitVec.zeroExtend 32 x✝ / 10#32 + BitVec.zeroExtend 32 x✝))
    [Meta.check] [0.001025] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if 10#32 = 0 then none else some (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝ / 10#32))
          (if 10#32 = 0 then none
          else
            if
                True ∧
                  (BitVec.zeroExtend 32 x✝ / 10#32).msb = (BitVec.zeroExtend 32 x✝).msb ∧
                    (BitVec.zeroExtend 32 x✝ / 10#32 + BitVec.zeroExtend 32 x✝).msb ≠
                      (BitVec.zeroExtend 32 x✝ / 10#32).msb then
              none
            else
              if
                  True ∧
                    (BitVec.zeroExtend 32 x✝ / 10#32 + BitVec.zeroExtend 32 x✝ < BitVec.zeroExtend 32 x✝ / 10#32 ∨
                      BitVec.zeroExtend 32 x✝ / 10#32 + BitVec.zeroExtend 32 x✝ < BitVec.zeroExtend 32 x✝) then
                none
              else some (BitVec.zeroExtend 32 x✝ / 10#32 + BitVec.zeroExtend 32 x✝))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if 10#32 = 0 then none else some (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝ / 10#32)) ⊑
            if 10#32 = 0 then none
            else
              if
                  True ∧
                    (BitVec.zeroExtend 32 x✝ / 10#32).msb = (BitVec.zeroExtend 32 x✝).msb ∧
                      (BitVec.zeroExtend 32 x✝ / 10#32 + BitVec.zeroExtend 32 x✝).msb ≠
                        (BitVec.zeroExtend 32 x✝ / 10#32).msb then
                none
              else
                if
                    True ∧
                      (BitVec.zeroExtend 32 x✝ / 10#32 + BitVec.zeroExtend 32 x✝ < BitVec.zeroExtend 32 x✝ / 10#32 ∨
                        BitVec.zeroExtend 32 x✝ / 10#32 + BitVec.zeroExtend 32 x✝ < BitVec.zeroExtend 32 x✝) then
                  none
                else some (BitVec.zeroExtend 32 x✝ / 10#32 + BitVec.zeroExtend 32 x✝)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬some (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝ / 10#32) ⊑
            if
                ((BitVec.zeroExtend 32 x✝ / 10#32).getLsbD 31 == (BitVec.zeroExtend 32 x✝).getLsbD 31 &&
                    !(BitVec.zeroExtend 32 x✝ / 10#32 + BitVec.zeroExtend 32 x✝).getLsbD 31 ==
                        (BitVec.zeroExtend 32 x✝ / 10#32).getLsbD 31) =
                  true then
              none
            else
              if
                  (!((!BitVec.zeroExtend 32 x✝ / 10#32 >ᵤ BitVec.zeroExtend 32 x✝ / 10#32 + BitVec.zeroExtend 32 x✝) &&
                        !BitVec.zeroExtend 32 x✝ >ᵤ BitVec.zeroExtend 32 x✝ / 10#32 + BitVec.zeroExtend 32 x✝)) =
                    true then
                none
              else some (BitVec.zeroExtend 32 x✝ / 10#32 + BitVec.zeroExtend 32 x✝)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gudivremhchangehwidth_proof.lean:114:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gudivremhchangehwidth_proof.lean:109:8: error: (kernel) declaration has metavariables 'udiv_illegal_type_c_thm'
[bv] [0.015668] Normalizing goal
  [Meta.synthInstance] [0.001694] ✅️ Decidable
        ((if 10#32 = 0 then none else some (BitVec.zeroExtend 32 x✝ / 10#32)) ⊑
          if 10#9 = 0 then none else some (BitVec.zeroExtend 32 (x✝ / 10#9)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 9
      x✝ : BitVec 9
      a✝ :
        ¬(if 10#32 = 0 then none else some (BitVec.zeroExtend 32 x✝ / 10#32)) ⊑
            if 10#9 = 0 then none else some (BitVec.zeroExtend 32 (x✝ / 10#9))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 9
      x✝ : BitVec 9
      a✝ : ¬some (BitVec.zeroExtend 32 x✝ / 10#32) ⊑ some (BitVec.zeroExtend 32 (x✝ / 10#9))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gudivremhchangehwidth_proof.lean:123:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gudivremhchangehwidth_proof.lean:118:8: error: (kernel) declaration has metavariables 'urem_i32_c_thm'
[bv] [0.015094] Normalizing goal
  [Meta.synthInstance] [0.001703] ✅️ Decidable
        ((if 10#32 = 0 then none else some (BitVec.zeroExtend 32 x✝ % 10#32)) ⊑
          if 10#8 = 0 then none else some (BitVec.zeroExtend 32 (x✝ % 10#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if 10#32 = 0 then none else some (BitVec.zeroExtend 32 x✝ % 10#32)) ⊑
            if 10#8 = 0 then none else some (BitVec.zeroExtend 32 (x✝ % 10#8))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ : ¬some (BitVec.zeroExtend 32 x✝ % 10#32) ⊑ some (BitVec.zeroExtend 32 (x✝ % 10#8))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gudivremhchangehwidth_proof.lean:134:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gudivremhchangehwidth_proof.lean:127:8: error: (kernel) declaration has metavariables 'urem_i32_c_multiuse_thm'
[bv] [0.033079] Normalizing goal
  [Meta.synthInstance] [0.001381] ✅️ Decidable
        ((if 10#32 = 0 then none else some (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝ % 10#32)) ⊑
          if 10#32 = 0 then none
          else
            if
                True ∧
                  (BitVec.zeroExtend 32 x✝ % 10#32).msb = (BitVec.zeroExtend 32 x✝).msb ∧
                    (BitVec.zeroExtend 32 x✝ % 10#32 + BitVec.zeroExtend 32 x✝).msb ≠
                      (BitVec.zeroExtend 32 x✝ % 10#32).msb then
              none
            else
              if
                  True ∧
                    (BitVec.zeroExtend 32 x✝ % 10#32 + BitVec.zeroExtend 32 x✝ < BitVec.zeroExtend 32 x✝ % 10#32 ∨
                      BitVec.zeroExtend 32 x✝ % 10#32 + BitVec.zeroExtend 32 x✝ < BitVec.zeroExtend 32 x✝) then
                none
              else some (BitVec.zeroExtend 32 x✝ % 10#32 + BitVec.zeroExtend 32 x✝))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if 10#32 = 0 then none else some (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝ % 10#32)) ⊑
            if 10#32 = 0 then none
            else
              if
                  True ∧
                    (BitVec.zeroExtend 32 x✝ % 10#32).msb = (BitVec.zeroExtend 32 x✝).msb ∧
                      (BitVec.zeroExtend 32 x✝ % 10#32 + BitVec.zeroExtend 32 x✝).msb ≠
                        (BitVec.zeroExtend 32 x✝ % 10#32).msb then
                none
              else
                if
                    True ∧
                      (BitVec.zeroExtend 32 x✝ % 10#32 + BitVec.zeroExtend 32 x✝ < BitVec.zeroExtend 32 x✝ % 10#32 ∨
                        BitVec.zeroExtend 32 x✝ % 10#32 + BitVec.zeroExtend 32 x✝ < BitVec.zeroExtend 32 x✝) then
                  none
                else some (BitVec.zeroExtend 32 x✝ % 10#32 + BitVec.zeroExtend 32 x✝)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬some (BitVec.zeroExtend 32 x✝ + BitVec.zeroExtend 32 x✝ % 10#32) ⊑
            if
                ((BitVec.zeroExtend 32 x✝ % 10#32).getLsbD 31 == (BitVec.zeroExtend 32 x✝).getLsbD 31 &&
                    !(BitVec.zeroExtend 32 x✝ % 10#32 + BitVec.zeroExtend 32 x✝).getLsbD 31 ==
                        (BitVec.zeroExtend 32 x✝ % 10#32).getLsbD 31) =
                  true then
              none
            else
              if
                  (!((!BitVec.zeroExtend 32 x✝ % 10#32 >ᵤ BitVec.zeroExtend 32 x✝ % 10#32 + BitVec.zeroExtend 32 x✝) &&
                        !BitVec.zeroExtend 32 x✝ >ᵤ BitVec.zeroExtend 32 x✝ % 10#32 + BitVec.zeroExtend 32 x✝)) =
                    true then
                none
              else some (BitVec.zeroExtend 32 x✝ % 10#32 + BitVec.zeroExtend 32 x✝)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gudivremhchangehwidth_proof.lean:143:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gudivremhchangehwidth_proof.lean:138:8: error: (kernel) declaration has metavariables 'urem_illegal_type_c_thm'
[bv] [0.009429] Normalizing goal
  [Meta.synthInstance] [0.001058] ✅️ Decidable
        ((if 10#32 = 0 then none else some (BitVec.zeroExtend 32 x✝ % 10#32)) ⊑
          if 10#9 = 0 then none else some (BitVec.zeroExtend 32 (x✝ % 10#9)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 9
      x✝ : BitVec 9
      a✝ :
        ¬(if 10#32 = 0 then none else some (BitVec.zeroExtend 32 x✝ % 10#32)) ⊑
            if 10#9 = 0 then none else some (BitVec.zeroExtend 32 (x✝ % 10#9))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 9
      x✝ : BitVec 9
      a✝ : ¬some (BitVec.zeroExtend 32 x✝ % 10#32) ⊑ some (BitVec.zeroExtend 32 (x✝ % 10#9))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gudivremhchangehwidth_proof.lean:152:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gudivremhchangehwidth_proof.lean:147:8: error: (kernel) declaration has metavariables 'udiv_c_i32_thm'
[bv] [0.021067] Normalizing goal
  [Meta.synthInstance] [0.001006] ✅️ Decidable
        ((if BitVec.zeroExtend 32 x✝ = 0 then none else some (10#32 / BitVec.zeroExtend 32 x✝)) ⊑
          if x✝ = 0 then none else some (BitVec.zeroExtend 32 (10#8 / x✝)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if BitVec.zeroExtend 32 x✝ = 0 then none else some (10#32 / BitVec.zeroExtend 32 x✝)) ⊑
            if x✝ = 0 then none else some (BitVec.zeroExtend 32 (10#8 / x✝))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if (BitVec.zeroExtend 32 x✝ == 0#32) = true then none else some (10#32 / BitVec.zeroExtend 32 x✝)) ⊑
            if (x✝ == 0#8) = true then none else some (BitVec.zeroExtend 32 (10#8 / x✝))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gudivremhchangehwidth_proof.lean:161:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gudivremhchangehwidth_proof.lean:156:8: error: (kernel) declaration has metavariables 'urem_c_i32_thm'
[bv] [0.023142] Normalizing goal
  [Meta.synthInstance] [0.001033] ✅️ Decidable
        ((if BitVec.zeroExtend 32 x✝ = 0 then none else some (10#32 % BitVec.zeroExtend 32 x✝)) ⊑
          if x✝ = 0 then none else some (BitVec.zeroExtend 32 (10#8 % x✝)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if BitVec.zeroExtend 32 x✝ = 0 then none else some (10#32 % BitVec.zeroExtend 32 x✝)) ⊑
            if x✝ = 0 then none else some (BitVec.zeroExtend 32 (10#8 % x✝))
      ⊢ False
  [Meta.appBuilder] [0.002062] ✅️ f: Subsingleton.elim, xs: [h✝, h]
    [Meta.synthInstance] [0.002018] ✅️ Subsingleton (Decidable c✝)
      [Meta.synthInstance] [0.001956] ✅️ apply instSubsingletonDecidable to Subsingleton (Decidable c✝)
        [Meta.synthInstance.tryResolve] [0.001930] ✅️ Subsingleton (Decidable c✝) ≟ Subsingleton (Decidable c✝)
          [Meta.isDefEq] [0.001885] ✅️ ?m.134115 =?= instSubsingletonDecidable c✝
            [Meta.isDefEq.assign] [0.001881] ✅️ ?m.134115 := instSubsingletonDecidable c✝
              [Meta.isDefEq.assign.checkTypes] [0.001868] ✅️ (?m.134115 : Subsingleton
                    (Decidable c✝)) := (instSubsingletonDecidable c✝ : Subsingleton (Decidable c✝))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if (BitVec.zeroExtend 32 x✝ == 0#32) = true then none else some (10#32 % BitVec.zeroExtend 32 x✝)) ⊑
            if (x✝ == 0#8) = true then none else some (BitVec.zeroExtend 32 (10#8 % x✝))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
