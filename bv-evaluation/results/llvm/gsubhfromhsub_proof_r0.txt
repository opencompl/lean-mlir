⚠ [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
⚠ [878/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [881/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
⚠ [887/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
⚠ [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
Bitwuzla proved the goal after 103.686549ms, solving context: 0.000000ms
LeanSAT proved the goal after 239.745669ms: rewriting 47.486470ms, bitblasting 0.000000ms, SAT solving 110.884830ms, LRAT trimming 40.730620ms, LRAT checking 37.524539ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhfromhsub_proof.lean:27:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhfromhsub_proof.lean:27:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhfromhsub_proof.lean:20:8: error: (kernel) declaration has metavariables 't1_flags_thm'
[bv] [0.110186] Normalizing goal
  [Meta.synthInstance] [0.001864] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (8 + 1) x✝ - BitVec.signExtend (8 + 1) x✝¹).msb ≠
                  (BitVec.signExtend (8 + 1) x✝ - BitVec.signExtend (8 + 1) x✝¹).getMsbD 1 then
            none
          else
            if True ∧ x✝ < x✝¹ then none
            else
              if
                  True ∧
                    (BitVec.signExtend (8 + 1) (x✝ - x✝¹) - BitVec.signExtend (8 + 1) x✝²).msb ≠
                      (BitVec.signExtend (8 + 1) (x✝ - x✝¹) - BitVec.signExtend (8 + 1) x✝²).getMsbD 1 then
                none
              else if True ∧ x✝ - x✝¹ < x✝² then none else some (x✝ - x✝¹ - x✝²)) ⊑
          if True ∧ x✝¹.msb = x✝².msb ∧ (x✝¹ + x✝²).msb ≠ x✝¹.msb then none
          else
            if True ∧ (x✝¹ + x✝² < x✝¹ ∨ x✝¹ + x✝² < x✝²) then none
            else
              if
                  True ∧
                    (BitVec.signExtend (8 + 1) x✝ - BitVec.signExtend (8 + 1) (x✝¹ + x✝²)).msb ≠
                      (BitVec.signExtend (8 + 1) x✝ - BitVec.signExtend (8 + 1) (x✝¹ + x✝²)).getMsbD 1 then
                none
              else if True ∧ x✝ < x✝¹ + x✝² then none else some (x✝ - (x✝¹ + x✝²)))
    [Meta.check] [0.001230] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if
              True ∧
                (BitVec.signExtend (8 + 1) x✝ - BitVec.signExtend (8 + 1) x✝¹).msb ≠
                  (BitVec.signExtend (8 + 1) x✝ - BitVec.signExtend (8 + 1) x✝¹).getMsbD 1 then
            none
          else
            if True ∧ x✝ < x✝¹ then none
            else
              if
                  True ∧
                    (BitVec.signExtend (8 + 1) (x✝ - x✝¹) - BitVec.signExtend (8 + 1) x✝²).msb ≠
                      (BitVec.signExtend (8 + 1) (x✝ - x✝¹) - BitVec.signExtend (8 + 1) x✝²).getMsbD 1 then
                none
              else if True ∧ x✝ - x✝¹ < x✝² then none else some (x✝ - x✝¹ - x✝²))
          (if True ∧ x✝¹.msb = x✝².msb ∧ (x✝¹ + x✝²).msb ≠ x✝¹.msb then none
          else
            if True ∧ (x✝¹ + x✝² < x✝¹ ∨ x✝¹ + x✝² < x✝²) then none
            else
              if
                  True ∧
                    (BitVec.signExtend (8 + 1) x✝ - BitVec.signExtend (8 + 1) (x✝¹ + x✝²)).msb ≠
                      (BitVec.signExtend (8 + 1) x✝ - BitVec.signExtend (8 + 1) (x✝¹ + x✝²)).getMsbD 1 then
                none
              else if True ∧ x✝ < x✝¹ + x✝² then none else some (x✝ - (x✝¹ + x✝²)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x✝² x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (8 + 1) x✝ - BitVec.signExtend (8 + 1) x✝¹).msb ≠
                    (BitVec.signExtend (8 + 1) x✝ - BitVec.signExtend (8 + 1) x✝¹).getMsbD 1 then
              none
            else
              if True ∧ x✝ < x✝¹ then none
              else
                if
                    True ∧
                      (BitVec.signExtend (8 + 1) (x✝ - x✝¹) - BitVec.signExtend (8 + 1) x✝²).msb ≠
                        (BitVec.signExtend (8 + 1) (x✝ - x✝¹) - BitVec.signExtend (8 + 1) x✝²).getMsbD 1 then
                  none
                else if True ∧ x✝ - x✝¹ < x✝² then none else some (x✝ - x✝¹ - x✝²)) ⊑
            if True ∧ x✝¹.msb = x✝².msb ∧ (x✝¹ + x✝²).msb ≠ x✝¹.msb then none
            else
              if True ∧ (x✝¹ + x✝² < x✝¹ ∨ x✝¹ + x✝² < x✝²) then none
              else
                if
                    True ∧
                      (BitVec.signExtend (8 + 1) x✝ - BitVec.signExtend (8 + 1) (x✝¹ + x✝²)).msb ≠
                        (BitVec.signExtend (8 + 1) x✝ - BitVec.signExtend (8 + 1) (x✝¹ + x✝²)).getMsbD 1 then
                  none
                else if True ∧ x✝ < x✝¹ + x✝² then none else some (x✝ - (x✝¹ + x✝²))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x✝² x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                (!(BitVec.signExtend 9 x✝ + (~~~BitVec.signExtend 9 x✝¹ + 1#9)).getLsbD 8 ==
                      (BitVec.signExtend 9 x✝ + (~~~BitVec.signExtend 9 x✝¹ + 1#9)).getMsbD 1) =
                  true then
              none
            else
              if (x✝¹ >ᵤ x✝) = true then none
              else
                if
                    (!(BitVec.signExtend 9 (x✝ + (~~~x✝¹ + 1#8)) + (~~~BitVec.signExtend 9 x✝² + 1#9)).getLsbD 8 ==
                          (BitVec.signExtend 9 (x✝ + (~~~x✝¹ + 1#8)) + (~~~BitVec.signExtend 9 x✝² + 1#9)).getMsbD 1) =
                      true then
                  none
                else
                  if (x✝² >ᵤ x✝ + (~~~x✝¹ + 1#8)) = true then none else some (x✝ + (~~~x✝¹ + 1#8) + (~~~x✝² + 1#8))) ⊑
            if (x✝¹.getLsbD 7 == x✝².getLsbD 7 && !(x✝¹ + x✝²).getLsbD 7 == x✝¹.getLsbD 7) = true then none
            else
              if (!((!x✝¹ >ᵤ x✝¹ + x✝²) && !x✝² >ᵤ x✝¹ + x✝²)) = true then none
              else
                if
                    (!(BitVec.signExtend 9 x✝ + (~~~BitVec.signExtend 9 (x✝¹ + x✝²) + 1#9)).getLsbD 8 ==
                          (BitVec.signExtend 9 x✝ + (~~~BitVec.signExtend 9 (x✝¹ + x✝²) + 1#9)).getMsbD 1) =
                      true then
                  none
                else if (x✝¹ + x✝² >ᵤ x✝) = true then none else some (x✝ + (~~~(x✝¹ + x✝²) + 1#8))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhfromhsub_proof.lean:38:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhfromhsub_proof.lean:38:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhfromhsub_proof.lean:31:8: error: (kernel) declaration has metavariables 't1_flags_nuw_only_thm'
[bv] [0.062267] Normalizing goal
  [Meta.synthInstance] [0.001531] ✅️ Decidable
        ((if True ∧ x✝ < x✝¹ then none else if True ∧ x✝ - x✝¹ < x✝² then none else some (x✝ - x✝¹ - x✝²)) ⊑
          if True ∧ (x✝¹ + x✝² < x✝¹ ∨ x✝¹ + x✝² < x✝²) then none
          else if True ∧ x✝ < x✝¹ + x✝² then none else some (x✝ - (x✝¹ + x✝²)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x✝² x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if True ∧ x✝ < x✝¹ then none else if True ∧ x✝ - x✝¹ < x✝² then none else some (x✝ - x✝¹ - x✝²)) ⊑
            if True ∧ (x✝¹ + x✝² < x✝¹ ∨ x✝¹ + x✝² < x✝²) then none
            else if True ∧ x✝ < x✝¹ + x✝² then none else some (x✝ - (x✝¹ + x✝²))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x✝² x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if (x✝¹ >ᵤ x✝) = true then none
            else if (x✝² >ᵤ x✝ + (~~~x✝¹ + 1#8)) = true then none else some (x✝ + (~~~x✝¹ + 1#8) + (~~~x✝² + 1#8))) ⊑
            if (!((!x✝¹ >ᵤ x✝¹ + x✝²) && !x✝² >ᵤ x✝¹ + x✝²)) = true then none
            else if (x✝¹ + x✝² >ᵤ x✝) = true then none else some (x✝ + (~~~(x✝¹ + x✝²) + 1#8))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhfromhsub_proof.lean:48:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhfromhsub_proof.lean:48:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhfromhsub_proof.lean:42:8: error: (kernel) declaration has metavariables 't1_flags_sub_nsw_sub_thm'
[bv] [0.039399] Normalizing goal
  [Meta.synthInstance] [0.001023] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (8 + 1) x✝ - BitVec.signExtend (8 + 1) x✝¹).msb ≠
                  (BitVec.signExtend (8 + 1) x✝ - BitVec.signExtend (8 + 1) x✝¹).getMsbD 1 then
            none
          else some (x✝ - x✝¹ - x✝²)) ⊑
          some (x✝ - (x✝¹ + x✝²)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x✝² x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (8 + 1) x✝ - BitVec.signExtend (8 + 1) x✝¹).msb ≠
                    (BitVec.signExtend (8 + 1) x✝ - BitVec.signExtend (8 + 1) x✝¹).getMsbD 1 then
              none
            else some (x✝ - x✝¹ - x✝²)) ⊑
            some (x✝ - (x✝¹ + x✝²))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x✝² x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                (!(BitVec.signExtend 9 x✝ + (~~~BitVec.signExtend 9 x✝¹ + 1#9)).getLsbD 8 ==
                      (BitVec.signExtend 9 x✝ + (~~~BitVec.signExtend 9 x✝¹ + 1#9)).getMsbD 1) =
                  true then
              none
            else some (x✝ + (~~~x✝¹ + 1#8) + (~~~x✝² + 1#8))) ⊑
            some (x✝ + (~~~(x✝¹ + x✝²) + 1#8))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhfromhsub_proof.lean:58:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhfromhsub_proof.lean:58:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhfromhsub_proof.lean:52:8: error: (kernel) declaration has metavariables 't1_flags_nuw_first_thm'
[bv] [0.028568] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x✝² x✝¹ x✝ : BitVec 8
      a✝ : ¬(if True ∧ x✝ < x✝¹ then none else some (x✝ - x✝¹ - x✝²)) ⊑ some (x✝ - (x✝¹ + x✝²))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x✝² x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if (x✝¹ >ᵤ x✝) = true then none else some (x✝ + (~~~x✝¹ + 1#8) + (~~~x✝² + 1#8))) ⊑
            some (x✝ + (~~~(x✝¹ + x✝²) + 1#8))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhfromhsub_proof.lean:68:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhfromhsub_proof.lean:62:8: error: (kernel) declaration has metavariables 't1_flags_nuw_second_thm'
[bv] [0.029068] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x✝² x✝¹ x✝ : BitVec 8
      a✝ : ¬(if True ∧ x✝ - x✝¹ < x✝² then none else some (x✝ - x✝¹ - x✝²)) ⊑ some (x✝ - (x✝¹ + x✝²))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x✝² x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if (x✝² >ᵤ x✝ + (~~~x✝¹ + 1#8)) = true then none else some (x✝ + (~~~x✝¹ + 1#8) + (~~~x✝² + 1#8))) ⊑
            some (x✝ + (~~~(x✝¹ + x✝²) + 1#8))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhfromhsub_proof.lean:78:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhfromhsub_proof.lean:78:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhfromhsub_proof.lean:72:8: error: (kernel) declaration has metavariables 't1_flags_nuw_nsw_first_thm'
[bv] [0.045554] Normalizing goal
  [Meta.synthInstance] [0.001079] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (8 + 1) x✝ - BitVec.signExtend (8 + 1) x✝¹).msb ≠
                  (BitVec.signExtend (8 + 1) x✝ - BitVec.signExtend (8 + 1) x✝¹).getMsbD 1 then
            none
          else if True ∧ x✝ < x✝¹ then none else some (x✝ - x✝¹ - x✝²)) ⊑
          some (x✝ - (x✝¹ + x✝²)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x✝² x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (8 + 1) x✝ - BitVec.signExtend (8 + 1) x✝¹).msb ≠
                    (BitVec.signExtend (8 + 1) x✝ - BitVec.signExtend (8 + 1) x✝¹).getMsbD 1 then
              none
            else if True ∧ x✝ < x✝¹ then none else some (x✝ - x✝¹ - x✝²)) ⊑
            some (x✝ - (x✝¹ + x✝²))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x✝² x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                (!(BitVec.signExtend 9 x✝ + (~~~BitVec.signExtend 9 x✝¹ + 1#9)).getLsbD 8 ==
                      (BitVec.signExtend 9 x✝ + (~~~BitVec.signExtend 9 x✝¹ + 1#9)).getMsbD 1) =
                  true then
              none
            else if (x✝¹ >ᵤ x✝) = true then none else some (x✝ + (~~~x✝¹ + 1#8) + (~~~x✝² + 1#8))) ⊑
            some (x✝ + (~~~(x✝¹ + x✝²) + 1#8))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhfromhsub_proof.lean:88:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhfromhsub_proof.lean:82:8: error: (kernel) declaration has metavariables 't1_flags_nuw_nsw_second_thm'
[bv] [0.056107] Normalizing goal
  [Meta.synthInstance] [0.001651] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (8 + 1) (x✝ - x✝¹) - BitVec.signExtend (8 + 1) x✝²).msb ≠
                  (BitVec.signExtend (8 + 1) (x✝ - x✝¹) - BitVec.signExtend (8 + 1) x✝²).getMsbD 1 then
            none
          else if True ∧ x✝ - x✝¹ < x✝² then none else some (x✝ - x✝¹ - x✝²)) ⊑
          some (x✝ - (x✝¹ + x✝²)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x✝² x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (8 + 1) (x✝ - x✝¹) - BitVec.signExtend (8 + 1) x✝²).msb ≠
                    (BitVec.signExtend (8 + 1) (x✝ - x✝¹) - BitVec.signExtend (8 + 1) x✝²).getMsbD 1 then
              none
            else if True ∧ x✝ - x✝¹ < x✝² then none else some (x✝ - x✝¹ - x✝²)) ⊑
            some (x✝ - (x✝¹ + x✝²))
      ⊢ False
  [Meta.isDefEq] [0.001018] ❌️ ?a ==
        ?a =?= (BitVec.signExtend 9 (x✝ + (~~~x✝¹ + 1#8)) + (~~~BitVec.signExtend 9 x✝² + 1#9)).getLsbD 8 ==
        (BitVec.signExtend 9 (x✝ + (~~~x✝¹ + 1#8)) + (~~~BitVec.signExtend 9 x✝² + 1#9)).getMsbD 1
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x✝² x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                (!(BitVec.signExtend 9 (x✝ + (~~~x✝¹ + 1#8)) + (~~~BitVec.signExtend 9 x✝² + 1#9)).getLsbD 8 ==
                      (BitVec.signExtend 9 (x✝ + (~~~x✝¹ + 1#8)) + (~~~BitVec.signExtend 9 x✝² + 1#9)).getMsbD 1) =
                  true then
              none
            else if (x✝² >ᵤ x✝ + (~~~x✝¹ + 1#8)) = true then none else some (x✝ + (~~~x✝¹ + 1#8) + (~~~x✝² + 1#8))) ⊑
            some (x✝ + (~~~(x✝¹ + x✝²) + 1#8))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 89.291019ms, solving context: 4.000000ms
LeanSAT proved the goal after 170.928390ms: rewriting 26.640650ms, bitblasting 0.000000ms, SAT solving 109.790810ms, LRAT trimming 10.143410ms, LRAT checking 20.229300ms
Bitwuzla proved the goal after 17.223229ms, solving context: 0.000000ms
LeanSAT proved the goal after 15.009320ms: rewriting 14.994060ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 14.114669ms, solving context: 0.000000ms
LeanSAT proved the goal after 13.705860ms: rewriting 13.684580ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 18.887820ms, solving context: 0.000000ms
LeanSAT proved the goal after 17.352820ms: rewriting 17.334500ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 77.614470ms, solving context: 0.000000ms
LeanSAT proved the goal after 86.319010ms: rewriting 23.256260ms, bitblasting 0.000000ms, SAT solving 60.190919ms, LRAT trimming 0.000000ms, LRAT checking 1.500381ms
