⚠ [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
⚠ [878/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [881/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
⚠ [887/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
⚠ [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcanonicalizehshlhlshrhtohmasking_proof.lean:16:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcanonicalizehshlhlshrhtohmasking_proof.lean:11:8: error: (kernel) declaration has metavariables 'positive_samevar_thm'
[bv] [0.026854] Normalizing goal
  [Meta.synthInstance] [0.001273] ✅️ Decidable
        ((if x✝¹ ≥ ↑32 then none else if x✝¹ ≥ ↑32 then none else some (x✝ <<< x✝¹ >>> x✝¹)) ⊑
          if x✝¹ ≥ ↑32 then none else some ((-1#32) >>> x✝¹ &&& x✝))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if x✝¹ ≥ ↑32 then none else if x✝¹ ≥ ↑32 then none else some (x✝ <<< x✝¹ >>> x✝¹)) ⊑
            if x✝¹ ≥ ↑32 then none else some ((-1#32) >>> x✝¹ &&& x✝)
      ⊢ False
  [Meta.isDefEq] [0.001146] ✅️ ?h₃ =?= fun a => Eq.refl (some (4294967295#32 >>> x✝¹ &&& x✝))
    [Meta.isDefEq.assign] [0.001143] ✅️ ?h₃ := fun a => Eq.refl (some (4294967295#32 >>> x✝¹ &&& x✝))
      [Meta.isDefEq.assign.checkTypes] [0.001119] ✅️ (?h₃ : ¬(!32#32 >ᵤ x✝¹) = true →
            some ((-1#32) >>> x✝¹ &&& x✝) =
              some
                (4294967295#32 >>> x✝¹ &&&
                  x✝)) := (fun a =>
            Eq.refl
              (some
                (4294967295#32 >>> x✝¹ &&&
                  x✝)) : ¬(!32#32 >ᵤ x✝¹) = true →
            some (4294967295#32 >>> x✝¹ &&& x✝) = some (4294967295#32 >>> x✝¹ &&& x✝))
        [Meta.isDefEq] [0.001115] ✅️ ¬(!32#32 >ᵤ x✝¹) = true →
              some ((-1#32) >>> x✝¹ &&& x✝) =
                some
                  (4294967295#32 >>> x✝¹ &&&
                    x✝) =?= ¬(!32#32 >ᵤ x✝¹) = true →
              some (4294967295#32 >>> x✝¹ &&& x✝) = some (4294967295#32 >>> x✝¹ &&& x✝)
          [Meta.isDefEq] [0.001083] ✅️ some ((-1#32) >>> x✝¹ &&& x✝) =
                some
                  (4294967295#32 >>> x✝¹ &&&
                    x✝) =?= some (4294967295#32 >>> x✝¹ &&& x✝) = some (4294967295#32 >>> x✝¹ &&& x✝)
            [Meta.isDefEq] [0.001065] ✅️ some ((-1#32) >>> x✝¹ &&& x✝) =?= some (4294967295#32 >>> x✝¹ &&& x✝)
              [Meta.isDefEq] [0.001042] ✅️ (-1#32) >>> x✝¹ &&& x✝ =?= 4294967295#32 >>> x✝¹ &&& x✝
                [Meta.isDefEq] [0.001013] ✅️ instHAndOfAndOp.1 ((-1#32) >>> x✝¹)
                      x✝ =?= instHAndOfAndOp.1 (4294967295#32 >>> x✝¹) x✝
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!32#32 >ᵤ x✝¹) = true then none else if (!32#32 >ᵤ x✝¹) = true then none else some (x✝ <<< x✝¹ >>> x✝¹)) ⊑
            if (!32#32 >ᵤ x✝¹) = true then none else some (4294967295#32 >>> x✝¹ &&& x✝)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcanonicalizehshlhlshrhtohmasking_proof.lean:25:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcanonicalizehshlhlshrhtohmasking_proof.lean:20:8: error: (kernel) declaration has metavariables 'positive_sameconst_thm'
[bv] [0.012416] Normalizing goal
  [Meta.synthInstance] [0.001548] ✅️ Decidable
        ((if 5#32 ≥ ↑32 then none else if 5#32 ≥ ↑32 then none else some (x✝ <<< 5#32 >>> 5#32)) ⊑
          some (x✝ &&& 134217727#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if 5#32 ≥ ↑32 then none else if 5#32 ≥ ↑32 then none else some (x✝ <<< 5#32 >>> 5#32)) ⊑
            some (x✝ &&& 134217727#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ : ¬some (x✝ <<< 5 >>> 5) ⊑ some (x✝ &&& 134217727#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcanonicalizehshlhlshrhtohmasking_proof.lean:35:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcanonicalizehshlhlshrhtohmasking_proof.lean:29:8: error: (kernel) declaration has metavariables 'positive_biggerShl_thm'
[bv] [0.017627] Normalizing goal
  [Meta.synthInstance] [0.001808] ✅️ Decidable
        ((if 10#32 ≥ ↑32 then none else if 5#32 ≥ ↑32 then none else some (x✝ <<< 10#32 >>> 5#32)) ⊑
          if 5#32 ≥ ↑32 then none else some (x✝ <<< 5#32 &&& 134217696#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if 10#32 ≥ ↑32 then none else if 5#32 ≥ ↑32 then none else some (x✝ <<< 10#32 >>> 5#32)) ⊑
            if 5#32 ≥ ↑32 then none else some (x✝ <<< 5#32 &&& 134217696#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ : ¬some (x✝ <<< 10 >>> 5) ⊑ some (x✝ <<< 5 &&& 134217696#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcanonicalizehshlhlshrhtohmasking_proof.lean:45:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcanonicalizehshlhlshrhtohmasking_proof.lean:39:8: error: (kernel) declaration has metavariables 'positive_biggerLshr_thm'
[bv] [0.014733] Normalizing goal
  [Meta.synthInstance] [0.001180] ✅️ Decidable
        ((if 5#32 ≥ ↑32 then none else if 10#32 ≥ ↑32 then none else some (x✝ <<< 5#32 >>> 10#32)) ⊑
          if 5#32 ≥ ↑32 then none else some (x✝ >>> 5#32 &&& 4194303#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if 5#32 ≥ ↑32 then none else if 10#32 ≥ ↑32 then none else some (x✝ <<< 5#32 >>> 10#32)) ⊑
            if 5#32 ≥ ↑32 then none else some (x✝ >>> 5#32 &&& 4194303#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ : ¬some (x✝ <<< 5 >>> 10) ⊑ some (x✝ >>> 5 &&& 4194303#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcanonicalizehshlhlshrhtohmasking_proof.lean:55:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcanonicalizehshlhlshrhtohmasking_proof.lean:49:8: error: (kernel) declaration has metavariables 'positive_biggerLshr_lshrexact_thm'
[bv] [0.019466] Normalizing goal
  [Meta.synthInstance] [0.002051] ✅️ Decidable
        ((if 5#32 ≥ ↑32 then none else if 10#32 ≥ ↑32 then none else some (x✝ <<< 5#32 >>> 10#32)) ⊑
          if 5#32 ≥ ↑32 then none else some (x✝ >>> 5#32 &&& 4194303#32))
    [Meta.check] [0.001026] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if 5#32 ≥ ↑32 then none else if 10#32 ≥ ↑32 then none else some (x✝ <<< 5#32 >>> 10#32))
          (if 5#32 ≥ ↑32 then none else some (x✝ >>> 5#32 &&& 4194303#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if 5#32 ≥ ↑32 then none else if 10#32 ≥ ↑32 then none else some (x✝ <<< 5#32 >>> 10#32)) ⊑
            if 5#32 ≥ ↑32 then none else some (x✝ >>> 5#32 &&& 4194303#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ : ¬some (x✝ <<< 5 >>> 10) ⊑ some (x✝ >>> 5 &&& 4194303#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcanonicalizehshlhlshrhtohmasking_proof.lean:64:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcanonicalizehshlhlshrhtohmasking_proof.lean:59:8: error: (kernel) declaration has metavariables 'positive_samevar_shlnuw_thm'
[bv] [0.041266] Normalizing goal
  [Meta.synthInstance] [0.001873] ✅️ Decidable
        ((if True ∧ x✝ <<< x✝¹ >>> x✝¹ = x✝ then none
          else if x✝¹ ≥ ↑32 then none else if x✝¹ ≥ ↑32 then none else some (x✝ <<< x✝¹ >>> x✝¹)) ⊑
          some x✝)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if True ∧ x✝ <<< x✝¹ >>> x✝¹ = x✝ then none
            else if x✝¹ ≥ ↑32 then none else if x✝¹ ≥ ↑32 then none else some (x✝ <<< x✝¹ >>> x✝¹)) ⊑
            some x✝
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (x✝ <<< x✝¹ >>> x✝¹ == x✝) = true then none
            else
              if (!32#32 >ᵤ x✝¹) = true then none
              else if (!32#32 >ᵤ x✝¹) = true then none else some (x✝ <<< x✝¹ >>> x✝¹)) ⊑
            some x✝
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcanonicalizehshlhlshrhtohmasking_proof.lean:74:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcanonicalizehshlhlshrhtohmasking_proof.lean:68:8: error: (kernel) declaration has metavariables 'positive_sameconst_shlnuw_thm'
[bv] [0.027442] Normalizing goal
  [Meta.synthInstance] [0.002016] ✅️ Decidable
        ((if True ∧ x✝ <<< 5#32 >>> 5#32 = x✝ then none
          else if 5#32 ≥ ↑32 then none else if 5#32 ≥ ↑32 then none else some (x✝ <<< 5#32 >>> 5#32)) ⊑
          some x✝)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if True ∧ x✝ <<< 5#32 >>> 5#32 = x✝ then none
            else if 5#32 ≥ ↑32 then none else if 5#32 ≥ ↑32 then none else some (x✝ <<< 5#32 >>> 5#32)) ⊑
            some x✝
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ : ¬(if (x✝ <<< 5 >>> 5 == x✝) = true then none else some (x✝ <<< 5 >>> 5)) ⊑ some x✝
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcanonicalizehshlhlshrhtohmasking_proof.lean:85:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcanonicalizehshlhlshrhtohmasking_proof.lean:78:8: error: (kernel) declaration has metavariables 'positive_biggerShl_shlnuw_thm'
[bv] [0.052579] Normalizing goal
  [Meta.synthInstance] [0.002273] ✅️ Decidable
        ((if True ∧ x✝ <<< 10#32 >>> 10#32 = x✝ then none
          else if 10#32 ≥ ↑32 then none else if 5#32 ≥ ↑32 then none else some (x✝ <<< 10#32 >>> 5#32)) ⊑
          if True ∧ (x✝ <<< 5#32).sshiftRight (5#32).toNat = x✝ then none
          else if True ∧ x✝ <<< 5#32 >>> 5#32 = x✝ then none else if 5#32 ≥ ↑32 then none else some (x✝ <<< 5#32))
    [Meta.check] [0.001281] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if True ∧ x✝ <<< 10#32 >>> 10#32 = x✝ then none
          else if 10#32 ≥ ↑32 then none else if 5#32 ≥ ↑32 then none else some (x✝ <<< 10#32 >>> 5#32))
          (if True ∧ (x✝ <<< 5#32).sshiftRight (5#32).toNat = x✝ then none
          else if True ∧ x✝ <<< 5#32 >>> 5#32 = x✝ then none else if 5#32 ≥ ↑32 then none else some (x✝ <<< 5#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if True ∧ x✝ <<< 10#32 >>> 10#32 = x✝ then none
            else if 10#32 ≥ ↑32 then none else if 5#32 ≥ ↑32 then none else some (x✝ <<< 10#32 >>> 5#32)) ⊑
            if True ∧ (x✝ <<< 5#32).sshiftRight (5#32).toNat = x✝ then none
            else if True ∧ x✝ <<< 5#32 >>> 5#32 = x✝ then none else if 5#32 ≥ ↑32 then none else some (x✝ <<< 5#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if (x✝ <<< 10 >>> 10 == x✝) = true then none else some (x✝ <<< 10 >>> 5)) ⊑
            if ((x✝ <<< 5).sshiftRight 5 == x✝) = true then none
            else if (x✝ <<< 5 >>> 5 == x✝) = true then none else some (x✝ <<< 5)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcanonicalizehshlhlshrhtohmasking_proof.lean:95:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcanonicalizehshlhlshrhtohmasking_proof.lean:89:8: error: (kernel) declaration has metavariables 'positive_biggerLshr_shlnuw_thm'
[bv] [0.033529] Normalizing goal
  [Meta.synthInstance] [0.002183] ✅️ Decidable
        ((if True ∧ x✝ <<< 5#32 >>> 5#32 = x✝ then none
          else if 5#32 ≥ ↑32 then none else if 10#32 ≥ ↑32 then none else some (x✝ <<< 5#32 >>> 10#32)) ⊑
          if 5#32 ≥ ↑32 then none else some (x✝ >>> 5#32))
    [Meta.check] [0.001196] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if True ∧ x✝ <<< 5#32 >>> 5#32 = x✝ then none
          else if 5#32 ≥ ↑32 then none else if 10#32 ≥ ↑32 then none else some (x✝ <<< 5#32 >>> 10#32))
          (if 5#32 ≥ ↑32 then none else some (x✝ >>> 5#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if True ∧ x✝ <<< 5#32 >>> 5#32 = x✝ then none
            else if 5#32 ≥ ↑32 then none else if 10#32 ≥ ↑32 then none else some (x✝ <<< 5#32 >>> 10#32)) ⊑
            if 5#32 ≥ ↑32 then none else some (x✝ >>> 5#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ : ¬(if (x✝ <<< 5 >>> 5 == x✝) = true then none else some (x✝ <<< 5 >>> 10)) ⊑ some (x✝ >>> 5)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcanonicalizehshlhlshrhtohmasking_proof.lean:105:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gcanonicalizehshlhlshrhtohmasking_proof.lean:99:8: error: (kernel) declaration has metavariables 'positive_biggerLshr_shlnuw_lshrexact_thm'
[bv] [0.025529] Normalizing goal
  [Meta.synthInstance] [0.001320] ✅️ Decidable
        ((if True ∧ x✝ <<< 5#32 >>> 5#32 = x✝ then none
          else if 5#32 ≥ ↑32 then none else if 10#32 ≥ ↑32 then none else some (x✝ <<< 5#32 >>> 10#32)) ⊑
          if 5#32 ≥ ↑32 then none else some (x✝ >>> 5#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if True ∧ x✝ <<< 5#32 >>> 5#32 = x✝ then none
            else if 5#32 ≥ ↑32 then none else if 10#32 ≥ ↑32 then none else some (x✝ <<< 5#32 >>> 10#32)) ⊑
            if 5#32 ≥ ↑32 then none else some (x✝ >>> 5#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ : ¬(if (x✝ <<< 5 >>> 5 == x✝) = true then none else some (x✝ <<< 5 >>> 10)) ⊑ some (x✝ >>> 5)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
