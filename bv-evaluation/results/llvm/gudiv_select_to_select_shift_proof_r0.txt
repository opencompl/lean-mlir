⚠ [871/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
⚠ [877/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
⚠ [884/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [887/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
⚠ [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gudiv_select_to_select_shift_proof.lean:18:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gudiv_select_to_select_shift_proof.lean:11:8: error: (kernel) declaration has metavariables 'test_thm'
[bv] [0.274623] Normalizing goal
  [Meta.synthInstance] [0.033327] ✅️ Decidable
        ((Option.bind
            (match some x✝¹ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 16#64
            | some { toFin := ⟨0, ⋯⟩ } => some 8#64)
            fun a =>
            if a = 0 then none
            else
              Option.bind
                (match some x✝¹ with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some 8#64
                | some { toFin := ⟨0, ⋯⟩ } => some 0#64)
                fun x => if x = 0 then none else some (x✝ / a + x✝ / x)) ⊑
          if 4#64 ≥ ↑64 then none
          else
            if 3#64 ≥ ↑64 then none
            else
              if True ∧ (x✝ >>> 4#64).msb = (x✝ >>> 3#64).msb ∧ (x✝ >>> 4#64 + x✝ >>> 3#64).msb ≠ (x✝ >>> 4#64).msb then
                none
              else
                if True ∧ (x✝ >>> 4#64 + x✝ >>> 3#64 < x✝ >>> 4#64 ∨ x✝ >>> 4#64 + x✝ >>> 3#64 < x✝ >>> 3#64) then none
                else some (x✝ >>> 4#64 + x✝ >>> 3#64))
    [Meta.synthInstance] [0.030381] ✅️ apply @instDecidableEqBitVec to DecidableEq (BitVec 64)
    [Meta.check] [0.002286] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (Option.bind
            (match some x✝¹ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 16#64
            | some { toFin := ⟨0, ⋯⟩ } => some 8#64)
            fun a =>
            if a = 0 then none
            else
              Option.bind
                (match some x✝¹ with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some 8#64
                | some { toFin := ⟨0, ⋯⟩ } => some 0#64)
                fun x => if x = 0 then none else some (x✝ / a + x✝ / x))
          (if 4#64 ≥ ↑64 then none
          else
            if 3#64 ≥ ↑64 then none
            else
              if True ∧ (x✝ >>> 4#64).msb = (x✝ >>> 3#64).msb ∧ (x✝ >>> 4#64 + x✝ >>> 3#64).msb ≠ (x✝ >>> 4#64).msb then
                none
              else
                if True ∧ (x✝ >>> 4#64 + x✝ >>> 3#64 < x✝ >>> 4#64 ∨ x✝ >>> 4#64 + x✝ >>> 3#64 < x✝ >>> 3#64) then none
                else some (x✝ >>> 4#64 + x✝ >>> 3#64))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 1
      e_1 : LLVM.IntW 64
      x✝¹ : BitVec 1
      x✝ : BitVec 64
      a✝ :
        ¬(Option.bind
              (match some x✝¹ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 16#64
              | some { toFin := ⟨0, ⋯⟩ } => some 8#64)
              fun a =>
              if a = 0 then none
              else
                Option.bind
                  (match some x✝¹ with
                  | none => none
                  | some { toFin := ⟨1, ⋯⟩ } => some 8#64
                  | some { toFin := ⟨0, ⋯⟩ } => some 0#64)
                  fun x => if x = 0 then none else some (x✝ / a + x✝ / x)) ⊑
            if 4#64 ≥ ↑64 then none
            else
              if 3#64 ≥ ↑64 then none
              else
                if
                    True ∧
                      (x✝ >>> 4#64).msb = (x✝ >>> 3#64).msb ∧ (x✝ >>> 4#64 + x✝ >>> 3#64).msb ≠ (x✝ >>> 4#64).msb then
                  none
                else
                  if True ∧ (x✝ >>> 4#64 + x✝ >>> 3#64 < x✝ >>> 4#64 ∨ x✝ >>> 4#64 + x✝ >>> 3#64 < x✝ >>> 3#64) then
                    none
                  else some (x✝ >>> 4#64 + x✝ >>> 3#64)
      ⊢ False
  [Meta.isDefEq] [0.001097] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝¹ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 16#64
      | some { toFin := ⟨0, ⋯⟩ } => some 8#64
  [Meta.isDefEq] [0.005030] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝¹ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 16#64
      | some { toFin := ⟨0, ⋯⟩ } => some 8#64
  [Meta.isDefEq] [0.001039] ❌️ ?a == ?a =?= a == 0#64
  [Meta.isDefEq] [0.001036] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝¹ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 8#64
      | some { toFin := ⟨0, ⋯⟩ } => some 0#64
  [Meta.isDefEq] [0.001011] ❌️ ?a == ?a =?= (x✝ >>> 4 + x✝ >>> 3).getLsbD 63 == (x✝ >>> 4).getLsbD 63
  [Meta.isDefEq] [0.001665] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (congr
              (congrArg And
                (Eq.trans
                  (congr (congrArg Eq (BitVec.msb_eq_getLsbD_last (x✝ >>> 4))) (BitVec.msb_eq_getLsbD_last (x✝ >>> 3)))
                  (Std.Tactic.BVDecide.Normalize.Bool.eq_to_beq ((x✝ >>> 4).getLsbD 63) ((x✝ >>> 3).getLsbD 63))))
              (Eq.trans
                (congr (congrArg Ne (BitVec.msb_eq_getLsbD_last (x✝ >>> 4 + x✝ >>> 3)))
                  (BitVec.msb_eq_getLsbD_last (x✝ >>> 4)))
                (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq ((x✝ >>> 4 + x✝ >>> 3).getLsbD 63)
                  ((x✝ >>> 4).getLsbD 63))))
            (Std.Tactic.BVDecide.Normalize.Bool.and_to_and ((x✝ >>> 4).getLsbD 63 == (x✝ >>> 3).getLsbD 63)
              !(x✝ >>> 4 + x✝ >>> 3).getLsbD 63 == (x✝ >>> 4).getLsbD 63)))
        (true_and
          (((x✝ >>> 4).getLsbD 63 == (x✝ >>> 3).getLsbD 63 &&
              !(x✝ >>> 4 + x✝ >>> 3).getLsbD 63 == (x✝ >>> 4).getLsbD 63) =
            true))
    [Meta.isDefEq.assign] [0.001661] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (congr
                (congrArg And
                  (Eq.trans
                    (congr (congrArg Eq (BitVec.msb_eq_getLsbD_last (x✝ >>> 4)))
                      (BitVec.msb_eq_getLsbD_last (x✝ >>> 3)))
                    (Std.Tactic.BVDecide.Normalize.Bool.eq_to_beq ((x✝ >>> 4).getLsbD 63) ((x✝ >>> 3).getLsbD 63))))
                (Eq.trans
                  (congr (congrArg Ne (BitVec.msb_eq_getLsbD_last (x✝ >>> 4 + x✝ >>> 3)))
                    (BitVec.msb_eq_getLsbD_last (x✝ >>> 4)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq ((x✝ >>> 4 + x✝ >>> 3).getLsbD 63)
                    ((x✝ >>> 4).getLsbD 63))))
              (Std.Tactic.BVDecide.Normalize.Bool.and_to_and ((x✝ >>> 4).getLsbD 63 == (x✝ >>> 3).getLsbD 63)
                !(x✝ >>> 4 + x✝ >>> 3).getLsbD 63 == (x✝ >>> 4).getLsbD 63)))
          (true_and
            (((x✝ >>> 4).getLsbD 63 == (x✝ >>> 3).getLsbD 63 &&
                !(x✝ >>> 4 + x✝ >>> 3).getLsbD 63 == (x✝ >>> 4).getLsbD 63) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.001631] ✅️ (?h₁ : (True ∧
              (x✝ >>> 4#64).msb = (x✝ >>> 3#64).msb ∧ (x✝ >>> 4#64 + x✝ >>> 3#64).msb ≠ (x✝ >>> 4#64).msb) =
            (((x✝ >>> 4).getLsbD 63 == (x✝ >>> 3).getLsbD 63 &&
                !(x✝ >>> 4 + x✝ >>> 3).getLsbD 63 == (x✝ >>> 4).getLsbD 63) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (congr
                  (congrArg And
                    (Eq.trans
                      (congr (congrArg Eq (BitVec.msb_eq_getLsbD_last (x✝ >>> 4)))
                        (BitVec.msb_eq_getLsbD_last (x✝ >>> 3)))
                      (Std.Tactic.BVDecide.Normalize.Bool.eq_to_beq ((x✝ >>> 4).getLsbD 63) ((x✝ >>> 3).getLsbD 63))))
                  (Eq.trans
                    (congr (congrArg Ne (BitVec.msb_eq_getLsbD_last (x✝ >>> 4 + x✝ >>> 3)))
                      (BitVec.msb_eq_getLsbD_last (x✝ >>> 4)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq ((x✝ >>> 4 + x✝ >>> 3).getLsbD 63)
                      ((x✝ >>> 4).getLsbD 63))))
                (Std.Tactic.BVDecide.Normalize.Bool.and_to_and ((x✝ >>> 4).getLsbD 63 == (x✝ >>> 3).getLsbD 63)
                  !(x✝ >>> 4 + x✝ >>> 3).getLsbD 63 == (x✝ >>> 4).getLsbD 63)))
            (true_and
              (((x✝ >>> 4).getLsbD 63 == (x✝ >>> 3).getLsbD 63 &&
                  !(x✝ >>> 4 + x✝ >>> 3).getLsbD 63 == (x✝ >>> 4).getLsbD 63) =
                true)) : (True ∧ (x✝ >>> 4).msb = (x✝ >>> 3).msb ∧ (x✝ >>> 4 + x✝ >>> 3).msb ≠ (x✝ >>> 4).msb) =
            (((x✝ >>> 4).getLsbD 63 == (x✝ >>> 3).getLsbD 63 &&
                !(x✝ >>> 4 + x✝ >>> 3).getLsbD 63 == (x✝ >>> 4).getLsbD 63) =
              true))
        [Meta.isDefEq] [0.001626] ✅️ (True ∧
                (x✝ >>> 4#64).msb = (x✝ >>> 3#64).msb ∧ (x✝ >>> 4#64 + x✝ >>> 3#64).msb ≠ (x✝ >>> 4#64).msb) =
              (((x✝ >>> 4).getLsbD 63 == (x✝ >>> 3).getLsbD 63 &&
                  !(x✝ >>> 4 + x✝ >>> 3).getLsbD 63 == (x✝ >>> 4).getLsbD 63) =
                true) =?= (True ∧ (x✝ >>> 4).msb = (x✝ >>> 3).msb ∧ (x✝ >>> 4 + x✝ >>> 3).msb ≠ (x✝ >>> 4).msb) =
              (((x✝ >>> 4).getLsbD 63 == (x✝ >>> 3).getLsbD 63 &&
                  !(x✝ >>> 4 + x✝ >>> 3).getLsbD 63 == (x✝ >>> 4).getLsbD 63) =
                true)
          [Meta.isDefEq] [0.001595] ✅️ True ∧
                (x✝ >>> 4#64).msb = (x✝ >>> 3#64).msb ∧
                  (x✝ >>> 4#64 + x✝ >>> 3#64).msb ≠
                    (x✝ >>>
                        4#64).msb =?= True ∧
                (x✝ >>> 4).msb = (x✝ >>> 3).msb ∧ (x✝ >>> 4 + x✝ >>> 3).msb ≠ (x✝ >>> 4).msb
            [Meta.isDefEq] [0.001569] ✅️ (x✝ >>> 4#64).msb = (x✝ >>> 3#64).msb ∧
                  (x✝ >>> 4#64 + x✝ >>> 3#64).msb ≠
                    (x✝ >>> 4#64).msb =?= (x✝ >>> 4).msb = (x✝ >>> 3).msb ∧ (x✝ >>> 4 + x✝ >>> 3).msb ≠ (x✝ >>> 4).msb
  [Meta.isDefEq] [0.001389] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr (congrArg Or (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x✝ >>> 4 + x✝ >>> 3) (x✝ >>> 4)))
                (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x✝ >>> 4 + x✝ >>> 3) (x✝ >>> 3)))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or (x✝ >>> 4 >ᵤ x✝ >>> 4 + x✝ >>> 3)
                (x✝ >>> 3 >ᵤ x✝ >>> 4 + x✝ >>> 3)))
            (congrArg (fun x => x = true)
              (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝ >>> 4 >ᵤ x✝ >>> 4 + x✝ >>> 3)
                (x✝ >>> 3 >ᵤ x✝ >>> 4 + x✝ >>> 3)))))
        (true_and ((!((!x✝ >>> 4 >ᵤ x✝ >>> 4 + x✝ >>> 3) && !x✝ >>> 3 >ᵤ x✝ >>> 4 + x✝ >>> 3)) = true))
    [Meta.isDefEq.assign] [0.001385] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr (congrArg Or (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x✝ >>> 4 + x✝ >>> 3) (x✝ >>> 4)))
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x✝ >>> 4 + x✝ >>> 3) (x✝ >>> 3)))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or (x✝ >>> 4 >ᵤ x✝ >>> 4 + x✝ >>> 3)
                  (x✝ >>> 3 >ᵤ x✝ >>> 4 + x✝ >>> 3)))
              (congrArg (fun x => x = true)
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝ >>> 4 >ᵤ x✝ >>> 4 + x✝ >>> 3)
                  (x✝ >>> 3 >ᵤ x✝ >>> 4 + x✝ >>> 3)))))
          (true_and ((!((!x✝ >>> 4 >ᵤ x✝ >>> 4 + x✝ >>> 3) && !x✝ >>> 3 >ᵤ x✝ >>> 4 + x✝ >>> 3)) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001366] ✅️ (?h₁ : (True ∧
              (x✝ >>> 4#64 + x✝ >>> 3#64 < x✝ >>> 4#64 ∨ x✝ >>> 4#64 + x✝ >>> 3#64 < x✝ >>> 3#64)) =
            ((!((!x✝ >>> 4 >ᵤ x✝ >>> 4 + x✝ >>> 3) && !x✝ >>> 3 >ᵤ x✝ >>> 4 + x✝ >>> 3)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr (congrArg Or (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x✝ >>> 4 + x✝ >>> 3) (x✝ >>> 4)))
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x✝ >>> 4 + x✝ >>> 3) (x✝ >>> 3)))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or (x✝ >>> 4 >ᵤ x✝ >>> 4 + x✝ >>> 3)
                    (x✝ >>> 3 >ᵤ x✝ >>> 4 + x✝ >>> 3)))
                (congrArg (fun x => x = true)
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x✝ >>> 4 >ᵤ x✝ >>> 4 + x✝ >>> 3)
                    (x✝ >>> 3 >ᵤ x✝ >>> 4 + x✝ >>> 3)))))
            (true_and
              ((!((!x✝ >>> 4 >ᵤ x✝ >>> 4 + x✝ >>> 3) && !x✝ >>> 3 >ᵤ x✝ >>> 4 + x✝ >>> 3)) =
                true)) : (True ∧ (x✝ >>> 4 + x✝ >>> 3 < x✝ >>> 4 ∨ x✝ >>> 4 + x✝ >>> 3 < x✝ >>> 3)) =
            ((!((!x✝ >>> 4 >ᵤ x✝ >>> 4 + x✝ >>> 3) && !x✝ >>> 3 >ᵤ x✝ >>> 4 + x✝ >>> 3)) = true))
        [Meta.isDefEq] [0.001362] ✅️ (True ∧
                (x✝ >>> 4#64 + x✝ >>> 3#64 < x✝ >>> 4#64 ∨ x✝ >>> 4#64 + x✝ >>> 3#64 < x✝ >>> 3#64)) =
              ((!((!x✝ >>> 4 >ᵤ x✝ >>> 4 + x✝ >>> 3) && !x✝ >>> 3 >ᵤ x✝ >>> 4 + x✝ >>> 3)) =
                true) =?= (True ∧ (x✝ >>> 4 + x✝ >>> 3 < x✝ >>> 4 ∨ x✝ >>> 4 + x✝ >>> 3 < x✝ >>> 3)) =
              ((!((!x✝ >>> 4 >ᵤ x✝ >>> 4 + x✝ >>> 3) && !x✝ >>> 3 >ᵤ x✝ >>> 4 + x✝ >>> 3)) = true)
          [Meta.isDefEq] [0.001329] ✅️ True ∧
                (x✝ >>> 4#64 + x✝ >>> 3#64 < x✝ >>> 4#64 ∨
                  x✝ >>> 4#64 + x✝ >>> 3#64 <
                    x✝ >>> 3#64) =?= True ∧ (x✝ >>> 4 + x✝ >>> 3 < x✝ >>> 4 ∨ x✝ >>> 4 + x✝ >>> 3 < x✝ >>> 3)
            [Meta.isDefEq] [0.001313] ✅️ x✝ >>> 4#64 + x✝ >>> 3#64 < x✝ >>> 4#64 ∨
                  x✝ >>> 4#64 + x✝ >>> 3#64 <
                    x✝ >>> 3#64 =?= x✝ >>> 4 + x✝ >>> 3 < x✝ >>> 4 ∨ x✝ >>> 4 + x✝ >>> 3 < x✝ >>> 3
              [Meta.isDefEq] [0.001123] ✅️ x✝ >>> 4#64 + x✝ >>> 3#64 < x✝ >>> 4#64 =?= x✝ >>> 4 + x✝ >>> 3 < x✝ >>> 4
                [Meta.isDefEq] [0.001089] ✅️ instLTBitVec.1 (x✝ >>> 4#64 + x✝ >>> 3#64)
                      (x✝ >>> 4#64) =?= instLTBitVec.1 (x✝ >>> 4 + x✝ >>> 3) (x✝ >>> 4)
                  [Meta.isDefEq] [0.001016] ✅️ (x✝ >>> 4#64 + x✝ >>> 3#64).toNat <
                        (x✝ >>> 4#64).toNat =?= (x✝ >>> 4 + x✝ >>> 3).toNat < (x✝ >>> 4).toNat
  [Meta.isDefEq] [0.001063] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝¹ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 16#64
      | some { toFin := ⟨0, ⋯⟩ } => some 8#64
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 1
      e_1 : LLVM.IntW 64
      x✝¹ : BitVec 1
      x✝ : BitVec 64
      a✝ :
        ¬(Option.bind
              (match some x✝¹ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 16#64
              | some { toFin := ⟨0, ⋯⟩ } => some 8#64)
              fun a =>
              if (a == 0#64) = true then none
              else
                Option.bind
                  (match some x✝¹ with
                  | none => none
                  | some { toFin := ⟨1, ⋯⟩ } => some 8#64
                  | some { toFin := ⟨0, ⋯⟩ } => some 0#64)
                  fun a_1 => if (a_1 == 0#64) = true then none else some (x✝ / a + x✝ / a_1)) ⊑
            if
                ((x✝ >>> 4).getLsbD 63 == (x✝ >>> 3).getLsbD 63 &&
                    !(x✝ >>> 4 + x✝ >>> 3).getLsbD 63 == (x✝ >>> 4).getLsbD 63) =
                  true then
              none
            else
              if (!((!x✝ >>> 4 >ᵤ x✝ >>> 4 + x✝ >>> 3) && !x✝ >>> 3 >ᵤ x✝ >>> 4 + x✝ >>> 3)) = true then none
              else some (x✝ >>> 4 + x✝ >>> 3)
      ⊢ False
  [Meta.isDefEq] [0.001041] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝¹ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 8#64
      | some { toFin := ⟨0, ⋯⟩ } => some 0#64
  [Meta.isDefEq] [0.001038] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝¹ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 8#64
      | some { toFin := ⟨0, ⋯⟩ } => some 0#64
  [Meta.isDefEq] [0.001015] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝¹ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 16#64
      | some { toFin := ⟨0, ⋯⟩ } => some 8#64
  [Meta.isDefEq] [0.001078] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝¹ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 16#64
      | some { toFin := ⟨0, ⋯⟩ } => some 8#64
  [Meta.isDefEq] [0.001032] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝¹ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 16#64
      | some { toFin := ⟨0, ⋯⟩ } => some 8#64
  [Meta.isDefEq] [0.001054] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝¹ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 8#64
      | some { toFin := ⟨0, ⋯⟩ } => some 0#64
  [Meta.isDefEq] [0.001034] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝¹ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 8#64
      | some { toFin := ⟨0, ⋯⟩ } => some 0#64
  [Meta.appBuilder] [0.001598] ✅️ f: Subsingleton.elim, xs: [h✝, h]
    [Meta.synthInstance] [0.001512] ✅️ Subsingleton (Decidable c✝)
      [Meta.synthInstance] [0.001364] ✅️ apply instSubsingletonDecidable to Subsingleton (Decidable c✝)
        [Meta.synthInstance.tryResolve] [0.001299] ✅️ Subsingleton (Decidable c✝) ≟ Subsingleton (Decidable c✝)
          [Meta.isDefEq] [0.001230] ✅️ ?m.30249 =?= instSubsingletonDecidable c✝
            [Meta.isDefEq.assign] [0.001225] ✅️ ?m.30249 := instSubsingletonDecidable c✝
  [Meta.Tactic.bv] Pipeline reached a fixpoint
