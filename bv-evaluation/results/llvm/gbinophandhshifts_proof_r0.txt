‚ö† [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
‚ö† [881/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
‚ö† [884/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
‚ö† [887/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
‚ö† [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
Bitwuzla proved the goal after 0.911760ms, solving context: 0.000000ms
LeanSAT proved the goal after 3.615080ms: rewriting 3.587510ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 0.577570ms, solving context: 0.000000ms
LeanSAT proved the goal after 3.559860ms: rewriting 3.544780ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 0.640600ms, solving context: 0.000000ms
LeanSAT proved the goal after 3.219110ms: rewriting 3.203470ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 78.286990ms, solving context: 0.000000ms
LeanSAT proved the goal after 83.062489ms: rewriting 22.310320ms, bitblasting 0.000000ms, SAT solving 57.038809ms, LRAT trimming 0.000000ms, LRAT checking 2.295680ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:29:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:22:8: error: (kernel) declaration has metavariables 'shl_and_and_fail_thm'
[bv] [0.025751] Normalizing goal
  [Meta.synthInstance] [0.002041] ‚úÖÔ∏è Decidable
        ((if 4#8 ‚â• ‚Üë8 then none else if 5#8 ‚â• ‚Üë8 then none else some (x‚úù <<< 4#8 &&& (x‚úù¬π <<< 5#8 &&& 88#8))) ‚äë
          if 4#8 ‚â• ‚Üë8 then none else if 5#8 ‚â• ‚Üë8 then none else some (x‚úù <<< 4#8 &&& (x‚úù¬π <<< 5#8 &&& 64#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if 4#8 ‚â• ‚Üë8 then none else if 5#8 ‚â• ‚Üë8 then none else some (x‚úù <<< 4#8 &&& (x‚úù¬π <<< 5#8 &&& 88#8))) ‚äë
            if 4#8 ‚â• ‚Üë8 then none else if 5#8 ‚â• ‚Üë8 then none else some (x‚úù <<< 4#8 &&& (x‚úù¬π <<< 5#8 &&& 64#8))
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù : ¬¨some (x‚úù <<< 4 &&& (x‚úù¬π <<< 5 &&& 88#8)) ‚äë some (x‚úù <<< 4 &&& (x‚úù¬π <<< 5 &&& 64#8))
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 0.820050ms, solving context: 0.000000ms
LeanSAT proved the goal after 3.170510ms: rewriting 3.150590ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 0.584540ms, solving context: 0.000000ms
LeanSAT proved the goal after 3.669010ms: rewriting 3.652260ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 0.656600ms, solving context: 0.000000ms
LeanSAT proved the goal after 2.895940ms: rewriting 2.881850ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 81.756429ms, solving context: 0.000000ms
LeanSAT proved the goal after 175.476389ms: rewriting 22.262710ms, bitblasting 0.000000ms, SAT solving 108.745530ms, LRAT trimming 29.098669ms, LRAT checking 9.944400ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:52:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:44:8: error: (kernel) declaration has metavariables 'shl_add_add_fail_thm'
[bv] [0.399174] Normalizing goal
  [Meta.synthInstance] [0.001721] ‚úÖÔ∏è Decidable
        ((if 2#8 ‚â• ‚Üë8 then none else if 2#8 ‚â• ‚Üë8 then none else some (x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8))) ‚äë
          if 2#8 ‚â• ‚Üë8 then none
          else
            if 2#8 ‚â• ‚Üë8 then none
            else
              if True ‚àß (x‚úù¬π >>> 2#8).msb = (48#8).msb ‚àß (x‚úù¬π >>> 2#8 + 48#8).msb ‚â† (x‚úù¬π >>> 2#8).msb then none
              else
                if True ‚àß (x‚úù¬π >>> 2#8 + 48#8 < x‚úù¬π >>> 2#8 ‚à® x‚úù¬π >>> 2#8 + 48#8 < 48#8) then none
                else
                  if
                      True ‚àß
                        (x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8) < x‚úù >>> 2#8 ‚à®
                          x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8) < x‚úù¬π >>> 2#8 + 48#8) then
                    none
                  else some (x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if 2#8 ‚â• ‚Üë8 then none else if 2#8 ‚â• ‚Üë8 then none else some (x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8))) ‚äë
            if 2#8 ‚â• ‚Üë8 then none
            else
              if 2#8 ‚â• ‚Üë8 then none
              else
                if True ‚àß (x‚úù¬π >>> 2#8).msb = (48#8).msb ‚àß (x‚úù¬π >>> 2#8 + 48#8).msb ‚â† (x‚úù¬π >>> 2#8).msb then none
                else
                  if True ‚àß (x‚úù¬π >>> 2#8 + 48#8 < x‚úù¬π >>> 2#8 ‚à® x‚úù¬π >>> 2#8 + 48#8 < 48#8) then none
                  else
                    if
                        True ‚àß
                          (x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8) < x‚úù >>> 2#8 ‚à®
                            x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8) < x‚úù¬π >>> 2#8 + 48#8) then
                      none
                    else some (x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8))
      ‚ä¢ False
  [Meta.isDefEq] [0.074110] ‚úÖÔ∏è ?x ‚â• ?y =?= 8#8 ‚â§ 2#8
    [Meta.isDefEq] [0.074073] ‚úÖÔ∏è ?y ‚â§ ?x =?= 8#8 ‚â§ 2#8
      [Meta.whnf] [0.005433] Non-easy whnf: LE Œ±
      [Meta.isDefEq] [0.024962] ‚úÖÔ∏è ?Œ± =?= BitVec 8
        [Meta.isDefEq.assign] [0.023680] ‚úÖÔ∏è ?Œ± := BitVec 8
          [Meta.isDefEq.assign.checkTypes] [0.022393] ‚úÖÔ∏è (?Œ± : Type ?u.39689) := (BitVec 8 : Type)
            [Meta.isDefEq] [0.013190] ‚úÖÔ∏è Type ?u.39689 =?= Type
              [Meta.isLevelDefEq] [0.011695] ‚úÖÔ∏è ?u.39689 =?= 0
      [Meta.isDefEq] [0.001574] ‚úÖÔ∏è ?inst‚úù =?= instLEBitVec
        [Meta.isDefEq.assign] [0.001565] ‚úÖÔ∏è ?inst‚úù := instLEBitVec
      [Meta.isDefEq] [0.001435] ‚úÖÔ∏è ?y =?= 8#8
      [Meta.isDefEq] [0.002879] ‚úÖÔ∏è ?x =?= 2#8
        [Meta.isDefEq.assign] [0.002862] ‚úÖÔ∏è ?x := 2#8
  [Meta.isDefEq] [0.007441] ‚úÖÔ∏è ?x ‚â§ ?y =?= 8#8 ‚â§ 2#8
    [Meta.isDefEq] [0.005806] ‚úÖÔ∏è ?x =?= 8#8
      [Meta.isDefEq.assign] [0.005799] ‚úÖÔ∏è ?x := 8#8
        [Meta.isDefEq.assign.checkTypes] [0.005788] ‚úÖÔ∏è (?x : BitVec ?w) := (8#8 : BitVec 8)
          [Meta.isDefEq] [0.005741] ‚úÖÔ∏è BitVec ?w =?= BitVec 8
            [Meta.isDefEq] [0.001293] ‚úÖÔ∏è ?w =?= 8
              [Meta.isDefEq.assign] [0.001280] ‚úÖÔ∏è ?w := 8
    [Meta.isDefEq] [0.001460] ‚úÖÔ∏è instLEBitVec =?= instLEBitVec
      [Meta.isDefEq.delta] [0.001376] ‚úÖÔ∏è instLEBitVec =?= instLEBitVec
  [Meta.isDefEq] [0.006445] ‚úÖÔ∏è ?x > ?y =?= 2#8 < 8#8
    [Meta.isDefEq] [0.006359] ‚úÖÔ∏è ?y < ?x =?= 2#8 < 8#8
      [Meta.whnf] [0.002221] Non-easy whnf: LT Œ±
      [Meta.isDefEq] [0.002802] ‚úÖÔ∏è ?inst‚úù =?= instLTBitVec
        [Meta.isDefEq.assign] [0.002798] ‚úÖÔ∏è ?inst‚úù := instLTBitVec
          [Meta.isDefEq.assign.checkTypes] [0.001483] ‚úÖÔ∏è (?inst‚úù : LT (BitVec 8)) := (instLTBitVec : LT (BitVec 8))
            [Meta.isDefEq] [0.001471] ‚úÖÔ∏è LT (BitVec 8) =?= LT (BitVec 8)
  [Meta.isDefEq] [0.001673] ‚úÖÔ∏è ?x < ?y =?= 2#8 < 8#8
    [Meta.isDefEq] [0.001460] ‚úÖÔ∏è ?x =?= 2#8
      [Meta.isDefEq.assign] [0.001454] ‚úÖÔ∏è ?x := 2#8
        [Meta.isDefEq.assign.checkTypes] [0.001446] ‚úÖÔ∏è (?x : BitVec ?w) := (2#8 : BitVec 8)
          [Meta.isDefEq] [0.001440] ‚úÖÔ∏è BitVec ?w =?= BitVec 8
            [Meta.isDefEq] [0.001414] ‚úÖÔ∏è ?w =?= 8
              [Meta.isDefEq.assign] [0.001408] ‚úÖÔ∏è ?w := 8
                [Meta.isDefEq.assign.checkTypes] [0.001400] ‚úÖÔ∏è (?w : ‚Ñï) := (8 : ‚Ñï)
  [Meta.isDefEq] [0.005328] ‚úÖÔ∏è ?a = ?a =?= true = true
    [Meta.isDefEq] [0.003655] ‚úÖÔ∏è ?Œ± =?= Bool
      [Meta.isDefEq.assign] [0.002117] ‚úÖÔ∏è ?Œ± := Bool
        [Meta.isDefEq.assign.checkTypes] [0.002103] ‚úÖÔ∏è (?Œ± : Sort ?u.39721) := (Bool : Type)
  [Meta.appBuilder] [0.019041] ‚úÖÔ∏è f: HShiftRight.hShiftRight, xs: [x‚úù, 2]
    [Meta.isDefEq] [0.001468] ‚úÖÔ∏è ?Œ≤ =?= ‚Ñï
      [Meta.isDefEq.assign] [0.001462] ‚úÖÔ∏è ?Œ≤ := ‚Ñï
        [Meta.isDefEq.assign.checkTypes] [0.001449] ‚úÖÔ∏è (?Œ≤ : Type ?u.39728) := (‚Ñï : Type)
    [Meta.synthInstance] [0.011595] ‚úÖÔ∏è HShiftRight (BitVec 8) ‚Ñï (BitVec 8)
      [Meta.synthInstance] [0.001709] new goal HShiftRight (BitVec 8) ‚Ñï _tc.0
      [Meta.synthInstance] [0.005135] ‚úÖÔ∏è apply @BitVec.instHShiftRightNat to HShiftRight (BitVec 8) ‚Ñï (BitVec 8)
        [Meta.synthInstance.tryResolve] [0.005063] ‚úÖÔ∏è HShiftRight (BitVec 8) ‚Ñï
              (BitVec 8) ‚âü HShiftRight (BitVec 8) ‚Ñï (BitVec 8)
          [Meta.isDefEq] [0.001829] ‚úÖÔ∏è HShiftRight (BitVec 8) ‚Ñï
                ?m.39734 =?= HShiftRight (BitVec ?m.39737) ‚Ñï (BitVec ?m.39737)
          [Meta.isDefEq] [0.003215] ‚úÖÔ∏è ?m.39735 =?= BitVec.instHShiftRightNat
            [Meta.isDefEq.assign] [0.003183] ‚úÖÔ∏è ?m.39735 := BitVec.instHShiftRightNat
              [Meta.isDefEq.assign.checkTypes] [0.003164] ‚úÖÔ∏è (?m.39735 : HShiftRight (BitVec 8) ‚Ñï
                    (BitVec 8)) := (BitVec.instHShiftRightNat : HShiftRight (BitVec 8) ‚Ñï (BitVec 8))
                [Meta.isDefEq] [0.001660] ‚úÖÔ∏è HShiftRight (BitVec 8) ‚Ñï (BitVec 8) =?= HShiftRight (BitVec 8) ‚Ñï (BitVec 8)
      [Meta.check] [0.001576] ‚úÖÔ∏è BitVec.instHShiftRightNat
  [Meta.appBuilder] [0.008157] ‚úÖÔ∏è f: HShiftRight.hShiftRight, xs: [x‚úù¬π, 2]
    [Meta.synthInstance] [0.006593] ‚úÖÔ∏è HShiftRight (BitVec 8) ‚Ñï (BitVec 8)
      [Meta.synthInstance] [0.006415] ‚úÖÔ∏è apply @BitVec.instHShiftRightNat to HShiftRight (BitVec 8) ‚Ñï (BitVec 8)
        [Meta.synthInstance.tryResolve] [0.006388] ‚úÖÔ∏è HShiftRight (BitVec 8) ‚Ñï
              (BitVec 8) ‚âü HShiftRight (BitVec 8) ‚Ñï (BitVec 8)
          [Meta.isDefEq] [0.006351] ‚úÖÔ∏è HShiftRight (BitVec 8) ‚Ñï
                ?m.39757 =?= HShiftRight (BitVec ?m.39760) ‚Ñï (BitVec ?m.39760)
            [Meta.isDefEq] [0.002945] ‚úÖÔ∏è BitVec 8 =?= BitVec ?m.39760
  [Meta.isDefEq] [0.003858] ‚ùåÔ∏è ?a + ?a =?= x‚úù¬π >>> 2 + 48#8
    [Meta.isDefEq] [0.003672] ‚ùåÔ∏è instHAdd =?= instHAdd
      [Meta.isDefEq] [0.003497] ‚ùåÔ∏è { hAdd := fun a b => Add.add a b } =?= { hAdd := fun a b => Add.add a b }
        [Meta.whnf] [0.001692] Non-easy whnf: HAdd (BitVec ?w) (BitVec ?w) (BitVec ?w)
  [Meta.isDefEq] [0.002150] ‚ùåÔ∏è ?a + ?a =?= x‚úù¬π >>> 2 + 48#8
    [Meta.isDefEq] [0.001780] ‚úÖÔ∏è ?a =?= x‚úù¬π >>> 2
      [Meta.isDefEq.assign] [0.001774] ‚úÖÔ∏è ?a := x‚úù¬π >>> 2
        [Meta.isDefEq.assign.checkTypes] [0.001764] ‚úÖÔ∏è (?a : BitVec ?w) := (x‚úù¬π >>> 2 : BitVec 8)
          [Meta.isDefEq] [0.001758] ‚úÖÔ∏è BitVec ?w =?= BitVec 8
            [Meta.isDefEq] [0.001733] ‚úÖÔ∏è ?w =?= 8
  [Meta.isDefEq] [0.002018] ‚ùåÔ∏è ?x.getLsbD ?i =?= (x‚úù¬π >>> 2).getLsbD 7
    [Meta.isDefEq] [0.001957] ‚ùåÔ∏è ?x =?= x‚úù¬π >>> 2
      [Meta.isDefEq.assign] [0.001941] ‚ùåÔ∏è ?x := x‚úù¬π >>> 2
        [Meta.isDefEq.assign.checkTypes] [0.001928] ‚ùåÔ∏è (?x : BitVec 0) := (x‚úù¬π >>> 2 : BitVec 8)
  [Meta.isDefEq] [0.002103] ‚ùåÔ∏è ?x.getLsbD ?i =?= (x‚úù¬π >>> 2).getLsbD 7
  [Meta.isDefEq] [0.003519] ‚úÖÔ∏è ?x.msb =?= (48#8).msb
    [Meta.isDefEq] [0.003454] ‚úÖÔ∏è ?x =?= 48#8
      [Meta.isDefEq.assign] [0.003450] ‚úÖÔ∏è ?x := 48#8
        [Meta.isDefEq.assign.checkTypes] [0.001743] ‚úÖÔ∏è (?x : BitVec 8) := (48#8 : BitVec 8)
          [Meta.isDefEq] [0.001733] ‚úÖÔ∏è BitVec 8 =?= BitVec 8
  [Meta.isDefEq] [0.003551] ‚ùåÔ∏è ?a = ?a =?= (x‚úù¬π >>> 2).getLsbD 7 = false
    [Meta.isDefEq] [0.001613] ‚úÖÔ∏è ?Œ± =?= Bool
      [Meta.isDefEq.assign] [0.001608] ‚úÖÔ∏è ?Œ± := Bool
        [Meta.isDefEq.assign.checkTypes] [0.001601] ‚úÖÔ∏è (?Œ± : Sort ?u.39832) := (Bool : Type)
    [Meta.isDefEq] [0.001840] ‚úÖÔ∏è ?a =?= (x‚úù¬π >>> 2).getLsbD 7
      [Meta.isDefEq.assign] [0.001835] ‚úÖÔ∏è ?a := (x‚úù¬π >>> 2).getLsbD 7
  [Meta.isDefEq] [0.001649] ‚úÖÔ∏è !?x =?= !(x‚úù¬π >>> 2).getLsbD 7
    [Meta.isDefEq] [0.001626] ‚úÖÔ∏è ?x =?= (x‚úù¬π >>> 2).getLsbD 7
      [Meta.isDefEq.assign] [0.001621] ‚úÖÔ∏è ?x := (x‚úù¬π >>> 2).getLsbD 7
  [Meta.isDefEq] [0.001808] ‚ùåÔ∏è ?a = ?a =?= (!(x‚úù¬π >>> 2).getLsbD 7) = true
  [Meta.isDefEq] [0.003351] ‚úÖÔ∏è ?x.msb =?= (x‚úù¬π >>> 2 + 48#8).msb
    [Meta.isDefEq] [0.003317] ‚úÖÔ∏è ?x =?= x‚úù¬π >>> 2 + 48#8
      [Meta.isDefEq.assign] [0.003313] ‚úÖÔ∏è ?x := x‚úù¬π >>> 2 + 48#8
        [Meta.isDefEq.assign.checkTypes] [0.003306] ‚úÖÔ∏è (?x : BitVec 8) := (x‚úù¬π >>> 2 + 48#8 : BitVec 8)
          [Meta.isDefEq] [0.003300] ‚úÖÔ∏è BitVec 8 =?= BitVec 8
  [Meta.isDefEq] [0.003917] ‚ùåÔ∏è ?a == ?a =?= (x‚úù¬π >>> 2 + 48#8).getLsbD 7 == (x‚úù¬π >>> 2).getLsbD 7
  [Meta.isDefEq] [0.012842] ‚ùåÔ∏è ?a == ?a =?= (x‚úù¬π >>> 2 + 48#8).getLsbD 7 == (x‚úù¬π >>> 2).getLsbD 7
    [Meta.isDefEq] [0.005225] ‚úÖÔ∏è ?Œ± =?= Bool
      [Meta.isDefEq.assign] [0.005221] ‚úÖÔ∏è ?Œ± := Bool
        [Meta.isDefEq.assign.checkTypes] [0.005216] ‚úÖÔ∏è (?Œ± : Type ?u.39896) := (Bool : Type)
          [Meta.isDefEq] [0.003596] ‚úÖÔ∏è Type ?u.39896 =?= Type
            [Meta.isLevelDefEq] [0.003591] ‚úÖÔ∏è ?u.39896 =?= 0
    [Meta.isDefEq.onFailure] [0.007145] ‚ùåÔ∏è ?a == ?a =?= (x‚úù¬π >>> 2 + 48#8).getLsbD 7 == (x‚úù¬π >>> 2).getLsbD 7
      [Meta.synthInstance] [0.007109] üí•Ô∏è BEq ?Œ±
        [Meta.synthInstance] [0.005429] new goal BEq ?Œ±
  [Meta.isDefEq] [0.001794] ‚ùåÔ∏è ?a =
        ?a =?= (!(x‚úù¬π >>> 2).getLsbD 7 && !(x‚úù¬π >>> 2 + 48#8).getLsbD 7 == (x‚úù¬π >>> 2).getLsbD 7) = true
    [Meta.isDefEq] [0.001703] ‚úÖÔ∏è ?Œ± =?= Bool
      [Meta.isDefEq.assign] [0.001699] ‚úÖÔ∏è ?Œ± := Bool
        [Meta.isDefEq.assign.checkTypes] [0.001693] ‚úÖÔ∏è (?Œ± : Sort ?u.39994) := (Bool : Type)
  [Meta.isDefEq] [0.005118] ‚úÖÔ∏è if ?b then ?x
      else
        ?y =?= if True ‚àß (x‚úù¬π >>> 2#8).msb = (48#8).msb ‚àß (x‚úù¬π >>> 2#8 + 48#8).msb ‚â† (x‚úù¬π >>> 2#8).msb then none
      else
        if True ‚àß (x‚úù¬π >>> 2#8 + 48#8 < x‚úù¬π >>> 2#8 ‚à® x‚úù¬π >>> 2#8 + 48#8 < 48#8) then none
        else
          if
              True ‚àß
                (x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8) < x‚úù >>> 2#8 ‚à®
                  x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8) < x‚úù¬π >>> 2#8 + 48#8) then
            none
          else some (x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8))
    [Meta.isDefEq] [0.003336] ‚úÖÔ∏è ?y =?= if True ‚àß (x‚úù¬π >>> 2#8 + 48#8 < x‚úù¬π >>> 2#8 ‚à® x‚úù¬π >>> 2#8 + 48#8 < 48#8) then
          none
        else
          if
              True ‚àß
                (x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8) < x‚úù >>> 2#8 ‚à®
                  x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8) < x‚úù¬π >>> 2#8 + 48#8) then
            none
          else some (x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8))
      [Meta.isDefEq.assign] [0.003332] ‚úÖÔ∏è ?y := if
              True ‚àß (x‚úù¬π >>> 2#8 + 48#8 < x‚úù¬π >>> 2#8 ‚à® x‚úù¬π >>> 2#8 + 48#8 < 48#8) then none
          else
            if
                True ‚àß
                  (x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8) < x‚úù >>> 2#8 ‚à®
                    x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8) < x‚úù¬π >>> 2#8 + 48#8) then
              none
            else some (x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8))
  [Meta.isDefEq] [0.011788] ‚úÖÔ∏è ?h‚ÇÅ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (congr
              (congrArg And
                (Eq.trans
                  (congr (congrArg Eq (BitVec.msb_eq_getLsbD_last (x‚úù¬π >>> 2))) (BitVec.msb_eq_getLsbD_last 48#8))
                  (Std.Tactic.BVDecide.Normalize.Bool.eq_false_to_beq ((x‚úù¬π >>> 2).getLsbD 7))))
              (Eq.trans
                (congr (congrArg Ne (BitVec.msb_eq_getLsbD_last (x‚úù¬π >>> 2 + 48#8)))
                  (BitVec.msb_eq_getLsbD_last (x‚úù¬π >>> 2)))
                (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq ((x‚úù¬π >>> 2 + 48#8).getLsbD 7) ((x‚úù¬π >>> 2).getLsbD 7))))
            (Std.Tactic.BVDecide.Normalize.Bool.and_to_and (!(x‚úù¬π >>> 2).getLsbD 7)
              !(x‚úù¬π >>> 2 + 48#8).getLsbD 7 == (x‚úù¬π >>> 2).getLsbD 7)))
        (true_and ((!(x‚úù¬π >>> 2).getLsbD 7 && !(x‚úù¬π >>> 2 + 48#8).getLsbD 7 == (x‚úù¬π >>> 2).getLsbD 7) = true))
    [Meta.isDefEq.assign] [0.011785] ‚úÖÔ∏è ?h‚ÇÅ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (congr
                (congrArg And
                  (Eq.trans
                    (congr (congrArg Eq (BitVec.msb_eq_getLsbD_last (x‚úù¬π >>> 2))) (BitVec.msb_eq_getLsbD_last 48#8))
                    (Std.Tactic.BVDecide.Normalize.Bool.eq_false_to_beq ((x‚úù¬π >>> 2).getLsbD 7))))
                (Eq.trans
                  (congr (congrArg Ne (BitVec.msb_eq_getLsbD_last (x‚úù¬π >>> 2 + 48#8)))
                    (BitVec.msb_eq_getLsbD_last (x‚úù¬π >>> 2)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq ((x‚úù¬π >>> 2 + 48#8).getLsbD 7)
                    ((x‚úù¬π >>> 2).getLsbD 7))))
              (Std.Tactic.BVDecide.Normalize.Bool.and_to_and (!(x‚úù¬π >>> 2).getLsbD 7)
                !(x‚úù¬π >>> 2 + 48#8).getLsbD 7 == (x‚úù¬π >>> 2).getLsbD 7)))
          (true_and ((!(x‚úù¬π >>> 2).getLsbD 7 && !(x‚úù¬π >>> 2 + 48#8).getLsbD 7 == (x‚úù¬π >>> 2).getLsbD 7) = true))
      [Meta.isDefEq.assign.checkTypes] [0.011758] ‚úÖÔ∏è (?h‚ÇÅ : (True ‚àß
              (x‚úù¬π >>> 2#8).msb = (48#8).msb ‚àß (x‚úù¬π >>> 2#8 + 48#8).msb ‚â† (x‚úù¬π >>> 2#8).msb) =
            ((!(x‚úù¬π >>> 2).getLsbD 7 && !(x‚úù¬π >>> 2 + 48#8).getLsbD 7 == (x‚úù¬π >>> 2).getLsbD 7) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (congr
                  (congrArg And
                    (Eq.trans
                      (congr (congrArg Eq (BitVec.msb_eq_getLsbD_last (x‚úù¬π >>> 2))) (BitVec.msb_eq_getLsbD_last 48#8))
                      (Std.Tactic.BVDecide.Normalize.Bool.eq_false_to_beq ((x‚úù¬π >>> 2).getLsbD 7))))
                  (Eq.trans
                    (congr (congrArg Ne (BitVec.msb_eq_getLsbD_last (x‚úù¬π >>> 2 + 48#8)))
                      (BitVec.msb_eq_getLsbD_last (x‚úù¬π >>> 2)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq ((x‚úù¬π >>> 2 + 48#8).getLsbD 7)
                      ((x‚úù¬π >>> 2).getLsbD 7))))
                (Std.Tactic.BVDecide.Normalize.Bool.and_to_and (!(x‚úù¬π >>> 2).getLsbD 7)
                  !(x‚úù¬π >>> 2 + 48#8).getLsbD 7 == (x‚úù¬π >>> 2).getLsbD 7)))
            (true_and
              ((!(x‚úù¬π >>> 2).getLsbD 7 && !(x‚úù¬π >>> 2 + 48#8).getLsbD 7 == (x‚úù¬π >>> 2).getLsbD 7) =
                true)) : (True ‚àß (x‚úù¬π >>> 2).msb = (48#8).msb ‚àß (x‚úù¬π >>> 2 + 48#8).msb ‚â† (x‚úù¬π >>> 2).msb) =
            ((!(x‚úù¬π >>> 2).getLsbD 7 && !(x‚úù¬π >>> 2 + 48#8).getLsbD 7 == (x‚úù¬π >>> 2).getLsbD 7) = true))
        [Meta.isDefEq] [0.011755] ‚úÖÔ∏è (True ‚àß
                (x‚úù¬π >>> 2#8).msb = (48#8).msb ‚àß (x‚úù¬π >>> 2#8 + 48#8).msb ‚â† (x‚úù¬π >>> 2#8).msb) =
              ((!(x‚úù¬π >>> 2).getLsbD 7 && !(x‚úù¬π >>> 2 + 48#8).getLsbD 7 == (x‚úù¬π >>> 2).getLsbD 7) =
                true) =?= (True ‚àß (x‚úù¬π >>> 2).msb = (48#8).msb ‚àß (x‚úù¬π >>> 2 + 48#8).msb ‚â† (x‚úù¬π >>> 2).msb) =
              ((!(x‚úù¬π >>> 2).getLsbD 7 && !(x‚úù¬π >>> 2 + 48#8).getLsbD 7 == (x‚úù¬π >>> 2).getLsbD 7) = true)
          [Meta.isDefEq] [0.011728] ‚úÖÔ∏è True ‚àß
                (x‚úù¬π >>> 2#8).msb = (48#8).msb ‚àß
                  (x‚úù¬π >>> 2#8 + 48#8).msb ‚â†
                    (x‚úù¬π >>> 2#8).msb =?= True ‚àß (x‚úù¬π >>> 2).msb = (48#8).msb ‚àß (x‚úù¬π >>> 2 + 48#8).msb ‚â† (x‚úù¬π >>> 2).msb
            [Meta.isDefEq] [0.011708] ‚úÖÔ∏è (x‚úù¬π >>> 2#8).msb = (48#8).msb ‚àß
                  (x‚úù¬π >>> 2#8 + 48#8).msb ‚â†
                    (x‚úù¬π >>> 2#8).msb =?= (x‚úù¬π >>> 2).msb = (48#8).msb ‚àß (x‚úù¬π >>> 2 + 48#8).msb ‚â† (x‚úù¬π >>> 2).msb
              [Meta.isDefEq] [0.003975] ‚úÖÔ∏è (x‚úù¬π >>> 2#8).msb = (48#8).msb =?= (x‚úù¬π >>> 2).msb = (48#8).msb
                [Meta.isDefEq] [0.003959] ‚úÖÔ∏è (x‚úù¬π >>> 2#8).msb =?= (x‚úù¬π >>> 2).msb
                  [Meta.isDefEq.delta] [0.003941] ‚úÖÔ∏è (x‚úù¬π >>> 2#8).msb =?= (x‚úù¬π >>> 2).msb
                    [Meta.isDefEq] [0.002145] ‚úÖÔ∏è x‚úù¬π >>> 2#8 =?= x‚úù¬π >>> 2
                      [Meta.isDefEq] [0.002102] ‚úÖÔ∏è BitVec.instHShiftRight.1 x‚úù¬π
                            2#8 =?= BitVec.instHShiftRightNat.1 x‚úù¬π 2
              [Meta.isDefEq] [0.007722] ‚úÖÔ∏è (x‚úù¬π >>> 2#8 + 48#8).msb ‚â†
                    (x‚úù¬π >>> 2#8).msb =?= (x‚úù¬π >>> 2 + 48#8).msb ‚â† (x‚úù¬π >>> 2).msb
                [Meta.isDefEq.delta] [0.007707] ‚úÖÔ∏è (x‚úù¬π >>> 2#8 + 48#8).msb ‚â†
                      (x‚úù¬π >>> 2#8).msb =?= (x‚úù¬π >>> 2 + 48#8).msb ‚â† (x‚úù¬π >>> 2).msb
                  [Meta.isDefEq] [0.007653] ‚úÖÔ∏è (x‚úù¬π >>> 2#8 + 48#8).msb =?= (x‚úù¬π >>> 2 + 48#8).msb
                    [Meta.isDefEq.delta] [0.007644] ‚úÖÔ∏è (x‚úù¬π >>> 2#8 + 48#8).msb =?= (x‚úù¬π >>> 2 + 48#8).msb
                      [Meta.isDefEq] [0.007637] ‚úÖÔ∏è x‚úù¬π >>> 2#8 + 48#8 =?= x‚úù¬π >>> 2 + 48#8
                        [Meta.isDefEq] [0.001863] ‚ùåÔ∏è instHAdd =?= instHAdd
                          [Meta.isDefEq.delta] [0.001763] ‚ùåÔ∏è instHAdd =?= instHAdd
                        [Meta.isDefEq] [0.005738] ‚úÖÔ∏è instHAdd.1 (x‚úù¬π >>> 2#8) 48#8 =?= instHAdd.1 (x‚úù¬π >>> 2) 48#8
                          [Meta.isDefEq] [0.003867] ‚úÖÔ∏è Add.add (x‚úù¬π >>> 2#8) 48#8 =?= Add.add (x‚úù¬π >>> 2) 48#8
                            [Meta.isDefEq] [0.003515] ‚ùåÔ∏è BitVec.instAdd =?= instAddNat
                              [Meta.isDefEq] [0.003469] ‚ùåÔ∏è { add := BitVec.add } =?= instAddNat
                                [Meta.isDefEq] [0.001802] ‚ùåÔ∏è { add := BitVec.add } =?= { add := Nat.add }
                                  [Meta.isDefEq] [0.001731] ‚ùåÔ∏è BitVec.add =?= Nat.add
  [Meta.isDefEq] [0.001776] ‚úÖÔ∏è ?x > ?y =?= x‚úù¬π >>> 2 + 48#8 < 48#8
    [Meta.isDefEq] [0.001747] ‚úÖÔ∏è ?y < ?x =?= x‚úù¬π >>> 2 + 48#8 < 48#8
  [Meta.isDefEq] [0.001646] ‚úÖÔ∏è if ?b then ?x
      else
        ?y =?= if True ‚àß (x‚úù¬π >>> 2#8 + 48#8 < x‚úù¬π >>> 2#8 ‚à® x‚úù¬π >>> 2#8 + 48#8 < 48#8) then none
      else
        if
            True ‚àß
              (x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8) < x‚úù >>> 2#8 ‚à®
                x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8) < x‚úù¬π >>> 2#8 + 48#8) then
          none
        else some (x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8))
    [Meta.isDefEq] [0.001505] ‚úÖÔ∏è ?b =?= True ‚àß (x‚úù¬π >>> 2#8 + 48#8 < x‚úù¬π >>> 2#8 ‚à® x‚úù¬π >>> 2#8 + 48#8 < 48#8)
      [Meta.isDefEq.assign] [0.001501] ‚úÖÔ∏è ?b := True ‚àß (x‚úù¬π >>> 2#8 + 48#8 < x‚úù¬π >>> 2#8 ‚à® x‚úù¬π >>> 2#8 + 48#8 < 48#8)
  [Meta.isDefEq] [0.002425] ‚úÖÔ∏è ?h‚ÇÅ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr (congrArg Or (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù¬π >>> 2 + 48#8) (x‚úù¬π >>> 2)))
                (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù¬π >>> 2 + 48#8) 48#8))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or (x‚úù¬π >>> 2 >·µ§ x‚úù¬π >>> 2 + 48#8) (48#8 >·µ§ x‚úù¬π >>> 2 + 48#8)))
            (congrArg (fun x => x = true)
              (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x‚úù¬π >>> 2 >·µ§ x‚úù¬π >>> 2 + 48#8) (48#8 >·µ§ x‚úù¬π >>> 2 + 48#8)))))
        (true_and ((!((!x‚úù¬π >>> 2 >·µ§ x‚úù¬π >>> 2 + 48#8) && !48#8 >·µ§ x‚úù¬π >>> 2 + 48#8)) = true))
    [Meta.isDefEq.assign] [0.002422] ‚úÖÔ∏è ?h‚ÇÅ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr (congrArg Or (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù¬π >>> 2 + 48#8) (x‚úù¬π >>> 2)))
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù¬π >>> 2 + 48#8) 48#8))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or (x‚úù¬π >>> 2 >·µ§ x‚úù¬π >>> 2 + 48#8)
                  (48#8 >·µ§ x‚úù¬π >>> 2 + 48#8)))
              (congrArg (fun x => x = true)
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x‚úù¬π >>> 2 >·µ§ x‚úù¬π >>> 2 + 48#8)
                  (48#8 >·µ§ x‚úù¬π >>> 2 + 48#8)))))
          (true_and ((!((!x‚úù¬π >>> 2 >·µ§ x‚úù¬π >>> 2 + 48#8) && !48#8 >·µ§ x‚úù¬π >>> 2 + 48#8)) = true))
      [Meta.isDefEq.assign.checkTypes] [0.002393] ‚úÖÔ∏è (?h‚ÇÅ : (True ‚àß
              (x‚úù¬π >>> 2#8 + 48#8 < x‚úù¬π >>> 2#8 ‚à® x‚úù¬π >>> 2#8 + 48#8 < 48#8)) =
            ((!((!x‚úù¬π >>> 2 >·µ§ x‚úù¬π >>> 2 + 48#8) && !48#8 >·µ§ x‚úù¬π >>> 2 + 48#8)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr (congrArg Or (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù¬π >>> 2 + 48#8) (x‚úù¬π >>> 2)))
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù¬π >>> 2 + 48#8) 48#8))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or (x‚úù¬π >>> 2 >·µ§ x‚úù¬π >>> 2 + 48#8)
                    (48#8 >·µ§ x‚úù¬π >>> 2 + 48#8)))
                (congrArg (fun x => x = true)
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x‚úù¬π >>> 2 >·µ§ x‚úù¬π >>> 2 + 48#8)
                    (48#8 >·µ§ x‚úù¬π >>> 2 + 48#8)))))
            (true_and
              ((!((!x‚úù¬π >>> 2 >·µ§ x‚úù¬π >>> 2 + 48#8) && !48#8 >·µ§ x‚úù¬π >>> 2 + 48#8)) =
                true)) : (True ‚àß (x‚úù¬π >>> 2 + 48#8 < x‚úù¬π >>> 2 ‚à® x‚úù¬π >>> 2 + 48#8 < 48#8)) =
            ((!((!x‚úù¬π >>> 2 >·µ§ x‚úù¬π >>> 2 + 48#8) && !48#8 >·µ§ x‚úù¬π >>> 2 + 48#8)) = true))
        [Meta.isDefEq] [0.002388] ‚úÖÔ∏è (True ‚àß (x‚úù¬π >>> 2#8 + 48#8 < x‚úù¬π >>> 2#8 ‚à® x‚úù¬π >>> 2#8 + 48#8 < 48#8)) =
              ((!((!x‚úù¬π >>> 2 >·µ§ x‚úù¬π >>> 2 + 48#8) && !48#8 >·µ§ x‚úù¬π >>> 2 + 48#8)) =
                true) =?= (True ‚àß (x‚úù¬π >>> 2 + 48#8 < x‚úù¬π >>> 2 ‚à® x‚úù¬π >>> 2 + 48#8 < 48#8)) =
              ((!((!x‚úù¬π >>> 2 >·µ§ x‚úù¬π >>> 2 + 48#8) && !48#8 >·µ§ x‚úù¬π >>> 2 + 48#8)) = true)
          [Meta.isDefEq] [0.002357] ‚úÖÔ∏è True ‚àß
                (x‚úù¬π >>> 2#8 + 48#8 < x‚úù¬π >>> 2#8 ‚à®
                  x‚úù¬π >>> 2#8 + 48#8 < 48#8) =?= True ‚àß (x‚úù¬π >>> 2 + 48#8 < x‚úù¬π >>> 2 ‚à® x‚úù¬π >>> 2 + 48#8 < 48#8)
            [Meta.isDefEq] [0.002344] ‚úÖÔ∏è x‚úù¬π >>> 2#8 + 48#8 < x‚úù¬π >>> 2#8 ‚à®
                  x‚úù¬π >>> 2#8 + 48#8 < 48#8 =?= x‚úù¬π >>> 2 + 48#8 < x‚úù¬π >>> 2 ‚à® x‚úù¬π >>> 2 + 48#8 < 48#8
              [Meta.isDefEq] [0.002205] ‚úÖÔ∏è x‚úù¬π >>> 2#8 + 48#8 < x‚úù¬π >>> 2#8 =?= x‚úù¬π >>> 2 + 48#8 < x‚úù¬π >>> 2
                [Meta.isDefEq] [0.002176] ‚úÖÔ∏è instLTBitVec.1 (x‚úù¬π >>> 2#8 + 48#8)
                      (x‚úù¬π >>> 2#8) =?= instLTBitVec.1 (x‚úù¬π >>> 2 + 48#8) (x‚úù¬π >>> 2)
                  [Meta.isDefEq] [0.002114] ‚úÖÔ∏è (x‚úù¬π >>> 2#8 + 48#8).toNat <
                        (x‚úù¬π >>> 2#8).toNat =?= (x‚úù¬π >>> 2 + 48#8).toNat < (x‚úù¬π >>> 2).toNat
                    [Meta.isDefEq] [0.002099] ‚úÖÔ∏è instLTNat.1 (x‚úù¬π >>> 2#8 + 48#8).toNat
                          (x‚úù¬π >>> 2#8).toNat =?= instLTNat.1 (x‚úù¬π >>> 2 + 48#8).toNat (x‚úù¬π >>> 2).toNat
                      [Meta.isDefEq] [0.002056] ‚úÖÔ∏è (x‚úù¬π >>> 2#8 + 48#8).toNat.lt
                            (x‚úù¬π >>> 2#8).toNat =?= (x‚úù¬π >>> 2 + 48#8).toNat.lt (x‚úù¬π >>> 2).toNat
                        [Meta.isDefEq.delta] [0.002044] ‚úÖÔ∏è (x‚úù¬π >>> 2#8 + 48#8).toNat.lt
                              (x‚úù¬π >>> 2#8).toNat =?= (x‚úù¬π >>> 2 + 48#8).toNat.lt (x‚úù¬π >>> 2).toNat
                          [Meta.isDefEq] [0.001998] ‚úÖÔ∏è (x‚úù¬π >>> 2#8 + 48#8).toNat =?= (x‚úù¬π >>> 2 + 48#8).toNat
                            [Meta.isDefEq.delta] [0.001986] ‚úÖÔ∏è (x‚úù¬π >>> 2#8 + 48#8).toNat =?= (x‚úù¬π >>> 2 + 48#8).toNat
                              [Meta.isDefEq] [0.001968] ‚úÖÔ∏è x‚úù¬π >>> 2#8 + 48#8 =?= x‚úù¬π >>> 2 + 48#8
                                [Meta.isDefEq] [0.001587] ‚ùåÔ∏è instHAdd =?= instHAdd
                                  [Meta.isDefEq.delta] [0.001499] ‚ùåÔ∏è instHAdd =?= instHAdd
                                    [Meta.isDefEq] [0.001491] ‚ùåÔ∏è BitVec 8 =?= ‚Ñï
  [Meta.isDefEq] [0.003129] ‚úÖÔ∏è ?x > ?y =?= x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8) < x‚úù >>> 2
    [Meta.isDefEq] [0.003090] ‚úÖÔ∏è ?y < ?x =?= x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8) < x‚úù >>> 2
      [Meta.isDefEq] [0.002981] ‚úÖÔ∏è ?inst‚úù =?= instLTBitVec
        [Meta.isDefEq.assign] [0.002977] ‚úÖÔ∏è ?inst‚úù := instLTBitVec
          [Meta.isDefEq.assign.checkTypes] [0.002973] ‚úÖÔ∏è (?inst‚úù : LT (BitVec 8)) := (instLTBitVec : LT (BitVec 8))
            [Meta.isDefEq] [0.002968] ‚úÖÔ∏è LT (BitVec 8) =?= LT (BitVec 8)
  [Meta.isDefEq] [0.002031] ‚úÖÔ∏è ?x < ?y =?= x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8) < x‚úù >>> 2
    [Meta.isDefEq] [0.001941] ‚úÖÔ∏è ?x =?= x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)
      [Meta.isDefEq.assign] [0.001938] ‚úÖÔ∏è ?x := x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)
        [Meta.isDefEq.assign.checkTypes] [0.001931] ‚úÖÔ∏è (?x : BitVec ?w) := (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8) : BitVec 8)
  [Meta.isDefEq] [0.004491] ‚ùåÔ∏è ?a = ?a =?= (x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) = true
    [Meta.isDefEq] [0.001518] ‚úÖÔ∏è ?Œ± =?= Bool
      [Meta.isDefEq.assign] [0.001514] ‚úÖÔ∏è ?Œ± := Bool
        [Meta.isDefEq.assign.checkTypes] [0.001510] ‚úÖÔ∏è (?Œ± : Sort ?u.40156) := (Bool : Type)
          [Meta.isDefEq] [0.001505] ‚úÖÔ∏è Sort ?u.40156 =?= Type
            [Meta.isLevelDefEq] [0.001498] ‚úÖÔ∏è ?u.40156 =?= 1
    [Meta.isDefEq] [0.001419] ‚úÖÔ∏è ?a =?= x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)
      [Meta.isDefEq.assign] [0.001414] ‚úÖÔ∏è ?a := x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)
        [Meta.isDefEq.assign.checkTypes] [0.001401] ‚úÖÔ∏è (?a : Bool) := (x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8) : Bool)
  [Meta.isDefEq] [0.006791] ‚úÖÔ∏è ?x > ?y =?= x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8) < x‚úù¬π >>> 2 + 48#8
    [Meta.isDefEq] [0.002191] ‚úÖÔ∏è ?y < ?x =?= x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8) < x‚úù¬π >>> 2 + 48#8
      [Meta.isDefEq] [0.001943] ‚úÖÔ∏è ?Œ± =?= BitVec 8
        [Meta.isDefEq.assign] [0.001933] ‚úÖÔ∏è ?Œ± := BitVec 8
  [Meta.isDefEq] [0.001584] ‚úÖÔ∏è ?h‚ÇÅ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) (x‚úù >>> 2)))
                (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) (x‚úù¬π >>> 2 + 48#8)))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or (x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))
                (x‚úù¬π >>> 2 + 48#8 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))))
            (congrArg (fun x => x = true)
              (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))
                (x‚úù¬π >>> 2 + 48#8 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))))))
        (true_and
          ((!((!x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) && !x‚úù¬π >>> 2 + 48#8 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))) =
            true))
    [Meta.isDefEq.assign] [0.001581] ‚úÖÔ∏è ?h‚ÇÅ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) (x‚úù >>> 2)))
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) (x‚úù¬π >>> 2 + 48#8)))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or (x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))
                  (x‚úù¬π >>> 2 + 48#8 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))))
              (congrArg (fun x => x = true)
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))
                  (x‚úù¬π >>> 2 + 48#8 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))))))
          (true_and
            ((!((!x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) && !x‚úù¬π >>> 2 + 48#8 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.001549] ‚úÖÔ∏è (?h‚ÇÅ : (True ‚àß
              (x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8) < x‚úù >>> 2#8 ‚à®
                x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8) < x‚úù¬π >>> 2#8 + 48#8)) =
            ((!((!x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) && !x‚úù¬π >>> 2 + 48#8 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) (x‚úù >>> 2)))
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) (x‚úù¬π >>> 2 + 48#8)))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or (x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))
                    (x‚úù¬π >>> 2 + 48#8 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))))
                (congrArg (fun x => x = true)
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))
                    (x‚úù¬π >>> 2 + 48#8 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))))))
            (true_and
              ((!((!x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) && !x‚úù¬π >>> 2 + 48#8 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))) =
                true)) : (True ‚àß
              (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8) < x‚úù >>> 2 ‚à® x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8) < x‚úù¬π >>> 2 + 48#8)) =
            ((!((!x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) && !x‚úù¬π >>> 2 + 48#8 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))) =
              true))
        [Meta.isDefEq] [0.001546] ‚úÖÔ∏è (True ‚àß
                (x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8) < x‚úù >>> 2#8 ‚à®
                  x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8) < x‚úù¬π >>> 2#8 + 48#8)) =
              ((!((!x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) && !x‚úù¬π >>> 2 + 48#8 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))) =
                true) =?= (True ‚àß
                (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8) < x‚úù >>> 2 ‚à® x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8) < x‚úù¬π >>> 2 + 48#8)) =
              ((!((!x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) && !x‚úù¬π >>> 2 + 48#8 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))) =
                true)
          [Meta.isDefEq] [0.001522] ‚úÖÔ∏è True ‚àß
                (x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8) < x‚úù >>> 2#8 ‚à®
                  x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8) <
                    x‚úù¬π >>> 2#8 +
                      48#8) =?= True ‚àß
                (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8) < x‚úù >>> 2 ‚à® x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8) < x‚úù¬π >>> 2 + 48#8)
            [Meta.isDefEq] [0.001506] ‚úÖÔ∏è x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8) < x‚úù >>> 2#8 ‚à®
                  x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8) <
                    x‚úù¬π >>> 2#8 +
                      48#8 =?= x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8) < x‚úù >>> 2 ‚à®
                  x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8) < x‚úù¬π >>> 2 + 48#8
              [Meta.isDefEq] [0.001374] ‚úÖÔ∏è x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8) <
                    x‚úù >>> 2#8 =?= x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8) < x‚úù >>> 2
                [Meta.isDefEq] [0.001350] ‚úÖÔ∏è instLTBitVec.1 (x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8))
                      (x‚úù >>> 2#8) =?= instLTBitVec.1 (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) (x‚úù >>> 2)
                  [Meta.isDefEq] [0.001297] ‚úÖÔ∏è (x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8)).toNat <
                        (x‚úù >>> 2#8).toNat =?= (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)).toNat < (x‚úù >>> 2).toNat
                    [Meta.isDefEq] [0.001279] ‚úÖÔ∏è instLTNat.1 (x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8)).toNat
                          (x‚úù >>> 2#8).toNat =?= instLTNat.1 (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)).toNat (x‚úù >>> 2).toNat
                      [Meta.isDefEq] [0.001239] ‚úÖÔ∏è (x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8)).toNat.lt
                            (x‚úù >>> 2#8).toNat =?= (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)).toNat.lt (x‚úù >>> 2).toNat
                        [Meta.isDefEq.delta] [0.001226] ‚úÖÔ∏è (x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8)).toNat.lt
                              (x‚úù >>> 2#8).toNat =?= (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)).toNat.lt (x‚úù >>> 2).toNat
                          [Meta.isDefEq] [0.001134] ‚úÖÔ∏è (x‚úù >>> 2#8 +
                                  (x‚úù¬π >>> 2#8 + 48#8)).toNat =?= (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)).toNat
                            [Meta.isDefEq.delta] [0.001113] ‚úÖÔ∏è (x‚úù >>> 2#8 +
                                    (x‚úù¬π >>> 2#8 + 48#8)).toNat =?= (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)).toNat
                              [Meta.isDefEq] [0.001106] ‚úÖÔ∏è x‚úù >>> 2#8 +
                                    (x‚úù¬π >>> 2#8 + 48#8) =?= x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)
  [Meta.isDefEq] [0.003028] ‚úÖÔ∏è ?h‚ÇÉ =?= fun a => Eq.refl (some (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)))
    [Meta.isDefEq.assign] [0.003025] ‚úÖÔ∏è ?h‚ÇÉ := fun a => Eq.refl (some (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)))
      [Meta.isDefEq.assign.checkTypes] [0.003001] ‚úÖÔ∏è (?h‚ÇÉ : ¬¨(!((!x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) &&
                    !x‚úù¬π >>> 2 + 48#8 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))) =
                true ‚Üí
            some (x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8)) =
              some
                (x‚úù >>> 2 +
                  (x‚úù¬π >>> 2 +
                    48#8))) := (fun a =>
            Eq.refl
              (some
                (x‚úù >>> 2 +
                  (x‚úù¬π >>> 2 +
                    48#8))) : ¬¨(!((!x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) &&
                    !x‚úù¬π >>> 2 + 48#8 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))) =
                true ‚Üí
            some (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) = some (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)))
        [Meta.isDefEq] [0.002997] ‚úÖÔ∏è ¬¨(!((!x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) &&
                      !x‚úù¬π >>> 2 + 48#8 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))) =
                  true ‚Üí
              some (x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8)) =
                some
                  (x‚úù >>> 2 +
                    (x‚úù¬π >>> 2 +
                      48#8)) =?= ¬¨(!((!x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) &&
                      !x‚úù¬π >>> 2 + 48#8 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))) =
                  true ‚Üí
              some (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) = some (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))
          [Meta.isDefEq] [0.002962] ‚úÖÔ∏è some (x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8)) =
                some
                  (x‚úù >>> 2 +
                    (x‚úù¬π >>> 2 + 48#8)) =?= some (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) = some (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))
            [Meta.isDefEq] [0.002943] ‚úÖÔ∏è some
                  (x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8)) =?= some (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))
              [Meta.isDefEq] [0.002920] ‚úÖÔ∏è x‚úù >>> 2#8 + (x‚úù¬π >>> 2#8 + 48#8) =?= x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)
                [Meta.isDefEq] [0.002807] ‚úÖÔ∏è instHAdd.1 (x‚úù >>> 2#8)
                      (x‚úù¬π >>> 2#8 + 48#8) =?= instHAdd.1 (x‚úù >>> 2) (x‚úù¬π >>> 2 + 48#8)
                  [Meta.isDefEq] [0.002783] ‚úÖÔ∏è Add.add (x‚úù >>> 2#8)
                        (x‚úù¬π >>> 2#8 + 48#8) =?= Add.add (x‚úù >>> 2) (x‚úù¬π >>> 2 + 48#8)
                    [Meta.isDefEq] [0.002708] ‚úÖÔ∏è BitVec.instAdd.1 (x‚úù >>> 2#8)
                          (x‚úù¬π >>> 2#8 + 48#8) =?= BitVec.instAdd.1 (x‚úù >>> 2) (x‚úù¬π >>> 2 + 48#8)
                      [Meta.isDefEq] [0.002688] ‚úÖÔ∏è (x‚úù >>> 2#8).add
                            (x‚úù¬π >>> 2#8 + 48#8) =?= (x‚úù >>> 2).add (x‚úù¬π >>> 2 + 48#8)
                        [Meta.isDefEq.delta] [0.002678] ‚úÖÔ∏è (x‚úù >>> 2#8).add
                              (x‚úù¬π >>> 2#8 + 48#8) =?= (x‚úù >>> 2).add (x‚úù¬π >>> 2 + 48#8)
                          [Meta.isDefEq] [0.002132] ‚úÖÔ∏è x‚úù >>> 2#8 =?= x‚úù >>> 2
                            [Meta.isDefEq] [0.002117] ‚úÖÔ∏è BitVec.instHShiftRight.1 x‚úù
                                  2#8 =?= BitVec.instHShiftRightNat.1 x‚úù 2
                              [Meta.isDefEq] [0.002093] ‚úÖÔ∏è x‚úù >>> (2#8).toNat =?= x‚úù.ushiftRight 2
                                [Meta.isDefEq] [0.002078] ‚úÖÔ∏è x‚úù.ushiftRight (2#8).toNat =?= x‚úù.ushiftRight 2
                                  [Meta.isDefEq.delta] [0.002070] ‚úÖÔ∏è x‚úù.ushiftRight (2#8).toNat =?= x‚úù.ushiftRight 2
                                    [Meta.isDefEq] [0.002059] ‚úÖÔ∏è (2#8).toNat =?= 2
  [Meta.synthInstance] [0.005181] ‚úÖÔ∏è Decidable
        ((!((!x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) && !x‚úù¬π >>> 2 + 48#8 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))) = true)
    [Meta.synthInstance] [0.001573] new goal Decidable
          ((!((!x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) && !x‚úù¬π >>> 2 + 48#8 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))) =
            true)
    [Meta.synthInstance] [0.001690] ‚úÖÔ∏è apply instDecidableEqBool to Decidable
          ((!((!x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) && !x‚úù¬π >>> 2 + 48#8 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))) =
            true)
      [Meta.synthInstance.tryResolve] [0.001618] ‚úÖÔ∏è Decidable
            ((!((!x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) && !x‚úù¬π >>> 2 + 48#8 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))) =
              true) ‚âü Decidable
            ((!((!x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) && !x‚úù¬π >>> 2 + 48#8 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))) =
              true)
        [Meta.isDefEq] [0.001540] ‚úÖÔ∏è ?m.40246 =?= instDecidableEqBool
              (!((!x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) && !x‚úù¬π >>> 2 + 48#8 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)))
              true
          [Meta.isDefEq.assign] [0.001536] ‚úÖÔ∏è ?m.40246 := instDecidableEqBool
                (!((!x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) && !x‚úù¬π >>> 2 + 48#8 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)))
                true
    [Meta.check] [0.001872] ‚úÖÔ∏è instDecidableEqBool
          (!((!x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) && !x‚úù¬π >>> 2 + 48#8 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))) true
  [Meta.isDefEq] [0.001659] ‚úÖÔ∏è ?h‚ÇÉ =?= fun a =>
        ite_congr
          (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr (congrArg Or (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù¬π >>> 2 + 48#8) (x‚úù¬π >>> 2)))
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù¬π >>> 2 + 48#8) 48#8))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or (x‚úù¬π >>> 2 >·µ§ x‚úù¬π >>> 2 + 48#8)
                    (48#8 >·µ§ x‚úù¬π >>> 2 + 48#8)))
                (congrArg (fun x => x = true)
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x‚úù¬π >>> 2 >·µ§ x‚úù¬π >>> 2 + 48#8)
                    (48#8 >·µ§ x‚úù¬π >>> 2 + 48#8)))))
            (true_and ((!((!x‚úù¬π >>> 2 >·µ§ x‚úù¬π >>> 2 + 48#8) && !48#8 >·µ§ x‚úù¬π >>> 2 + 48#8)) = true)))
          (fun a => Eq.refl none) fun a =>
          ite_congr
            (Eq.trans
              (congrArg (And True)
                (Eq.trans
                  (Eq.trans
                    (congr
                      (congrArg Or
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) (x‚úù >>> 2)))
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) (x‚úù¬π >>> 2 + 48#8)))
                    (Std.Tactic.BVDecide.Normalize.Bool.or_to_or (x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))
                      (x‚úù¬π >>> 2 + 48#8 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))))
                  (congrArg (fun x => x = true)
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))
                      (x‚úù¬π >>> 2 + 48#8 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))))))
              (true_and
                ((!((!x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) &&
                      !x‚úù¬π >>> 2 + 48#8 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))) =
                  true)))
            (fun a => Eq.refl none) fun a => Eq.refl (some (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)))
    [Meta.isDefEq.assign] [0.001654] ‚úÖÔ∏è ?h‚ÇÉ := fun a =>
          ite_congr
            (Eq.trans
              (congrArg (And True)
                (Eq.trans
                  (Eq.trans
                    (congr (congrArg Or (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù¬π >>> 2 + 48#8) (x‚úù¬π >>> 2)))
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù¬π >>> 2 + 48#8) 48#8))
                    (Std.Tactic.BVDecide.Normalize.Bool.or_to_or (x‚úù¬π >>> 2 >·µ§ x‚úù¬π >>> 2 + 48#8)
                      (48#8 >·µ§ x‚úù¬π >>> 2 + 48#8)))
                  (congrArg (fun x => x = true)
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x‚úù¬π >>> 2 >·µ§ x‚úù¬π >>> 2 + 48#8)
                      (48#8 >·µ§ x‚úù¬π >>> 2 + 48#8)))))
              (true_and ((!((!x‚úù¬π >>> 2 >·µ§ x‚úù¬π >>> 2 + 48#8) && !48#8 >·µ§ x‚úù¬π >>> 2 + 48#8)) = true)))
            (fun a => Eq.refl none) fun a =>
            ite_congr
              (Eq.trans
                (congrArg (And True)
                  (Eq.trans
                    (Eq.trans
                      (congr
                        (congrArg Or
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) (x‚úù >>> 2)))
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))
                          (x‚úù¬π >>> 2 + 48#8)))
                      (Std.Tactic.BVDecide.Normalize.Bool.or_to_or (x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))
                        (x‚úù¬π >>> 2 + 48#8 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))))
                    (congrArg (fun x => x = true)
                      (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))
                        (x‚úù¬π >>> 2 + 48#8 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))))))
                (true_and
                  ((!((!x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) &&
                        !x‚úù¬π >>> 2 + 48#8 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))) =
                    true)))
              (fun a => Eq.refl none) fun a => Eq.refl (some (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨some (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) ‚äë
            if (!(x‚úù¬π >>> 2).getLsbD 7 && !(x‚úù¬π >>> 2 + 48#8).getLsbD 7 == (x‚úù¬π >>> 2).getLsbD 7) = true then none
            else
              if (!((!x‚úù¬π >>> 2 >·µ§ x‚úù¬π >>> 2 + 48#8) && !48#8 >·µ§ x‚úù¬π >>> 2 + 48#8)) = true then none
              else
                if
                    (!((!x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) &&
                          !x‚úù¬π >>> 2 + 48#8 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))) =
                      true then
                  none
                else some (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))
      ‚ä¢ False
  [Meta.isDefEq] [0.001795] ‚ùåÔ∏è ?a == ?a =?= (x‚úù¬π >>> 2 + 48#8).getLsbD 7 == (x‚úù¬π >>> 2).getLsbD 7
  [Meta.isDefEq] [0.002180] ‚ùåÔ∏è if ?c then ?a
      else
        ?a =?= if
          (!((!x‚úù >>> 2 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8)) && !x‚úù¬π >>> 2 + 48#8 >·µ§ x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))) =
            true then
        none
      else some (x‚úù >>> 2 + (x‚úù¬π >>> 2 + 48#8))
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 14.113610ms, solving context: 0.000000ms
LeanSAT proved the goal after 9.021640ms: rewriting 8.998450ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 0.493340ms, solving context: 0.000000ms
LeanSAT proved the goal after 2.828580ms: rewriting 2.817980ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 0.483730ms, solving context: 0.000000ms
LeanSAT proved the goal after 2.478620ms: rewriting 2.469080ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 83.123040ms, solving context: 3.000000ms
LeanSAT proved the goal after 89.413880ms: rewriting 17.416470ms, bitblasting 0.000000ms, SAT solving 64.692040ms, LRAT trimming 0.000000ms, LRAT checking 5.537909ms
Bitwuzla proved the goal after 8.180999ms, solving context: 0.000000ms
LeanSAT proved the goal after 3.194760ms: rewriting 3.175150ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 0.627250ms, solving context: 0.000000ms
LeanSAT proved the goal after 4.189650ms: rewriting 4.178630ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 0.743800ms, solving context: 0.000000ms
LeanSAT proved the goal after 3.821580ms: rewriting 3.809640ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 90.115130ms, solving context: 0.000000ms
LeanSAT proved the goal after 129.268559ms: rewriting 31.088670ms, bitblasting 0.000000ms, SAT solving 63.648919ms, LRAT trimming 24.218130ms, LRAT checking 5.152740ms
Bitwuzla proved the goal after 0.779230ms, solving context: 0.000000ms
LeanSAT proved the goal after 3.852210ms: rewriting 3.836760ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 0.635830ms, solving context: 0.000000ms
LeanSAT proved the goal after 3.238850ms: rewriting 3.228590ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 0.646580ms, solving context: 0.000000ms
LeanSAT proved the goal after 3.482520ms: rewriting 3.472190ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 82.723180ms, solving context: 2.000000ms
LeanSAT proved the goal after 85.566759ms: rewriting 17.526220ms, bitblasting 0.000000ms, SAT solving 62.546709ms, LRAT trimming 0.000000ms, LRAT checking 4.183101ms
Bitwuzla proved the goal after 0.991490ms, solving context: 0.000000ms
LeanSAT proved the goal after 2.967670ms: rewriting 2.946490ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 0.529630ms, solving context: 0.000000ms
LeanSAT proved the goal after 2.706980ms: rewriting 2.696829ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 0.447340ms, solving context: 0.000000ms
LeanSAT proved the goal after 4.524430ms: rewriting 4.515920ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 73.249240ms, solving context: 2.000000ms
LeanSAT proved the goal after 80.078370ms: rewriting 16.560970ms, bitblasting 0.000000ms, SAT solving 56.434320ms, LRAT trimming 1.903370ms, LRAT checking 2.068050ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:106:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:106:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:106:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:106:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:100:8: error: (kernel) declaration has metavariables 'lshr_or_or_no_const_thm'
[bv] [0.022238] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 8
      x‚úù¬≥ x‚úù¬≤ x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if x‚úù¬π ‚â• ‚Üë8 then none else if x‚úù¬π ‚â• ‚Üë8 then none else some (x‚úù >>> x‚úù¬π ||| (x‚úù¬≤ >>> x‚úù¬π ||| x‚úù¬≥))) ‚äë
            if x‚úù¬π ‚â• ‚Üë8 then none else some ((x‚úù¬≤ ||| x‚úù) >>> x‚úù¬π ||| x‚úù¬≥)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 8
      x‚úù¬≥ x‚úù¬≤ x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if (!8#8 >·µ§ x‚úù¬π) = true then none
            else if (!8#8 >·µ§ x‚úù¬π) = true then none else some (x‚úù >>> x‚úù¬π ||| (x‚úù¬≤ >>> x‚úù¬π ||| x‚úù¬≥))) ‚äë
            if (!8#8 >·µ§ x‚úù¬π) = true then none else some ((x‚úù¬≤ ||| x‚úù) >>> x‚úù¬π ||| x‚úù¬≥)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:116:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:116:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:116:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:116:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:110:8: error: (kernel) declaration has metavariables 'shl_xor_xor_no_const_thm'
[bv] [0.022210] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 8
      x‚úù¬≥ x‚úù¬≤ x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if x‚úù¬π ‚â• ‚Üë8 then none else if x‚úù¬π ‚â• ‚Üë8 then none else some (x‚úù <<< x‚úù¬π ^^^ (x‚úù¬≤ <<< x‚úù¬π ^^^ x‚úù¬≥))) ‚äë
            if x‚úù¬π ‚â• ‚Üë8 then none else some ((x‚úù¬≤ ^^^ x‚úù) <<< x‚úù¬π ^^^ x‚úù¬≥)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 8
      x‚úù¬≥ x‚úù¬≤ x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if (!8#8 >·µ§ x‚úù¬π) = true then none
            else if (!8#8 >·µ§ x‚úù¬π) = true then none else some (x‚úù <<< x‚úù¬π ^^^ (x‚úù¬≤ <<< x‚úù¬π ^^^ x‚úù¬≥))) ‚äë
            if (!8#8 >·µ§ x‚úù¬π) = true then none else some ((x‚úù¬≤ ^^^ x‚úù) <<< x‚úù¬π ^^^ x‚úù¬≥)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:126:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:126:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:126:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:126:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:120:8: error: (kernel) declaration has metavariables 'shl_add_add_no_const_thm'
[bv] [0.025066] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 8
      x‚úù¬≥ x‚úù¬≤ x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if x‚úù¬π ‚â• ‚Üë8 then none else if x‚úù¬π ‚â• ‚Üë8 then none else some (x‚úù <<< x‚úù¬π + (x‚úù¬≤ <<< x‚úù¬π + x‚úù¬≥))) ‚äë
            if x‚úù¬π ‚â• ‚Üë8 then none else some ((x‚úù¬≤ + x‚úù) <<< x‚úù¬π + x‚úù¬≥)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 8
      x‚úù¬≥ x‚úù¬≤ x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if (!8#8 >·µ§ x‚úù¬π) = true then none
            else if (!8#8 >·µ§ x‚úù¬π) = true then none else some (x‚úù <<< x‚úù¬π + (x‚úù¬≤ <<< x‚úù¬π + x‚úù¬≥))) ‚äë
            if (!8#8 >·µ§ x‚úù¬π) = true then none else some ((x‚úù¬≤ + x‚úù) <<< x‚úù¬π + x‚úù¬≥)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 0.632380ms, solving context: 0.000000ms
LeanSAT proved the goal after 2.652380ms: rewriting 2.638110ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 0.485010ms, solving context: 0.000000ms
LeanSAT proved the goal after 2.726580ms: rewriting 2.716030ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 0.459570ms, solving context: 0.000000ms
LeanSAT proved the goal after 2.412370ms: rewriting 2.403490ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 72.305510ms, solving context: 0.000000ms
LeanSAT proved the goal after 79.364809ms: rewriting 17.030290ms, bitblasting 0.000000ms, SAT solving 55.762229ms, LRAT trimming 2.627980ms, LRAT checking 2.181550ms
Bitwuzla proved the goal after 0.600100ms, solving context: 0.000000ms
LeanSAT proved the goal after 2.624400ms: rewriting 2.612670ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 0.469920ms, solving context: 0.000000ms
LeanSAT proved the goal after 2.673430ms: rewriting 2.665040ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 0.486520ms, solving context: 0.000000ms
LeanSAT proved the goal after 2.387190ms: rewriting 2.379220ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 71.775340ms, solving context: 1.000000ms
LeanSAT proved the goal after 74.903910ms: rewriting 16.203190ms, bitblasting 0.000000ms, SAT solving 54.812870ms, LRAT trimming 0.000000ms, LRAT checking 1.900510ms
Bitwuzla proved the goal after 0.544450ms, solving context: 0.000000ms
LeanSAT proved the goal after 2.690900ms: rewriting 2.678930ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 0.472290ms, solving context: 0.000000ms
LeanSAT proved the goal after 2.658480ms: rewriting 2.650480ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 0.463570ms, solving context: 0.000000ms
LeanSAT proved the goal after 2.411220ms: rewriting 2.402920ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 70.111139ms, solving context: 1.000000ms
LeanSAT proved the goal after 74.890920ms: rewriting 16.415000ms, bitblasting 0.000000ms, SAT solving 54.757600ms, LRAT trimming 0.000000ms, LRAT checking 1.795270ms
Bitwuzla proved the goal after 0.591940ms, solving context: 0.000000ms
LeanSAT proved the goal after 2.632360ms: rewriting 2.619910ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 0.460020ms, solving context: 0.000000ms
LeanSAT proved the goal after 2.624030ms: rewriting 2.615250ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 0.468750ms, solving context: 0.000000ms
LeanSAT proved the goal after 2.397020ms: rewriting 2.388900ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 73.366970ms, solving context: 0.000000ms
LeanSAT proved the goal after 78.585689ms: rewriting 18.647189ms, bitblasting 0.000000ms, SAT solving 54.991100ms, LRAT trimming 0.000000ms, LRAT checking 3.072360ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:182:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:174:8: error: (kernel) declaration has metavariables 'lshr_and_add_fail_thm'
[bv] [0.022997] Normalizing goal
  [Meta.synthInstance] [0.001216] ‚úÖÔ∏è Decidable
        ((if 1#8 ‚â• ‚Üë8 then none else if 1#8 ‚â• ‚Üë8 then none else some (x‚úù >>> 1#8 + (x‚úù¬π >>> 1#8 &&& 123#8))) ‚äë
          if 1#8 ‚â• ‚Üë8 then none
          else
            if 1#8 ‚â• ‚Üë8 then none
            else
              if
                  True ‚àß
                    (x‚úù >>> 1#8 + (x‚úù¬π >>> 1#8 &&& 123#8) < x‚úù >>> 1#8 ‚à®
                      x‚úù >>> 1#8 + (x‚úù¬π >>> 1#8 &&& 123#8) < x‚úù¬π >>> 1#8 &&& 123#8) then
                none
              else some (x‚úù >>> 1#8 + (x‚úù¬π >>> 1#8 &&& 123#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if 1#8 ‚â• ‚Üë8 then none else if 1#8 ‚â• ‚Üë8 then none else some (x‚úù >>> 1#8 + (x‚úù¬π >>> 1#8 &&& 123#8))) ‚äë
            if 1#8 ‚â• ‚Üë8 then none
            else
              if 1#8 ‚â• ‚Üë8 then none
              else
                if
                    True ‚àß
                      (x‚úù >>> 1#8 + (x‚úù¬π >>> 1#8 &&& 123#8) < x‚úù >>> 1#8 ‚à®
                        x‚úù >>> 1#8 + (x‚úù¬π >>> 1#8 &&& 123#8) < x‚úù¬π >>> 1#8 &&& 123#8) then
                  none
                else some (x‚úù >>> 1#8 + (x‚úù¬π >>> 1#8 &&& 123#8))
      ‚ä¢ False
  [Meta.isDefEq] [0.001267] ‚úÖÔ∏è ?h‚ÇÅ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8)) (x‚úù >>> 1)))
                (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8)) (x‚úù¬π >>> 1 &&& 123#8)))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or (x‚úù >>> 1 >·µ§ x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8))
                (x‚úù¬π >>> 1 &&& 123#8 >·µ§ x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8))))
            (congrArg (fun x => x = true)
              (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x‚úù >>> 1 >·µ§ x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8))
                (x‚úù¬π >>> 1 &&& 123#8 >·µ§ x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8))))))
        (true_and
          ((!((!x‚úù >>> 1 >·µ§ x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8)) &&
                !x‚úù¬π >>> 1 &&& 123#8 >·µ§ x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8))) =
            true))
    [Meta.isDefEq.assign] [0.001265] ‚úÖÔ∏è ?h‚ÇÅ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8)) (x‚úù >>> 1)))
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8))
                    (x‚úù¬π >>> 1 &&& 123#8)))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or (x‚úù >>> 1 >·µ§ x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8))
                  (x‚úù¬π >>> 1 &&& 123#8 >·µ§ x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8))))
              (congrArg (fun x => x = true)
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x‚úù >>> 1 >·µ§ x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8))
                  (x‚úù¬π >>> 1 &&& 123#8 >·µ§ x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8))))))
          (true_and
            ((!((!x‚úù >>> 1 >·µ§ x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8)) &&
                  !x‚úù¬π >>> 1 &&& 123#8 >·µ§ x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8))) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.001251] ‚úÖÔ∏è (?h‚ÇÅ : (True ‚àß
              (x‚úù >>> 1#8 + (x‚úù¬π >>> 1#8 &&& 123#8) < x‚úù >>> 1#8 ‚à®
                x‚úù >>> 1#8 + (x‚úù¬π >>> 1#8 &&& 123#8) < x‚úù¬π >>> 1#8 &&& 123#8)) =
            ((!((!x‚úù >>> 1 >·µ§ x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8)) &&
                  !x‚úù¬π >>> 1 &&& 123#8 >·µ§ x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8))) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8)) (x‚úù >>> 1)))
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8))
                      (x‚úù¬π >>> 1 &&& 123#8)))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or (x‚úù >>> 1 >·µ§ x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8))
                    (x‚úù¬π >>> 1 &&& 123#8 >·µ§ x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8))))
                (congrArg (fun x => x = true)
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x‚úù >>> 1 >·µ§ x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8))
                    (x‚úù¬π >>> 1 &&& 123#8 >·µ§ x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8))))))
            (true_and
              ((!((!x‚úù >>> 1 >·µ§ x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8)) &&
                    !x‚úù¬π >>> 1 &&& 123#8 >·µ§ x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8))) =
                true)) : (True ‚àß
              (x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8) < x‚úù >>> 1 ‚à® x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8) < x‚úù¬π >>> 1 &&& 123#8)) =
            ((!((!x‚úù >>> 1 >·µ§ x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8)) &&
                  !x‚úù¬π >>> 1 &&& 123#8 >·µ§ x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8))) =
              true))
        [Meta.isDefEq] [0.001248] ‚úÖÔ∏è (True ‚àß
                (x‚úù >>> 1#8 + (x‚úù¬π >>> 1#8 &&& 123#8) < x‚úù >>> 1#8 ‚à®
                  x‚úù >>> 1#8 + (x‚úù¬π >>> 1#8 &&& 123#8) < x‚úù¬π >>> 1#8 &&& 123#8)) =
              ((!((!x‚úù >>> 1 >·µ§ x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8)) &&
                    !x‚úù¬π >>> 1 &&& 123#8 >·µ§ x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8))) =
                true) =?= (True ‚àß
                (x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8) < x‚úù >>> 1 ‚à®
                  x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8) < x‚úù¬π >>> 1 &&& 123#8)) =
              ((!((!x‚úù >>> 1 >·µ§ x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8)) &&
                    !x‚úù¬π >>> 1 &&& 123#8 >·µ§ x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8))) =
                true)
          [Meta.isDefEq] [0.001226] ‚úÖÔ∏è True ‚àß
                (x‚úù >>> 1#8 + (x‚úù¬π >>> 1#8 &&& 123#8) < x‚úù >>> 1#8 ‚à®
                  x‚úù >>> 1#8 + (x‚úù¬π >>> 1#8 &&& 123#8) <
                    x‚úù¬π >>> 1#8 &&&
                      123#8) =?= True ‚àß
                (x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8) < x‚úù >>> 1 ‚à® x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8) < x‚úù¬π >>> 1 &&& 123#8)
            [Meta.isDefEq] [0.001209] ‚úÖÔ∏è x‚úù >>> 1#8 + (x‚úù¬π >>> 1#8 &&& 123#8) < x‚úù >>> 1#8 ‚à®
                  x‚úù >>> 1#8 + (x‚úù¬π >>> 1#8 &&& 123#8) <
                    x‚úù¬π >>> 1#8 &&&
                      123#8 =?= x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8) < x‚úù >>> 1 ‚à®
                  x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8) < x‚úù¬π >>> 1 &&& 123#8
              [Meta.isDefEq] [0.001070] ‚úÖÔ∏è x‚úù >>> 1#8 + (x‚úù¬π >>> 1#8 &&& 123#8) <
                    x‚úù >>> 1#8 =?= x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8) < x‚úù >>> 1
                [Meta.isDefEq] [0.001047] ‚úÖÔ∏è instLTBitVec.1 (x‚úù >>> 1#8 + (x‚úù¬π >>> 1#8 &&& 123#8))
                      (x‚úù >>> 1#8) =?= instLTBitVec.1 (x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8)) (x‚úù >>> 1)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨some (x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8)) ‚äë
            if
                (!((!x‚úù >>> 1 >·µ§ x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8)) &&
                      !x‚úù¬π >>> 1 &&& 123#8 >·µ§ x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8))) =
                  true then
              none
            else some (x‚úù >>> 1 + (x‚úù¬π >>> 1 &&& 123#8))
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:194:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:186:8: error: (kernel) declaration has metavariables 'lshr_add_or_fail_thm'
[bv] [0.021375] Normalizing goal
  [Meta.synthInstance] [0.001153] ‚úÖÔ∏è Decidable
        ((if 1#8 ‚â• ‚Üë8 then none else if 1#8 ‚â• ‚Üë8 then none else some (x‚úù >>> 1#8 ||| x‚úù¬π >>> 1#8 + 123#8)) ‚äë
          if 1#8 ‚â• ‚Üë8 then none
          else
            if 1#8 ‚â• ‚Üë8 then none
            else
              if True ‚àß (x‚úù¬π >>> 1#8 + 123#8 < x‚úù¬π >>> 1#8 ‚à® x‚úù¬π >>> 1#8 + 123#8 < 123#8) then none
              else some (x‚úù >>> 1#8 ||| x‚úù¬π >>> 1#8 + 123#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if 1#8 ‚â• ‚Üë8 then none else if 1#8 ‚â• ‚Üë8 then none else some (x‚úù >>> 1#8 ||| x‚úù¬π >>> 1#8 + 123#8)) ‚äë
            if 1#8 ‚â• ‚Üë8 then none
            else
              if 1#8 ‚â• ‚Üë8 then none
              else
                if True ‚àß (x‚úù¬π >>> 1#8 + 123#8 < x‚úù¬π >>> 1#8 ‚à® x‚úù¬π >>> 1#8 + 123#8 < 123#8) then none
                else some (x‚úù >>> 1#8 ||| x‚úù¬π >>> 1#8 + 123#8)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨some (x‚úù >>> 1 ||| x‚úù¬π >>> 1 + 123#8) ‚äë
            if (!((!x‚úù¬π >>> 1 >·µ§ x‚úù¬π >>> 1 + 123#8) && !123#8 >·µ§ x‚úù¬π >>> 1 + 123#8)) = true then none
            else some (x‚úù >>> 1 ||| x‚úù¬π >>> 1 + 123#8)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:206:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:198:8: error: (kernel) declaration has metavariables 'lshr_add_xor_fail_thm'
[bv] [0.022437] Normalizing goal
  [Meta.synthInstance] [0.001217] ‚úÖÔ∏è Decidable
        ((if 1#8 ‚â• ‚Üë8 then none else if 1#8 ‚â• ‚Üë8 then none else some (x‚úù >>> 1#8 ^^^ x‚úù¬π >>> 1#8 + 123#8)) ‚äë
          if 1#8 ‚â• ‚Üë8 then none
          else
            if 1#8 ‚â• ‚Üë8 then none
            else
              if True ‚àß (x‚úù¬π >>> 1#8 + 123#8 < x‚úù¬π >>> 1#8 ‚à® x‚úù¬π >>> 1#8 + 123#8 < 123#8) then none
              else some (x‚úù >>> 1#8 ^^^ x‚úù¬π >>> 1#8 + 123#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if 1#8 ‚â• ‚Üë8 then none else if 1#8 ‚â• ‚Üë8 then none else some (x‚úù >>> 1#8 ^^^ x‚úù¬π >>> 1#8 + 123#8)) ‚äë
            if 1#8 ‚â• ‚Üë8 then none
            else
              if 1#8 ‚â• ‚Üë8 then none
              else
                if True ‚àß (x‚úù¬π >>> 1#8 + 123#8 < x‚úù¬π >>> 1#8 ‚à® x‚úù¬π >>> 1#8 + 123#8 < 123#8) then none
                else some (x‚úù >>> 1#8 ^^^ x‚úù¬π >>> 1#8 + 123#8)
      ‚ä¢ False
  [Meta.isDefEq] [0.001067] ‚úÖÔ∏è ?h‚ÇÅ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr (congrArg Or (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù¬π >>> 1 + 123#8) (x‚úù¬π >>> 1)))
                (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù¬π >>> 1 + 123#8) 123#8))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or (x‚úù¬π >>> 1 >·µ§ x‚úù¬π >>> 1 + 123#8)
                (123#8 >·µ§ x‚úù¬π >>> 1 + 123#8)))
            (congrArg (fun x => x = true)
              (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x‚úù¬π >>> 1 >·µ§ x‚úù¬π >>> 1 + 123#8)
                (123#8 >·µ§ x‚úù¬π >>> 1 + 123#8)))))
        (true_and ((!((!x‚úù¬π >>> 1 >·µ§ x‚úù¬π >>> 1 + 123#8) && !123#8 >·µ§ x‚úù¬π >>> 1 + 123#8)) = true))
    [Meta.isDefEq.assign] [0.001065] ‚úÖÔ∏è ?h‚ÇÅ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr (congrArg Or (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù¬π >>> 1 + 123#8) (x‚úù¬π >>> 1)))
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù¬π >>> 1 + 123#8) 123#8))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or (x‚úù¬π >>> 1 >·µ§ x‚úù¬π >>> 1 + 123#8)
                  (123#8 >·µ§ x‚úù¬π >>> 1 + 123#8)))
              (congrArg (fun x => x = true)
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x‚úù¬π >>> 1 >·µ§ x‚úù¬π >>> 1 + 123#8)
                  (123#8 >·µ§ x‚úù¬π >>> 1 + 123#8)))))
          (true_and ((!((!x‚úù¬π >>> 1 >·µ§ x‚úù¬π >>> 1 + 123#8) && !123#8 >·µ§ x‚úù¬π >>> 1 + 123#8)) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001050] ‚úÖÔ∏è (?h‚ÇÅ : (True ‚àß
              (x‚úù¬π >>> 1#8 + 123#8 < x‚úù¬π >>> 1#8 ‚à® x‚úù¬π >>> 1#8 + 123#8 < 123#8)) =
            ((!((!x‚úù¬π >>> 1 >·µ§ x‚úù¬π >>> 1 + 123#8) && !123#8 >·µ§ x‚úù¬π >>> 1 + 123#8)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr (congrArg Or (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù¬π >>> 1 + 123#8) (x‚úù¬π >>> 1)))
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (x‚úù¬π >>> 1 + 123#8) 123#8))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or (x‚úù¬π >>> 1 >·µ§ x‚úù¬π >>> 1 + 123#8)
                    (123#8 >·µ§ x‚úù¬π >>> 1 + 123#8)))
                (congrArg (fun x => x = true)
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim (x‚úù¬π >>> 1 >·µ§ x‚úù¬π >>> 1 + 123#8)
                    (123#8 >·µ§ x‚úù¬π >>> 1 + 123#8)))))
            (true_and
              ((!((!x‚úù¬π >>> 1 >·µ§ x‚úù¬π >>> 1 + 123#8) && !123#8 >·µ§ x‚úù¬π >>> 1 + 123#8)) =
                true)) : (True ‚àß (x‚úù¬π >>> 1 + 123#8 < x‚úù¬π >>> 1 ‚à® x‚úù¬π >>> 1 + 123#8 < 123#8)) =
            ((!((!x‚úù¬π >>> 1 >·µ§ x‚úù¬π >>> 1 + 123#8) && !123#8 >·µ§ x‚úù¬π >>> 1 + 123#8)) = true))
        [Meta.isDefEq] [0.001047] ‚úÖÔ∏è (True ‚àß (x‚úù¬π >>> 1#8 + 123#8 < x‚úù¬π >>> 1#8 ‚à® x‚úù¬π >>> 1#8 + 123#8 < 123#8)) =
              ((!((!x‚úù¬π >>> 1 >·µ§ x‚úù¬π >>> 1 + 123#8) && !123#8 >·µ§ x‚úù¬π >>> 1 + 123#8)) =
                true) =?= (True ‚àß (x‚úù¬π >>> 1 + 123#8 < x‚úù¬π >>> 1 ‚à® x‚úù¬π >>> 1 + 123#8 < 123#8)) =
              ((!((!x‚úù¬π >>> 1 >·µ§ x‚úù¬π >>> 1 + 123#8) && !123#8 >·µ§ x‚úù¬π >>> 1 + 123#8)) = true)
          [Meta.isDefEq] [0.001026] ‚úÖÔ∏è True ‚àß
                (x‚úù¬π >>> 1#8 + 123#8 < x‚úù¬π >>> 1#8 ‚à®
                  x‚úù¬π >>> 1#8 + 123#8 < 123#8) =?= True ‚àß (x‚úù¬π >>> 1 + 123#8 < x‚úù¬π >>> 1 ‚à® x‚úù¬π >>> 1 + 123#8 < 123#8)
            [Meta.isDefEq] [0.001008] ‚úÖÔ∏è x‚úù¬π >>> 1#8 + 123#8 < x‚úù¬π >>> 1#8 ‚à®
                  x‚úù¬π >>> 1#8 + 123#8 < 123#8 =?= x‚úù¬π >>> 1 + 123#8 < x‚úù¬π >>> 1 ‚à® x‚úù¬π >>> 1 + 123#8 < 123#8
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨some (x‚úù >>> 1 ^^^ x‚úù¬π >>> 1 + 123#8) ‚äë
            if (!((!x‚úù¬π >>> 1 >·µ§ x‚úù¬π >>> 1 + 123#8) && !123#8 >·µ§ x‚úù¬π >>> 1 + 123#8)) = true then none
            else some (x‚úù >>> 1 ^^^ x‚úù¬π >>> 1 + 123#8)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:218:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:210:8: error: (kernel) declaration has metavariables 'shl_add_and_fail_mismatch_shift_thm'
[bv] [0.022399] Normalizing goal
  [Meta.synthInstance] [0.001200] ‚úÖÔ∏è Decidable
        ((if 1#8 ‚â• ‚Üë8 then none else if 1#8 ‚â• ‚Üë8 then none else some (x‚úù <<< 1#8 &&& x‚úù¬π >>> 1#8 + 123#8)) ‚äë
          if 1#8 ‚â• ‚Üë8 then none
          else
            if 1#8 ‚â• ‚Üë8 then none
            else
              if True ‚àß (x‚úù¬π >>> 1#8 + 123#8 < x‚úù¬π >>> 1#8 ‚à® x‚úù¬π >>> 1#8 + 123#8 < 123#8) then none
              else some (x‚úù <<< 1#8 &&& x‚úù¬π >>> 1#8 + 123#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if 1#8 ‚â• ‚Üë8 then none else if 1#8 ‚â• ‚Üë8 then none else some (x‚úù <<< 1#8 &&& x‚úù¬π >>> 1#8 + 123#8)) ‚äë
            if 1#8 ‚â• ‚Üë8 then none
            else
              if 1#8 ‚â• ‚Üë8 then none
              else
                if True ‚àß (x‚úù¬π >>> 1#8 + 123#8 < x‚úù¬π >>> 1#8 ‚à® x‚úù¬π >>> 1#8 + 123#8 < 123#8) then none
                else some (x‚úù <<< 1#8 &&& x‚úù¬π >>> 1#8 + 123#8)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨some (x‚úù <<< 1 &&& x‚úù¬π >>> 1 + 123#8) ‚äë
            if (!((!x‚úù¬π >>> 1 >·µ§ x‚úù¬π >>> 1 + 123#8) && !123#8 >·µ§ x‚úù¬π >>> 1 + 123#8)) = true then none
            else some (x‚úù <<< 1 &&& x‚úù¬π >>> 1 + 123#8)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:229:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:229:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:222:8: error: (kernel) declaration has metavariables 'and_ashr_not_thm'
[bv] [0.025667] Normalizing goal
  [Meta.synthInstance] [0.001025] ‚úÖÔ∏è Decidable
        ((if x‚úù¬π ‚â• ‚Üë8 then none
          else if x‚úù¬π ‚â• ‚Üë8 then none else some (x‚úù.sshiftRight x‚úù¬π.toNat &&& (x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^ -1#8))) ‚äë
          if x‚úù¬π ‚â• ‚Üë8 then none else some ((x‚úù &&& (x‚úù¬≤ ^^^ -1#8)).sshiftRight x‚úù¬π.toNat))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x‚úù¬≤ x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if x‚úù¬π ‚â• ‚Üë8 then none
            else if x‚úù¬π ‚â• ‚Üë8 then none else some (x‚úù.sshiftRight x‚úù¬π.toNat &&& (x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^ -1#8))) ‚äë
            if x‚úù¬π ‚â• ‚Üë8 then none else some ((x‚úù &&& (x‚úù¬≤ ^^^ -1#8)).sshiftRight x‚úù¬π.toNat)
      ‚ä¢ False
  [Meta.isDefEq] [0.001092] ‚úÖÔ∏è ?h‚ÇÉ =?= fun a =>
        Eq.refl (some (x‚úù.sshiftRight x‚úù¬π.toNat &&& (x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^ 255#8)))
    [Meta.isDefEq.assign] [0.001090] ‚úÖÔ∏è ?h‚ÇÉ := fun a =>
          Eq.refl (some (x‚úù.sshiftRight x‚úù¬π.toNat &&& (x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^ 255#8)))
      [Meta.isDefEq.assign.checkTypes] [0.001065] ‚úÖÔ∏è (?h‚ÇÉ : ¬¨(!8#8 >·µ§ x‚úù¬π) = true ‚Üí
            some (x‚úù.sshiftRight x‚úù¬π.toNat &&& (x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^ -1#8)) =
              some
                (x‚úù.sshiftRight x‚úù¬π.toNat &&&
                  (x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^
                    255#8))) := (fun a =>
            Eq.refl
              (some
                (x‚úù.sshiftRight x‚úù¬π.toNat &&&
                  (x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^
                    255#8))) : ¬¨(!8#8 >·µ§ x‚úù¬π) = true ‚Üí
            some (x‚úù.sshiftRight x‚úù¬π.toNat &&& (x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^ 255#8)) =
              some (x‚úù.sshiftRight x‚úù¬π.toNat &&& (x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^ 255#8)))
        [Meta.isDefEq] [0.001062] ‚úÖÔ∏è ¬¨(!8#8 >·µ§ x‚úù¬π) = true ‚Üí
              some (x‚úù.sshiftRight x‚úù¬π.toNat &&& (x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^ -1#8)) =
                some
                  (x‚úù.sshiftRight x‚úù¬π.toNat &&&
                    (x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^
                      255#8)) =?= ¬¨(!8#8 >·µ§ x‚úù¬π) = true ‚Üí
              some (x‚úù.sshiftRight x‚úù¬π.toNat &&& (x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^ 255#8)) =
                some (x‚úù.sshiftRight x‚úù¬π.toNat &&& (x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^ 255#8))
          [Meta.isDefEq] [0.001024] ‚úÖÔ∏è some (x‚úù.sshiftRight x‚úù¬π.toNat &&& (x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^ -1#8)) =
                some
                  (x‚úù.sshiftRight x‚úù¬π.toNat &&&
                    (x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^
                      255#8)) =?= some (x‚úù.sshiftRight x‚úù¬π.toNat &&& (x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^ 255#8)) =
                some (x‚úù.sshiftRight x‚úù¬π.toNat &&& (x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^ 255#8))
            [Meta.isDefEq] [0.001005] ‚úÖÔ∏è some
                  (x‚úù.sshiftRight x‚úù¬π.toNat &&&
                    (x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^
                      -1#8)) =?= some (x‚úù.sshiftRight x‚úù¬π.toNat &&& (x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^ 255#8))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x‚úù¬≤ x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if (!8#8 >·µ§ x‚úù¬π) = true then none
            else
              if (!8#8 >·µ§ x‚úù¬π) = true then none
              else some (x‚úù.sshiftRight x‚úù¬π.toNat &&& (x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^ 255#8))) ‚äë
            if (!8#8 >·µ§ x‚úù¬π) = true then none else some ((x‚úù &&& (x‚úù¬≤ ^^^ 255#8)).sshiftRight x‚úù¬π.toNat)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:240:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:240:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:233:8: error: (kernel) declaration has metavariables 'and_ashr_not_commuted_thm'
[bv] [0.025036] Normalizing goal
  [Meta.synthInstance] [0.001012] ‚úÖÔ∏è Decidable
        ((if x‚úù¬π ‚â• ‚Üë8 then none
          else if x‚úù¬π ‚â• ‚Üë8 then none else some ((x‚úù.sshiftRight x‚úù¬π.toNat ^^^ -1#8) &&& x‚úù¬≤.sshiftRight x‚úù¬π.toNat)) ‚äë
          if x‚úù¬π ‚â• ‚Üë8 then none else some ((x‚úù¬≤ &&& (x‚úù ^^^ -1#8)).sshiftRight x‚úù¬π.toNat))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x‚úù¬≤ x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if x‚úù¬π ‚â• ‚Üë8 then none
            else if x‚úù¬π ‚â• ‚Üë8 then none else some ((x‚úù.sshiftRight x‚úù¬π.toNat ^^^ -1#8) &&& x‚úù¬≤.sshiftRight x‚úù¬π.toNat)) ‚äë
            if x‚úù¬π ‚â• ‚Üë8 then none else some ((x‚úù¬≤ &&& (x‚úù ^^^ -1#8)).sshiftRight x‚úù¬π.toNat)
      ‚ä¢ False
  [Meta.isDefEq] [0.001015] ‚úÖÔ∏è ?h‚ÇÉ =?= fun a =>
        Eq.refl (some ((x‚úù.sshiftRight x‚úù¬π.toNat ^^^ 255#8) &&& x‚úù¬≤.sshiftRight x‚úù¬π.toNat))
    [Meta.isDefEq.assign] [0.001011] ‚úÖÔ∏è ?h‚ÇÉ := fun a =>
          Eq.refl (some ((x‚úù.sshiftRight x‚úù¬π.toNat ^^^ 255#8) &&& x‚úù¬≤.sshiftRight x‚úù¬π.toNat))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x‚úù¬≤ x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if (!8#8 >·µ§ x‚úù¬π) = true then none
            else
              if (!8#8 >·µ§ x‚úù¬π) = true then none
              else some ((x‚úù.sshiftRight x‚úù¬π.toNat ^^^ 255#8) &&& x‚úù¬≤.sshiftRight x‚úù¬π.toNat)) ‚äë
            if (!8#8 >·µ§ x‚úù¬π) = true then none else some ((x‚úù¬≤ &&& (x‚úù ^^^ 255#8)).sshiftRight x‚úù¬π.toNat)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:251:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:251:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:244:8: error: (kernel) declaration has metavariables 'or_ashr_not_thm'
[bv] [0.024102] Normalizing goal
  [Meta.synthInstance] [0.001013] ‚úÖÔ∏è Decidable
        ((if x‚úù¬π ‚â• ‚Üë8 then none
          else if x‚úù¬π ‚â• ‚Üë8 then none else some (x‚úù.sshiftRight x‚úù¬π.toNat ||| x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^ -1#8)) ‚äë
          if x‚úù¬π ‚â• ‚Üë8 then none else some ((x‚úù ||| x‚úù¬≤ ^^^ -1#8).sshiftRight x‚úù¬π.toNat))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x‚úù¬≤ x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if x‚úù¬π ‚â• ‚Üë8 then none
            else if x‚úù¬π ‚â• ‚Üë8 then none else some (x‚úù.sshiftRight x‚úù¬π.toNat ||| x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^ -1#8)) ‚äë
            if x‚úù¬π ‚â• ‚Üë8 then none else some ((x‚úù ||| x‚úù¬≤ ^^^ -1#8).sshiftRight x‚úù¬π.toNat)
      ‚ä¢ False
  [Meta.isDefEq] [0.001045] ‚úÖÔ∏è ?h‚ÇÉ =?= fun a =>
        Eq.refl (some (x‚úù.sshiftRight x‚úù¬π.toNat ||| x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^ 255#8))
    [Meta.isDefEq.assign] [0.001041] ‚úÖÔ∏è ?h‚ÇÉ := fun a =>
          Eq.refl (some (x‚úù.sshiftRight x‚úù¬π.toNat ||| x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^ 255#8))
      [Meta.isDefEq.assign.checkTypes] [0.001015] ‚úÖÔ∏è (?h‚ÇÉ : ¬¨(!8#8 >·µ§ x‚úù¬π) = true ‚Üí
            some (x‚úù.sshiftRight x‚úù¬π.toNat ||| x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^ -1#8) =
              some
                (x‚úù.sshiftRight x‚úù¬π.toNat |||
                  x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^
                    255#8)) := (fun a =>
            Eq.refl
              (some
                (x‚úù.sshiftRight x‚úù¬π.toNat |||
                  x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^
                    255#8)) : ¬¨(!8#8 >·µ§ x‚úù¬π) = true ‚Üí
            some (x‚úù.sshiftRight x‚úù¬π.toNat ||| x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^ 255#8) =
              some (x‚úù.sshiftRight x‚úù¬π.toNat ||| x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^ 255#8))
        [Meta.isDefEq] [0.001010] ‚úÖÔ∏è ¬¨(!8#8 >·µ§ x‚úù¬π) = true ‚Üí
              some (x‚úù.sshiftRight x‚úù¬π.toNat ||| x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^ -1#8) =
                some
                  (x‚úù.sshiftRight x‚úù¬π.toNat |||
                    x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^
                      255#8) =?= ¬¨(!8#8 >·µ§ x‚úù¬π) = true ‚Üí
              some (x‚úù.sshiftRight x‚úù¬π.toNat ||| x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^ 255#8) =
                some (x‚úù.sshiftRight x‚úù¬π.toNat ||| x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^ 255#8)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x‚úù¬≤ x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if (!8#8 >·µ§ x‚úù¬π) = true then none
            else
              if (!8#8 >·µ§ x‚úù¬π) = true then none
              else some (x‚úù.sshiftRight x‚úù¬π.toNat ||| x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^ 255#8)) ‚äë
            if (!8#8 >·µ§ x‚úù¬π) = true then none else some ((x‚úù ||| x‚úù¬≤ ^^^ 255#8).sshiftRight x‚úù¬π.toNat)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:262:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:262:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:255:8: error: (kernel) declaration has metavariables 'or_ashr_not_commuted_thm'
[bv] [0.024100] Normalizing goal
  [Meta.synthInstance] [0.001020] ‚úÖÔ∏è Decidable
        ((if x‚úù¬π ‚â• ‚Üë8 then none
          else if x‚úù¬π ‚â• ‚Üë8 then none else some (x‚úù.sshiftRight x‚úù¬π.toNat ^^^ -1#8 ||| x‚úù¬≤.sshiftRight x‚úù¬π.toNat)) ‚äë
          if x‚úù¬π ‚â• ‚Üë8 then none else some ((x‚úù¬≤ ||| x‚úù ^^^ -1#8).sshiftRight x‚úù¬π.toNat))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x‚úù¬≤ x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if x‚úù¬π ‚â• ‚Üë8 then none
            else if x‚úù¬π ‚â• ‚Üë8 then none else some (x‚úù.sshiftRight x‚úù¬π.toNat ^^^ -1#8 ||| x‚úù¬≤.sshiftRight x‚úù¬π.toNat)) ‚äë
            if x‚úù¬π ‚â• ‚Üë8 then none else some ((x‚úù¬≤ ||| x‚úù ^^^ -1#8).sshiftRight x‚úù¬π.toNat)
      ‚ä¢ False
  [Meta.isDefEq] [0.001011] ‚úÖÔ∏è ?h‚ÇÉ =?= fun a =>
        Eq.refl (some (x‚úù.sshiftRight x‚úù¬π.toNat ^^^ 255#8 ||| x‚úù¬≤.sshiftRight x‚úù¬π.toNat))
    [Meta.isDefEq.assign] [0.001007] ‚úÖÔ∏è ?h‚ÇÉ := fun a =>
          Eq.refl (some (x‚úù.sshiftRight x‚úù¬π.toNat ^^^ 255#8 ||| x‚úù¬≤.sshiftRight x‚úù¬π.toNat))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x‚úù¬≤ x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if (!8#8 >·µ§ x‚úù¬π) = true then none
            else
              if (!8#8 >·µ§ x‚úù¬π) = true then none
              else some (x‚úù.sshiftRight x‚úù¬π.toNat ^^^ 255#8 ||| x‚úù¬≤.sshiftRight x‚úù¬π.toNat)) ‚äë
            if (!8#8 >·µ§ x‚úù¬π) = true then none else some ((x‚úù¬≤ ||| x‚úù ^^^ 255#8).sshiftRight x‚úù¬π.toNat)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:273:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:273:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:266:8: error: (kernel) declaration has metavariables 'xor_ashr_not_thm'
[bv] [0.022752] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x‚úù¬≤ x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if x‚úù¬π ‚â• ‚Üë8 then none
            else if x‚úù¬π ‚â• ‚Üë8 then none else some (x‚úù.sshiftRight x‚úù¬π.toNat ^^^ (x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^ -1#8))) ‚äë
            if x‚úù¬π ‚â• ‚Üë8 then none else some ((x‚úù¬≤ ^^^ x‚úù).sshiftRight x‚úù¬π.toNat ^^^ -1#8)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x‚úù¬≤ x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if (!8#8 >·µ§ x‚úù¬π) = true then none
            else
              if (!8#8 >·µ§ x‚úù¬π) = true then none
              else some (x‚úù.sshiftRight x‚úù¬π.toNat ^^^ (x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^ 255#8))) ‚äë
            if (!8#8 >·µ§ x‚úù¬π) = true then none else some ((x‚úù¬≤ ^^^ x‚úù).sshiftRight x‚úù¬π.toNat ^^^ 255#8)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:284:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:284:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:277:8: error: (kernel) declaration has metavariables 'xor_ashr_not_commuted_thm'
[bv] [0.022892] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x‚úù¬≤ x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if x‚úù¬π ‚â• ‚Üë8 then none
            else if x‚úù¬π ‚â• ‚Üë8 then none else some (x‚úù.sshiftRight x‚úù¬π.toNat ^^^ -1#8 ^^^ x‚úù¬≤.sshiftRight x‚úù¬π.toNat)) ‚äë
            if x‚úù¬π ‚â• ‚Üë8 then none else some ((x‚úù ^^^ x‚úù¬≤).sshiftRight x‚úù¬π.toNat ^^^ -1#8)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x‚úù¬≤ x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if (!8#8 >·µ§ x‚úù¬π) = true then none
            else
              if (!8#8 >·µ§ x‚úù¬π) = true then none
              else some (x‚úù.sshiftRight x‚úù¬π.toNat ^^^ 255#8 ^^^ x‚úù¬≤.sshiftRight x‚úù¬π.toNat)) ‚äë
            if (!8#8 >·µ§ x‚úù¬π) = true then none else some ((x‚úù ^^^ x‚úù¬≤).sshiftRight x‚úù¬π.toNat ^^^ 255#8)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:295:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:295:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:288:8: error: (kernel) declaration has metavariables 'xor_ashr_not_fail_lshr_ashr_thm'
[bv] [0.026084] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x‚úù¬≤ x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if x‚úù¬π ‚â• ‚Üë8 then none
            else if x‚úù¬π ‚â• ‚Üë8 then none else some (x‚úù >>> x‚úù¬π ^^^ (x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^ -1#8))) ‚äë
            if x‚úù¬π ‚â• ‚Üë8 then none
            else if x‚úù¬π ‚â• ‚Üë8 then none else some (x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^ x‚úù >>> x‚úù¬π ^^^ -1#8)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x‚úù¬≤ x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if (!8#8 >·µ§ x‚úù¬π) = true then none
            else if (!8#8 >·µ§ x‚úù¬π) = true then none else some (x‚úù >>> x‚úù¬π ^^^ (x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^ 255#8))) ‚äë
            if (!8#8 >·µ§ x‚úù¬π) = true then none
            else if (!8#8 >·µ§ x‚úù¬π) = true then none else some (x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^ x‚úù >>> x‚úù¬π ^^^ 255#8)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:306:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:306:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:299:8: error: (kernel) declaration has metavariables 'xor_ashr_not_fail_ashr_lshr_thm'
[bv] [0.025844] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x‚úù¬≤ x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if x‚úù¬π ‚â• ‚Üë8 then none
            else if x‚úù¬π ‚â• ‚Üë8 then none else some (x‚úù.sshiftRight x‚úù¬π.toNat ^^^ (x‚úù¬≤ >>> x‚úù¬π ^^^ -1#8))) ‚äë
            if x‚úù¬π ‚â• ‚Üë8 then none
            else if x‚úù¬π ‚â• ‚Üë8 then none else some (x‚úù¬≤ >>> x‚úù¬π ^^^ x‚úù.sshiftRight x‚úù¬π.toNat ^^^ -1#8)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x‚úù¬≤ x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if (!8#8 >·µ§ x‚úù¬π) = true then none
            else if (!8#8 >·µ§ x‚úù¬π) = true then none else some (x‚úù.sshiftRight x‚úù¬π.toNat ^^^ (x‚úù¬≤ >>> x‚úù¬π ^^^ 255#8))) ‚äë
            if (!8#8 >·µ§ x‚úù¬π) = true then none
            else if (!8#8 >·µ§ x‚úù¬π) = true then none else some (x‚úù¬≤ >>> x‚úù¬π ^^^ x‚úù.sshiftRight x‚úù¬π.toNat ^^^ 255#8)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:317:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:317:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophandhshifts_proof.lean:310:8: error: (kernel) declaration has metavariables 'xor_ashr_not_fail_invalid_xor_constant_thm'
[bv] [0.020728] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x‚úù¬≤ x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if x‚úù¬π ‚â• ‚Üë8 then none
            else if x‚úù¬π ‚â• ‚Üë8 then none else some (x‚úù.sshiftRight x‚úù¬π.toNat ^^^ (x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^ 254#8))) ‚äë
            if x‚úù¬π ‚â• ‚Üë8 then none else some ((x‚úù¬≤ ^^^ x‚úù).sshiftRight x‚úù¬π.toNat ^^^ 254#8)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x‚úù¬≤ x‚úù¬π x‚úù : BitVec 8
      a‚úù :
        ¬¨(if (!8#8 >·µ§ x‚úù¬π) = true then none
            else
              if (!8#8 >·µ§ x‚úù¬π) = true then none
              else some (x‚úù.sshiftRight x‚úù¬π.toNat ^^^ (x‚úù¬≤.sshiftRight x‚úù¬π.toNat ^^^ 254#8))) ‚äë
            if (!8#8 >·µ§ x‚úù¬π) = true then none else some ((x‚úù¬≤ ^^^ x‚úù).sshiftRight x‚úù¬π.toNat ^^^ 254#8)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
