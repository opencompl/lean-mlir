⚠ [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
⚠ [866/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
⚠ [883/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [886/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
⚠ [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:16:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:16:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:11:8: error: (kernel) declaration has metavariables 'add_shl_same_amount_thm'
[bv] [0.023283] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 6
      x✝² x✝¹ x✝ : BitVec 6
      a✝ :
        ¬(if x✝¹ ≥ ↑6 then none else if x✝¹ ≥ ↑6 then none else some (x✝ <<< x✝¹ + x✝² <<< x✝¹)) ⊑
            if x✝¹ ≥ ↑6 then none else some ((x✝ + x✝²) <<< x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 6
      x✝² x✝¹ x✝ : BitVec 6
      a✝ :
        ¬(if (!6#6 >ᵤ x✝¹) = true then none
            else if (!6#6 >ᵤ x✝¹) = true then none else some (x✝ <<< x✝¹ + x✝² <<< x✝¹)) ⊑
            if (!6#6 >ᵤ x✝¹) = true then none else some ((x✝ + x✝²) <<< x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:28:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:28:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:20:8: error: (kernel) declaration has metavariables 'add_shl_same_amount_nuw_thm'
[bv] [0.060459] Normalizing goal
  [Meta.synthInstance] [0.001424] ✅️ Decidable
        ((if True ∧ x✝ <<< x✝¹ >>> x✝¹ = x✝ then none
          else
            if x✝¹ ≥ ↑64 then none
            else
              if True ∧ x✝² <<< x✝¹ >>> x✝¹ = x✝² then none
              else
                if x✝¹ ≥ ↑64 then none
                else
                  if True ∧ (x✝ <<< x✝¹ + x✝² <<< x✝¹ < x✝ <<< x✝¹ ∨ x✝ <<< x✝¹ + x✝² <<< x✝¹ < x✝² <<< x✝¹) then none
                  else some (x✝ <<< x✝¹ + x✝² <<< x✝¹)) ⊑
          if True ∧ (x✝ + x✝² < x✝ ∨ x✝ + x✝² < x✝²) then none
          else
            if True ∧ (x✝ + x✝²) <<< x✝¹ >>> x✝¹ = x✝ + x✝² then none
            else if x✝¹ ≥ ↑64 then none else some ((x✝ + x✝²) <<< x✝¹))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 64
      x✝² x✝¹ x✝ : BitVec 64
      a✝ :
        ¬(if True ∧ x✝ <<< x✝¹ >>> x✝¹ = x✝ then none
            else
              if x✝¹ ≥ ↑64 then none
              else
                if True ∧ x✝² <<< x✝¹ >>> x✝¹ = x✝² then none
                else
                  if x✝¹ ≥ ↑64 then none
                  else
                    if True ∧ (x✝ <<< x✝¹ + x✝² <<< x✝¹ < x✝ <<< x✝¹ ∨ x✝ <<< x✝¹ + x✝² <<< x✝¹ < x✝² <<< x✝¹) then none
                    else some (x✝ <<< x✝¹ + x✝² <<< x✝¹)) ⊑
            if True ∧ (x✝ + x✝² < x✝ ∨ x✝ + x✝² < x✝²) then none
            else
              if True ∧ (x✝ + x✝²) <<< x✝¹ >>> x✝¹ = x✝ + x✝² then none
              else if x✝¹ ≥ ↑64 then none else some ((x✝ + x✝²) <<< x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 64
      x✝² x✝¹ x✝ : BitVec 64
      a✝ :
        ¬(if (x✝ <<< x✝¹ >>> x✝¹ == x✝) = true then none
            else
              if (!64#64 >ᵤ x✝¹) = true then none
              else
                if (x✝² <<< x✝¹ >>> x✝¹ == x✝²) = true then none
                else
                  if (!64#64 >ᵤ x✝¹) = true then none
                  else
                    if
                        (!((!x✝ <<< x✝¹ >ᵤ x✝ <<< x✝¹ + x✝² <<< x✝¹) && !x✝² <<< x✝¹ >ᵤ x✝ <<< x✝¹ + x✝² <<< x✝¹)) =
                          true then
                      none
                    else some (x✝ <<< x✝¹ + x✝² <<< x✝¹)) ⊑
            if (!((!x✝ >ᵤ x✝ + x✝²) && !x✝² >ᵤ x✝ + x✝²)) = true then none
            else
              if ((x✝ + x✝²) <<< x✝¹ >>> x✝¹ == x✝ + x✝²) = true then none
              else if (!64#64 >ᵤ x✝¹) = true then none else some ((x✝ + x✝²) <<< x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:39:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:39:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:32:8: error: (kernel) declaration has metavariables 'add_shl_same_amount_partial_nsw1_thm'
[bv] [0.035943] Normalizing goal
  [Meta.synthInstance] [0.001097] ✅️ Decidable
        ((if True ∧ (x✝ <<< x✝¹).sshiftRight x✝¹.toNat = x✝ then none
          else
            if x✝¹ ≥ ↑6 then none
            else
              if True ∧ (x✝² <<< x✝¹).sshiftRight x✝¹.toNat = x✝² then none
              else if x✝¹ ≥ ↑6 then none else some (x✝ <<< x✝¹ + x✝² <<< x✝¹)) ⊑
          if x✝¹ ≥ ↑6 then none else some ((x✝ + x✝²) <<< x✝¹))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 6
      x✝² x✝¹ x✝ : BitVec 6
      a✝ :
        ¬(if True ∧ (x✝ <<< x✝¹).sshiftRight x✝¹.toNat = x✝ then none
            else
              if x✝¹ ≥ ↑6 then none
              else
                if True ∧ (x✝² <<< x✝¹).sshiftRight x✝¹.toNat = x✝² then none
                else if x✝¹ ≥ ↑6 then none else some (x✝ <<< x✝¹ + x✝² <<< x✝¹)) ⊑
            if x✝¹ ≥ ↑6 then none else some ((x✝ + x✝²) <<< x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 6
      x✝² x✝¹ x✝ : BitVec 6
      a✝ :
        ¬(if ((x✝ <<< x✝¹).sshiftRight x✝¹.toNat == x✝) = true then none
            else
              if (!6#6 >ᵤ x✝¹) = true then none
              else
                if ((x✝² <<< x✝¹).sshiftRight x✝¹.toNat == x✝²) = true then none
                else if (!6#6 >ᵤ x✝¹) = true then none else some (x✝ <<< x✝¹ + x✝² <<< x✝¹)) ⊑
            if (!6#6 >ᵤ x✝¹) = true then none else some ((x✝ + x✝²) <<< x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:50:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:50:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:43:8: error: (kernel) declaration has metavariables 'add_shl_same_amount_partial_nsw2_thm'
[bv] [0.043321] Normalizing goal
  [Meta.synthInstance] [0.001292] ✅️ Decidable
        ((if x✝¹ ≥ ↑6 then none
          else
            if True ∧ (x✝² <<< x✝¹).sshiftRight x✝¹.toNat = x✝² then none
            else
              if x✝¹ ≥ ↑6 then none
              else
                if True ∧ (x✝ <<< x✝¹).msb = (x✝² <<< x✝¹).msb ∧ (x✝ <<< x✝¹ + x✝² <<< x✝¹).msb ≠ (x✝ <<< x✝¹).msb then
                  none
                else some (x✝ <<< x✝¹ + x✝² <<< x✝¹)) ⊑
          if x✝¹ ≥ ↑6 then none else some ((x✝ + x✝²) <<< x✝¹))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 6
      x✝² x✝¹ x✝ : BitVec 6
      a✝ :
        ¬(if x✝¹ ≥ ↑6 then none
            else
              if True ∧ (x✝² <<< x✝¹).sshiftRight x✝¹.toNat = x✝² then none
              else
                if x✝¹ ≥ ↑6 then none
                else
                  if
                      True ∧
                        (x✝ <<< x✝¹).msb = (x✝² <<< x✝¹).msb ∧ (x✝ <<< x✝¹ + x✝² <<< x✝¹).msb ≠ (x✝ <<< x✝¹).msb then
                    none
                  else some (x✝ <<< x✝¹ + x✝² <<< x✝¹)) ⊑
            if x✝¹ ≥ ↑6 then none else some ((x✝ + x✝²) <<< x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 6
      x✝² x✝¹ x✝ : BitVec 6
      a✝ :
        ¬(if (!6#6 >ᵤ x✝¹) = true then none
            else
              if ((x✝² <<< x✝¹).sshiftRight x✝¹.toNat == x✝²) = true then none
              else
                if (!6#6 >ᵤ x✝¹) = true then none
                else
                  if
                      ((x✝ <<< x✝¹).getLsbD 5 == (x✝² <<< x✝¹).getLsbD 5 &&
                          !(x✝ <<< x✝¹ + x✝² <<< x✝¹).getLsbD 5 == (x✝ <<< x✝¹).getLsbD 5) =
                        true then
                    none
                  else some (x✝ <<< x✝¹ + x✝² <<< x✝¹)) ⊑
            if (!6#6 >ᵤ x✝¹) = true then none else some ((x✝ + x✝²) <<< x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:61:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:61:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:54:8: error: (kernel) declaration has metavariables 'add_shl_same_amount_partial_nuw1_thm'
[bv] [0.037488] Normalizing goal
  [Meta.synthInstance] [0.001204] ✅️ Decidable
        ((if True ∧ x✝ <<< x✝¹ >>> x✝¹ = x✝ then none
          else
            if x✝¹ ≥ ↑6 then none
            else
              if True ∧ x✝² <<< x✝¹ >>> x✝¹ = x✝² then none
              else if x✝¹ ≥ ↑6 then none else some (x✝ <<< x✝¹ + x✝² <<< x✝¹)) ⊑
          if x✝¹ ≥ ↑6 then none else some ((x✝ + x✝²) <<< x✝¹))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 6
      x✝² x✝¹ x✝ : BitVec 6
      a✝ :
        ¬(if True ∧ x✝ <<< x✝¹ >>> x✝¹ = x✝ then none
            else
              if x✝¹ ≥ ↑6 then none
              else
                if True ∧ x✝² <<< x✝¹ >>> x✝¹ = x✝² then none
                else if x✝¹ ≥ ↑6 then none else some (x✝ <<< x✝¹ + x✝² <<< x✝¹)) ⊑
            if x✝¹ ≥ ↑6 then none else some ((x✝ + x✝²) <<< x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 6
      x✝² x✝¹ x✝ : BitVec 6
      a✝ :
        ¬(if (x✝ <<< x✝¹ >>> x✝¹ == x✝) = true then none
            else
              if (!6#6 >ᵤ x✝¹) = true then none
              else
                if (x✝² <<< x✝¹ >>> x✝¹ == x✝²) = true then none
                else if (!6#6 >ᵤ x✝¹) = true then none else some (x✝ <<< x✝¹ + x✝² <<< x✝¹)) ⊑
            if (!6#6 >ᵤ x✝¹) = true then none else some ((x✝ + x✝²) <<< x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:72:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:72:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:65:8: error: (kernel) declaration has metavariables 'add_shl_same_amount_partial_nuw2_thm'
[bv] [0.041336] Normalizing goal
  [Meta.synthInstance] [0.001257] ✅️ Decidable
        ((if True ∧ x✝ <<< x✝¹ >>> x✝¹ = x✝ then none
          else
            if x✝¹ ≥ ↑6 then none
            else
              if x✝¹ ≥ ↑6 then none
              else
                if True ∧ (x✝ <<< x✝¹ + x✝² <<< x✝¹ < x✝ <<< x✝¹ ∨ x✝ <<< x✝¹ + x✝² <<< x✝¹ < x✝² <<< x✝¹) then none
                else some (x✝ <<< x✝¹ + x✝² <<< x✝¹)) ⊑
          if x✝¹ ≥ ↑6 then none else some ((x✝ + x✝²) <<< x✝¹))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 6
      x✝² x✝¹ x✝ : BitVec 6
      a✝ :
        ¬(if True ∧ x✝ <<< x✝¹ >>> x✝¹ = x✝ then none
            else
              if x✝¹ ≥ ↑6 then none
              else
                if x✝¹ ≥ ↑6 then none
                else
                  if True ∧ (x✝ <<< x✝¹ + x✝² <<< x✝¹ < x✝ <<< x✝¹ ∨ x✝ <<< x✝¹ + x✝² <<< x✝¹ < x✝² <<< x✝¹) then none
                  else some (x✝ <<< x✝¹ + x✝² <<< x✝¹)) ⊑
            if x✝¹ ≥ ↑6 then none else some ((x✝ + x✝²) <<< x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 6
      x✝² x✝¹ x✝ : BitVec 6
      a✝ :
        ¬(if (x✝ <<< x✝¹ >>> x✝¹ == x✝) = true then none
            else
              if (!6#6 >ᵤ x✝¹) = true then none
              else
                if (!6#6 >ᵤ x✝¹) = true then none
                else
                  if
                      (!((!x✝ <<< x✝¹ >ᵤ x✝ <<< x✝¹ + x✝² <<< x✝¹) && !x✝² <<< x✝¹ >ᵤ x✝ <<< x✝¹ + x✝² <<< x✝¹)) =
                        true then
                    none
                  else some (x✝ <<< x✝¹ + x✝² <<< x✝¹)) ⊑
            if (!6#6 >ᵤ x✝¹) = true then none else some ((x✝ + x✝²) <<< x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:81:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:81:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:76:8: error: (kernel) declaration has metavariables 'sub_shl_same_amount_thm'
[bv] [0.048741] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 6
      x✝² x✝¹ x✝ : BitVec 6
      a✝ :
        ¬(if x✝¹ ≥ ↑6 then none else if x✝¹ ≥ ↑6 then none else some (x✝ <<< x✝¹ - x✝² <<< x✝¹)) ⊑
            if x✝¹ ≥ ↑6 then none else some ((x✝ - x✝²) <<< x✝¹)
      ⊢ False
  [Meta.appBuilder] [0.002589] ✅️ f: HAdd.hAdd, xs: [~~~(x✝² <<< x✝¹), 1#6]
    [Meta.synthInstance] [0.002523] ✅️ HAdd (BitVec 6) (BitVec 6) (BitVec 6)
      [Meta.synthInstance] [0.002089] ✅️ apply @BitVec.instAdd to Add (BitVec 6)
        [Meta.synthInstance.tryResolve] [0.002069] ✅️ Add (BitVec 6) ≟ Add (BitVec 6)
          [Meta.isDefEq] [0.002024] ✅️ Add (BitVec 6) =?= Add (BitVec ?m.141812)
            [Meta.isDefEq] [0.002002] ✅️ BitVec 6 =?= BitVec ?m.141812
              [Meta.isDefEq] [0.001990] ✅️ 6 =?= ?m.141812
                [Meta.isDefEq.assign] [0.001986] ✅️ ?m.141812 := 6
                  [Meta.isDefEq.assign.checkTypes] [0.001980] ✅️ (?m.141812 : ℕ) := (6 : ℕ)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 6
      x✝² x✝¹ x✝ : BitVec 6
      a✝ :
        ¬(if (!6#6 >ᵤ x✝¹) = true then none
            else if (!6#6 >ᵤ x✝¹) = true then none else some (x✝ <<< x✝¹ + (~~~(x✝² <<< x✝¹) + 1#6))) ⊑
            if (!6#6 >ᵤ x✝¹) = true then none else some ((x✝ + (~~~x✝² + 1#6)) <<< x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:93:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:93:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:85:8: error: (kernel) declaration has metavariables 'sub_shl_same_amount_nuw_thm'
[bv] [0.063449] Normalizing goal
  [Meta.synthInstance] [0.001325] ✅️ Decidable
        ((if True ∧ x✝ <<< x✝¹ >>> x✝¹ = x✝ then none
          else
            if x✝¹ ≥ ↑64 then none
            else
              if True ∧ x✝² <<< x✝¹ >>> x✝¹ = x✝² then none
              else
                if x✝¹ ≥ ↑64 then none
                else if True ∧ x✝ <<< x✝¹ < x✝² <<< x✝¹ then none else some (x✝ <<< x✝¹ - x✝² <<< x✝¹)) ⊑
          if True ∧ x✝ < x✝² then none
          else
            if True ∧ (x✝ - x✝²) <<< x✝¹ >>> x✝¹ = x✝ - x✝² then none
            else if x✝¹ ≥ ↑64 then none else some ((x✝ - x✝²) <<< x✝¹))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 64
      x✝² x✝¹ x✝ : BitVec 64
      a✝ :
        ¬(if True ∧ x✝ <<< x✝¹ >>> x✝¹ = x✝ then none
            else
              if x✝¹ ≥ ↑64 then none
              else
                if True ∧ x✝² <<< x✝¹ >>> x✝¹ = x✝² then none
                else
                  if x✝¹ ≥ ↑64 then none
                  else if True ∧ x✝ <<< x✝¹ < x✝² <<< x✝¹ then none else some (x✝ <<< x✝¹ - x✝² <<< x✝¹)) ⊑
            if True ∧ x✝ < x✝² then none
            else
              if True ∧ (x✝ - x✝²) <<< x✝¹ >>> x✝¹ = x✝ - x✝² then none
              else if x✝¹ ≥ ↑64 then none else some ((x✝ - x✝²) <<< x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 64
      x✝² x✝¹ x✝ : BitVec 64
      a✝ :
        ¬(if (x✝ <<< x✝¹ >>> x✝¹ == x✝) = true then none
            else
              if (!64#64 >ᵤ x✝¹) = true then none
              else
                if (x✝² <<< x✝¹ >>> x✝¹ == x✝²) = true then none
                else
                  if (!64#64 >ᵤ x✝¹) = true then none
                  else
                    if (x✝² <<< x✝¹ >ᵤ x✝ <<< x✝¹) = true then none
                    else some (x✝ <<< x✝¹ + (~~~(x✝² <<< x✝¹) + 1#64))) ⊑
            if (x✝² >ᵤ x✝) = true then none
            else
              if ((x✝ + (~~~x✝² + 1#64)) <<< x✝¹ >>> x✝¹ == x✝ + (~~~x✝² + 1#64)) = true then none
              else if (!64#64 >ᵤ x✝¹) = true then none else some ((x✝ + (~~~x✝² + 1#64)) <<< x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:104:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:104:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:97:8: error: (kernel) declaration has metavariables 'sub_shl_same_amount_partial_nsw1_thm'
[bv] [0.046564] Normalizing goal
  [Meta.synthInstance] [0.001100] ✅️ Decidable
        ((if True ∧ (x✝ <<< x✝¹).sshiftRight x✝¹.toNat = x✝ then none
          else
            if x✝¹ ≥ ↑6 then none
            else
              if True ∧ (x✝² <<< x✝¹).sshiftRight x✝¹.toNat = x✝² then none
              else if x✝¹ ≥ ↑6 then none else some (x✝ <<< x✝¹ - x✝² <<< x✝¹)) ⊑
          if x✝¹ ≥ ↑6 then none else some ((x✝ - x✝²) <<< x✝¹))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 6
      x✝² x✝¹ x✝ : BitVec 6
      a✝ :
        ¬(if True ∧ (x✝ <<< x✝¹).sshiftRight x✝¹.toNat = x✝ then none
            else
              if x✝¹ ≥ ↑6 then none
              else
                if True ∧ (x✝² <<< x✝¹).sshiftRight x✝¹.toNat = x✝² then none
                else if x✝¹ ≥ ↑6 then none else some (x✝ <<< x✝¹ - x✝² <<< x✝¹)) ⊑
            if x✝¹ ≥ ↑6 then none else some ((x✝ - x✝²) <<< x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 6
      x✝² x✝¹ x✝ : BitVec 6
      a✝ :
        ¬(if ((x✝ <<< x✝¹).sshiftRight x✝¹.toNat == x✝) = true then none
            else
              if (!6#6 >ᵤ x✝¹) = true then none
              else
                if ((x✝² <<< x✝¹).sshiftRight x✝¹.toNat == x✝²) = true then none
                else if (!6#6 >ᵤ x✝¹) = true then none else some (x✝ <<< x✝¹ + (~~~(x✝² <<< x✝¹) + 1#6))) ⊑
            if (!6#6 >ᵤ x✝¹) = true then none else some ((x✝ + (~~~x✝² + 1#6)) <<< x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:115:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:115:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:108:8: error: (kernel) declaration has metavariables 'sub_shl_same_amount_partial_nsw2_thm'
[bv] [0.056481] Normalizing goal
  [Meta.synthInstance] [0.001362] ✅️ Decidable
        ((if x✝¹ ≥ ↑6 then none
          else
            if True ∧ (x✝² <<< x✝¹).sshiftRight x✝¹.toNat = x✝² then none
            else
              if x✝¹ ≥ ↑6 then none
              else
                if
                    True ∧
                      (BitVec.signExtend (6 + 1) (x✝ <<< x✝¹) - BitVec.signExtend (6 + 1) (x✝² <<< x✝¹)).msb ≠
                        (BitVec.signExtend (6 + 1) (x✝ <<< x✝¹) - BitVec.signExtend (6 + 1) (x✝² <<< x✝¹)).getMsbD
                          1 then
                  none
                else some (x✝ <<< x✝¹ - x✝² <<< x✝¹)) ⊑
          if x✝¹ ≥ ↑6 then none else some ((x✝ - x✝²) <<< x✝¹))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 6
      x✝² x✝¹ x✝ : BitVec 6
      a✝ :
        ¬(if x✝¹ ≥ ↑6 then none
            else
              if True ∧ (x✝² <<< x✝¹).sshiftRight x✝¹.toNat = x✝² then none
              else
                if x✝¹ ≥ ↑6 then none
                else
                  if
                      True ∧
                        (BitVec.signExtend (6 + 1) (x✝ <<< x✝¹) - BitVec.signExtend (6 + 1) (x✝² <<< x✝¹)).msb ≠
                          (BitVec.signExtend (6 + 1) (x✝ <<< x✝¹) - BitVec.signExtend (6 + 1) (x✝² <<< x✝¹)).getMsbD
                            1 then
                    none
                  else some (x✝ <<< x✝¹ - x✝² <<< x✝¹)) ⊑
            if x✝¹ ≥ ↑6 then none else some ((x✝ - x✝²) <<< x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 6
      x✝² x✝¹ x✝ : BitVec 6
      a✝ :
        ¬(if (!6#6 >ᵤ x✝¹) = true then none
            else
              if ((x✝² <<< x✝¹).sshiftRight x✝¹.toNat == x✝²) = true then none
              else
                if (!6#6 >ᵤ x✝¹) = true then none
                else
                  if
                      (!(BitVec.signExtend 7 (x✝ <<< x✝¹) + (~~~BitVec.signExtend 7 (x✝² <<< x✝¹) + 1#7)).getLsbD 6 ==
                            (BitVec.signExtend 7 (x✝ <<< x✝¹) + (~~~BitVec.signExtend 7 (x✝² <<< x✝¹) + 1#7)).getMsbD
                              1) =
                        true then
                    none
                  else some (x✝ <<< x✝¹ + (~~~(x✝² <<< x✝¹) + 1#6))) ⊑
            if (!6#6 >ᵤ x✝¹) = true then none else some ((x✝ + (~~~x✝² + 1#6)) <<< x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:126:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:126:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:119:8: error: (kernel) declaration has metavariables 'sub_shl_same_amount_partial_nuw1_thm'
[bv] [0.048857] Normalizing goal
  [Meta.synthInstance] [0.001121] ✅️ Decidable
        ((if True ∧ x✝ <<< x✝¹ >>> x✝¹ = x✝ then none
          else
            if x✝¹ ≥ ↑6 then none
            else
              if True ∧ x✝² <<< x✝¹ >>> x✝¹ = x✝² then none
              else if x✝¹ ≥ ↑6 then none else some (x✝ <<< x✝¹ - x✝² <<< x✝¹)) ⊑
          if x✝¹ ≥ ↑6 then none else some ((x✝ - x✝²) <<< x✝¹))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 6
      x✝² x✝¹ x✝ : BitVec 6
      a✝ :
        ¬(if True ∧ x✝ <<< x✝¹ >>> x✝¹ = x✝ then none
            else
              if x✝¹ ≥ ↑6 then none
              else
                if True ∧ x✝² <<< x✝¹ >>> x✝¹ = x✝² then none
                else if x✝¹ ≥ ↑6 then none else some (x✝ <<< x✝¹ - x✝² <<< x✝¹)) ⊑
            if x✝¹ ≥ ↑6 then none else some ((x✝ - x✝²) <<< x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 6
      x✝² x✝¹ x✝ : BitVec 6
      a✝ :
        ¬(if (x✝ <<< x✝¹ >>> x✝¹ == x✝) = true then none
            else
              if (!6#6 >ᵤ x✝¹) = true then none
              else
                if (x✝² <<< x✝¹ >>> x✝¹ == x✝²) = true then none
                else if (!6#6 >ᵤ x✝¹) = true then none else some (x✝ <<< x✝¹ + (~~~(x✝² <<< x✝¹) + 1#6))) ⊑
            if (!6#6 >ᵤ x✝¹) = true then none else some ((x✝ + (~~~x✝² + 1#6)) <<< x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:137:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:137:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:130:8: error: (kernel) declaration has metavariables 'sub_shl_same_amount_partial_nuw2_thm'
[bv] [0.045014] Normalizing goal
  [Meta.synthInstance] [0.001129] ✅️ Decidable
        ((if True ∧ x✝ <<< x✝¹ >>> x✝¹ = x✝ then none
          else
            if x✝¹ ≥ ↑6 then none
            else
              if x✝¹ ≥ ↑6 then none
              else if True ∧ x✝ <<< x✝¹ < x✝² <<< x✝¹ then none else some (x✝ <<< x✝¹ - x✝² <<< x✝¹)) ⊑
          if x✝¹ ≥ ↑6 then none else some ((x✝ - x✝²) <<< x✝¹))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 6
      x✝² x✝¹ x✝ : BitVec 6
      a✝ :
        ¬(if True ∧ x✝ <<< x✝¹ >>> x✝¹ = x✝ then none
            else
              if x✝¹ ≥ ↑6 then none
              else
                if x✝¹ ≥ ↑6 then none
                else if True ∧ x✝ <<< x✝¹ < x✝² <<< x✝¹ then none else some (x✝ <<< x✝¹ - x✝² <<< x✝¹)) ⊑
            if x✝¹ ≥ ↑6 then none else some ((x✝ - x✝²) <<< x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 6
      x✝² x✝¹ x✝ : BitVec 6
      a✝ :
        ¬(if (x✝ <<< x✝¹ >>> x✝¹ == x✝) = true then none
            else
              if (!6#6 >ᵤ x✝¹) = true then none
              else
                if (!6#6 >ᵤ x✝¹) = true then none
                else
                  if (x✝² <<< x✝¹ >ᵤ x✝ <<< x✝¹) = true then none else some (x✝ <<< x✝¹ + (~~~(x✝² <<< x✝¹) + 1#6))) ⊑
            if (!6#6 >ᵤ x✝¹) = true then none else some ((x✝ + (~~~x✝² + 1#6)) <<< x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:146:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gshlhfactor_proof.lean:141:8: error: (kernel) declaration has metavariables 'add_shl_same_amount_constants_thm'
[bv] [0.022724] Normalizing goal
  [Meta.synthInstance] [0.001098] ✅️ Decidable
        ((if x✝ ≥ ↑8 then none else if x✝ ≥ ↑8 then none else some (4#8 <<< x✝ + 3#8 <<< x✝)) ⊑
          if x✝ ≥ ↑8 then none else some (7#8 <<< x✝))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if x✝ ≥ ↑8 then none else if x✝ ≥ ↑8 then none else some (4#8 <<< x✝ + 3#8 <<< x✝)) ⊑
            if x✝ ≥ ↑8 then none else some (7#8 <<< x✝)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if (!8#8 >ᵤ x✝) = true then none else if (!8#8 >ᵤ x✝) = true then none else some (4#8 <<< x✝ + 3#8 <<< x✝)) ⊑
            if (!8#8 >ᵤ x✝) = true then none else some (7#8 <<< x✝)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
