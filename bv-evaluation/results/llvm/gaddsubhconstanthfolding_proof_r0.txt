⚠ [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
⚠ [882/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [885/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
⚠ [887/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
⚠ [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
Bitwuzla proved the goal after 79.084180ms, solving context: 0.000000ms
LeanSAT proved the goal after 80.101350ms: rewriting 17.803270ms, bitblasting 0.000000ms, SAT solving 57.396960ms, LRAT trimming 0.000000ms, LRAT checking 3.473440ms
Bitwuzla proved the goal after 80.957640ms, solving context: 0.000000ms
LeanSAT proved the goal after 88.364409ms: rewriting 16.625900ms, bitblasting 0.000000ms, SAT solving 61.331409ms, LRAT trimming 0.000000ms, LRAT checking 8.925170ms
Bitwuzla proved the goal after 79.795360ms, solving context: 0.000000ms
LeanSAT proved the goal after 189.947319ms: rewriting 36.488000ms, bitblasting 0.000000ms, SAT solving 108.610469ms, LRAT trimming 18.910500ms, LRAT checking 21.629060ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddsubhconstanthfolding_proof.lean:45:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddsubhconstanthfolding_proof.lean:38:8: error: (kernel) declaration has metavariables 'add_nsw_const_const_sub_nsw_thm'
[bv] [0.101319] Normalizing goal
  [Meta.synthInstance] [0.002280] ✅️ Decidable
        ((if True ∧ x✝.msb = (1#8).msb ∧ (x✝ + 1#8).msb ≠ x✝.msb then none
          else
            if
                True ∧
                  (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 1#8)).msb ≠
                    (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 1#8)).getMsbD 1 then
              none
            else some (129#8 - (x✝ + 1#8))) ⊑
          if
              True ∧
                (BitVec.signExtend (8 + 1) 128#8 - BitVec.signExtend (8 + 1) x✝).msb ≠
                  (BitVec.signExtend (8 + 1) 128#8 - BitVec.signExtend (8 + 1) x✝).getMsbD 1 then
            none
          else some (128#8 - x✝))
    [Meta.check] [0.001339] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if True ∧ x✝.msb = (1#8).msb ∧ (x✝ + 1#8).msb ≠ x✝.msb then none
          else
            if
                True ∧
                  (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 1#8)).msb ≠
                    (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 1#8)).getMsbD 1 then
              none
            else some (129#8 - (x✝ + 1#8)))
          (if
              True ∧
                (BitVec.signExtend (8 + 1) 128#8 - BitVec.signExtend (8 + 1) x✝).msb ≠
                  (BitVec.signExtend (8 + 1) 128#8 - BitVec.signExtend (8 + 1) x✝).getMsbD 1 then
            none
          else some (128#8 - x✝))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if True ∧ x✝.msb = (1#8).msb ∧ (x✝ + 1#8).msb ≠ x✝.msb then none
            else
              if
                  True ∧
                    (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 1#8)).msb ≠
                      (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 1#8)).getMsbD 1 then
                none
              else some (129#8 - (x✝ + 1#8))) ⊑
            if
                True ∧
                  (BitVec.signExtend (8 + 1) 128#8 - BitVec.signExtend (8 + 1) x✝).msb ≠
                    (BitVec.signExtend (8 + 1) 128#8 - BitVec.signExtend (8 + 1) x✝).getMsbD 1 then
              none
            else some (128#8 - x✝)
      ⊢ False
  [Meta.isDefEq] [0.002121] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (congr
              (congrArg Ne
                (Eq.trans
                  (congrArg BitVec.msb
                    (Eq.trans (BitVec.sub_toAdd (385#9) (BitVec.signExtend 9 (x✝ + 1#8)))
                      (Eq.trans (congrArg (HAdd.hAdd 385#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝ + 1#8))))
                        (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (385#9)
                          (~~~BitVec.signExtend 9 (x✝ + 1#8)) 1#9))))
                  (BitVec.msb_eq_getLsbD_last (386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)))))
              (congrArg (fun x => x.getMsbD 1)
                (Eq.trans (BitVec.sub_toAdd (385#9) (BitVec.signExtend 9 (x✝ + 1#8)))
                  (Eq.trans (congrArg (HAdd.hAdd 385#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝ + 1#8))))
                    (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (385#9) (~~~BitVec.signExtend 9 (x✝ + 1#8))
                      1#9)))))
            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq ((386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getLsbD 8)
              ((386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getMsbD 1))))
        (true_and
          ((!(386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getLsbD 8 ==
                (386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getMsbD 1) =
            true))
    [Meta.isDefEq.assign] [0.002118] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (congr
                (congrArg Ne
                  (Eq.trans
                    (congrArg BitVec.msb
                      (Eq.trans (BitVec.sub_toAdd (385#9) (BitVec.signExtend 9 (x✝ + 1#8)))
                        (Eq.trans (congrArg (HAdd.hAdd 385#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝ + 1#8))))
                          (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (385#9)
                            (~~~BitVec.signExtend 9 (x✝ + 1#8)) 1#9))))
                    (BitVec.msb_eq_getLsbD_last (386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)))))
                (congrArg (fun x => x.getMsbD 1)
                  (Eq.trans (BitVec.sub_toAdd (385#9) (BitVec.signExtend 9 (x✝ + 1#8)))
                    (Eq.trans (congrArg (HAdd.hAdd 385#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝ + 1#8))))
                      (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (385#9) (~~~BitVec.signExtend 9 (x✝ + 1#8))
                        1#9)))))
              (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq ((386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getLsbD 8)
                ((386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getMsbD 1))))
          (true_and
            ((!(386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getLsbD 8 ==
                  (386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getMsbD 1) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.002099] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 1#8)).msb ≠
                (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 1#8)).getMsbD 1) =
            ((!(386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getLsbD 8 ==
                  (386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getMsbD 1) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (congr
                  (congrArg Ne
                    (Eq.trans
                      (congrArg BitVec.msb
                        (Eq.trans (BitVec.sub_toAdd (385#9) (BitVec.signExtend 9 (x✝ + 1#8)))
                          (Eq.trans
                            (congrArg (HAdd.hAdd 385#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝ + 1#8))))
                            (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (385#9)
                              (~~~BitVec.signExtend 9 (x✝ + 1#8)) 1#9))))
                      (BitVec.msb_eq_getLsbD_last (386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)))))
                  (congrArg (fun x => x.getMsbD 1)
                    (Eq.trans (BitVec.sub_toAdd (385#9) (BitVec.signExtend 9 (x✝ + 1#8)))
                      (Eq.trans (congrArg (HAdd.hAdd 385#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝ + 1#8))))
                        (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (385#9)
                          (~~~BitVec.signExtend 9 (x✝ + 1#8)) 1#9)))))
                (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq ((386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getLsbD 8)
                  ((386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getMsbD 1))))
            (true_and
              ((!(386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getLsbD 8 ==
                    (386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getMsbD 1) =
                true)) : (True ∧
              (385#9 - BitVec.signExtend 9 (x✝ + 1#8)).msb ≠ (385#9 - BitVec.signExtend 9 (x✝ + 1#8)).getMsbD 1) =
            ((!(386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getLsbD 8 ==
                  (386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getMsbD 1) =
              true))
        [Meta.isDefEq] [0.002095] ✅️ (True ∧
                (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 1#8)).msb ≠
                  (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 1#8)).getMsbD 1) =
              ((!(386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getLsbD 8 ==
                    (386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getMsbD 1) =
                true) =?= (True ∧
                (385#9 - BitVec.signExtend 9 (x✝ + 1#8)).msb ≠ (385#9 - BitVec.signExtend 9 (x✝ + 1#8)).getMsbD 1) =
              ((!(386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getLsbD 8 ==
                    (386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getMsbD 1) =
                true)
          [Meta.isDefEq] [0.002072] ✅️ True ∧
                (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 1#8)).msb ≠
                  (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 1#8)).getMsbD
                    1 =?= True ∧
                (385#9 - BitVec.signExtend 9 (x✝ + 1#8)).msb ≠ (385#9 - BitVec.signExtend 9 (x✝ + 1#8)).getMsbD 1
            [Meta.isDefEq] [0.002060] ✅️ (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 1#8)).msb ≠
                  (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 1#8)).getMsbD
                    1 =?= (385#9 - BitVec.signExtend 9 (x✝ + 1#8)).msb ≠
                  (385#9 - BitVec.signExtend 9 (x✝ + 1#8)).getMsbD 1
              [Meta.isDefEq.delta] [0.002046] ✅️ (BitVec.signExtend (8 + 1) 129#8 -
                        BitVec.signExtend (8 + 1) (x✝ + 1#8)).msb ≠
                    (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 1#8)).getMsbD
                      1 =?= (385#9 - BitVec.signExtend 9 (x✝ + 1#8)).msb ≠
                    (385#9 - BitVec.signExtend 9 (x✝ + 1#8)).getMsbD 1
                [Meta.isDefEq] [0.001994] ✅️ (BitVec.signExtend (8 + 1) 129#8 -
                        BitVec.signExtend (8 + 1) (x✝ + 1#8)).msb =?= (385#9 - BitVec.signExtend 9 (x✝ + 1#8)).msb
                  [Meta.isDefEq.delta] [0.001983] ✅️ (BitVec.signExtend (8 + 1) 129#8 -
                          BitVec.signExtend (8 + 1) (x✝ + 1#8)).msb =?= (385#9 - BitVec.signExtend 9 (x✝ + 1#8)).msb
                    [Meta.isDefEq] [0.001968] ✅️ BitVec.signExtend (8 + 1) 129#8 -
                          BitVec.signExtend (8 + 1) (x✝ + 1#8) =?= 385#9 - BitVec.signExtend 9 (x✝ + 1#8)
                      [Meta.isDefEq] [0.001946] ✅️ instHSub.1 (BitVec.signExtend (8 + 1) 129#8)
                            (BitVec.signExtend (8 + 1)
                              (x✝ + 1#8)) =?= instHSub.1 (385#9) (BitVec.signExtend 9 (x✝ + 1#8))
                        [Meta.isDefEq] [0.001909] ✅️ Sub.sub (BitVec.signExtend (8 + 1) 129#8)
                              (BitVec.signExtend (8 + 1)
                                (x✝ + 1#8)) =?= Sub.sub (385#9) (BitVec.signExtend 9 (x✝ + 1#8))
                          [Meta.isDefEq] [0.001892] ✅️ BitVec.instSub.1 (BitVec.signExtend (8 + 1) 129#8)
                                (BitVec.signExtend (8 + 1)
                                  (x✝ + 1#8)) =?= BitVec.instSub.1 (385#9) (BitVec.signExtend 9 (x✝ + 1#8))
                            [Meta.isDefEq] [0.001860] ✅️ (BitVec.signExtend (8 + 1) 129#8).sub
                                  (BitVec.signExtend (8 + 1)
                                    (x✝ + 1#8)) =?= (385#9).sub (BitVec.signExtend 9 (x✝ + 1#8))
                              [Meta.isDefEq.delta] [0.001851] ✅️ (BitVec.signExtend (8 + 1) 129#8).sub
                                    (BitVec.signExtend (8 + 1)
                                      (x✝ + 1#8)) =?= (385#9).sub (BitVec.signExtend 9 (x✝ + 1#8))
                                [Meta.isDefEq] [0.001796] ✅️ BitVec.signExtend (8 + 1) 129#8 =?= 385#9
                                  [Meta.isDefEq] [0.001778] ✅️ BitVec.ofInt (8 + 1) (129#8).toInt =?= 385#9
                                    [Meta.isDefEq] [0.001760] ✅️ ((129#8).toInt %
                                              Int.ofNat (2 ^ (8 + 1))).toNat#'⋯ =?= 385#9
                                      [Meta.isDefEq] [0.001743] ✅️ ((129#8).toInt %
                                                Int.ofNat
                                                  (2 ^ (8 + 1))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 9) 385 }
                                        [Meta.isDefEq] [0.001728] ✅️ {
                                              toFin :=
                                                ⟨((129#8).toInt % Int.ofNat (2 ^ (8 + 1))).toNat,
                                                  ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 9) 385 }
                                          [Meta.isDefEq] [0.001679] ✅️ ⟨((129#8).toInt % Int.ofNat (2 ^ (8 + 1))).toNat,
                                                ⋯⟩ =?= Fin.ofNat' (2 ^ 9) 385
                                            [Meta.isDefEq] [0.001661] ✅️ ⟨((129#8).toInt %
                                                      Int.ofNat (2 ^ (8 + 1))).toNat,
                                                  ⋯⟩ =?= ⟨385 % 2 ^ 9, ⋯⟩
                                              [Meta.isDefEq] [0.001597] ✅️ ((129#8).toInt %
                                                      Int.ofNat (2 ^ (8 + 1))).toNat =?= 385 % 2 ^ 9
                                                [Meta.isDefEq] [0.001556] ✅️ match
                                                      (129#8).toInt % Int.ofNat (2 ^ (8 + 1)) with
                                                    | Int.ofNat n => n
                                                    | Int.negSucc a => 0 =?= 385 % 2 ^ 9
                                                  [Meta.whnf] [0.001233] Non-easy whnf: (fun motive x h_1 h_2 =>
                                                          Int.casesOn x (fun a => h_1 a) fun a => h_2 a)
                                                        (fun x => ℕ) ((129#8).toInt % Int.ofNat (2 ^ (8 + 1))) h_1 h_2
                                                    [Meta.whnf] [0.001212] Non-easy whnf: (129#8).toInt %
                                                          Int.ofNat (2 ^ (8 + 1))
                                                      [Meta.whnf] [0.001206] Non-easy whnf: instHMod.1 (129#8).toInt
                                                            (Int.ofNat (2 ^ (8 + 1)))
                                                        [Meta.whnf] [0.001199] Non-easy whnf: Int.instMod.1
                                                              (129#8).toInt (Int.ofNat (2 ^ (8 + 1)))
                                                          [Meta.whnf] [0.001182] Non-easy whnf: match (129#8).toInt,
                                                                Int.ofNat (2 ^ (8 + 1)) with
                                                              | Int.ofNat m, n => Int.ofNat (m % n.natAbs)
                                                              | Int.negSucc m, n =>
                                                                Int.subNatNat n.natAbs (m % n.natAbs).succ
  [Meta.isDefEq] [0.001907] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (congr
              (congrArg Ne
                (Eq.trans
                  (congrArg BitVec.msb
                    (Eq.trans (BitVec.sub_toAdd (384#9) (BitVec.signExtend 9 x✝))
                      (Eq.trans (congrArg (HAdd.hAdd 384#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 x✝)))
                        (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (384#9) (~~~BitVec.signExtend 9 x✝)
                          1#9))))
                  (BitVec.msb_eq_getLsbD_last (385#9 + ~~~BitVec.signExtend 9 x✝))))
              (congrArg (fun x => x.getMsbD 1)
                (Eq.trans (BitVec.sub_toAdd (384#9) (BitVec.signExtend 9 x✝))
                  (Eq.trans (congrArg (HAdd.hAdd 384#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 x✝)))
                    (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (384#9) (~~~BitVec.signExtend 9 x✝) 1#9)))))
            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq ((385#9 + ~~~BitVec.signExtend 9 x✝).getLsbD 8)
              ((385#9 + ~~~BitVec.signExtend 9 x✝).getMsbD 1))))
        (true_and
          ((!(385#9 + ~~~BitVec.signExtend 9 x✝).getLsbD 8 == (385#9 + ~~~BitVec.signExtend 9 x✝).getMsbD 1) = true))
    [Meta.isDefEq.assign] [0.001902] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (congr
                (congrArg Ne
                  (Eq.trans
                    (congrArg BitVec.msb
                      (Eq.trans (BitVec.sub_toAdd (384#9) (BitVec.signExtend 9 x✝))
                        (Eq.trans (congrArg (HAdd.hAdd 384#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 x✝)))
                          (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (384#9) (~~~BitVec.signExtend 9 x✝)
                            1#9))))
                    (BitVec.msb_eq_getLsbD_last (385#9 + ~~~BitVec.signExtend 9 x✝))))
                (congrArg (fun x => x.getMsbD 1)
                  (Eq.trans (BitVec.sub_toAdd (384#9) (BitVec.signExtend 9 x✝))
                    (Eq.trans (congrArg (HAdd.hAdd 384#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 x✝)))
                      (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (384#9) (~~~BitVec.signExtend 9 x✝) 1#9)))))
              (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq ((385#9 + ~~~BitVec.signExtend 9 x✝).getLsbD 8)
                ((385#9 + ~~~BitVec.signExtend 9 x✝).getMsbD 1))))
          (true_and
            ((!(385#9 + ~~~BitVec.signExtend 9 x✝).getLsbD 8 == (385#9 + ~~~BitVec.signExtend 9 x✝).getMsbD 1) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001874] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (8 + 1) 128#8 - BitVec.signExtend (8 + 1) x✝).msb ≠
                (BitVec.signExtend (8 + 1) 128#8 - BitVec.signExtend (8 + 1) x✝).getMsbD 1) =
            ((!(385#9 + ~~~BitVec.signExtend 9 x✝).getLsbD 8 == (385#9 + ~~~BitVec.signExtend 9 x✝).getMsbD 1) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (congr
                  (congrArg Ne
                    (Eq.trans
                      (congrArg BitVec.msb
                        (Eq.trans (BitVec.sub_toAdd (384#9) (BitVec.signExtend 9 x✝))
                          (Eq.trans (congrArg (HAdd.hAdd 384#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 x✝)))
                            (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (384#9) (~~~BitVec.signExtend 9 x✝)
                              1#9))))
                      (BitVec.msb_eq_getLsbD_last (385#9 + ~~~BitVec.signExtend 9 x✝))))
                  (congrArg (fun x => x.getMsbD 1)
                    (Eq.trans (BitVec.sub_toAdd (384#9) (BitVec.signExtend 9 x✝))
                      (Eq.trans (congrArg (HAdd.hAdd 384#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 x✝)))
                        (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (384#9) (~~~BitVec.signExtend 9 x✝)
                          1#9)))))
                (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq ((385#9 + ~~~BitVec.signExtend 9 x✝).getLsbD 8)
                  ((385#9 + ~~~BitVec.signExtend 9 x✝).getMsbD 1))))
            (true_and
              ((!(385#9 + ~~~BitVec.signExtend 9 x✝).getLsbD 8 == (385#9 + ~~~BitVec.signExtend 9 x✝).getMsbD 1) =
                true)) : (True ∧ (384#9 - BitVec.signExtend 9 x✝).msb ≠ (384#9 - BitVec.signExtend 9 x✝).getMsbD 1) =
            ((!(385#9 + ~~~BitVec.signExtend 9 x✝).getLsbD 8 == (385#9 + ~~~BitVec.signExtend 9 x✝).getMsbD 1) = true))
        [Meta.isDefEq] [0.001869] ✅️ (True ∧
                (BitVec.signExtend (8 + 1) 128#8 - BitVec.signExtend (8 + 1) x✝).msb ≠
                  (BitVec.signExtend (8 + 1) 128#8 - BitVec.signExtend (8 + 1) x✝).getMsbD 1) =
              ((!(385#9 + ~~~BitVec.signExtend 9 x✝).getLsbD 8 == (385#9 + ~~~BitVec.signExtend 9 x✝).getMsbD 1) =
                true) =?= (True ∧ (384#9 - BitVec.signExtend 9 x✝).msb ≠ (384#9 - BitVec.signExtend 9 x✝).getMsbD 1) =
              ((!(385#9 + ~~~BitVec.signExtend 9 x✝).getLsbD 8 == (385#9 + ~~~BitVec.signExtend 9 x✝).getMsbD 1) = true)
          [Meta.isDefEq] [0.001834] ✅️ True ∧
                (BitVec.signExtend (8 + 1) 128#8 - BitVec.signExtend (8 + 1) x✝).msb ≠
                  (BitVec.signExtend (8 + 1) 128#8 - BitVec.signExtend (8 + 1) x✝).getMsbD
                    1 =?= True ∧ (384#9 - BitVec.signExtend 9 x✝).msb ≠ (384#9 - BitVec.signExtend 9 x✝).getMsbD 1
            [Meta.isDefEq] [0.001816] ✅️ (BitVec.signExtend (8 + 1) 128#8 - BitVec.signExtend (8 + 1) x✝).msb ≠
                  (BitVec.signExtend (8 + 1) 128#8 - BitVec.signExtend (8 + 1) x✝).getMsbD
                    1 =?= (384#9 - BitVec.signExtend 9 x✝).msb ≠ (384#9 - BitVec.signExtend 9 x✝).getMsbD 1
              [Meta.isDefEq.delta] [0.001793] ✅️ (BitVec.signExtend (8 + 1) 128#8 - BitVec.signExtend (8 + 1) x✝).msb ≠
                    (BitVec.signExtend (8 + 1) 128#8 - BitVec.signExtend (8 + 1) x✝).getMsbD
                      1 =?= (384#9 - BitVec.signExtend 9 x✝).msb ≠ (384#9 - BitVec.signExtend 9 x✝).getMsbD 1
                [Meta.isDefEq] [0.001732] ✅️ (BitVec.signExtend (8 + 1) 128#8 -
                        BitVec.signExtend (8 + 1) x✝).msb =?= (384#9 - BitVec.signExtend 9 x✝).msb
                  [Meta.isDefEq.delta] [0.001716] ✅️ (BitVec.signExtend (8 + 1) 128#8 -
                          BitVec.signExtend (8 + 1) x✝).msb =?= (384#9 - BitVec.signExtend 9 x✝).msb
                    [Meta.isDefEq] [0.001697] ✅️ BitVec.signExtend (8 + 1) 128#8 -
                          BitVec.signExtend (8 + 1) x✝ =?= 384#9 - BitVec.signExtend 9 x✝
                      [Meta.isDefEq] [0.001664] ✅️ instHSub.1 (BitVec.signExtend (8 + 1) 128#8)
                            (BitVec.signExtend (8 + 1) x✝) =?= instHSub.1 (384#9) (BitVec.signExtend 9 x✝)
                        [Meta.isDefEq] [0.001610] ✅️ Sub.sub (BitVec.signExtend (8 + 1) 128#8)
                              (BitVec.signExtend (8 + 1) x✝) =?= Sub.sub (384#9) (BitVec.signExtend 9 x✝)
                          [Meta.isDefEq] [0.001579] ✅️ BitVec.instSub.1 (BitVec.signExtend (8 + 1) 128#8)
                                (BitVec.signExtend (8 + 1) x✝) =?= BitVec.instSub.1 (384#9) (BitVec.signExtend 9 x✝)
                            [Meta.isDefEq] [0.001533] ✅️ (BitVec.signExtend (8 + 1) 128#8).sub
                                  (BitVec.signExtend (8 + 1) x✝) =?= (384#9).sub (BitVec.signExtend 9 x✝)
                              [Meta.isDefEq.delta] [0.001517] ✅️ (BitVec.signExtend (8 + 1) 128#8).sub
                                    (BitVec.signExtend (8 + 1) x✝) =?= (384#9).sub (BitVec.signExtend 9 x✝)
                                [Meta.isDefEq] [0.001451] ✅️ BitVec.signExtend (8 + 1) 128#8 =?= 384#9
                                  [Meta.isDefEq] [0.001425] ✅️ BitVec.ofInt (8 + 1) (128#8).toInt =?= 384#9
                                    [Meta.isDefEq] [0.001401] ✅️ ((128#8).toInt %
                                              Int.ofNat (2 ^ (8 + 1))).toNat#'⋯ =?= 384#9
                                      [Meta.isDefEq] [0.001375] ✅️ ((128#8).toInt %
                                                Int.ofNat
                                                  (2 ^ (8 + 1))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 9) 384 }
                                        [Meta.isDefEq] [0.001354] ✅️ {
                                              toFin :=
                                                ⟨((128#8).toInt % Int.ofNat (2 ^ (8 + 1))).toNat,
                                                  ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 9) 384 }
                                          [Meta.isDefEq] [0.001294] ✅️ ⟨((128#8).toInt % Int.ofNat (2 ^ (8 + 1))).toNat,
                                                ⋯⟩ =?= Fin.ofNat' (2 ^ 9) 384
                                            [Meta.isDefEq] [0.001270] ✅️ ⟨((128#8).toInt %
                                                      Int.ofNat (2 ^ (8 + 1))).toNat,
                                                  ⋯⟩ =?= ⟨384 % 2 ^ 9, ⋯⟩
                                              [Meta.isDefEq] [0.001202] ✅️ ((128#8).toInt %
                                                      Int.ofNat (2 ^ (8 + 1))).toNat =?= 384 % 2 ^ 9
                                                [Meta.isDefEq] [0.001144] ✅️ match
                                                      (128#8).toInt % Int.ofNat (2 ^ (8 + 1)) with
                                                    | Int.ofNat n => n
                                                    | Int.negSucc a => 0 =?= 384 % 2 ^ 9
  [Meta.isDefEq] [0.001264] ✅️ ?h₃ =?= fun a =>
        congrArg some
          (Eq.trans (BitVec.sub_toAdd (128#8) x✝)
            (Eq.trans (congrArg (HAdd.hAdd 128#8) (BitVec.neg_eq_not_add x✝))
              (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (128#8) (~~~x✝) 1#8)))
    [Meta.isDefEq.assign] [0.001259] ✅️ ?h₃ := fun a =>
          congrArg some
            (Eq.trans (BitVec.sub_toAdd (128#8) x✝)
              (Eq.trans (congrArg (HAdd.hAdd 128#8) (BitVec.neg_eq_not_add x✝))
                (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (128#8) (~~~x✝) 1#8)))
      [Meta.isDefEq.assign.checkTypes] [0.001215] ✅️ (?h₃ : ¬(!(385#9 + ~~~BitVec.signExtend 9 x✝).getLsbD 8 ==
                    (385#9 + ~~~BitVec.signExtend 9 x✝).getMsbD 1) =
                true →
            some (128#8 - x✝) =
              some
                (129#8 +
                  ~~~x✝)) := (fun a =>
            congrArg some
              (Eq.trans (BitVec.sub_toAdd (128#8) x✝)
                (Eq.trans (congrArg (HAdd.hAdd 128#8) (BitVec.neg_eq_not_add x✝))
                  (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (128#8) (~~~x✝)
                    1#8))) : ¬(!(385#9 + ~~~BitVec.signExtend 9 x✝).getLsbD 8 ==
                    (385#9 + ~~~BitVec.signExtend 9 x✝).getMsbD 1) =
                true →
            some (128#8 - x✝) = some (128#8 + 1#8 + ~~~x✝))
        [Meta.isDefEq] [0.001210] ✅️ ¬(!(385#9 + ~~~BitVec.signExtend 9 x✝).getLsbD 8 ==
                      (385#9 + ~~~BitVec.signExtend 9 x✝).getMsbD 1) =
                  true →
              some (128#8 - x✝) =
                some
                  (129#8 +
                    ~~~x✝) =?= ¬(!(385#9 + ~~~BitVec.signExtend 9 x✝).getLsbD 8 ==
                      (385#9 + ~~~BitVec.signExtend 9 x✝).getMsbD 1) =
                  true →
              some (128#8 - x✝) = some (128#8 + 1#8 + ~~~x✝)
          [Meta.isDefEq] [0.001157] ✅️ some (128#8 - x✝) =
                some (129#8 + ~~~x✝) =?= some (128#8 - x✝) = some (128#8 + 1#8 + ~~~x✝)
            [Meta.isDefEq] [0.001125] ✅️ some (129#8 + ~~~x✝) =?= some (128#8 + 1#8 + ~~~x✝)
              [Meta.isDefEq] [0.001102] ✅️ 129#8 + ~~~x✝ =?= 128#8 + 1#8 + ~~~x✝
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if (!x✝.getLsbD 7 && !(x✝ + 1#8).getLsbD 7 == x✝.getLsbD 7) = true then none
            else
              if
                  (!(386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getLsbD 8 ==
                        (386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getMsbD 1) =
                    true then
                none
              else some (129#8 + ~~~x✝)) ⊑
            if
                (!(385#9 + ~~~BitVec.signExtend 9 x✝).getLsbD 8 == (385#9 + ~~~BitVec.signExtend 9 x✝).getMsbD 1) =
                  true then
              none
            else some (129#8 + ~~~x✝)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddsubhconstanthfolding_proof.lean:55:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddsubhconstanthfolding_proof.lean:49:8: error: (kernel) declaration has metavariables 'add_nsw_const_const_sub_thm'
[bv] [0.046068] Normalizing goal
  [Meta.synthInstance] [0.001119] ✅️ Decidable
        ((if True ∧ x✝.msb = (1#8).msb ∧ (x✝ + 1#8).msb ≠ x✝.msb then none else some (129#8 - (x✝ + 1#8))) ⊑
          some (128#8 - x✝))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if True ∧ x✝.msb = (1#8).msb ∧ (x✝ + 1#8).msb ≠ x✝.msb then none else some (129#8 - (x✝ + 1#8))) ⊑
            some (128#8 - x✝)
      ⊢ False
  [Meta.appBuilder] [0.001741] ✅️ f: HAdd.hAdd, xs: [0#8, ~~~x✝]
    [Meta.synthInstance] [0.001640] ✅️ HAdd (BitVec 8) (BitVec 8) (BitVec 8)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if (!x✝.getLsbD 7 && !(x✝ + 1#8).getLsbD 7 == x✝.getLsbD 7) = true then none else some (129#8 + ~~~x✝)) ⊑
            some (129#8 + ~~~x✝)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddsubhconstanthfolding_proof.lean:65:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddsubhconstanthfolding_proof.lean:59:8: error: (kernel) declaration has metavariables 'add_const_const_sub_nsw_thm'
[bv] [0.062154] Normalizing goal
  [Meta.synthInstance] [0.001790] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 1#8)).msb ≠
                  (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 1#8)).getMsbD 1 then
            none
          else some (129#8 - (x✝ + 1#8))) ⊑
          some (128#8 - x✝))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 1#8)).msb ≠
                    (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 1#8)).getMsbD 1 then
              none
            else some (129#8 - (x✝ + 1#8))) ⊑
            some (128#8 - x✝)
      ⊢ False
  [Meta.isDefEq] [0.002736] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (congr
              (congrArg Ne
                (Eq.trans
                  (congrArg BitVec.msb
                    (Eq.trans (BitVec.sub_toAdd (385#9) (BitVec.signExtend 9 (x✝ + 1#8)))
                      (Eq.trans (congrArg (HAdd.hAdd 385#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝ + 1#8))))
                        (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (385#9)
                          (~~~BitVec.signExtend 9 (x✝ + 1#8)) 1#9))))
                  (BitVec.msb_eq_getLsbD_last (386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)))))
              (congrArg (fun x => x.getMsbD 1)
                (Eq.trans (BitVec.sub_toAdd (385#9) (BitVec.signExtend 9 (x✝ + 1#8)))
                  (Eq.trans (congrArg (HAdd.hAdd 385#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝ + 1#8))))
                    (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (385#9) (~~~BitVec.signExtend 9 (x✝ + 1#8))
                      1#9)))))
            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq ((386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getLsbD 8)
              ((386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getMsbD 1))))
        (true_and
          ((!(386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getLsbD 8 ==
                (386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getMsbD 1) =
            true))
    [Meta.isDefEq.assign] [0.002732] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (congr
                (congrArg Ne
                  (Eq.trans
                    (congrArg BitVec.msb
                      (Eq.trans (BitVec.sub_toAdd (385#9) (BitVec.signExtend 9 (x✝ + 1#8)))
                        (Eq.trans (congrArg (HAdd.hAdd 385#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝ + 1#8))))
                          (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (385#9)
                            (~~~BitVec.signExtend 9 (x✝ + 1#8)) 1#9))))
                    (BitVec.msb_eq_getLsbD_last (386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)))))
                (congrArg (fun x => x.getMsbD 1)
                  (Eq.trans (BitVec.sub_toAdd (385#9) (BitVec.signExtend 9 (x✝ + 1#8)))
                    (Eq.trans (congrArg (HAdd.hAdd 385#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝ + 1#8))))
                      (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (385#9) (~~~BitVec.signExtend 9 (x✝ + 1#8))
                        1#9)))))
              (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq ((386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getLsbD 8)
                ((386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getMsbD 1))))
          (true_and
            ((!(386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getLsbD 8 ==
                  (386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getMsbD 1) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.002700] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 1#8)).msb ≠
                (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 1#8)).getMsbD 1) =
            ((!(386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getLsbD 8 ==
                  (386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getMsbD 1) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (congr
                  (congrArg Ne
                    (Eq.trans
                      (congrArg BitVec.msb
                        (Eq.trans (BitVec.sub_toAdd (385#9) (BitVec.signExtend 9 (x✝ + 1#8)))
                          (Eq.trans
                            (congrArg (HAdd.hAdd 385#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝ + 1#8))))
                            (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (385#9)
                              (~~~BitVec.signExtend 9 (x✝ + 1#8)) 1#9))))
                      (BitVec.msb_eq_getLsbD_last (386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)))))
                  (congrArg (fun x => x.getMsbD 1)
                    (Eq.trans (BitVec.sub_toAdd (385#9) (BitVec.signExtend 9 (x✝ + 1#8)))
                      (Eq.trans (congrArg (HAdd.hAdd 385#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝ + 1#8))))
                        (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (385#9)
                          (~~~BitVec.signExtend 9 (x✝ + 1#8)) 1#9)))))
                (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq ((386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getLsbD 8)
                  ((386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getMsbD 1))))
            (true_and
              ((!(386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getLsbD 8 ==
                    (386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getMsbD 1) =
                true)) : (True ∧
              (385#9 - BitVec.signExtend 9 (x✝ + 1#8)).msb ≠ (385#9 - BitVec.signExtend 9 (x✝ + 1#8)).getMsbD 1) =
            ((!(386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getLsbD 8 ==
                  (386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getMsbD 1) =
              true))
        [Meta.isDefEq] [0.002695] ✅️ (True ∧
                (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 1#8)).msb ≠
                  (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 1#8)).getMsbD 1) =
              ((!(386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getLsbD 8 ==
                    (386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getMsbD 1) =
                true) =?= (True ∧
                (385#9 - BitVec.signExtend 9 (x✝ + 1#8)).msb ≠ (385#9 - BitVec.signExtend 9 (x✝ + 1#8)).getMsbD 1) =
              ((!(386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getLsbD 8 ==
                    (386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getMsbD 1) =
                true)
          [Meta.isDefEq] [0.002659] ✅️ True ∧
                (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 1#8)).msb ≠
                  (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 1#8)).getMsbD
                    1 =?= True ∧
                (385#9 - BitVec.signExtend 9 (x✝ + 1#8)).msb ≠ (385#9 - BitVec.signExtend 9 (x✝ + 1#8)).getMsbD 1
            [Meta.isDefEq] [0.002641] ✅️ (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 1#8)).msb ≠
                  (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 1#8)).getMsbD
                    1 =?= (385#9 - BitVec.signExtend 9 (x✝ + 1#8)).msb ≠
                  (385#9 - BitVec.signExtend 9 (x✝ + 1#8)).getMsbD 1
              [Meta.isDefEq.delta] [0.002618] ✅️ (BitVec.signExtend (8 + 1) 129#8 -
                        BitVec.signExtend (8 + 1) (x✝ + 1#8)).msb ≠
                    (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 1#8)).getMsbD
                      1 =?= (385#9 - BitVec.signExtend 9 (x✝ + 1#8)).msb ≠
                    (385#9 - BitVec.signExtend 9 (x✝ + 1#8)).getMsbD 1
                [Meta.isDefEq] [0.002531] ✅️ (BitVec.signExtend (8 + 1) 129#8 -
                        BitVec.signExtend (8 + 1) (x✝ + 1#8)).msb =?= (385#9 - BitVec.signExtend 9 (x✝ + 1#8)).msb
                  [Meta.isDefEq.delta] [0.002514] ✅️ (BitVec.signExtend (8 + 1) 129#8 -
                          BitVec.signExtend (8 + 1) (x✝ + 1#8)).msb =?= (385#9 - BitVec.signExtend 9 (x✝ + 1#8)).msb
                    [Meta.isDefEq] [0.002495] ✅️ BitVec.signExtend (8 + 1) 129#8 -
                          BitVec.signExtend (8 + 1) (x✝ + 1#8) =?= 385#9 - BitVec.signExtend 9 (x✝ + 1#8)
                      [Meta.isDefEq] [0.002463] ✅️ instHSub.1 (BitVec.signExtend (8 + 1) 129#8)
                            (BitVec.signExtend (8 + 1)
                              (x✝ + 1#8)) =?= instHSub.1 (385#9) (BitVec.signExtend 9 (x✝ + 1#8))
                        [Meta.isDefEq] [0.002405] ✅️ Sub.sub (BitVec.signExtend (8 + 1) 129#8)
                              (BitVec.signExtend (8 + 1)
                                (x✝ + 1#8)) =?= Sub.sub (385#9) (BitVec.signExtend 9 (x✝ + 1#8))
                          [Meta.isDefEq] [0.002376] ✅️ BitVec.instSub.1 (BitVec.signExtend (8 + 1) 129#8)
                                (BitVec.signExtend (8 + 1)
                                  (x✝ + 1#8)) =?= BitVec.instSub.1 (385#9) (BitVec.signExtend 9 (x✝ + 1#8))
                            [Meta.isDefEq] [0.002332] ✅️ (BitVec.signExtend (8 + 1) 129#8).sub
                                  (BitVec.signExtend (8 + 1)
                                    (x✝ + 1#8)) =?= (385#9).sub (BitVec.signExtend 9 (x✝ + 1#8))
                              [Meta.isDefEq.delta] [0.002315] ✅️ (BitVec.signExtend (8 + 1) 129#8).sub
                                    (BitVec.signExtend (8 + 1)
                                      (x✝ + 1#8)) =?= (385#9).sub (BitVec.signExtend 9 (x✝ + 1#8))
                                [Meta.isDefEq] [0.002247] ✅️ BitVec.signExtend (8 + 1) 129#8 =?= 385#9
                                  [Meta.isDefEq] [0.002220] ✅️ BitVec.ofInt (8 + 1) (129#8).toInt =?= 385#9
                                    [Meta.isDefEq] [0.002187] ✅️ ((129#8).toInt %
                                              Int.ofNat (2 ^ (8 + 1))).toNat#'⋯ =?= 385#9
                                      [Meta.isDefEq] [0.002158] ✅️ ((129#8).toInt %
                                                Int.ofNat
                                                  (2 ^ (8 + 1))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 9) 385 }
                                        [Meta.isDefEq] [0.002137] ✅️ {
                                              toFin :=
                                                ⟨((129#8).toInt % Int.ofNat (2 ^ (8 + 1))).toNat,
                                                  ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 9) 385 }
                                          [Meta.isDefEq] [0.002075] ✅️ ⟨((129#8).toInt % Int.ofNat (2 ^ (8 + 1))).toNat,
                                                ⋯⟩ =?= Fin.ofNat' (2 ^ 9) 385
                                            [Meta.isDefEq] [0.002051] ✅️ ⟨((129#8).toInt %
                                                      Int.ofNat (2 ^ (8 + 1))).toNat,
                                                  ⋯⟩ =?= ⟨385 % 2 ^ 9, ⋯⟩
                                              [Meta.isDefEq] [0.001974] ✅️ ((129#8).toInt %
                                                      Int.ofNat (2 ^ (8 + 1))).toNat =?= 385 % 2 ^ 9
                                                [Meta.isDefEq] [0.001915] ✅️ match
                                                      (129#8).toInt % Int.ofNat (2 ^ (8 + 1)) with
                                                    | Int.ofNat n => n
                                                    | Int.negSucc a => 0 =?= 385 % 2 ^ 9
                                                  [Meta.whnf] [0.001563] Non-easy whnf: (fun motive x h_1 h_2 =>
                                                          Int.casesOn x (fun a => h_1 a) fun a => h_2 a)
                                                        (fun x => ℕ) ((129#8).toInt % Int.ofNat (2 ^ (8 + 1))) h_1 h_2
                                                    [Meta.whnf] [0.001532] Non-easy whnf: (129#8).toInt %
                                                          Int.ofNat (2 ^ (8 + 1))
                                                      [Meta.whnf] [0.001522] Non-easy whnf: instHMod.1 (129#8).toInt
                                                            (Int.ofNat (2 ^ (8 + 1)))
                                                        [Meta.whnf] [0.001511] Non-easy whnf: Int.instMod.1
                                                              (129#8).toInt (Int.ofNat (2 ^ (8 + 1)))
                                                          [Meta.whnf] [0.001494] Non-easy whnf: match (129#8).toInt,
                                                                Int.ofNat (2 ^ (8 + 1)) with
                                                              | Int.ofNat m, n => Int.ofNat (m % n.natAbs)
                                                              | Int.negSucc m, n =>
                                                                Int.subNatNat n.natAbs (m % n.natAbs).succ
                                                            [Meta.whnf] [0.001181] Non-easy whnf: (fun motive x x_1 h_1
                                                                      h_2 =>
                                                                    Int.casesOn x (fun a => h_1 a x_1) fun a =>
                                                                      h_2 a x_1)
                                                                  (fun x x => ℤ) (129#8).toInt (Int.ofNat (2 ^ (8 + 1)))
                                                                  h_1 h_2
                                                              [Meta.whnf] [0.001155] Non-easy whnf: (129#8).toInt
                                                                [Meta.whnf] [0.001136] Non-easy whnf: if
                                                                        2 * (129#8).toNat < 2 ^ 8 then ↑(129#8).toNat
                                                                    else ↑(129#8).toNat - ↑(2 ^ 8)
                                                                  [Meta.whnf] [0.001113] Non-easy whnf: Decidable.casesOn
                                                                        ((2 * (129#8).toNat).decLt (2 ^ 8))
                                                                        (fun x => ↑(129#8).toNat - ↑(2 ^ 8)) fun x =>
                                                                        ↑(129#8).toNat
  [Meta.appBuilder] [0.002585] ✅️ f: HAdd.hAdd, xs: [~~~(x✝ + 1#8), 1#8]
    [Meta.synthInstance] [0.002497] ✅️ HAdd (BitVec 8) (BitVec 8) (BitVec 8)
      [Meta.synthInstance] [0.001844] ✅️ apply @BitVec.instAdd to Add (BitVec 8)
        [Meta.synthInstance.tryResolve] [0.001807] ✅️ Add (BitVec 8) ≟ Add (BitVec 8)
          [Meta.isDefEq] [0.001739] ✅️ Add (BitVec 8) =?= Add (BitVec ?m.23936)
            [Meta.isDefEq] [0.001710] ✅️ BitVec 8 =?= BitVec ?m.23936
              [Meta.isDefEq] [0.001690] ✅️ 8 =?= ?m.23936
                [Meta.isDefEq.assign] [0.001684] ✅️ ?m.23936 := 8
                  [Meta.isDefEq.assign.checkTypes] [0.001673] ✅️ (?m.23936 : ℕ) := (8 : ℕ)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                (!(386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getLsbD 8 ==
                      (386#9 + ~~~BitVec.signExtend 9 (x✝ + 1#8)).getMsbD 1) =
                  true then
              none
            else some (129#8 + ~~~x✝)) ⊑
            some (129#8 + ~~~x✝)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddsubhconstanthfolding_proof.lean:76:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddsubhconstanthfolding_proof.lean:69:8: error: (kernel) declaration has metavariables 'add_nsw_const_const_sub_nsw_ov_thm'
[bv] [0.055695] Normalizing goal
  [Meta.synthInstance] [0.001315] ✅️ Decidable
        ((if True ∧ x✝.msb = (2#8).msb ∧ (x✝ + 2#8).msb ≠ x✝.msb then none
          else
            if
                True ∧
                  (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 2#8)).msb ≠
                    (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 2#8)).getMsbD 1 then
              none
            else some (129#8 - (x✝ + 2#8))) ⊑
          some (127#8 - x✝))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if True ∧ x✝.msb = (2#8).msb ∧ (x✝ + 2#8).msb ≠ x✝.msb then none
            else
              if
                  True ∧
                    (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 2#8)).msb ≠
                      (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 2#8)).getMsbD 1 then
                none
              else some (129#8 - (x✝ + 2#8))) ⊑
            some (127#8 - x✝)
      ⊢ False
  [Meta.isDefEq] [0.005745] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (congr
              (congrArg Ne
                (Eq.trans
                  (congrArg BitVec.msb
                    (Eq.trans (BitVec.sub_toAdd (385#9) (BitVec.signExtend 9 (x✝ + 2#8)))
                      (Eq.trans (congrArg (HAdd.hAdd 385#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝ + 2#8))))
                        (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (385#9)
                          (~~~BitVec.signExtend 9 (x✝ + 2#8)) 1#9))))
                  (BitVec.msb_eq_getLsbD_last (386#9 + ~~~BitVec.signExtend 9 (x✝ + 2#8)))))
              (congrArg (fun x => x.getMsbD 1)
                (Eq.trans (BitVec.sub_toAdd (385#9) (BitVec.signExtend 9 (x✝ + 2#8)))
                  (Eq.trans (congrArg (HAdd.hAdd 385#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝ + 2#8))))
                    (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (385#9) (~~~BitVec.signExtend 9 (x✝ + 2#8))
                      1#9)))))
            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq ((386#9 + ~~~BitVec.signExtend 9 (x✝ + 2#8)).getLsbD 8)
              ((386#9 + ~~~BitVec.signExtend 9 (x✝ + 2#8)).getMsbD 1))))
        (true_and
          ((!(386#9 + ~~~BitVec.signExtend 9 (x✝ + 2#8)).getLsbD 8 ==
                (386#9 + ~~~BitVec.signExtend 9 (x✝ + 2#8)).getMsbD 1) =
            true))
    [Meta.isDefEq.assign] [0.005743] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (congr
                (congrArg Ne
                  (Eq.trans
                    (congrArg BitVec.msb
                      (Eq.trans (BitVec.sub_toAdd (385#9) (BitVec.signExtend 9 (x✝ + 2#8)))
                        (Eq.trans (congrArg (HAdd.hAdd 385#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝ + 2#8))))
                          (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (385#9)
                            (~~~BitVec.signExtend 9 (x✝ + 2#8)) 1#9))))
                    (BitVec.msb_eq_getLsbD_last (386#9 + ~~~BitVec.signExtend 9 (x✝ + 2#8)))))
                (congrArg (fun x => x.getMsbD 1)
                  (Eq.trans (BitVec.sub_toAdd (385#9) (BitVec.signExtend 9 (x✝ + 2#8)))
                    (Eq.trans (congrArg (HAdd.hAdd 385#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝ + 2#8))))
                      (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (385#9) (~~~BitVec.signExtend 9 (x✝ + 2#8))
                        1#9)))))
              (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq ((386#9 + ~~~BitVec.signExtend 9 (x✝ + 2#8)).getLsbD 8)
                ((386#9 + ~~~BitVec.signExtend 9 (x✝ + 2#8)).getMsbD 1))))
          (true_and
            ((!(386#9 + ~~~BitVec.signExtend 9 (x✝ + 2#8)).getLsbD 8 ==
                  (386#9 + ~~~BitVec.signExtend 9 (x✝ + 2#8)).getMsbD 1) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.005721] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 2#8)).msb ≠
                (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 2#8)).getMsbD 1) =
            ((!(386#9 + ~~~BitVec.signExtend 9 (x✝ + 2#8)).getLsbD 8 ==
                  (386#9 + ~~~BitVec.signExtend 9 (x✝ + 2#8)).getMsbD 1) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (congr
                  (congrArg Ne
                    (Eq.trans
                      (congrArg BitVec.msb
                        (Eq.trans (BitVec.sub_toAdd (385#9) (BitVec.signExtend 9 (x✝ + 2#8)))
                          (Eq.trans
                            (congrArg (HAdd.hAdd 385#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝ + 2#8))))
                            (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (385#9)
                              (~~~BitVec.signExtend 9 (x✝ + 2#8)) 1#9))))
                      (BitVec.msb_eq_getLsbD_last (386#9 + ~~~BitVec.signExtend 9 (x✝ + 2#8)))))
                  (congrArg (fun x => x.getMsbD 1)
                    (Eq.trans (BitVec.sub_toAdd (385#9) (BitVec.signExtend 9 (x✝ + 2#8)))
                      (Eq.trans (congrArg (HAdd.hAdd 385#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝ + 2#8))))
                        (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (385#9)
                          (~~~BitVec.signExtend 9 (x✝ + 2#8)) 1#9)))))
                (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq ((386#9 + ~~~BitVec.signExtend 9 (x✝ + 2#8)).getLsbD 8)
                  ((386#9 + ~~~BitVec.signExtend 9 (x✝ + 2#8)).getMsbD 1))))
            (true_and
              ((!(386#9 + ~~~BitVec.signExtend 9 (x✝ + 2#8)).getLsbD 8 ==
                    (386#9 + ~~~BitVec.signExtend 9 (x✝ + 2#8)).getMsbD 1) =
                true)) : (True ∧
              (385#9 - BitVec.signExtend 9 (x✝ + 2#8)).msb ≠ (385#9 - BitVec.signExtend 9 (x✝ + 2#8)).getMsbD 1) =
            ((!(386#9 + ~~~BitVec.signExtend 9 (x✝ + 2#8)).getLsbD 8 ==
                  (386#9 + ~~~BitVec.signExtend 9 (x✝ + 2#8)).getMsbD 1) =
              true))
        [Meta.isDefEq] [0.005718] ✅️ (True ∧
                (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 2#8)).msb ≠
                  (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 2#8)).getMsbD 1) =
              ((!(386#9 + ~~~BitVec.signExtend 9 (x✝ + 2#8)).getLsbD 8 ==
                    (386#9 + ~~~BitVec.signExtend 9 (x✝ + 2#8)).getMsbD 1) =
                true) =?= (True ∧
                (385#9 - BitVec.signExtend 9 (x✝ + 2#8)).msb ≠ (385#9 - BitVec.signExtend 9 (x✝ + 2#8)).getMsbD 1) =
              ((!(386#9 + ~~~BitVec.signExtend 9 (x✝ + 2#8)).getLsbD 8 ==
                    (386#9 + ~~~BitVec.signExtend 9 (x✝ + 2#8)).getMsbD 1) =
                true)
          [Meta.isDefEq] [0.005698] ✅️ True ∧
                (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 2#8)).msb ≠
                  (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 2#8)).getMsbD
                    1 =?= True ∧
                (385#9 - BitVec.signExtend 9 (x✝ + 2#8)).msb ≠ (385#9 - BitVec.signExtend 9 (x✝ + 2#8)).getMsbD 1
            [Meta.isDefEq] [0.005688] ✅️ (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 2#8)).msb ≠
                  (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 2#8)).getMsbD
                    1 =?= (385#9 - BitVec.signExtend 9 (x✝ + 2#8)).msb ≠
                  (385#9 - BitVec.signExtend 9 (x✝ + 2#8)).getMsbD 1
              [Meta.isDefEq.delta] [0.005673] ✅️ (BitVec.signExtend (8 + 1) 129#8 -
                        BitVec.signExtend (8 + 1) (x✝ + 2#8)).msb ≠
                    (BitVec.signExtend (8 + 1) 129#8 - BitVec.signExtend (8 + 1) (x✝ + 2#8)).getMsbD
                      1 =?= (385#9 - BitVec.signExtend 9 (x✝ + 2#8)).msb ≠
                    (385#9 - BitVec.signExtend 9 (x✝ + 2#8)).getMsbD 1
                [Meta.isDefEq] [0.005637] ✅️ (BitVec.signExtend (8 + 1) 129#8 -
                        BitVec.signExtend (8 + 1) (x✝ + 2#8)).msb =?= (385#9 - BitVec.signExtend 9 (x✝ + 2#8)).msb
                  [Meta.isDefEq.delta] [0.005628] ✅️ (BitVec.signExtend (8 + 1) 129#8 -
                          BitVec.signExtend (8 + 1) (x✝ + 2#8)).msb =?= (385#9 - BitVec.signExtend 9 (x✝ + 2#8)).msb
                    [Meta.isDefEq] [0.005618] ✅️ BitVec.signExtend (8 + 1) 129#8 -
                          BitVec.signExtend (8 + 1) (x✝ + 2#8) =?= 385#9 - BitVec.signExtend 9 (x✝ + 2#8)
                      [Meta.isDefEq] [0.005598] ✅️ instHSub.1 (BitVec.signExtend (8 + 1) 129#8)
                            (BitVec.signExtend (8 + 1)
                              (x✝ + 2#8)) =?= instHSub.1 (385#9) (BitVec.signExtend 9 (x✝ + 2#8))
                        [Meta.isDefEq] [0.005563] ✅️ Sub.sub (BitVec.signExtend (8 + 1) 129#8)
                              (BitVec.signExtend (8 + 1)
                                (x✝ + 2#8)) =?= Sub.sub (385#9) (BitVec.signExtend 9 (x✝ + 2#8))
                          [Meta.isDefEq] [0.005546] ✅️ BitVec.instSub.1 (BitVec.signExtend (8 + 1) 129#8)
                                (BitVec.signExtend (8 + 1)
                                  (x✝ + 2#8)) =?= BitVec.instSub.1 (385#9) (BitVec.signExtend 9 (x✝ + 2#8))
                            [Meta.isDefEq] [0.005519] ✅️ (BitVec.signExtend (8 + 1) 129#8).sub
                                  (BitVec.signExtend (8 + 1)
                                    (x✝ + 2#8)) =?= (385#9).sub (BitVec.signExtend 9 (x✝ + 2#8))
                              [Meta.isDefEq.delta] [0.005511] ✅️ (BitVec.signExtend (8 + 1) 129#8).sub
                                    (BitVec.signExtend (8 + 1)
                                      (x✝ + 2#8)) =?= (385#9).sub (BitVec.signExtend 9 (x✝ + 2#8))
                                [Meta.isDefEq] [0.005471] ✅️ BitVec.signExtend (8 + 1) 129#8 =?= 385#9
                                  [Meta.isDefEq] [0.005454] ✅️ BitVec.ofInt (8 + 1) (129#8).toInt =?= 385#9
                                    [Meta.isDefEq] [0.005437] ✅️ ((129#8).toInt %
                                              Int.ofNat (2 ^ (8 + 1))).toNat#'⋯ =?= 385#9
                                      [Meta.isDefEq] [0.005420] ✅️ ((129#8).toInt %
                                                Int.ofNat
                                                  (2 ^ (8 + 1))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 9) 385 }
                                        [Meta.isDefEq] [0.005408] ✅️ {
                                              toFin :=
                                                ⟨((129#8).toInt % Int.ofNat (2 ^ (8 + 1))).toNat,
                                                  ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 9) 385 }
                                          [Meta.isDefEq] [0.005359] ✅️ ⟨((129#8).toInt % Int.ofNat (2 ^ (8 + 1))).toNat,
                                                ⋯⟩ =?= Fin.ofNat' (2 ^ 9) 385
                                            [Meta.isDefEq] [0.005341] ✅️ ⟨((129#8).toInt %
                                                      Int.ofNat (2 ^ (8 + 1))).toNat,
                                                  ⋯⟩ =?= ⟨385 % 2 ^ 9, ⋯⟩
                                              [Meta.isDefEq] [0.005262] ✅️ ((129#8).toInt %
                                                      Int.ofNat (2 ^ (8 + 1))).toNat =?= 385 % 2 ^ 9
                                                [Meta.isDefEq] [0.005221] ✅️ match
                                                      (129#8).toInt % Int.ofNat (2 ^ (8 + 1)) with
                                                    | Int.ofNat n => n
                                                    | Int.negSucc a => 0 =?= 385 % 2 ^ 9
                                                  [Meta.whnf] [0.005016] Non-easy whnf: (fun motive x h_1 h_2 =>
                                                          Int.casesOn x (fun a => h_1 a) fun a => h_2 a)
                                                        (fun x => ℕ) ((129#8).toInt % Int.ofNat (2 ^ (8 + 1))) h_1 h_2
                                                    [Meta.whnf] [0.004998] Non-easy whnf: (129#8).toInt %
                                                          Int.ofNat (2 ^ (8 + 1))
                                                      [Meta.whnf] [0.004992] Non-easy whnf: instHMod.1 (129#8).toInt
                                                            (Int.ofNat (2 ^ (8 + 1)))
                                                        [Meta.whnf] [0.004986] Non-easy whnf: Int.instMod.1
                                                              (129#8).toInt (Int.ofNat (2 ^ (8 + 1)))
                                                          [Meta.whnf] [0.004976] Non-easy whnf: match (129#8).toInt,
                                                                Int.ofNat (2 ^ (8 + 1)) with
                                                              | Int.ofNat m, n => Int.ofNat (m % n.natAbs)
                                                              | Int.negSucc m, n =>
                                                                Int.subNatNat n.natAbs (m % n.natAbs).succ
                                                            [Meta.whnf] [0.004842] Non-easy whnf: (fun motive x x_1 h_1
                                                                      h_2 =>
                                                                    Int.casesOn x (fun a => h_1 a x_1) fun a =>
                                                                      h_2 a x_1)
                                                                  (fun x x => ℤ) (129#8).toInt (Int.ofNat (2 ^ (8 + 1)))
                                                                  h_1 h_2
                                                              [Meta.whnf] [0.004827] Non-easy whnf: (129#8).toInt
                                                                [Meta.whnf] [0.004803] Non-easy whnf: if
                                                                        2 * (129#8).toNat < 2 ^ 8 then ↑(129#8).toNat
                                                                    else ↑(129#8).toNat - ↑(2 ^ 8)
                                                                  [Meta.whnf] [0.004794] Non-easy whnf: Decidable.casesOn
                                                                        ((2 * (129#8).toNat).decLt (2 ^ 8))
                                                                        (fun x => ↑(129#8).toNat - ↑(2 ^ 8)) fun x =>
                                                                        ↑(129#8).toNat
                                                                    [Meta.whnf] [0.002370] Non-easy whnf: (2 *
                                                                              (129#8).toNat).decLt
                                                                          (2 ^ 8)
                                                                      [Meta.whnf] [0.002362] Non-easy whnf: (2 *
                                                                                  (129#8).toNat).succ.decLe
                                                                            (2 ^ 8)
                                                                        [Meta.whnf] [0.002347] Non-easy whnf: if h :
                                                                                (2 * (129#8).toNat).succ.ble (2 ^ 8) =
                                                                                  true then
                                                                              isTrue ⋯
                                                                            else isFalse ⋯
                                                                          [Meta.whnf] [0.002339] Non-easy whnf: Decidable.casesOn
                                                                                (instDecidableEqBool
                                                                                  ((2 * (129#8).toNat).succ.ble (2 ^ 8))
                                                                                  true)
                                                                                (fun h => isFalse ⋯) fun h => isTrue ⋯
                                                                            [Meta.whnf] [0.002324] Non-easy whnf: instDecidableEqBool
                                                                                  ((2 * (129#8).toNat).succ.ble (2 ^ 8))
                                                                                  true
                                                                              [Meta.whnf] [0.002318] Non-easy whnf: ((2 *
                                                                                              (129#8).toNat).succ.ble
                                                                                        (2 ^ 8)).decEq
                                                                                    true
                                                                                [Meta.whnf] [0.002310] Non-easy whnf: match
                                                                                      (2 * (129#8).toNat).succ.ble
                                                                                        (2 ^ 8),
                                                                                      true with
                                                                                    | false, false => isTrue ⋯
                                                                                    | false, true => isFalse ⋯
                                                                                    | true, false => isFalse ⋯
                                                                                    | true, true => isTrue ⋯
                                                                                  [Meta.whnf] [0.002278] Non-easy whnf: (fun
                                                                                            motive a b h_1 h_2 h_3
                                                                                            h_4 =>
                                                                                          Bool.casesOn a
                                                                                            (Bool.casesOn b (h_1 ())
                                                                                              (h_2 ()))
                                                                                            (Bool.casesOn b (h_3 ())
                                                                                              (h_4 ())))
                                                                                        (fun a b => Decidable (a = b))
                                                                                        ((2 * (129#8).toNat).succ.ble
                                                                                          (2 ^ 8))
                                                                                        true h_1 h_2 h_3 h_4
                                                                                    [Meta.whnf] [0.002247] Non-easy whnf: (2 *
                                                                                                (129#8).toNat).succ.ble
                                                                                          (2 ^ 8)
                                                                                      [Meta.whnf] [0.002236] Non-easy whnf: (2 *
                                                                                              (129#8).toNat).succ
                                                                                        [Meta.whnf] [0.002231] Non-easy whnf: 2 *
                                                                                              (129#8).toNat
                                                                                          [Meta.whnf] [0.002213] Non-easy whnf: instHMul.1
                                                                                                2 (129#8).toNat
                                                                                            [Meta.whnf] [0.002146] Non-easy whnf: instMulNat.1
                                                                                                  2 (129#8).toNat
                                                                                              [Meta.whnf] [0.002115] Non-easy whnf: (129#8).toNat
                                                                                                [Meta.whnf] [0.002104] Non-easy whnf: ↑(129#8).toFin
                                                                                                  [Meta.whnf] [0.002093] Non-easy whnf: (129#8).toFin.1
                                                                                                    [Meta.whnf] [0.002066] Non-easy whnf: (129#8).toFin
                                                                    [Meta.whnf] [0.002400] Non-easy whnf: instHSub.1
                                                                          ↑(129#8).toNat ↑(2 ^ 8)
                                                                      [Meta.whnf] [0.002383] Non-easy whnf: Int.instSub.1
                                                                            ↑(129#8).toNat ↑(2 ^ 8)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if (!x✝.getLsbD 7 && !(x✝ + 2#8).getLsbD 7 == x✝.getLsbD 7) = true then none
            else
              if
                  (!(386#9 + ~~~BitVec.signExtend 9 (x✝ + 2#8)).getLsbD 8 ==
                        (386#9 + ~~~BitVec.signExtend 9 (x✝ + 2#8)).getMsbD 1) =
                    true then
                none
              else some (130#8 + ~~~(x✝ + 2#8))) ⊑
            some (128#8 + ~~~x✝)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddsubhconstanthfolding_proof.lean:87:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddsubhconstanthfolding_proof.lean:80:8: error: (kernel) declaration has metavariables 'add_nuw_const_const_sub_nuw_thm'
[bv] [0.053603] Normalizing goal
  [Meta.synthInstance] [0.001103] ✅️ Decidable
        ((if True ∧ (x✝ + 1#8 < x✝ ∨ x✝ + 1#8 < 1#8) then none
          else if True ∧ 129#8 < x✝ + 1#8 then none else some (129#8 - (x✝ + 1#8))) ⊑
          if True ∧ 128#8 < x✝ then none else some (128#8 - x✝))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if True ∧ (x✝ + 1#8 < x✝ ∨ x✝ + 1#8 < 1#8) then none
            else if True ∧ 129#8 < x✝ + 1#8 then none else some (129#8 - (x✝ + 1#8))) ⊑
            if True ∧ 128#8 < x✝ then none else some (128#8 - x✝)
      ⊢ False
  [Meta.whnf] [0.014106] Non-easy whnf: (?a || ?b) = !(!?a && !?b)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if (!((!x✝ >ᵤ x✝ + 1#8) && !1#8 >ᵤ x✝ + 1#8)) = true then none
            else if (x✝ + 1#8 >ᵤ 129#8) = true then none else some (129#8 + ~~~x✝)) ⊑
            if (x✝ >ᵤ 128#8) = true then none else some (129#8 + ~~~x✝)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddsubhconstanthfolding_proof.lean:97:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddsubhconstanthfolding_proof.lean:91:8: error: (kernel) declaration has metavariables 'add_nuw_const_const_sub_thm'
[bv] [0.027430] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ : ¬(if True ∧ (x✝ + 1#8 < x✝ ∨ x✝ + 1#8 < 1#8) then none else some (129#8 - (x✝ + 1#8))) ⊑ some (128#8 - x✝)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if (!((!x✝ >ᵤ x✝ + 1#8) && !1#8 >ᵤ x✝ + 1#8)) = true then none else some (129#8 + ~~~x✝)) ⊑
            some (129#8 + ~~~x✝)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddsubhconstanthfolding_proof.lean:107:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddsubhconstanthfolding_proof.lean:101:8: error: (kernel) declaration has metavariables 'add_const_const_sub_nuw_thm'
[bv] [0.024645] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ : ¬(if True ∧ 129#8 < x✝ + 1#8 then none else some (129#8 - (x✝ + 1#8))) ⊑ some (128#8 - x✝)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ : ¬(if (x✝ + 1#8 >ᵤ 129#8) = true then none else some (129#8 + ~~~x✝)) ⊑ some (129#8 + ~~~x✝)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 82.899849ms, solving context: 0.000000ms
LeanSAT proved the goal after 83.514300ms: rewriting 16.794670ms, bitblasting 0.000000ms, SAT solving 61.231690ms, LRAT trimming 0.000000ms, LRAT checking 2.112880ms
Bitwuzla proved the goal after 89.530079ms, solving context: 2.000000ms
LeanSAT proved the goal after 79.752260ms: rewriting 16.193290ms, bitblasting 0.000000ms, SAT solving 56.653830ms, LRAT trimming 0.000000ms, LRAT checking 5.995400ms
Bitwuzla proved the goal after 83.842610ms, solving context: 0.000000ms
LeanSAT proved the goal after 164.556239ms: rewriting 25.886980ms, bitblasting 0.000000ms, SAT solving 110.529519ms, LRAT trimming 4.652920ms, LRAT checking 14.318270ms
Bitwuzla proved the goal after 11.295620ms, solving context: 0.000000ms
LeanSAT proved the goal after 10.222260ms: rewriting 10.205890ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 11.986010ms, solving context: 0.000000ms
LeanSAT proved the goal after 10.890680ms: rewriting 10.872360ms, bitblasting 0.000000ms, SAT solving 0.000000ms, LRAT trimming 0.000000ms, LRAT checking 0.000000ms
Bitwuzla proved the goal after 78.700079ms, solving context: 0.000000ms
LeanSAT proved the goal after 141.949079ms: rewriting 20.024810ms, bitblasting 0.000000ms, SAT solving 104.460041ms, LRAT trimming 4.994669ms, LRAT checking 10.377340ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddsubhconstanthfolding_proof.lean:172:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddsubhconstanthfolding_proof.lean:165:8: error: (kernel) declaration has metavariables 'addsub_combine_constants_thm'
[bv] [0.036035] Normalizing goal
  [Meta.synthInstance] [0.001112] ✅️ Decidable
        ((if True ∧ (x✝ + 42#7).msb = (10#7 - x✝¹).msb ∧ (x✝ + 42#7 + (10#7 - x✝¹)).msb ≠ (x✝ + 42#7).msb then none
          else some (x✝ + 42#7 + (10#7 - x✝¹))) ⊑
          some (x✝ - x✝¹ + 52#7))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 7
      x✝¹ x✝ : BitVec 7
      a✝ :
        ¬(if True ∧ (x✝ + 42#7).msb = (10#7 - x✝¹).msb ∧ (x✝ + 42#7 + (10#7 - x✝¹)).msb ≠ (x✝ + 42#7).msb then none
            else some (x✝ + 42#7 + (10#7 - x✝¹))) ⊑
            some (x✝ - x✝¹ + 52#7)
      ⊢ False
  [Meta.isDefEq] [0.001313] ✅️ ?h₃ =?= fun a =>
        congrArg (fun x => some (x✝ + 42#7 + x))
          (Eq.trans (BitVec.sub_toAdd (10#7) x✝¹)
            (Eq.trans (congrArg (HAdd.hAdd 10#7) (BitVec.neg_eq_not_add x✝¹))
              (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (10#7) (~~~x✝¹) 1#7)))
    [Meta.isDefEq.assign] [0.001310] ✅️ ?h₃ := fun a =>
          congrArg (fun x => some (x✝ + 42#7 + x))
            (Eq.trans (BitVec.sub_toAdd (10#7) x✝¹)
              (Eq.trans (congrArg (HAdd.hAdd 10#7) (BitVec.neg_eq_not_add x✝¹))
                (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (10#7) (~~~x✝¹) 1#7)))
      [Meta.isDefEq.assign.checkTypes] [0.001280] ✅️ (?h₃ : ¬((x✝ + 42#7).getLsbD 6 == (11#7 + ~~~x✝¹).getLsbD 6 &&
                  !(x✝ + 42#7 + (11#7 + ~~~x✝¹)).getLsbD 6 == (x✝ + 42#7).getLsbD 6) =
                true →
            some (x✝ + 42#7 + (10#7 - x✝¹)) =
              some
                (x✝ + 42#7 +
                  (11#7 +
                    ~~~x✝¹))) := (fun a =>
            congrArg (fun x => some (x✝ + 42#7 + x))
              (Eq.trans (BitVec.sub_toAdd (10#7) x✝¹)
                (Eq.trans (congrArg (HAdd.hAdd 10#7) (BitVec.neg_eq_not_add x✝¹))
                  (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (10#7) (~~~x✝¹)
                    1#7))) : ¬((x✝ + 42#7).getLsbD 6 == (11#7 + ~~~x✝¹).getLsbD 6 &&
                  !(x✝ + 42#7 + (11#7 + ~~~x✝¹)).getLsbD 6 == (x✝ + 42#7).getLsbD 6) =
                true →
            some (x✝ + 42#7 + (10#7 - x✝¹)) = some (x✝ + 42#7 + (10#7 + 1#7 + ~~~x✝¹)))
        [Meta.isDefEq] [0.001277] ✅️ ¬((x✝ + 42#7).getLsbD 6 == (11#7 + ~~~x✝¹).getLsbD 6 &&
                    !(x✝ + 42#7 + (11#7 + ~~~x✝¹)).getLsbD 6 == (x✝ + 42#7).getLsbD 6) =
                  true →
              some (x✝ + 42#7 + (10#7 - x✝¹)) =
                some
                  (x✝ + 42#7 +
                    (11#7 +
                      ~~~x✝¹)) =?= ¬((x✝ + 42#7).getLsbD 6 == (11#7 + ~~~x✝¹).getLsbD 6 &&
                    !(x✝ + 42#7 + (11#7 + ~~~x✝¹)).getLsbD 6 == (x✝ + 42#7).getLsbD 6) =
                  true →
              some (x✝ + 42#7 + (10#7 - x✝¹)) = some (x✝ + 42#7 + (10#7 + 1#7 + ~~~x✝¹))
          [Meta.isDefEq] [0.001245] ✅️ some (x✝ + 42#7 + (10#7 - x✝¹)) =
                some
                  (x✝ + 42#7 +
                    (11#7 + ~~~x✝¹)) =?= some (x✝ + 42#7 + (10#7 - x✝¹)) = some (x✝ + 42#7 + (10#7 + 1#7 + ~~~x✝¹))
            [Meta.isDefEq] [0.001225] ✅️ some (x✝ + 42#7 + (11#7 + ~~~x✝¹)) =?= some (x✝ + 42#7 + (10#7 + 1#7 + ~~~x✝¹))
              [Meta.isDefEq] [0.001204] ✅️ x✝ + 42#7 + (11#7 + ~~~x✝¹) =?= x✝ + 42#7 + (10#7 + 1#7 + ~~~x✝¹)
                [Meta.isDefEq] [0.001082] ✅️ instHAdd.1 (x✝ + 42#7)
                      (11#7 + ~~~x✝¹) =?= instHAdd.1 (x✝ + 42#7) (10#7 + 1#7 + ~~~x✝¹)
                  [Meta.isDefEq] [0.001041] ✅️ Add.add (x✝ + 42#7)
                        (11#7 + ~~~x✝¹) =?= Add.add (x✝ + 42#7) (10#7 + 1#7 + ~~~x✝¹)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 7
      x✝¹ x✝ : BitVec 7
      a✝ :
        ¬(if
                ((x✝ + 42#7).getLsbD 6 == (11#7 + ~~~x✝¹).getLsbD 6 &&
                    !(x✝ + 42#7 + (11#7 + ~~~x✝¹)).getLsbD 6 == (x✝ + 42#7).getLsbD 6) =
                  true then
              none
            else some (x✝ + 42#7 + (11#7 + ~~~x✝¹))) ⊑
            some (x✝ + (~~~x✝¹ + 1#7) + 52#7)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 82.517580ms, solving context: 2.000000ms
LeanSAT proved the goal after 97.504669ms: rewriting 21.672059ms, bitblasting 0.000000ms, SAT solving 54.400950ms, LRAT trimming 7.436330ms, LRAT checking 11.162300ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddsubhconstanthfolding_proof.lean:192:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddsubhconstanthfolding_proof.lean:185:8: error: (kernel) declaration has metavariables 'sub_from_constant_commute_thm'
[bv] [0.049997] Normalizing goal
  [Meta.synthInstance] [0.001371] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (5 + 1) 10#5 - BitVec.signExtend (5 + 1) x✝¹).msb ≠
                  (BitVec.signExtend (5 + 1) 10#5 - BitVec.signExtend (5 + 1) x✝¹).getMsbD 1 then
            none
          else
            if True ∧ (x✝ * x✝).msb = (10#5 - x✝¹).msb ∧ (x✝ * x✝ + (10#5 - x✝¹)).msb ≠ (x✝ * x✝).msb then none
            else some (x✝ * x✝ + (10#5 - x✝¹))) ⊑
          some (x✝ * x✝ - x✝¹ + 10#5))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 5
      x✝¹ x✝ : BitVec 5
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (5 + 1) 10#5 - BitVec.signExtend (5 + 1) x✝¹).msb ≠
                    (BitVec.signExtend (5 + 1) 10#5 - BitVec.signExtend (5 + 1) x✝¹).getMsbD 1 then
              none
            else
              if True ∧ (x✝ * x✝).msb = (10#5 - x✝¹).msb ∧ (x✝ * x✝ + (10#5 - x✝¹)).msb ≠ (x✝ * x✝).msb then none
              else some (x✝ * x✝ + (10#5 - x✝¹))) ⊑
            some (x✝ * x✝ - x✝¹ + 10#5)
      ⊢ False
  [Meta.isDefEq] [0.001536] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (congr
              (congrArg Ne
                (Eq.trans
                  (congrArg BitVec.msb
                    (Eq.trans (BitVec.sub_toAdd (10#6) (BitVec.signExtend 6 x✝¹))
                      (Eq.trans (congrArg (HAdd.hAdd 10#6) (BitVec.neg_eq_not_add (BitVec.signExtend 6 x✝¹)))
                        (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (10#6) (~~~BitVec.signExtend 6 x✝¹)
                          1#6))))
                  (BitVec.msb_eq_getLsbD_last (11#6 + ~~~BitVec.signExtend 6 x✝¹))))
              (congrArg (fun x => x.getMsbD 1)
                (Eq.trans (BitVec.sub_toAdd (10#6) (BitVec.signExtend 6 x✝¹))
                  (Eq.trans (congrArg (HAdd.hAdd 10#6) (BitVec.neg_eq_not_add (BitVec.signExtend 6 x✝¹)))
                    (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (10#6) (~~~BitVec.signExtend 6 x✝¹) 1#6)))))
            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq ((11#6 + ~~~BitVec.signExtend 6 x✝¹).getLsbD 5)
              ((11#6 + ~~~BitVec.signExtend 6 x✝¹).getMsbD 1))))
        (true_and
          ((!(11#6 + ~~~BitVec.signExtend 6 x✝¹).getLsbD 5 == (11#6 + ~~~BitVec.signExtend 6 x✝¹).getMsbD 1) = true))
    [Meta.isDefEq.assign] [0.001533] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (congr
                (congrArg Ne
                  (Eq.trans
                    (congrArg BitVec.msb
                      (Eq.trans (BitVec.sub_toAdd (10#6) (BitVec.signExtend 6 x✝¹))
                        (Eq.trans (congrArg (HAdd.hAdd 10#6) (BitVec.neg_eq_not_add (BitVec.signExtend 6 x✝¹)))
                          (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (10#6) (~~~BitVec.signExtend 6 x✝¹)
                            1#6))))
                    (BitVec.msb_eq_getLsbD_last (11#6 + ~~~BitVec.signExtend 6 x✝¹))))
                (congrArg (fun x => x.getMsbD 1)
                  (Eq.trans (BitVec.sub_toAdd (10#6) (BitVec.signExtend 6 x✝¹))
                    (Eq.trans (congrArg (HAdd.hAdd 10#6) (BitVec.neg_eq_not_add (BitVec.signExtend 6 x✝¹)))
                      (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (10#6) (~~~BitVec.signExtend 6 x✝¹) 1#6)))))
              (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq ((11#6 + ~~~BitVec.signExtend 6 x✝¹).getLsbD 5)
                ((11#6 + ~~~BitVec.signExtend 6 x✝¹).getMsbD 1))))
          (true_and
            ((!(11#6 + ~~~BitVec.signExtend 6 x✝¹).getLsbD 5 == (11#6 + ~~~BitVec.signExtend 6 x✝¹).getMsbD 1) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001515] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (5 + 1) 10#5 - BitVec.signExtend (5 + 1) x✝¹).msb ≠
                (BitVec.signExtend (5 + 1) 10#5 - BitVec.signExtend (5 + 1) x✝¹).getMsbD 1) =
            ((!(11#6 + ~~~BitVec.signExtend 6 x✝¹).getLsbD 5 == (11#6 + ~~~BitVec.signExtend 6 x✝¹).getMsbD 1) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (congr
                  (congrArg Ne
                    (Eq.trans
                      (congrArg BitVec.msb
                        (Eq.trans (BitVec.sub_toAdd (10#6) (BitVec.signExtend 6 x✝¹))
                          (Eq.trans (congrArg (HAdd.hAdd 10#6) (BitVec.neg_eq_not_add (BitVec.signExtend 6 x✝¹)))
                            (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (10#6) (~~~BitVec.signExtend 6 x✝¹)
                              1#6))))
                      (BitVec.msb_eq_getLsbD_last (11#6 + ~~~BitVec.signExtend 6 x✝¹))))
                  (congrArg (fun x => x.getMsbD 1)
                    (Eq.trans (BitVec.sub_toAdd (10#6) (BitVec.signExtend 6 x✝¹))
                      (Eq.trans (congrArg (HAdd.hAdd 10#6) (BitVec.neg_eq_not_add (BitVec.signExtend 6 x✝¹)))
                        (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (10#6) (~~~BitVec.signExtend 6 x✝¹)
                          1#6)))))
                (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq ((11#6 + ~~~BitVec.signExtend 6 x✝¹).getLsbD 5)
                  ((11#6 + ~~~BitVec.signExtend 6 x✝¹).getMsbD 1))))
            (true_and
              ((!(11#6 + ~~~BitVec.signExtend 6 x✝¹).getLsbD 5 == (11#6 + ~~~BitVec.signExtend 6 x✝¹).getMsbD 1) =
                true)) : (True ∧ (10#6 - BitVec.signExtend 6 x✝¹).msb ≠ (10#6 - BitVec.signExtend 6 x✝¹).getMsbD 1) =
            ((!(11#6 + ~~~BitVec.signExtend 6 x✝¹).getLsbD 5 == (11#6 + ~~~BitVec.signExtend 6 x✝¹).getMsbD 1) = true))
        [Meta.isDefEq] [0.001512] ✅️ (True ∧
                (BitVec.signExtend (5 + 1) 10#5 - BitVec.signExtend (5 + 1) x✝¹).msb ≠
                  (BitVec.signExtend (5 + 1) 10#5 - BitVec.signExtend (5 + 1) x✝¹).getMsbD 1) =
              ((!(11#6 + ~~~BitVec.signExtend 6 x✝¹).getLsbD 5 == (11#6 + ~~~BitVec.signExtend 6 x✝¹).getMsbD 1) =
                true) =?= (True ∧ (10#6 - BitVec.signExtend 6 x✝¹).msb ≠ (10#6 - BitVec.signExtend 6 x✝¹).getMsbD 1) =
              ((!(11#6 + ~~~BitVec.signExtend 6 x✝¹).getLsbD 5 == (11#6 + ~~~BitVec.signExtend 6 x✝¹).getMsbD 1) = true)
          [Meta.isDefEq] [0.001493] ✅️ True ∧
                (BitVec.signExtend (5 + 1) 10#5 - BitVec.signExtend (5 + 1) x✝¹).msb ≠
                  (BitVec.signExtend (5 + 1) 10#5 - BitVec.signExtend (5 + 1) x✝¹).getMsbD
                    1 =?= True ∧ (10#6 - BitVec.signExtend 6 x✝¹).msb ≠ (10#6 - BitVec.signExtend 6 x✝¹).getMsbD 1
            [Meta.isDefEq] [0.001479] ✅️ (BitVec.signExtend (5 + 1) 10#5 - BitVec.signExtend (5 + 1) x✝¹).msb ≠
                  (BitVec.signExtend (5 + 1) 10#5 - BitVec.signExtend (5 + 1) x✝¹).getMsbD
                    1 =?= (10#6 - BitVec.signExtend 6 x✝¹).msb ≠ (10#6 - BitVec.signExtend 6 x✝¹).getMsbD 1
              [Meta.isDefEq.delta] [0.001465] ✅️ (BitVec.signExtend (5 + 1) 10#5 - BitVec.signExtend (5 + 1) x✝¹).msb ≠
                    (BitVec.signExtend (5 + 1) 10#5 - BitVec.signExtend (5 + 1) x✝¹).getMsbD
                      1 =?= (10#6 - BitVec.signExtend 6 x✝¹).msb ≠ (10#6 - BitVec.signExtend 6 x✝¹).getMsbD 1
                [Meta.isDefEq] [0.001412] ✅️ (BitVec.signExtend (5 + 1) 10#5 -
                        BitVec.signExtend (5 + 1) x✝¹).msb =?= (10#6 - BitVec.signExtend 6 x✝¹).msb
                  [Meta.isDefEq.delta] [0.001403] ✅️ (BitVec.signExtend (5 + 1) 10#5 -
                          BitVec.signExtend (5 + 1) x✝¹).msb =?= (10#6 - BitVec.signExtend 6 x✝¹).msb
                    [Meta.isDefEq] [0.001383] ✅️ BitVec.signExtend (5 + 1) 10#5 -
                          BitVec.signExtend (5 + 1) x✝¹ =?= 10#6 - BitVec.signExtend 6 x✝¹
                      [Meta.isDefEq] [0.001359] ✅️ instHSub.1 (BitVec.signExtend (5 + 1) 10#5)
                            (BitVec.signExtend (5 + 1) x✝¹) =?= instHSub.1 (10#6) (BitVec.signExtend 6 x✝¹)
                        [Meta.isDefEq] [0.001307] ✅️ Sub.sub (BitVec.signExtend (5 + 1) 10#5)
                              (BitVec.signExtend (5 + 1) x✝¹) =?= Sub.sub (10#6) (BitVec.signExtend 6 x✝¹)
                          [Meta.isDefEq] [0.001288] ✅️ BitVec.instSub.1 (BitVec.signExtend (5 + 1) 10#5)
                                (BitVec.signExtend (5 + 1) x✝¹) =?= BitVec.instSub.1 (10#6) (BitVec.signExtend 6 x✝¹)
                            [Meta.isDefEq] [0.001252] ✅️ (BitVec.signExtend (5 + 1) 10#5).sub
                                  (BitVec.signExtend (5 + 1) x✝¹) =?= (10#6).sub (BitVec.signExtend 6 x✝¹)
                              [Meta.isDefEq.delta] [0.001243] ✅️ (BitVec.signExtend (5 + 1) 10#5).sub
                                    (BitVec.signExtend (5 + 1) x✝¹) =?= (10#6).sub (BitVec.signExtend 6 x✝¹)
                                [Meta.isDefEq] [0.001150] ✅️ BitVec.signExtend (5 + 1) 10#5 =?= 10#6
                                  [Meta.isDefEq] [0.001135] ✅️ BitVec.ofInt (5 + 1) (10#5).toInt =?= 10#6
                                    [Meta.isDefEq] [0.001119] ✅️ ((10#5).toInt %
                                              Int.ofNat (2 ^ (5 + 1))).toNat#'⋯ =?= 10#6
                                      [Meta.isDefEq] [0.001101] ✅️ ((10#5).toInt %
                                                Int.ofNat (2 ^ (5 + 1))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 6) 10 }
                                        [Meta.isDefEq] [0.001089] ✅️ {
                                              toFin :=
                                                ⟨((10#5).toInt % Int.ofNat (2 ^ (5 + 1))).toNat,
                                                  ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 6) 10 }
                                          [Meta.isDefEq] [0.001041] ✅️ ⟨((10#5).toInt % Int.ofNat (2 ^ (5 + 1))).toNat,
                                                ⋯⟩ =?= Fin.ofNat' (2 ^ 6) 10
                                            [Meta.isDefEq] [0.001017] ✅️ ⟨((10#5).toInt %
                                                      Int.ofNat (2 ^ (5 + 1))).toNat,
                                                  ⋯⟩ =?= ⟨10 % 2 ^ 6, ⋯⟩
  [Meta.isDefEq] [0.001031] ✅️ ?h₃ =?= fun a =>
        congrArg (fun x => some (x✝ * x✝ + x))
          (Eq.trans (BitVec.sub_toAdd (10#5) x✝¹)
            (Eq.trans (congrArg (HAdd.hAdd 10#5) (BitVec.neg_eq_not_add x✝¹))
              (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (10#5) (~~~x✝¹) 1#5)))
    [Meta.isDefEq.assign] [0.001027] ✅️ ?h₃ := fun a =>
          congrArg (fun x => some (x✝ * x✝ + x))
            (Eq.trans (BitVec.sub_toAdd (10#5) x✝¹)
              (Eq.trans (congrArg (HAdd.hAdd 10#5) (BitVec.neg_eq_not_add x✝¹))
                (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (10#5) (~~~x✝¹) 1#5)))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 5
      x✝¹ x✝ : BitVec 5
      a✝ :
        ¬(if
                (!(11#6 + ~~~BitVec.signExtend 6 x✝¹).getLsbD 5 == (11#6 + ~~~BitVec.signExtend 6 x✝¹).getMsbD 1) =
                  true then
              none
            else
              if
                  ((x✝ * x✝).getLsbD 4 == (11#5 + ~~~x✝¹).getLsbD 4 &&
                      !(x✝ * x✝ + (11#5 + ~~~x✝¹)).getLsbD 4 == (x✝ * x✝).getLsbD 4) =
                    true then
                none
              else some (x✝ * x✝ + (11#5 + ~~~x✝¹))) ⊑
            some (x✝ * x✝ + (~~~x✝¹ + 1#5) + 10#5)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
