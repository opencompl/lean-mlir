⚠ [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
⚠ [878/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [881/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
⚠ [887/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
⚠ [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhxorhcmp_proof.lean:17:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhxorhcmp_proof.lean:11:8: error: (kernel) declaration has metavariables 'sext_xor_sub_thm'
[bv] [0.036626] Normalizing goal
  [Meta.synthInstance] [0.001497] ✅️ Decidable
        (some ((x✝ ^^^ BitVec.signExtend 64 x✝¹) - BitVec.signExtend 64 x✝¹) ⊑
          match some x✝¹ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some (0#64 - x✝)
          | some { toFin := ⟨0, ⋯⟩ } => some x✝)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 1
      e_1 : LLVM.IntW 64
      x✝¹ : BitVec 1
      x✝ : BitVec 64
      a✝ :
        ¬some ((x✝ ^^^ BitVec.signExtend 64 x✝¹) - BitVec.signExtend 64 x✝¹) ⊑
            match some x✝¹ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (0#64 - x✝)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 1
      e_1 : LLVM.IntW 64
      x✝¹ : BitVec 1
      x✝ : BitVec 64
      a✝ :
        ¬some ((x✝ ^^^ BitVec.signExtend 64 x✝¹) + (~~~BitVec.signExtend 64 x✝¹ + 1#64)) ⊑
            match some x✝¹ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (~~~x✝ + 1#64)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhxorhcmp_proof.lean:27:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhxorhcmp_proof.lean:21:8: error: (kernel) declaration has metavariables 'sext_xor_sub_1_thm'
[bv] [0.057472] Normalizing goal
  [Meta.synthInstance] [0.002291] ✅️ Decidable
        (some ((BitVec.signExtend 64 x✝ ^^^ x✝¹) - BitVec.signExtend 64 x✝) ⊑
          match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some (0#64 - x✝¹)
          | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      e_1 : LLVM.IntW 1
      x✝¹ : BitVec 64
      x✝ : BitVec 1
      a✝ :
        ¬some ((BitVec.signExtend 64 x✝ ^^^ x✝¹) - BitVec.signExtend 64 x✝) ⊑
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (0#64 - x✝¹)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
      ⊢ False
  [Meta.isDefEq] [0.001089] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (0#64 - x✝¹)
      | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
  [Meta.isDefEq] [0.001189] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (0#64 - x✝¹)
      | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
  [Meta.isDefEq] [0.001195] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (0#64 - x✝¹)
      | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
  [Meta.isDefEq] [0.001066] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (~~~x✝¹ + 1#64)
      | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
  [Meta.isDefEq] [0.001039] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (~~~x✝¹ + 1#64)
      | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
  [Meta.isDefEq] [0.001033] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (~~~x✝¹ + 1#64)
      | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
  [Meta.isDefEq] [0.001055] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (~~~x✝¹ + 1#64)
      | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
  [Meta.isDefEq] [0.001204] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (~~~x✝¹ + 1#64)
      | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
  [Meta.isDefEq] [0.001128] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (~~~x✝¹ + 1#64)
      | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      e_1 : LLVM.IntW 1
      x✝¹ : BitVec 64
      x✝ : BitVec 1
      a✝ :
        ¬some ((BitVec.signExtend 64 x✝ ^^^ x✝¹) + (~~~BitVec.signExtend 64 x✝ + 1#64)) ⊑
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (~~~x✝¹ + 1#64)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
      ⊢ False
  [Meta.isDefEq] [0.001019] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (~~~x✝¹ + 1#64)
      | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
  [Meta.isDefEq] [0.001195] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (~~~x✝¹ + 1#64)
      | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
  [Meta.isDefEq] [0.001185] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (~~~x✝¹ + 1#64)
      | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
  [Meta.isDefEq] [0.001040] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (~~~x✝¹ + 1#64)
      | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
  [Meta.isDefEq] [0.001183] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (~~~x✝¹ + 1#64)
      | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
  [Meta.isDefEq] [0.001171] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (~~~x✝¹ + 1#64)
      | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhxorhcmp_proof.lean:37:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhxorhcmp_proof.lean:31:8: error: (kernel) declaration has metavariables 'sext_xor_sub_2_thm'
[bv] [0.059014] Normalizing goal
  [Meta.synthInstance] [0.002404] ✅️ Decidable
        (some (BitVec.signExtend 64 x✝ - (x✝¹ ^^^ BitVec.signExtend 64 x✝)) ⊑
          match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (0#64 - x✝¹))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      e_1 : LLVM.IntW 1
      x✝¹ : BitVec 64
      x✝ : BitVec 1
      a✝ :
        ¬some (BitVec.signExtend 64 x✝ - (x✝¹ ^^^ BitVec.signExtend 64 x✝)) ⊑
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (0#64 - x✝¹)
      ⊢ False
  [Meta.isDefEq] [0.001173] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (0#64 - x✝¹)
  [Meta.isDefEq] [0.001241] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (0#64 - x✝¹)
  [Meta.isDefEq] [0.001229] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (0#64 - x✝¹)
  [Meta.isDefEq] [0.001137] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (~~~x✝¹ + 1#64)
  [Meta.isDefEq] [0.001243] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (~~~x✝¹ + 1#64)
  [Meta.isDefEq] [0.001218] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (~~~x✝¹ + 1#64)
  [Meta.isDefEq] [0.001068] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (~~~x✝¹ + 1#64)
  [Meta.isDefEq] [0.001153] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (~~~x✝¹ + 1#64)
  [Meta.isDefEq] [0.001134] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (~~~x✝¹ + 1#64)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      e_1 : LLVM.IntW 1
      x✝¹ : BitVec 64
      x✝ : BitVec 1
      a✝ :
        ¬some (BitVec.signExtend 64 x✝ + (~~~(x✝¹ ^^^ BitVec.signExtend 64 x✝) + 1#64)) ⊑
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (~~~x✝¹ + 1#64)
      ⊢ False
  [Meta.isDefEq] [0.001062] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (~~~x✝¹ + 1#64)
  [Meta.isDefEq] [0.001174] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (~~~x✝¹ + 1#64)
  [Meta.isDefEq] [0.001191] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (~~~x✝¹ + 1#64)
  [Meta.isDefEq] [0.001104] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (~~~x✝¹ + 1#64)
  [Meta.isDefEq] [0.001238] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (~~~x✝¹ + 1#64)
  [Meta.isDefEq] [0.001244] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
      | some { toFin := ⟨0, ⋯⟩ } => some (~~~x✝¹ + 1#64)
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhxorhcmp_proof.lean:47:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhxorhcmp_proof.lean:41:8: error: (kernel) declaration has metavariables 'sext_xor_sub_3_thm'
[bv] [0.041533] Normalizing goal
  [Meta.synthInstance] [0.001818] ✅️ Decidable
        (some (BitVec.signExtend 64 x✝ - (BitVec.signExtend 64 x✝ ^^^ x✝¹)) ⊑
          match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some (0#64 - x✝¹))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      e_1 : LLVM.IntW 1
      x✝¹ : BitVec 64
      x✝ : BitVec 1
      a✝ :
        ¬some (BitVec.signExtend 64 x✝ - (BitVec.signExtend 64 x✝ ^^^ x✝¹)) ⊑
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (0#64 - x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      e_1 : LLVM.IntW 1
      x✝¹ : BitVec 64
      x✝ : BitVec 1
      a✝ :
        ¬some (BitVec.signExtend 64 x✝ + (~~~(BitVec.signExtend 64 x✝ ^^^ x✝¹) + 1#64)) ⊑
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some (~~~x✝¹ + 1#64)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 88.411560ms, solving context: 0.000000ms
LeanSAT proved the goal after 82.714479ms: rewriting 19.348430ms, bitblasting 0.000000ms, SAT solving 58.617269ms, LRAT trimming 0.000000ms, LRAT checking 3.059530ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhxorhcmp_proof.lean:67:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhxorhcmp_proof.lean:61:8: error: (kernel) declaration has metavariables 'sext_diff_i1_xor_sub_thm'
[bv] [0.030230] Normalizing goal
  [Meta.synthInstance] [0.001378] ✅️ Decidable
        (some (BitVec.signExtend 64 x✝ - BitVec.signExtend 64 x✝¹) ⊑
          if
              True ∧
                (BitVec.zeroExtend 64 x✝¹).msb = (BitVec.signExtend 64 x✝).msb ∧
                  (BitVec.zeroExtend 64 x✝¹ + BitVec.signExtend 64 x✝).msb ≠ (BitVec.zeroExtend 64 x✝¹).msb then
            none
          else some (BitVec.zeroExtend 64 x✝¹ + BitVec.signExtend 64 x✝))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 1
      x✝¹ x✝ : BitVec 1
      a✝ :
        ¬some (BitVec.signExtend 64 x✝ - BitVec.signExtend 64 x✝¹) ⊑
            if
                True ∧
                  (BitVec.zeroExtend 64 x✝¹).msb = (BitVec.signExtend 64 x✝).msb ∧
                    (BitVec.zeroExtend 64 x✝¹ + BitVec.signExtend 64 x✝).msb ≠ (BitVec.zeroExtend 64 x✝¹).msb then
              none
            else some (BitVec.zeroExtend 64 x✝¹ + BitVec.signExtend 64 x✝)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 1
      x✝¹ x✝ : BitVec 1
      a✝ :
        ¬some (BitVec.signExtend 64 x✝ + (~~~BitVec.signExtend 64 x✝¹ + 1#64)) ⊑
            if
                ((BitVec.zeroExtend 64 x✝¹).getLsbD 63 == (BitVec.signExtend 64 x✝).getLsbD 63 &&
                    !(BitVec.zeroExtend 64 x✝¹ + BitVec.signExtend 64 x✝).getLsbD 63 ==
                        (BitVec.zeroExtend 64 x✝¹).getLsbD 63) =
                  true then
              none
            else some (BitVec.zeroExtend 64 x✝¹ + BitVec.signExtend 64 x✝)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhxorhcmp_proof.lean:77:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhxorhcmp_proof.lean:71:8: error: (kernel) declaration has metavariables 'sext_diff_i1_xor_sub_1_thm'
[bv] [0.034606] Normalizing goal
  [Meta.synthInstance] [0.001242] ✅️ Decidable
        (some (BitVec.signExtend 64 x✝ - BitVec.signExtend 64 x✝¹) ⊑
          if
              True ∧
                (BitVec.zeroExtend 64 x✝¹).msb = (BitVec.signExtend 64 x✝).msb ∧
                  (BitVec.zeroExtend 64 x✝¹ + BitVec.signExtend 64 x✝).msb ≠ (BitVec.zeroExtend 64 x✝¹).msb then
            none
          else some (BitVec.zeroExtend 64 x✝¹ + BitVec.signExtend 64 x✝))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 1
      x✝¹ x✝ : BitVec 1
      a✝ :
        ¬some (BitVec.signExtend 64 x✝ - BitVec.signExtend 64 x✝¹) ⊑
            if
                True ∧
                  (BitVec.zeroExtend 64 x✝¹).msb = (BitVec.signExtend 64 x✝).msb ∧
                    (BitVec.zeroExtend 64 x✝¹ + BitVec.signExtend 64 x✝).msb ≠ (BitVec.zeroExtend 64 x✝¹).msb then
              none
            else some (BitVec.zeroExtend 64 x✝¹ + BitVec.signExtend 64 x✝)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 1
      x✝¹ x✝ : BitVec 1
      a✝ :
        ¬some (BitVec.signExtend 64 x✝ + (~~~BitVec.signExtend 64 x✝¹ + 1#64)) ⊑
            if
                ((BitVec.zeroExtend 64 x✝¹).getLsbD 63 == (BitVec.signExtend 64 x✝).getLsbD 63 &&
                    !(BitVec.zeroExtend 64 x✝¹ + BitVec.signExtend 64 x✝).getLsbD 63 ==
                        (BitVec.zeroExtend 64 x✝¹).getLsbD 63) =
                  true then
              none
            else some (BitVec.zeroExtend 64 x✝¹ + BitVec.signExtend 64 x✝)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhxorhcmp_proof.lean:88:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhxorhcmp_proof.lean:81:8: error: (kernel) declaration has metavariables 'sext_multi_uses_thm'
[bv] [0.042335] Normalizing goal
  [Meta.synthInstance] [0.001604] ✅️ Decidable
        (some (x✝ * BitVec.signExtend 64 x✝¹ + ((x✝² ^^^ BitVec.signExtend 64 x✝¹) - BitVec.signExtend 64 x✝¹)) ⊑
          match some x✝¹ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some (0#64 - (x✝ + x✝²))
          | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      e_1 : LLVM.IntW 1
      e_2 : LLVM.IntW 64
      x✝² : BitVec 64
      x✝¹ : BitVec 1
      x✝ : BitVec 64
      a✝ :
        ¬some (x✝ * BitVec.signExtend 64 x✝¹ + ((x✝² ^^^ BitVec.signExtend 64 x✝¹) - BitVec.signExtend 64 x✝¹)) ⊑
            match some x✝¹ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (0#64 - (x✝ + x✝²))
            | some { toFin := ⟨0, ⋯⟩ } => some x✝²
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      e_1 : LLVM.IntW 1
      e_2 : LLVM.IntW 64
      x✝² : BitVec 64
      x✝¹ : BitVec 1
      x✝ : BitVec 64
      a✝ :
        ¬some
              (x✝ * BitVec.signExtend 64 x✝¹ +
                ((x✝² ^^^ BitVec.signExtend 64 x✝¹) + (~~~BitVec.signExtend 64 x✝¹ + 1#64))) ⊑
            match some x✝¹ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (~~~(x✝ + x✝²) + 1#64)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝²
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhxorhcmp_proof.lean:99:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhxorhcmp_proof.lean:92:8: error: (kernel) declaration has metavariables 'absdiff_thm'
[bv] [0.047350] Normalizing goal
  [Meta.synthInstance] [0.001412] ✅️ Decidable
        (some
            ((BitVec.signExtend 64 (BitVec.ofBool (x✝¹ >ᵤ x✝)) ^^^ x✝ - x✝¹) -
              BitVec.signExtend 64 (BitVec.ofBool (x✝¹ >ᵤ x✝))) ⊑
          match some (BitVec.ofBool (x✝¹ >ᵤ x✝)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some (0#64 - (x✝ - x✝¹))
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝ - x✝¹))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 64
      x✝¹ x✝ : BitVec 64
      a✝ :
        ¬some
              ((BitVec.signExtend 64 (BitVec.ofBool (x✝¹ >ᵤ x✝)) ^^^ x✝ - x✝¹) -
                BitVec.signExtend 64 (BitVec.ofBool (x✝¹ >ᵤ x✝))) ⊑
            match some (BitVec.ofBool (x✝¹ >ᵤ x✝)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (0#64 - (x✝ - x✝¹))
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝ - x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 64
      x✝¹ x✝ : BitVec 64
      a✝ :
        ¬some
              ((BitVec.signExtend 64 (if (x✝¹ >ᵤ x✝) = true then 1#1 else 0#1) ^^^ x✝ + (~~~x✝¹ + 1#64)) +
                (~~~BitVec.signExtend 64 (if (x✝¹ >ᵤ x✝) = true then 1#1 else 0#1) + 1#64)) ⊑
            match some (if (x✝¹ >ᵤ x✝) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (~~~(x✝ + (~~~x✝¹ + 1#64)) + 1#64)
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝ + (~~~x✝¹ + 1#64))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhxorhcmp_proof.lean:110:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhxorhcmp_proof.lean:103:8: error: (kernel) declaration has metavariables 'absdiff1_thm'
[bv] [0.072808] Normalizing goal
  [Meta.synthInstance] [0.002404] ✅️ Decidable
        (some
            ((x✝ - x✝¹ ^^^ BitVec.signExtend 64 (BitVec.ofBool (x✝¹ >ᵤ x✝))) -
              BitVec.signExtend 64 (BitVec.ofBool (x✝¹ >ᵤ x✝))) ⊑
          match some (BitVec.ofBool (x✝¹ >ᵤ x✝)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some (0#64 - (x✝ - x✝¹))
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝ - x✝¹))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 64
      x✝¹ x✝ : BitVec 64
      a✝ :
        ¬some
              ((x✝ - x✝¹ ^^^ BitVec.signExtend 64 (BitVec.ofBool (x✝¹ >ᵤ x✝))) -
                BitVec.signExtend 64 (BitVec.ofBool (x✝¹ >ᵤ x✝))) ⊑
            match some (BitVec.ofBool (x✝¹ >ᵤ x✝)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (0#64 - (x✝ - x✝¹))
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝ - x✝¹)
      ⊢ False
  [Meta.isDefEq] [0.001158] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝¹ >ᵤ x✝) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (0#64 - (x✝ - x✝¹))
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝ - x✝¹)
  [Meta.isDefEq] [0.001261] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝¹ >ᵤ x✝) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (0#64 - (x✝ - x✝¹))
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝ - x✝¹)
  [Meta.isDefEq] [0.001254] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝¹ >ᵤ x✝) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (0#64 - (x✝ - x✝¹))
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝ - x✝¹)
  [Meta.isDefEq] [0.001184] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝¹ >ᵤ x✝) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (~~~(x✝ + (~~~x✝¹ + 1#64)) + 1#64)
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝ + (~~~x✝¹ + 1#64))
  [Meta.isDefEq] [0.001267] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝¹ >ᵤ x✝) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (~~~(x✝ + (~~~x✝¹ + 1#64)) + 1#64)
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝ + (~~~x✝¹ + 1#64))
  [Meta.isDefEq] [0.001263] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝¹ >ᵤ x✝) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (~~~(x✝ + (~~~x✝¹ + 1#64)) + 1#64)
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝ + (~~~x✝¹ + 1#64))
  [Meta.isDefEq] [0.001154] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝¹ >ᵤ x✝) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (~~~(x✝ + (~~~x✝¹ + 1#64)) + 1#64)
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝ + (~~~x✝¹ + 1#64))
  [Meta.isDefEq] [0.001259] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝¹ >ᵤ x✝) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (~~~(x✝ + (~~~x✝¹ + 1#64)) + 1#64)
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝ + (~~~x✝¹ + 1#64))
  [Meta.isDefEq] [0.001331] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝¹ >ᵤ x✝) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (~~~(x✝ + (~~~x✝¹ + 1#64)) + 1#64)
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝ + (~~~x✝¹ + 1#64))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 64
      x✝¹ x✝ : BitVec 64
      a✝ :
        ¬some
              ((x✝ + (~~~x✝¹ + 1#64) ^^^ BitVec.signExtend 64 (if (x✝¹ >ᵤ x✝) = true then 1#1 else 0#1)) +
                (~~~BitVec.signExtend 64 (if (x✝¹ >ᵤ x✝) = true then 1#1 else 0#1) + 1#64)) ⊑
            match some (if (x✝¹ >ᵤ x✝) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (~~~(x✝ + (~~~x✝¹ + 1#64)) + 1#64)
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝ + (~~~x✝¹ + 1#64))
      ⊢ False
  [Meta.isDefEq] [0.001007] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝¹ >ᵤ x✝) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (~~~(x✝ + (~~~x✝¹ + 1#64)) + 1#64)
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝ + (~~~x✝¹ + 1#64))
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhxorhcmp_proof.lean:121:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gsubhxorhcmp_proof.lean:114:8: error: (kernel) declaration has metavariables 'absdiff2_thm'
[bv] [0.088298] Normalizing goal
  [Meta.synthInstance] [0.002333] ✅️ Decidable
        (some
            ((x✝ - x✝¹ ^^^ BitVec.signExtend 64 (BitVec.ofBool (x✝¹ >ᵤ x✝))) -
              BitVec.signExtend 64 (BitVec.ofBool (x✝¹ >ᵤ x✝))) ⊑
          match some (BitVec.ofBool (x✝¹ >ᵤ x✝)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some (0#64 - (x✝ - x✝¹))
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝ - x✝¹))
    [Meta.check] [0.001011] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (some
            ((x✝ - x✝¹ ^^^ BitVec.signExtend 64 (BitVec.ofBool (x✝¹ >ᵤ x✝))) -
              BitVec.signExtend 64 (BitVec.ofBool (x✝¹ >ᵤ x✝))))
          (match some (BitVec.ofBool (x✝¹ >ᵤ x✝)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some (0#64 - (x✝ - x✝¹))
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝ - x✝¹))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 64
      x✝¹ x✝ : BitVec 64
      a✝ :
        ¬some
              ((x✝ - x✝¹ ^^^ BitVec.signExtend 64 (BitVec.ofBool (x✝¹ >ᵤ x✝))) -
                BitVec.signExtend 64 (BitVec.ofBool (x✝¹ >ᵤ x✝))) ⊑
            match some (BitVec.ofBool (x✝¹ >ᵤ x✝)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (0#64 - (x✝ - x✝¹))
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝ - x✝¹)
      ⊢ False
  [Meta.isDefEq] [0.001164] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝¹ >ᵤ x✝) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (0#64 - (x✝ - x✝¹))
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝ - x✝¹)
  [Meta.isDefEq] [0.001299] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝¹ >ᵤ x✝) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (0#64 - (x✝ - x✝¹))
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝ - x✝¹)
  [Meta.isDefEq] [0.001246] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝¹ >ᵤ x✝) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (0#64 - (x✝ - x✝¹))
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝ - x✝¹)
  [Meta.appBuilder] [0.003200] ✅️ f: HAdd.hAdd, xs: [~~~(x✝ + (~~~x✝¹ + 1#64)), 1#64]
    [Meta.synthInstance] [0.003093] ✅️ HAdd (BitVec 64) (BitVec 64) (BitVec 64)
      [Meta.synthInstance] [0.002597] ✅️ apply @instHAdd to HAdd (BitVec 64) (BitVec 64) (BitVec 64)
        [Meta.synthInstance.tryResolve] [0.002510] ✅️ HAdd (BitVec 64) (BitVec 64)
              (BitVec 64) ≟ HAdd (BitVec 64) (BitVec 64) (BitVec 64)
          [Meta.isDefEq] [0.002419] ✅️ HAdd (BitVec 64) (BitVec 64) ?m.87018 =?= HAdd ?m.87021 ?m.87021 ?m.87021
            [Meta.isDefEq] [0.002290] ✅️ ?m.87018 =?= BitVec 64
              [Meta.isDefEq.assign] [0.002284] ✅️ ?m.87018 := BitVec 64
                [Meta.isDefEq.assign.checkTypes] [0.002279] ✅️ (?m.87018 : outParam
                      (Type ?u.87013)) := (BitVec 64 : Type)
                  [Meta.isDefEq] [0.002269] ✅️ outParam (Type ?u.87013) =?= Type
  [Meta.isDefEq] [0.001119] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝¹ >ᵤ x✝) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (~~~(x✝ + (~~~x✝¹ + 1#64)) + 1#64)
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝ + (~~~x✝¹ + 1#64))
  [Meta.isDefEq] [0.001307] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝¹ >ᵤ x✝) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (~~~(x✝ + (~~~x✝¹ + 1#64)) + 1#64)
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝ + (~~~x✝¹ + 1#64))
  [Meta.isDefEq] [0.001242] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝¹ >ᵤ x✝) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (~~~(x✝ + (~~~x✝¹ + 1#64)) + 1#64)
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝ + (~~~x✝¹ + 1#64))
  [Meta.isDefEq] [0.001143] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝¹ >ᵤ x✝) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (~~~(x✝ + (~~~x✝¹ + 1#64)) + 1#64)
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝ + (~~~x✝¹ + 1#64))
  [Meta.isDefEq] [0.001283] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝¹ >ᵤ x✝) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (~~~(x✝ + (~~~x✝¹ + 1#64)) + 1#64)
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝ + (~~~x✝¹ + 1#64))
  [Meta.isDefEq] [0.001238] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝¹ >ᵤ x✝) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (~~~(x✝ + (~~~x✝¹ + 1#64)) + 1#64)
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝ + (~~~x✝¹ + 1#64))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 64
      x✝¹ x✝ : BitVec 64
      a✝ :
        ¬some
              ((x✝ + (~~~x✝¹ + 1#64) ^^^ BitVec.signExtend 64 (if (x✝¹ >ᵤ x✝) = true then 1#1 else 0#1)) +
                (~~~BitVec.signExtend 64 (if (x✝¹ >ᵤ x✝) = true then 1#1 else 0#1) + 1#64)) ⊑
            match some (if (x✝¹ >ᵤ x✝) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (~~~(x✝ + (~~~x✝¹ + 1#64)) + 1#64)
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝ + (~~~x✝¹ + 1#64))
      ⊢ False
  [Meta.isDefEq] [0.001157] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝¹ >ᵤ x✝) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (~~~(x✝ + (~~~x✝¹ + 1#64)) + 1#64)
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝ + (~~~x✝¹ + 1#64))
  [Meta.isDefEq] [0.001279] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝¹ >ᵤ x✝) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (~~~(x✝ + (~~~x✝¹ + 1#64)) + 1#64)
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝ + (~~~x✝¹ + 1#64))
  [Meta.isDefEq] [0.001230] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝¹ >ᵤ x✝) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (~~~(x✝ + (~~~x✝¹ + 1#64)) + 1#64)
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝ + (~~~x✝¹ + 1#64))
  [Meta.isDefEq] [0.001159] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝¹ >ᵤ x✝) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (~~~(x✝ + (~~~x✝¹ + 1#64)) + 1#64)
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝ + (~~~x✝¹ + 1#64))
  [Meta.isDefEq] [0.001269] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝¹ >ᵤ x✝) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (~~~(x✝ + (~~~x✝¹ + 1#64)) + 1#64)
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝ + (~~~x✝¹ + 1#64))
  [Meta.isDefEq] [0.001259] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some (if (x✝¹ >ᵤ x✝) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some (~~~(x✝ + (~~~x✝¹ + 1#64)) + 1#64)
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝ + (~~~x✝¹ + 1#64))
  [Meta.Tactic.bv] Pipeline reached a fixpoint
