‚ö† [875/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
‚ö† [879/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
‚ö† [882/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
‚ö† [887/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
‚ö† [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gadd4_proof.lean:18:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gadd4_proof.lean:11:8: error: (kernel) declaration has metavariables 'match_unsigned_thm'
[bv] [0.047151] Normalizing goal
  [Meta.synthInstance] [0.002051] ‚úÖÔ∏è Decidable
        ((if 299#64 = 0 then none
          else
            if 299#64 = 0 then none
            else if 64#64 = 0 then none else some (x‚úù % 299#64 + x‚úù / 299#64 % 64#64 * 299#64)) ‚äë
          if 19136#64 = 0 then none else some (x‚úù % 19136#64))
    [Meta.check] [0.001057] ‚úÖÔ∏è BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if 299#64 = 0 then none
          else
            if 299#64 = 0 then none else if 64#64 = 0 then none else some (x‚úù % 299#64 + x‚úù / 299#64 % 64#64 * 299#64))
          (if 19136#64 = 0 then none else some (x‚úù % 19136#64))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      x‚úù : BitVec 64
      a‚úù :
        ¬¨(if 299#64 = 0 then none
            else
              if 299#64 = 0 then none
              else if 64#64 = 0 then none else some (x‚úù % 299#64 + x‚úù / 299#64 % 64#64 * 299#64)) ‚äë
            if 19136#64 = 0 then none else some (x‚úù % 19136#64)
      ‚ä¢ False
  [Meta.isDefEq] [0.002446] ‚ùåÔ∏è ?a == ?a =?= 299#64 == 0#64
    [Meta.isDefEq.onFailure] [0.001964] ‚ùåÔ∏è ?a == ?a =?= 299#64 == 0#64
      [Meta.synthInstance] [0.001933] üí•Ô∏è BEq ?Œ±
        [Meta.synthInstance] [0.001816] new goal BEq ?Œ±
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      x‚úù : BitVec 64
      a‚úù : ¬¨some (x‚úù % 299#64 + x‚úù / 299#64 % 64#64 * 299#64) ‚äë some (x‚úù % 19136#64)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gadd4_proof.lean:29:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gadd4_proof.lean:22:8: error: (kernel) declaration has metavariables 'match_andAsRem_lshrAsDiv_shlAsMul_thm'
[bv] [0.017111] Normalizing goal
  [Meta.synthInstance] [0.001413] ‚úÖÔ∏è Decidable
        ((if 6#64 ‚â• ‚Üë64 then none
          else
            if 9#64 = 0 then none
            else if 6#64 ‚â• ‚Üë64 then none else some ((x‚úù &&& 63#64) + (x‚úù >>> 6#64 % 9#64) <<< 6#64)) ‚äë
          if 576#64 = 0 then none else some (x‚úù % 576#64))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      x‚úù : BitVec 64
      a‚úù :
        ¬¨(if 6#64 ‚â• ‚Üë64 then none
            else
              if 9#64 = 0 then none
              else if 6#64 ‚â• ‚Üë64 then none else some ((x‚úù &&& 63#64) + (x‚úù >>> 6#64 % 9#64) <<< 6#64)) ‚äë
            if 576#64 = 0 then none else some (x‚úù % 576#64)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      x‚úù : BitVec 64
      a‚úù : ¬¨some ((x‚úù &&& 63#64) + (x‚úù >>> 6 % 9#64) <<< 6) ‚äë some (x‚úù % 576#64)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gadd4_proof.lean:41:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gadd4_proof.lean:33:8: error: (kernel) declaration has metavariables 'match_signed_thm'
[bv] [0.172509] Normalizing goal
  [Meta.synthInstance] [0.001801] ‚úÖÔ∏è Decidable
        (((Option.map (fun div => x‚úù - div * 299#64)
                (if (299#64 == 0 || 64 != 1 && x‚úù == BitVec.intMin 64 && 299#64 == -1) = true then none
                else some (x‚úù.sdiv 299#64))).bind
            fun x =>
            if (299#64 == 0 || 64 != 1 && x‚úù == BitVec.intMin 64 && 299#64 == -1) = true then none
            else
              (Option.map (fun div => x‚úù.sdiv 299#64 - div * 64#64)
                    (if (64#64 == 0 || 64 != 1 && x‚úù.sdiv 299#64 == BitVec.intMin 64 && 64#64 == -1) = true then none
                    else some ((x‚úù.sdiv 299#64).sdiv 64#64))).bind
                fun x_1 =>
                if (19136#64 == 0 || 64 != 1 && x‚úù == BitVec.intMin 64 && 19136#64 == -1) = true then none
                else
                  (Option.map (fun div => x‚úù.sdiv 19136#64 - div * 9#64)
                        (if (9#64 == 0 || 64 != 1 && x‚úù.sdiv 19136#64 == BitVec.intMin 64 && 9#64 == -1) = true then
                          none
                        else some ((x‚úù.sdiv 19136#64).sdiv 9#64))).bind
                    fun x_2 => some (x + x_1 * 299#64 + x_2 * 19136#64)) ‚äë
          Option.map (fun div => x‚úù - div * 172224#64)
            (if (172224#64 == 0 || 64 != 1 && x‚úù == BitVec.intMin 64 && 172224#64 == -1) = true then none
            else some (x‚úù.sdiv 172224#64)))
    [Meta.check] [0.001185] ‚úÖÔ∏è BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          ((Option.map (fun div => x‚úù - div * 299#64)
                (if (299#64 == 0 || 64 != 1 && x‚úù == BitVec.intMin 64 && 299#64 == -1) = true then none
                else some (x‚úù.sdiv 299#64))).bind
            fun x =>
            if (299#64 == 0 || 64 != 1 && x‚úù == BitVec.intMin 64 && 299#64 == -1) = true then none
            else
              (Option.map (fun div => x‚úù.sdiv 299#64 - div * 64#64)
                    (if (64#64 == 0 || 64 != 1 && x‚úù.sdiv 299#64 == BitVec.intMin 64 && 64#64 == -1) = true then none
                    else some ((x‚úù.sdiv 299#64).sdiv 64#64))).bind
                fun x_1 =>
                if (19136#64 == 0 || 64 != 1 && x‚úù == BitVec.intMin 64 && 19136#64 == -1) = true then none
                else
                  (Option.map (fun div => x‚úù.sdiv 19136#64 - div * 9#64)
                        (if (9#64 == 0 || 64 != 1 && x‚úù.sdiv 19136#64 == BitVec.intMin 64 && 9#64 == -1) = true then
                          none
                        else some ((x‚úù.sdiv 19136#64).sdiv 9#64))).bind
                    fun x_2 => some (x + x_1 * 299#64 + x_2 * 19136#64))
          (Option.map (fun div => x‚úù - div * 172224#64)
            (if (172224#64 == 0 || 64 != 1 && x‚úù == BitVec.intMin 64 && 172224#64 == -1) = true then none
            else some (x‚úù.sdiv 172224#64)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      x‚úù : BitVec 64
      a‚úù :
        ¬¨((Option.map (fun div => x‚úù - div * 299#64)
                  (if (299#64 == 0 || 64 != 1 && x‚úù == BitVec.intMin 64 && 299#64 == -1) = true then none
                  else some (x‚úù.sdiv 299#64))).bind
              fun x =>
              if (299#64 == 0 || 64 != 1 && x‚úù == BitVec.intMin 64 && 299#64 == -1) = true then none
              else
                (Option.map (fun div => x‚úù.sdiv 299#64 - div * 64#64)
                      (if (64#64 == 0 || 64 != 1 && x‚úù.sdiv 299#64 == BitVec.intMin 64 && 64#64 == -1) = true then none
                      else some ((x‚úù.sdiv 299#64).sdiv 64#64))).bind
                  fun x_1 =>
                  if (19136#64 == 0 || 64 != 1 && x‚úù == BitVec.intMin 64 && 19136#64 == -1) = true then none
                  else
                    (Option.map (fun div => x‚úù.sdiv 19136#64 - div * 9#64)
                          (if (9#64 == 0 || 64 != 1 && x‚úù.sdiv 19136#64 == BitVec.intMin 64 && 9#64 == -1) = true then
                            none
                          else some ((x‚úù.sdiv 19136#64).sdiv 9#64))).bind
                      fun x_2 => some (x + x_1 * 299#64 + x_2 * 19136#64)) ‚äë
            Option.map (fun div => x‚úù - div * 172224#64)
              (if (172224#64 == 0 || 64 != 1 && x‚úù == BitVec.intMin 64 && 172224#64 == -1) = true then none
              else some (x‚úù.sdiv 172224#64))
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      x‚úù : BitVec 64
      a‚úù :
        ¬¨((Option.map (fun div => x‚úù + (~~~(div * 299#64) + 1#64))
                  (some (if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64))).bind
              fun a =>
              (Option.map
                    (fun div =>
                      (if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) +
                        (~~~(div * 64#64) + 1#64))
                    (some
                      (if
                          (if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64).getLsbD
                              63 =
                            true then
                        ~~~(((~~~if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) +
                                1#64) /
                              64#64) +
                          1#64
                      else
                        (if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) /
                          64#64))).bind
                fun a_1 =>
                (Option.map
                      (fun div =>
                        (if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 19136#64) + 1#64 else x‚úù / 19136#64) +
                          (~~~(div * 9#64) + 1#64))
                      (some
                        (if
                            (if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 19136#64) + 1#64
                                  else x‚úù / 19136#64).getLsbD
                                63 =
                              true then
                          ~~~(((~~~if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 19136#64) + 1#64
                                    else x‚úù / 19136#64) +
                                  1#64) /
                                9#64) +
                            1#64
                        else
                          (if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 19136#64) + 1#64 else x‚úù / 19136#64) /
                            9#64))).bind
                  fun a_2 => some (a + a_1 * 299#64 + a_2 * 19136#64)) ‚äë
            Option.map (fun div => x‚úù + (~~~(div * 172224#64) + 1#64))
              (some (if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 172224#64) + 1#64 else x‚úù / 172224#64))
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gadd4_proof.lean:54:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gadd4_proof.lean:45:8: error: (kernel) declaration has metavariables 'not_match_inconsistent_signs_thm'
[bv] [0.089148] Normalizing goal
  [Meta.synthInstance] [0.002517] ‚úÖÔ∏è Decidable
        ((if 299#64 = 0 then none
          else
            if (299#64 == 0 || 64 != 1 && x‚úù == BitVec.intMin 64 && 299#64 == -1) = true then none
            else if 64#64 = 0 then none else some (x‚úù % 299#64 + x‚úù.sdiv 299#64 % 64#64 * 299#64)) ‚äë
          if 299#64 = 0 then none
          else
            if (299#64 == 0 || 64 != 1 && x‚úù == BitVec.intMin 64 && 299#64 == -1) = true then none
            else
              if
                  True ‚àß
                    (BitVec.signExtend (2 * 64) (x‚úù.sdiv 299#64 &&& 63#64) * BitVec.signExtend (2 * 64) 299#64 <
                        BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ‚à®
                      BitVec.signExtend (2 * 64) (x‚úù.sdiv 299#64 &&& 63#64) * BitVec.signExtend (2 * 64) 299#64 ‚â•
                        BitVec.twoPow (2 * 64) (64 - 1)) then
                none
              else
                if
                    True ‚àß
                      BitVec.zeroExtend (2 * 64) (x‚úù.sdiv 299#64 &&& 63#64) * BitVec.zeroExtend (2 * 64) 299#64 ‚â•
                        BitVec.twoPow (2 * 64) (64 - 1) <<< 1 then
                  none
                else
                  if
                      True ‚àß
                        (x‚úù % 299#64).msb = ((x‚úù.sdiv 299#64 &&& 63#64) * 299#64).msb ‚àß
                          (x‚úù % 299#64 + (x‚úù.sdiv 299#64 &&& 63#64) * 299#64).msb ‚â† (x‚úù % 299#64).msb then
                    none
                  else
                    if
                        True ‚àß
                          (x‚úù % 299#64 + (x‚úù.sdiv 299#64 &&& 63#64) * 299#64 < x‚úù % 299#64 ‚à®
                            x‚úù % 299#64 + (x‚úù.sdiv 299#64 &&& 63#64) * 299#64 <
                              (x‚úù.sdiv 299#64 &&& 63#64) * 299#64) then
                      none
                    else some (x‚úù % 299#64 + (x‚úù.sdiv 299#64 &&& 63#64) * 299#64))
    [Meta.check] [0.001683] ‚úÖÔ∏è BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if 299#64 = 0 then none
          else
            if (299#64 == 0 || 64 != 1 && x‚úù == BitVec.intMin 64 && 299#64 == -1) = true then none
            else if 64#64 = 0 then none else some (x‚úù % 299#64 + x‚úù.sdiv 299#64 % 64#64 * 299#64))
          (if 299#64 = 0 then none
          else
            if (299#64 == 0 || 64 != 1 && x‚úù == BitVec.intMin 64 && 299#64 == -1) = true then none
            else
              if
                  True ‚àß
                    (BitVec.signExtend (2 * 64) (x‚úù.sdiv 299#64 &&& 63#64) * BitVec.signExtend (2 * 64) 299#64 <
                        BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ‚à®
                      BitVec.signExtend (2 * 64) (x‚úù.sdiv 299#64 &&& 63#64) * BitVec.signExtend (2 * 64) 299#64 ‚â•
                        BitVec.twoPow (2 * 64) (64 - 1)) then
                none
              else
                if
                    True ‚àß
                      BitVec.zeroExtend (2 * 64) (x‚úù.sdiv 299#64 &&& 63#64) * BitVec.zeroExtend (2 * 64) 299#64 ‚â•
                        BitVec.twoPow (2 * 64) (64 - 1) <<< 1 then
                  none
                else
                  if
                      True ‚àß
                        (x‚úù % 299#64).msb = ((x‚úù.sdiv 299#64 &&& 63#64) * 299#64).msb ‚àß
                          (x‚úù % 299#64 + (x‚úù.sdiv 299#64 &&& 63#64) * 299#64).msb ‚â† (x‚úù % 299#64).msb then
                    none
                  else
                    if
                        True ‚àß
                          (x‚úù % 299#64 + (x‚úù.sdiv 299#64 &&& 63#64) * 299#64 < x‚úù % 299#64 ‚à®
                            x‚úù % 299#64 + (x‚úù.sdiv 299#64 &&& 63#64) * 299#64 <
                              (x‚úù.sdiv 299#64 &&& 63#64) * 299#64) then
                      none
                    else some (x‚úù % 299#64 + (x‚úù.sdiv 299#64 &&& 63#64) * 299#64))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      x‚úù : BitVec 64
      a‚úù :
        ¬¨(if 299#64 = 0 then none
            else
              if (299#64 == 0 || 64 != 1 && x‚úù == BitVec.intMin 64 && 299#64 == -1) = true then none
              else if 64#64 = 0 then none else some (x‚úù % 299#64 + x‚úù.sdiv 299#64 % 64#64 * 299#64)) ‚äë
            if 299#64 = 0 then none
            else
              if (299#64 == 0 || 64 != 1 && x‚úù == BitVec.intMin 64 && 299#64 == -1) = true then none
              else
                if
                    True ‚àß
                      (BitVec.signExtend (2 * 64) (x‚úù.sdiv 299#64 &&& 63#64) * BitVec.signExtend (2 * 64) 299#64 <
                          BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ‚à®
                        BitVec.signExtend (2 * 64) (x‚úù.sdiv 299#64 &&& 63#64) * BitVec.signExtend (2 * 64) 299#64 ‚â•
                          BitVec.twoPow (2 * 64) (64 - 1)) then
                  none
                else
                  if
                      True ‚àß
                        BitVec.zeroExtend (2 * 64) (x‚úù.sdiv 299#64 &&& 63#64) * BitVec.zeroExtend (2 * 64) 299#64 ‚â•
                          BitVec.twoPow (2 * 64) (64 - 1) <<< 1 then
                    none
                  else
                    if
                        True ‚àß
                          (x‚úù % 299#64).msb = ((x‚úù.sdiv 299#64 &&& 63#64) * 299#64).msb ‚àß
                            (x‚úù % 299#64 + (x‚úù.sdiv 299#64 &&& 63#64) * 299#64).msb ‚â† (x‚úù % 299#64).msb then
                      none
                    else
                      if
                          True ‚àß
                            (x‚úù % 299#64 + (x‚úù.sdiv 299#64 &&& 63#64) * 299#64 < x‚úù % 299#64 ‚à®
                              x‚úù % 299#64 + (x‚úù.sdiv 299#64 &&& 63#64) * 299#64 <
                                (x‚úù.sdiv 299#64 &&& 63#64) * 299#64) then
                        none
                      else some (x‚úù % 299#64 + (x‚úù.sdiv 299#64 &&& 63#64) * 299#64)
      ‚ä¢ False
  [Meta.isDefEq] [0.001859] ‚úÖÔ∏è ?h‚ÇÅ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Eq.trans
                    (congrArg
                      (fun x =>
                        BitVec.signExtend 128 (x &&& 63#64) * 299#128 < BitVec.signExtend 128 (BitVec.twoPow 64 63))
                      (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv x‚úù 299#64)
                        (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x‚úù))
                          (fun a =>
                            Eq.trans
                              (ite_cond_eq_false (-x‚úù / -299#64) (-(-x‚úù / 299#64))
                                (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 299#64))
                                  (eq_false' fun h => Bool.noConfusion h)))
                              (Eq.trans (congrArg (fun x => -(x / 299#64)) (BitVec.neg_eq_not_add x‚úù))
                                (BitVec.neg_eq_not_add ((~~~x‚úù + 1#64) / 299#64))))
                          fun a =>
                          ite_cond_eq_false (-(x‚úù / -299#64)) (x‚úù / 299#64)
                            (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 299#64))
                              (eq_false' fun h => Bool.noConfusion h)))))
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                      (BitVec.signExtend 128
                          ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                            63#64) *
                        299#128)
                      (BitVec.signExtend 128 (BitVec.twoPow 64 63)))))
                (Eq.trans
                  (Eq.trans
                    (congrArg (fun x => BitVec.signExtend 128 (x &&& 63#64) * 299#128 ‚â• BitVec.twoPow 128 63)
                      (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv x‚úù 299#64)
                        (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x‚úù))
                          (fun a =>
                            Eq.trans
                              (ite_cond_eq_false (-x‚úù / -299#64) (-(-x‚úù / 299#64))
                                (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 299#64))
                                  (eq_false' fun h => Bool.noConfusion h)))
                              (Eq.trans (congrArg (fun x => -(x / 299#64)) (BitVec.neg_eq_not_add x‚úù))
                                (BitVec.neg_eq_not_add ((~~~x‚úù + 1#64) / 299#64))))
                          fun a =>
                          ite_cond_eq_false (-(x‚úù / -299#64)) (x‚úù / 299#64)
                            (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 299#64))
                              (eq_false' fun h => Bool.noConfusion h)))))
                    Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 128 63)
                      (BitVec.signExtend 128
                          ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                            63#64) *
                        299#128))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                            (BitVec.signExtend 128
                                ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                                  63#64) *
                              299#128)
                            (BitVec.twoPow 128 63)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 128 63 >·µ§
                            BitVec.signExtend 128
                                ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                                  63#64) *
                              299#128)
                          true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true
                          (BitVec.twoPow 128 63 >·µ§
                            BitVec.signExtend 128
                                ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                                  63#64) *
                              299#128)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 128 (BitVec.twoPow 64 63) >·µ§
                  BitVec.signExtend 128
                      ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&& 63#64) *
                    299#128)
                !BitVec.twoPow 128 63 >·µ§
                    BitVec.signExtend 128
                        ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                          63#64) *
                      299#128))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 128 (BitVec.twoPow 64 63) >·µ§
                    BitVec.signExtend 128
                        ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                          63#64) *
                      299#128)
                  !BitVec.twoPow 128 63 >·µ§
                      BitVec.signExtend 128
                          ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                            63#64) *
                        299#128)
                (congrArg
                  (fun x =>
                    !((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >·µ§
                            BitVec.signExtend 128
                                ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                                  63#64) *
                              299#128) &&
                        x))
                  (Bool.not_not
                    (BitVec.twoPow 128 63 >·µ§
                      BitVec.signExtend 128
                          ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                            63#64) *
                        299#128)))))))
        (true_and
          ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >·µ§
                    BitVec.signExtend 128
                        ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                          63#64) *
                      299#128) &&
                BitVec.twoPow 128 63 >·µ§
                  BitVec.signExtend 128
                      ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&& 63#64) *
                    299#128)) =
            true))
    [Meta.isDefEq.assign] [0.001857] ‚úÖÔ∏è ?h‚ÇÅ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Eq.trans
                      (congrArg
                        (fun x =>
                          BitVec.signExtend 128 (x &&& 63#64) * 299#128 < BitVec.signExtend 128 (BitVec.twoPow 64 63))
                        (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv x‚úù 299#64)
                          (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x‚úù))
                            (fun a =>
                              Eq.trans
                                (ite_cond_eq_false (-x‚úù / -299#64) (-(-x‚úù / 299#64))
                                  (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 299#64))
                                    (eq_false' fun h => Bool.noConfusion h)))
                                (Eq.trans (congrArg (fun x => -(x / 299#64)) (BitVec.neg_eq_not_add x‚úù))
                                  (BitVec.neg_eq_not_add ((~~~x‚úù + 1#64) / 299#64))))
                            fun a =>
                            ite_cond_eq_false (-(x‚úù / -299#64)) (x‚úù / 299#64)
                              (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 299#64))
                                (eq_false' fun h => Bool.noConfusion h)))))
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                        (BitVec.signExtend 128
                            ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                              63#64) *
                          299#128)
                        (BitVec.signExtend 128 (BitVec.twoPow 64 63)))))
                  (Eq.trans
                    (Eq.trans
                      (congrArg (fun x => BitVec.signExtend 128 (x &&& 63#64) * 299#128 ‚â• BitVec.twoPow 128 63)
                        (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv x‚úù 299#64)
                          (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x‚úù))
                            (fun a =>
                              Eq.trans
                                (ite_cond_eq_false (-x‚úù / -299#64) (-(-x‚úù / 299#64))
                                  (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 299#64))
                                    (eq_false' fun h => Bool.noConfusion h)))
                                (Eq.trans (congrArg (fun x => -(x / 299#64)) (BitVec.neg_eq_not_add x‚úù))
                                  (BitVec.neg_eq_not_add ((~~~x‚úù + 1#64) / 299#64))))
                            fun a =>
                            ite_cond_eq_false (-(x‚úù / -299#64)) (x‚úù / 299#64)
                              (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 299#64))
                                (eq_false' fun h => Bool.noConfusion h)))))
                      Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2)
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 128 63)
                        (BitVec.signExtend 128
                            ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                              63#64) *
                          299#128))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                              (BitVec.signExtend 128
                                  ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64
                                    else x‚úù / 299#64) &&&
                                    63#64) *
                                299#128)
                              (BitVec.twoPow 128 63)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 128 63 >·µ§
                              BitVec.signExtend 128
                                  ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64
                                    else x‚úù / 299#64) &&&
                                    63#64) *
                                299#128)
                            true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true
                            (BitVec.twoPow 128 63 >·µ§
                              BitVec.signExtend 128
                                  ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64
                                    else x‚úù / 299#64) &&&
                                    63#64) *
                                299#128)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 128 (BitVec.twoPow 64 63) >·µ§
                    BitVec.signExtend 128
                        ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                          63#64) *
                      299#128)
                  !BitVec.twoPow 128 63 >·µ§
                      BitVec.signExtend 128
                          ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                            63#64) *
                        299#128))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 128 (BitVec.twoPow 64 63) >·µ§
                      BitVec.signExtend 128
                          ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                            63#64) *
                        299#128)
                    !BitVec.twoPow 128 63 >·µ§
                        BitVec.signExtend 128
                            ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                              63#64) *
                          299#128)
                  (congrArg
                    (fun x =>
                      !((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >·µ§
                              BitVec.signExtend 128
                                  ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64
                                    else x‚úù / 299#64) &&&
                                    63#64) *
                                299#128) &&
                          x))
                    (Bool.not_not
                      (BitVec.twoPow 128 63 >·µ§
                        BitVec.signExtend 128
                            ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                              63#64) *
                          299#128)))))))
          (true_and
            ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >·µ§
                      BitVec.signExtend 128
                          ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                            63#64) *
                        299#128) &&
                  BitVec.twoPow 128 63 >·µ§
                    BitVec.signExtend 128
                        ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                          63#64) *
                      299#128)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.001810] ‚úÖÔ∏è (?h‚ÇÅ : (True ‚àß
              (BitVec.signExtend (2 * 64) (x‚úù.sdiv 299#64 &&& 63#64) * BitVec.signExtend (2 * 64) 299#64 <
                  BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ‚à®
                BitVec.signExtend (2 * 64) (x‚úù.sdiv 299#64 &&& 63#64) * BitVec.signExtend (2 * 64) 299#64 ‚â•
                  BitVec.twoPow (2 * 64) (64 - 1))) =
            ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >·µ§
                      BitVec.signExtend 128
                          ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                            63#64) *
                        299#128) &&
                  BitVec.twoPow 128 63 >·µ§
                    BitVec.signExtend 128
                        ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                          63#64) *
                      299#128)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Eq.trans
                        (congrArg
                          (fun x =>
                            BitVec.signExtend 128 (x &&& 63#64) * 299#128 < BitVec.signExtend 128 (BitVec.twoPow 64 63))
                          (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv x‚úù 299#64)
                            (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x‚úù))
                              (fun a =>
                                Eq.trans
                                  (ite_cond_eq_false (-x‚úù / -299#64) (-(-x‚úù / 299#64))
                                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 299#64))
                                      (eq_false' fun h => Bool.noConfusion h)))
                                  (Eq.trans (congrArg (fun x => -(x / 299#64)) (BitVec.neg_eq_not_add x‚úù))
                                    (BitVec.neg_eq_not_add ((~~~x‚úù + 1#64) / 299#64))))
                              fun a =>
                              ite_cond_eq_false (-(x‚úù / -299#64)) (x‚úù / 299#64)
                                (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 299#64))
                                  (eq_false' fun h => Bool.noConfusion h)))))
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                          (BitVec.signExtend 128
                              ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                                63#64) *
                            299#128)
                          (BitVec.signExtend 128 (BitVec.twoPow 64 63)))))
                    (Eq.trans
                      (Eq.trans
                        (congrArg (fun x => BitVec.signExtend 128 (x &&& 63#64) * 299#128 ‚â• BitVec.twoPow 128 63)
                          (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv x‚úù 299#64)
                            (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x‚úù))
                              (fun a =>
                                Eq.trans
                                  (ite_cond_eq_false (-x‚úù / -299#64) (-(-x‚úù / 299#64))
                                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 299#64))
                                      (eq_false' fun h => Bool.noConfusion h)))
                                  (Eq.trans (congrArg (fun x => -(x / 299#64)) (BitVec.neg_eq_not_add x‚úù))
                                    (BitVec.neg_eq_not_add ((~~~x‚úù + 1#64) / 299#64))))
                              fun a =>
                              ite_cond_eq_false (-(x‚úù / -299#64)) (x‚úù / 299#64)
                                (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 299#64))
                                  (eq_false' fun h => Bool.noConfusion h)))))
                        Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2)
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 128 63)
                          (BitVec.signExtend 128
                              ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                                63#64) *
                            299#128))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                                (BitVec.signExtend 128
                                    ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64
                                      else x‚úù / 299#64) &&&
                                      63#64) *
                                  299#128)
                                (BitVec.twoPow 128 63)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 128 63 >·µ§
                                BitVec.signExtend 128
                                    ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64
                                      else x‚úù / 299#64) &&&
                                      63#64) *
                                  299#128)
                              true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true
                              (BitVec.twoPow 128 63 >·µ§
                                BitVec.signExtend 128
                                    ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64
                                      else x‚úù / 299#64) &&&
                                      63#64) *
                                  299#128)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 128 (BitVec.twoPow 64 63) >·µ§
                      BitVec.signExtend 128
                          ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                            63#64) *
                        299#128)
                    !BitVec.twoPow 128 63 >·µ§
                        BitVec.signExtend 128
                            ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                              63#64) *
                          299#128))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 128 (BitVec.twoPow 64 63) >·µ§
                        BitVec.signExtend 128
                            ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                              63#64) *
                          299#128)
                      !BitVec.twoPow 128 63 >·µ§
                          BitVec.signExtend 128
                              ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                                63#64) *
                            299#128)
                    (congrArg
                      (fun x =>
                        !((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >·µ§
                                BitVec.signExtend 128
                                    ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64
                                      else x‚úù / 299#64) &&&
                                      63#64) *
                                  299#128) &&
                            x))
                      (Bool.not_not
                        (BitVec.twoPow 128 63 >·µ§
                          BitVec.signExtend 128
                              ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                                63#64) *
                            299#128)))))))
            (true_and
              ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >·µ§
                        BitVec.signExtend 128
                            ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                              63#64) *
                          299#128) &&
                    BitVec.twoPow 128 63 >·µ§
                      BitVec.signExtend 128
                          ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                            63#64) *
                        299#128)) =
                true)) : (True ‚àß
              (BitVec.signExtend 128 (x‚úù.sdiv 299#64 &&& 63#64) * 299#128 <
                  BitVec.signExtend 128 (BitVec.twoPow 64 63) ‚à®
                BitVec.signExtend 128 (x‚úù.sdiv 299#64 &&& 63#64) * 299#128 ‚â• BitVec.twoPow 128 63)) =
            ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >·µ§
                      BitVec.signExtend 128
                          ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                            63#64) *
                        299#128) &&
                  BitVec.twoPow 128 63 >·µ§
                    BitVec.signExtend 128
                        ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                          63#64) *
                      299#128)) =
              true))
        [Meta.isDefEq] [0.001807] ‚úÖÔ∏è (True ‚àß
                (BitVec.signExtend (2 * 64) (x‚úù.sdiv 299#64 &&& 63#64) * BitVec.signExtend (2 * 64) 299#64 <
                    BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ‚à®
                  BitVec.signExtend (2 * 64) (x‚úù.sdiv 299#64 &&& 63#64) * BitVec.signExtend (2 * 64) 299#64 ‚â•
                    BitVec.twoPow (2 * 64) (64 - 1))) =
              ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >·µ§
                        BitVec.signExtend 128
                            ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                              63#64) *
                          299#128) &&
                    BitVec.twoPow 128 63 >·µ§
                      BitVec.signExtend 128
                          ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                            63#64) *
                        299#128)) =
                true) =?= (True ‚àß
                (BitVec.signExtend 128 (x‚úù.sdiv 299#64 &&& 63#64) * 299#128 <
                    BitVec.signExtend 128 (BitVec.twoPow 64 63) ‚à®
                  BitVec.signExtend 128 (x‚úù.sdiv 299#64 &&& 63#64) * 299#128 ‚â• BitVec.twoPow 128 63)) =
              ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >·µ§
                        BitVec.signExtend 128
                            ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                              63#64) *
                          299#128) &&
                    BitVec.twoPow 128 63 >·µ§
                      BitVec.signExtend 128
                          ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                            63#64) *
                        299#128)) =
                true)
          [Meta.isDefEq] [0.001787] ‚úÖÔ∏è True ‚àß
                (BitVec.signExtend (2 * 64) (x‚úù.sdiv 299#64 &&& 63#64) * BitVec.signExtend (2 * 64) 299#64 <
                    BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ‚à®
                  BitVec.signExtend (2 * 64) (x‚úù.sdiv 299#64 &&& 63#64) * BitVec.signExtend (2 * 64) 299#64 ‚â•
                    BitVec.twoPow (2 * 64)
                      (64 -
                        1)) =?= True ‚àß
                (BitVec.signExtend 128 (x‚úù.sdiv 299#64 &&& 63#64) * 299#128 <
                    BitVec.signExtend 128 (BitVec.twoPow 64 63) ‚à®
                  BitVec.signExtend 128 (x‚úù.sdiv 299#64 &&& 63#64) * 299#128 ‚â• BitVec.twoPow 128 63)
            [Meta.isDefEq] [0.001772] ‚úÖÔ∏è BitVec.signExtend (2 * 64) (x‚úù.sdiv 299#64 &&& 63#64) *
                      BitVec.signExtend (2 * 64) 299#64 <
                    BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ‚à®
                  BitVec.signExtend (2 * 64) (x‚úù.sdiv 299#64 &&& 63#64) * BitVec.signExtend (2 * 64) 299#64 ‚â•
                    BitVec.twoPow (2 * 64)
                      (64 -
                        1) =?= BitVec.signExtend 128 (x‚úù.sdiv 299#64 &&& 63#64) * 299#128 <
                    BitVec.signExtend 128 (BitVec.twoPow 64 63) ‚à®
                  BitVec.signExtend 128 (x‚úù.sdiv 299#64 &&& 63#64) * 299#128 ‚â• BitVec.twoPow 128 63
              [Meta.isDefEq] [0.001650] ‚úÖÔ∏è BitVec.signExtend (2 * 64) (x‚úù.sdiv 299#64 &&& 63#64) *
                      BitVec.signExtend (2 * 64) 299#64 <
                    BitVec.signExtend (2 * 64)
                      (BitVec.twoPow 64
                        (64 -
                          1)) =?= BitVec.signExtend 128 (x‚úù.sdiv 299#64 &&& 63#64) * 299#128 <
                    BitVec.signExtend 128 (BitVec.twoPow 64 63)
                [Meta.isDefEq] [0.001629] ‚úÖÔ∏è instLTBitVec.1
                      (BitVec.signExtend (2 * 64) (x‚úù.sdiv 299#64 &&& 63#64) * BitVec.signExtend (2 * 64) 299#64)
                      (BitVec.signExtend (2 * 64)
                        (BitVec.twoPow 64
                          (64 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 128 (x‚úù.sdiv 299#64 &&& 63#64) * 299#128)
                      (BitVec.signExtend 128 (BitVec.twoPow 64 63))
                  [Meta.isDefEq] [0.001574] ‚úÖÔ∏è (BitVec.signExtend (2 * 64) (x‚úù.sdiv 299#64 &&& 63#64) *
                            BitVec.signExtend (2 * 64) 299#64).toNat <
                        (BitVec.signExtend (2 * 64)
                            (BitVec.twoPow 64
                              (64 -
                                1))).toNat =?= (BitVec.signExtend 128 (x‚úù.sdiv 299#64 &&& 63#64) * 299#128).toNat <
                        (BitVec.signExtend 128 (BitVec.twoPow 64 63)).toNat
                    [Meta.isDefEq] [0.001559] ‚úÖÔ∏è instLTNat.1
                          (BitVec.signExtend (2 * 64) (x‚úù.sdiv 299#64 &&& 63#64) *
                              BitVec.signExtend (2 * 64) 299#64).toNat
                          (BitVec.signExtend (2 * 64)
                              (BitVec.twoPow 64
                                (64 -
                                  1))).toNat =?= instLTNat.1
                          (BitVec.signExtend 128 (x‚úù.sdiv 299#64 &&& 63#64) * 299#128).toNat
                          (BitVec.signExtend 128 (BitVec.twoPow 64 63)).toNat
                      [Meta.isDefEq] [0.001529] ‚úÖÔ∏è (BitVec.signExtend (2 * 64) (x‚úù.sdiv 299#64 &&& 63#64) *
                                  BitVec.signExtend (2 * 64) 299#64).toNat.lt
                            (BitVec.signExtend (2 * 64)
                                (BitVec.twoPow 64
                                  (64 -
                                    1))).toNat =?= (BitVec.signExtend 128 (x‚úù.sdiv 299#64 &&& 63#64) * 299#128).toNat.lt
                            (BitVec.signExtend 128 (BitVec.twoPow 64 63)).toNat
                        [Meta.isDefEq.delta] [0.001518] ‚úÖÔ∏è (BitVec.signExtend (2 * 64) (x‚úù.sdiv 299#64 &&& 63#64) *
                                    BitVec.signExtend (2 * 64) 299#64).toNat.lt
                              (BitVec.signExtend (2 * 64)
                                  (BitVec.twoPow 64
                                    (64 -
                                      1))).toNat =?= (BitVec.signExtend 128 (x‚úù.sdiv 299#64 &&& 63#64) *
                                    299#128).toNat.lt
                              (BitVec.signExtend 128 (BitVec.twoPow 64 63)).toNat
                          [Meta.isDefEq] [0.001419] ‚úÖÔ∏è (BitVec.signExtend (2 * 64) (x‚úù.sdiv 299#64 &&& 63#64) *
                                  BitVec.signExtend (2 * 64)
                                    299#64).toNat =?= (BitVec.signExtend 128 (x‚úù.sdiv 299#64 &&& 63#64) * 299#128).toNat
                            [Meta.isDefEq.delta] [0.001407] ‚úÖÔ∏è (BitVec.signExtend (2 * 64) (x‚úù.sdiv 299#64 &&& 63#64) *
                                    BitVec.signExtend (2 * 64)
                                      299#64).toNat =?= (BitVec.signExtend 128 (x‚úù.sdiv 299#64 &&& 63#64) *
                                    299#128).toNat
                              [Meta.isDefEq] [0.001386] ‚úÖÔ∏è BitVec.signExtend (2 * 64) (x‚úù.sdiv 299#64 &&& 63#64) *
                                    BitVec.signExtend (2 * 64)
                                      299#64 =?= BitVec.signExtend 128 (x‚úù.sdiv 299#64 &&& 63#64) * 299#128
                                [Meta.isDefEq] [0.001361] ‚úÖÔ∏è instHMul.1
                                      (BitVec.signExtend (2 * 64) (x‚úù.sdiv 299#64 &&& 63#64))
                                      (BitVec.signExtend (2 * 64)
                                        299#64) =?= instHMul.1 (BitVec.signExtend 128 (x‚úù.sdiv 299#64 &&& 63#64))
                                      299#128
                                  [Meta.isDefEq] [0.001310] ‚úÖÔ∏è Mul.mul
                                        (BitVec.signExtend (2 * 64) (x‚úù.sdiv 299#64 &&& 63#64))
                                        (BitVec.signExtend (2 * 64)
                                          299#64) =?= Mul.mul (BitVec.signExtend 128 (x‚úù.sdiv 299#64 &&& 63#64)) 299#128
                                    [Meta.isDefEq] [0.001290] ‚úÖÔ∏è BitVec.instMul.1
                                          (BitVec.signExtend (2 * 64) (x‚úù.sdiv 299#64 &&& 63#64))
                                          (BitVec.signExtend (2 * 64)
                                            299#64) =?= BitVec.instMul.1
                                          (BitVec.signExtend 128 (x‚úù.sdiv 299#64 &&& 63#64)) 299#128
                                      [Meta.isDefEq] [0.001251] ‚úÖÔ∏è (BitVec.signExtend (2 * 64)
                                                (x‚úù.sdiv 299#64 &&& 63#64)).mul
                                            (BitVec.signExtend (2 * 64)
                                              299#64) =?= (BitVec.signExtend 128 (x‚úù.sdiv 299#64 &&& 63#64)).mul 299#128
                                        [Meta.isDefEq.delta] [0.001241] ‚úÖÔ∏è (BitVec.signExtend (2 * 64)
                                                  (x‚úù.sdiv 299#64 &&& 63#64)).mul
                                              (BitVec.signExtend (2 * 64)
                                                299#64) =?= (BitVec.signExtend 128 (x‚úù.sdiv 299#64 &&& 63#64)).mul
                                              299#128
                                          [Meta.isDefEq] [0.001165] ‚úÖÔ∏è BitVec.signExtend (2 * 64) 299#64 =?= 299#128
                                            [Meta.isDefEq] [0.001149] ‚úÖÔ∏è BitVec.ofInt (2 * 64)
                                                  (299#64).toInt =?= 299#128
                                              [Meta.isDefEq] [0.001134] ‚úÖÔ∏è ((299#64).toInt %
                                                        Int.ofNat (2 ^ (2 * 64))).toNat#'‚ãØ =?= 299#128
                                                [Meta.isDefEq] [0.001117] ‚úÖÔ∏è ((299#64).toInt %
                                                          Int.ofNat
                                                            (2 ^
                                                              (2 *
                                                                64))).toNat#'‚ãØ =?= { toFin := Fin.ofNat' (2 ^ 128) 299 }
                                                  [Meta.isDefEq] [0.001105] ‚úÖÔ∏è {
                                                        toFin :=
                                                          ‚ü®((299#64).toInt % Int.ofNat (2 ^ (2 * 64))).toNat,
                                                            ‚ãØ‚ü© } =?= { toFin := Fin.ofNat' (2 ^ 128) 299 }
                                                    [Meta.isDefEq] [0.001052] ‚úÖÔ∏è ‚ü®((299#64).toInt %
                                                              Int.ofNat (2 ^ (2 * 64))).toNat,
                                                          ‚ãØ‚ü© =?= Fin.ofNat' (2 ^ 128) 299
                                                      [Meta.isDefEq] [0.001033] ‚úÖÔ∏è ‚ü®((299#64).toInt %
                                                                Int.ofNat (2 ^ (2 * 64))).toNat,
                                                            ‚ãØ‚ü© =?= ‚ü®299 % 2 ^ 128, ‚ãØ‚ü©
  [Meta.isDefEq] [0.001081] ‚úÖÔ∏è ?h‚ÇÅ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congrArg (fun x => BitVec.zeroExtend 128 (x &&& 63#64) * 299#128 ‚â• BitVec.twoPow 128 63 <<< 1)
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv x‚úù 299#64)
                  (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x‚úù))
                    (fun a =>
                      Eq.trans
                        (ite_cond_eq_false (-x‚úù / -299#64) (-(-x‚úù / 299#64))
                          (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 299#64))
                            (eq_false' fun h => Bool.noConfusion h)))
                        (Eq.trans (congrArg (fun x => -(x / 299#64)) (BitVec.neg_eq_not_add x‚úù))
                          (BitVec.neg_eq_not_add ((~~~x‚úù + 1#64) / 299#64))))
                    fun a =>
                    ite_cond_eq_false (-(x‚úù / -299#64)) (x‚úù / 299#64)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 299#64))
                        (eq_false' fun h => Bool.noConfusion h)))))
              Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2)
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 128 63 <<< 1)
                (BitVec.zeroExtend 128
                    ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&& 63#64) *
                  299#128))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                      (BitVec.zeroExtend 128
                          ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                            63#64) *
                        299#128)
                      (BitVec.twoPow 128 63 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 128 63 <<< 1 >·µ§
                      BitVec.zeroExtend 128
                          ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                            63#64) *
                        299#128)
                    true))
                (congrArg (fun x => (!x) = true)
                  (beq_true
                    (BitVec.twoPow 128 63 <<< 1 >·µ§
                      BitVec.zeroExtend 128
                          ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                            63#64) *
                        299#128)))))))
        (true_and
          ((!BitVec.twoPow 128 63 <<< 1 >·µ§
                BitVec.zeroExtend 128
                    ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&& 63#64) *
                  299#128) =
            true))
    [Meta.isDefEq.assign] [0.001079] ‚úÖÔ∏è ?h‚ÇÅ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congrArg (fun x => BitVec.zeroExtend 128 (x &&& 63#64) * 299#128 ‚â• BitVec.twoPow 128 63 <<< 1)
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv x‚úù 299#64)
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x‚úù))
                      (fun a =>
                        Eq.trans
                          (ite_cond_eq_false (-x‚úù / -299#64) (-(-x‚úù / 299#64))
                            (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 299#64))
                              (eq_false' fun h => Bool.noConfusion h)))
                          (Eq.trans (congrArg (fun x => -(x / 299#64)) (BitVec.neg_eq_not_add x‚úù))
                            (BitVec.neg_eq_not_add ((~~~x‚úù + 1#64) / 299#64))))
                      fun a =>
                      ite_cond_eq_false (-(x‚úù / -299#64)) (x‚úù / 299#64)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 299#64))
                          (eq_false' fun h => Bool.noConfusion h)))))
                Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 128 63 <<< 1)
                  (BitVec.zeroExtend 128
                      ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&& 63#64) *
                    299#128))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                        (BitVec.zeroExtend 128
                            ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                              63#64) *
                          299#128)
                        (BitVec.twoPow 128 63 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 128 63 <<< 1 >·µ§
                        BitVec.zeroExtend 128
                            ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                              63#64) *
                          299#128)
                      true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true
                      (BitVec.twoPow 128 63 <<< 1 >·µ§
                        BitVec.zeroExtend 128
                            ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                              63#64) *
                          299#128)))))))
          (true_and
            ((!BitVec.twoPow 128 63 <<< 1 >·µ§
                  BitVec.zeroExtend 128
                      ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&& 63#64) *
                    299#128) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.001038] ‚úÖÔ∏è (?h‚ÇÅ : (True ‚àß
              BitVec.zeroExtend (2 * 64) (x‚úù.sdiv 299#64 &&& 63#64) * BitVec.zeroExtend (2 * 64) 299#64 ‚â•
                BitVec.twoPow (2 * 64) (64 - 1) <<< 1) =
            ((!BitVec.twoPow 128 63 <<< 1 >·µ§
                  BitVec.zeroExtend 128
                      ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&& 63#64) *
                    299#128) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congrArg (fun x => BitVec.zeroExtend 128 (x &&& 63#64) * 299#128 ‚â• BitVec.twoPow 128 63 <<< 1)
                    (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv x‚úù 299#64)
                      (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x‚úù))
                        (fun a =>
                          Eq.trans
                            (ite_cond_eq_false (-x‚úù / -299#64) (-(-x‚úù / 299#64))
                              (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 299#64))
                                (eq_false' fun h => Bool.noConfusion h)))
                            (Eq.trans (congrArg (fun x => -(x / 299#64)) (BitVec.neg_eq_not_add x‚úù))
                              (BitVec.neg_eq_not_add ((~~~x‚úù + 1#64) / 299#64))))
                        fun a =>
                        ite_cond_eq_false (-(x‚úù / -299#64)) (x‚úù / 299#64)
                          (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 299#64))
                            (eq_false' fun h => Bool.noConfusion h)))))
                  Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 128 63 <<< 1)
                    (BitVec.zeroExtend 128
                        ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                          63#64) *
                      299#128))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                          (BitVec.zeroExtend 128
                              ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                                63#64) *
                            299#128)
                          (BitVec.twoPow 128 63 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 128 63 <<< 1 >·µ§
                          BitVec.zeroExtend 128
                              ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                                63#64) *
                            299#128)
                        true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true
                        (BitVec.twoPow 128 63 <<< 1 >·µ§
                          BitVec.zeroExtend 128
                              ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                                63#64) *
                            299#128)))))))
            (true_and
              ((!BitVec.twoPow 128 63 <<< 1 >·µ§
                    BitVec.zeroExtend 128
                        ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                          63#64) *
                      299#128) =
                true)) : (True ‚àß
              BitVec.zeroExtend 128 (x‚úù.sdiv 299#64 &&& 63#64) * 299#128 ‚â• BitVec.twoPow 128 63 <<< 1) =
            ((!BitVec.twoPow 128 63 <<< 1 >·µ§
                  BitVec.zeroExtend 128
                      ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&& 63#64) *
                    299#128) =
              true))
        [Meta.isDefEq] [0.001034] ‚úÖÔ∏è (True ‚àß
                BitVec.zeroExtend (2 * 64) (x‚úù.sdiv 299#64 &&& 63#64) * BitVec.zeroExtend (2 * 64) 299#64 ‚â•
                  BitVec.twoPow (2 * 64) (64 - 1) <<< 1) =
              ((!BitVec.twoPow 128 63 <<< 1 >·µ§
                    BitVec.zeroExtend 128
                        ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                          63#64) *
                      299#128) =
                true) =?= (True ‚àß
                BitVec.zeroExtend 128 (x‚úù.sdiv 299#64 &&& 63#64) * 299#128 ‚â• BitVec.twoPow 128 63 <<< 1) =
              ((!BitVec.twoPow 128 63 <<< 1 >·µ§
                    BitVec.zeroExtend 128
                        ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                          63#64) *
                      299#128) =
                true)
          [Meta.isDefEq] [0.001010] ‚úÖÔ∏è True ‚àß
                BitVec.zeroExtend (2 * 64) (x‚úù.sdiv 299#64 &&& 63#64) * BitVec.zeroExtend (2 * 64) 299#64 ‚â•
                  BitVec.twoPow (2 * 64) (64 - 1) <<<
                    1 =?= True ‚àß BitVec.zeroExtend 128 (x‚úù.sdiv 299#64 &&& 63#64) * 299#128 ‚â• BitVec.twoPow 128 63 <<< 1
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      x‚úù : BitVec 64
      a‚úù :
        ¬¨some
              (x‚úù % 299#64 +
                (if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) % 64#64 * 299#64) ‚äë
            if
                (!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >·µ§
                          BitVec.signExtend 128
                              ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                                63#64) *
                            299#128) &&
                      BitVec.twoPow 128 63 >·µ§
                        BitVec.signExtend 128
                            ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                              63#64) *
                          299#128)) =
                  true then
              none
            else
              if
                  (!BitVec.twoPow 128 63 <<< 1 >·µ§
                        BitVec.zeroExtend 128
                            ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                              63#64) *
                          299#128) =
                    true then
                none
              else
                if
                    ((x‚úù % 299#64).getLsbD 63 ==
                          (((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                                  63#64) *
                                299#64).getLsbD
                            63 &&
                        !(x‚úù % 299#64 +
                                  ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64
                                      else x‚úù / 299#64) &&&
                                      63#64) *
                                    299#64).getLsbD
                              63 ==
                            (x‚úù % 299#64).getLsbD 63) =
                      true then
                  none
                else
                  if
                      (!((!x‚úù % 299#64 >·µ§
                                x‚úù % 299#64 +
                                  ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64
                                      else x‚úù / 299#64) &&&
                                      63#64) *
                                    299#64) &&
                            !((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                                    63#64) *
                                  299#64 >·µ§
                                x‚úù % 299#64 +
                                  ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64
                                      else x‚úù / 299#64) &&&
                                      63#64) *
                                    299#64)) =
                        true then
                    none
                  else
                    some
                      (x‚úù % 299#64 +
                        ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 299#64) + 1#64 else x‚úù / 299#64) &&&
                            63#64) *
                          299#64)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gadd4_proof.lean:67:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gadd4_proof.lean:58:8: error: (kernel) declaration has metavariables 'not_match_inconsistent_values_thm'
[bv] [0.110849] Normalizing goal
  [Meta.synthInstance] [0.003635] ‚úÖÔ∏è Decidable
        ((if 299#64 = 0 then none
          else
            if 29#64 = 0 then none else if 64#64 = 0 then none else some (x‚úù % 299#64 + x‚úù / 29#64 % 64#64 * 299#64)) ‚äë
          if 299#64 = 0 then none
          else
            if 29#64 = 0 then none
            else
              if
                  True ‚àß
                    (BitVec.signExtend (2 * 64) (x‚úù / 29#64 &&& 63#64) * BitVec.signExtend (2 * 64) 299#64 <
                        BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ‚à®
                      BitVec.signExtend (2 * 64) (x‚úù / 29#64 &&& 63#64) * BitVec.signExtend (2 * 64) 299#64 ‚â•
                        BitVec.twoPow (2 * 64) (64 - 1)) then
                none
              else
                if
                    True ‚àß
                      BitVec.zeroExtend (2 * 64) (x‚úù / 29#64 &&& 63#64) * BitVec.zeroExtend (2 * 64) 299#64 ‚â•
                        BitVec.twoPow (2 * 64) (64 - 1) <<< 1 then
                  none
                else
                  if
                      True ‚àß
                        (x‚úù % 299#64).msb = ((x‚úù / 29#64 &&& 63#64) * 299#64).msb ‚àß
                          (x‚úù % 299#64 + (x‚úù / 29#64 &&& 63#64) * 299#64).msb ‚â† (x‚úù % 299#64).msb then
                    none
                  else
                    if
                        True ‚àß
                          (x‚úù % 299#64 + (x‚úù / 29#64 &&& 63#64) * 299#64 < x‚úù % 299#64 ‚à®
                            x‚úù % 299#64 + (x‚úù / 29#64 &&& 63#64) * 299#64 < (x‚úù / 29#64 &&& 63#64) * 299#64) then
                      none
                    else some (x‚úù % 299#64 + (x‚úù / 29#64 &&& 63#64) * 299#64))
    [Meta.check] [0.002609] ‚úÖÔ∏è BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if 299#64 = 0 then none
          else if 29#64 = 0 then none else if 64#64 = 0 then none else some (x‚úù % 299#64 + x‚úù / 29#64 % 64#64 * 299#64))
          (if 299#64 = 0 then none
          else
            if 29#64 = 0 then none
            else
              if
                  True ‚àß
                    (BitVec.signExtend (2 * 64) (x‚úù / 29#64 &&& 63#64) * BitVec.signExtend (2 * 64) 299#64 <
                        BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ‚à®
                      BitVec.signExtend (2 * 64) (x‚úù / 29#64 &&& 63#64) * BitVec.signExtend (2 * 64) 299#64 ‚â•
                        BitVec.twoPow (2 * 64) (64 - 1)) then
                none
              else
                if
                    True ‚àß
                      BitVec.zeroExtend (2 * 64) (x‚úù / 29#64 &&& 63#64) * BitVec.zeroExtend (2 * 64) 299#64 ‚â•
                        BitVec.twoPow (2 * 64) (64 - 1) <<< 1 then
                  none
                else
                  if
                      True ‚àß
                        (x‚úù % 299#64).msb = ((x‚úù / 29#64 &&& 63#64) * 299#64).msb ‚àß
                          (x‚úù % 299#64 + (x‚úù / 29#64 &&& 63#64) * 299#64).msb ‚â† (x‚úù % 299#64).msb then
                    none
                  else
                    if
                        True ‚àß
                          (x‚úù % 299#64 + (x‚úù / 29#64 &&& 63#64) * 299#64 < x‚úù % 299#64 ‚à®
                            x‚úù % 299#64 + (x‚úù / 29#64 &&& 63#64) * 299#64 < (x‚úù / 29#64 &&& 63#64) * 299#64) then
                      none
                    else some (x‚úù % 299#64 + (x‚úù / 29#64 &&& 63#64) * 299#64))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      x‚úù : BitVec 64
      a‚úù :
        ¬¨(if 299#64 = 0 then none
            else
              if 29#64 = 0 then none
              else if 64#64 = 0 then none else some (x‚úù % 299#64 + x‚úù / 29#64 % 64#64 * 299#64)) ‚äë
            if 299#64 = 0 then none
            else
              if 29#64 = 0 then none
              else
                if
                    True ‚àß
                      (BitVec.signExtend (2 * 64) (x‚úù / 29#64 &&& 63#64) * BitVec.signExtend (2 * 64) 299#64 <
                          BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ‚à®
                        BitVec.signExtend (2 * 64) (x‚úù / 29#64 &&& 63#64) * BitVec.signExtend (2 * 64) 299#64 ‚â•
                          BitVec.twoPow (2 * 64) (64 - 1)) then
                  none
                else
                  if
                      True ‚àß
                        BitVec.zeroExtend (2 * 64) (x‚úù / 29#64 &&& 63#64) * BitVec.zeroExtend (2 * 64) 299#64 ‚â•
                          BitVec.twoPow (2 * 64) (64 - 1) <<< 1 then
                    none
                  else
                    if
                        True ‚àß
                          (x‚úù % 299#64).msb = ((x‚úù / 29#64 &&& 63#64) * 299#64).msb ‚àß
                            (x‚úù % 299#64 + (x‚úù / 29#64 &&& 63#64) * 299#64).msb ‚â† (x‚úù % 299#64).msb then
                      none
                    else
                      if
                          True ‚àß
                            (x‚úù % 299#64 + (x‚úù / 29#64 &&& 63#64) * 299#64 < x‚úù % 299#64 ‚à®
                              x‚úù % 299#64 + (x‚úù / 29#64 &&& 63#64) * 299#64 < (x‚úù / 29#64 &&& 63#64) * 299#64) then
                        none
                      else some (x‚úù % 299#64 + (x‚úù / 29#64 &&& 63#64) * 299#64)
      ‚ä¢ False
  [Meta.isDefEq] [0.001172] ‚ùåÔ∏è ?a == ?a =?= 299#64 == 0#64
  [Meta.isDefEq] [0.001845] ‚úÖÔ∏è ?h‚ÇÅ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128)
                    (BitVec.signExtend 128 (BitVec.twoPow 64 63))))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 128 63)
                      (BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                            (BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128) (BitVec.twoPow 128 63)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 128 63 >·µ§ BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128) true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true (BitVec.twoPow 128 63 >·µ§ BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 128 (BitVec.twoPow 64 63) >·µ§ BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128)
                !BitVec.twoPow 128 63 >·µ§ BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 128 (BitVec.twoPow 64 63) >·µ§
                    BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128)
                  !BitVec.twoPow 128 63 >·µ§ BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128)
                (congrArg
                  (fun x =>
                    !((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >·µ§
                            BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128) &&
                        x))
                  (Bool.not_not (BitVec.twoPow 128 63 >·µ§ BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128)))))))
        (true_and
          ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >·µ§
                    BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128) &&
                BitVec.twoPow 128 63 >·µ§ BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128)) =
            true))
    [Meta.isDefEq.assign] [0.001842] ‚úÖÔ∏è ?h‚ÇÅ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                      (BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128)
                      (BitVec.signExtend 128 (BitVec.twoPow 64 63))))
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 128 63)
                        (BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                              (BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128) (BitVec.twoPow 128 63)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 128 63 >·µ§ BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128) true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true
                            (BitVec.twoPow 128 63 >·µ§ BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 128 (BitVec.twoPow 64 63) >·µ§
                    BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128)
                  !BitVec.twoPow 128 63 >·µ§ BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 128 (BitVec.twoPow 64 63) >·µ§
                      BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128)
                    !BitVec.twoPow 128 63 >·µ§ BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128)
                  (congrArg
                    (fun x =>
                      !((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >·µ§
                              BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128) &&
                          x))
                    (Bool.not_not (BitVec.twoPow 128 63 >·µ§ BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128)))))))
          (true_and
            ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >·µ§
                      BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128) &&
                  BitVec.twoPow 128 63 >·µ§ BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.001810] ‚úÖÔ∏è (?h‚ÇÅ : (True ‚àß
              (BitVec.signExtend (2 * 64) (x‚úù / 29#64 &&& 63#64) * BitVec.signExtend (2 * 64) 299#64 <
                  BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ‚à®
                BitVec.signExtend (2 * 64) (x‚úù / 29#64 &&& 63#64) * BitVec.signExtend (2 * 64) 299#64 ‚â•
                  BitVec.twoPow (2 * 64) (64 - 1))) =
            ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >·µ§
                      BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128) &&
                  BitVec.twoPow 128 63 >·µ§ BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                        (BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128)
                        (BitVec.signExtend 128 (BitVec.twoPow 64 63))))
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 128 63)
                          (BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                                (BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128) (BitVec.twoPow 128 63)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 128 63 >·µ§ BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128) true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true
                              (BitVec.twoPow 128 63 >·µ§ BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 128 (BitVec.twoPow 64 63) >·µ§
                      BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128)
                    !BitVec.twoPow 128 63 >·µ§ BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 128 (BitVec.twoPow 64 63) >·µ§
                        BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128)
                      !BitVec.twoPow 128 63 >·µ§ BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128)
                    (congrArg
                      (fun x =>
                        !((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >·µ§
                                BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128) &&
                            x))
                      (Bool.not_not
                        (BitVec.twoPow 128 63 >·µ§ BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128)))))))
            (true_and
              ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >·µ§
                        BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128) &&
                    BitVec.twoPow 128 63 >·µ§ BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128)) =
                true)) : (True ‚àß
              (BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128 < BitVec.signExtend 128 (BitVec.twoPow 64 63) ‚à®
                BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128 ‚â• BitVec.twoPow 128 63)) =
            ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >·µ§
                      BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128) &&
                  BitVec.twoPow 128 63 >·µ§ BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128)) =
              true))
        [Meta.isDefEq] [0.001806] ‚úÖÔ∏è (True ‚àß
                (BitVec.signExtend (2 * 64) (x‚úù / 29#64 &&& 63#64) * BitVec.signExtend (2 * 64) 299#64 <
                    BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ‚à®
                  BitVec.signExtend (2 * 64) (x‚úù / 29#64 &&& 63#64) * BitVec.signExtend (2 * 64) 299#64 ‚â•
                    BitVec.twoPow (2 * 64) (64 - 1))) =
              ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >·µ§
                        BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128) &&
                    BitVec.twoPow 128 63 >·µ§ BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128)) =
                true) =?= (True ‚àß
                (BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128 < BitVec.signExtend 128 (BitVec.twoPow 64 63) ‚à®
                  BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128 ‚â• BitVec.twoPow 128 63)) =
              ((!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >·µ§
                        BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128) &&
                    BitVec.twoPow 128 63 >·µ§ BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128)) =
                true)
          [Meta.isDefEq] [0.001782] ‚úÖÔ∏è True ‚àß
                (BitVec.signExtend (2 * 64) (x‚úù / 29#64 &&& 63#64) * BitVec.signExtend (2 * 64) 299#64 <
                    BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ‚à®
                  BitVec.signExtend (2 * 64) (x‚úù / 29#64 &&& 63#64) * BitVec.signExtend (2 * 64) 299#64 ‚â•
                    BitVec.twoPow (2 * 64)
                      (64 -
                        1)) =?= True ‚àß
                (BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128 < BitVec.signExtend 128 (BitVec.twoPow 64 63) ‚à®
                  BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128 ‚â• BitVec.twoPow 128 63)
            [Meta.isDefEq] [0.001765] ‚úÖÔ∏è BitVec.signExtend (2 * 64) (x‚úù / 29#64 &&& 63#64) *
                      BitVec.signExtend (2 * 64) 299#64 <
                    BitVec.signExtend (2 * 64) (BitVec.twoPow 64 (64 - 1)) ‚à®
                  BitVec.signExtend (2 * 64) (x‚úù / 29#64 &&& 63#64) * BitVec.signExtend (2 * 64) 299#64 ‚â•
                    BitVec.twoPow (2 * 64)
                      (64 -
                        1) =?= BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128 <
                    BitVec.signExtend 128 (BitVec.twoPow 64 63) ‚à®
                  BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128 ‚â• BitVec.twoPow 128 63
              [Meta.isDefEq] [0.001650] ‚úÖÔ∏è BitVec.signExtend (2 * 64) (x‚úù / 29#64 &&& 63#64) *
                      BitVec.signExtend (2 * 64) 299#64 <
                    BitVec.signExtend (2 * 64)
                      (BitVec.twoPow 64
                        (64 -
                          1)) =?= BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128 <
                    BitVec.signExtend 128 (BitVec.twoPow 64 63)
                [Meta.isDefEq] [0.001627] ‚úÖÔ∏è instLTBitVec.1
                      (BitVec.signExtend (2 * 64) (x‚úù / 29#64 &&& 63#64) * BitVec.signExtend (2 * 64) 299#64)
                      (BitVec.signExtend (2 * 64)
                        (BitVec.twoPow 64
                          (64 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128)
                      (BitVec.signExtend 128 (BitVec.twoPow 64 63))
                  [Meta.isDefEq] [0.001572] ‚úÖÔ∏è (BitVec.signExtend (2 * 64) (x‚úù / 29#64 &&& 63#64) *
                            BitVec.signExtend (2 * 64) 299#64).toNat <
                        (BitVec.signExtend (2 * 64)
                            (BitVec.twoPow 64
                              (64 -
                                1))).toNat =?= (BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128).toNat <
                        (BitVec.signExtend 128 (BitVec.twoPow 64 63)).toNat
                    [Meta.isDefEq] [0.001558] ‚úÖÔ∏è instLTNat.1
                          (BitVec.signExtend (2 * 64) (x‚úù / 29#64 &&& 63#64) * BitVec.signExtend (2 * 64) 299#64).toNat
                          (BitVec.signExtend (2 * 64)
                              (BitVec.twoPow 64
                                (64 -
                                  1))).toNat =?= instLTNat.1
                          (BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128).toNat
                          (BitVec.signExtend 128 (BitVec.twoPow 64 63)).toNat
                      [Meta.isDefEq] [0.001521] ‚úÖÔ∏è (BitVec.signExtend (2 * 64) (x‚úù / 29#64 &&& 63#64) *
                                  BitVec.signExtend (2 * 64) 299#64).toNat.lt
                            (BitVec.signExtend (2 * 64)
                                (BitVec.twoPow 64
                                  (64 -
                                    1))).toNat =?= (BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128).toNat.lt
                            (BitVec.signExtend 128 (BitVec.twoPow 64 63)).toNat
                        [Meta.isDefEq.delta] [0.001510] ‚úÖÔ∏è (BitVec.signExtend (2 * 64) (x‚úù / 29#64 &&& 63#64) *
                                    BitVec.signExtend (2 * 64) 299#64).toNat.lt
                              (BitVec.signExtend (2 * 64)
                                  (BitVec.twoPow 64
                                    (64 -
                                      1))).toNat =?= (BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128).toNat.lt
                              (BitVec.signExtend 128 (BitVec.twoPow 64 63)).toNat
                          [Meta.isDefEq] [0.001415] ‚úÖÔ∏è (BitVec.signExtend (2 * 64) (x‚úù / 29#64 &&& 63#64) *
                                  BitVec.signExtend (2 * 64)
                                    299#64).toNat =?= (BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128).toNat
                            [Meta.isDefEq.delta] [0.001403] ‚úÖÔ∏è (BitVec.signExtend (2 * 64) (x‚úù / 29#64 &&& 63#64) *
                                    BitVec.signExtend (2 * 64)
                                      299#64).toNat =?= (BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128).toNat
                              [Meta.isDefEq] [0.001384] ‚úÖÔ∏è BitVec.signExtend (2 * 64) (x‚úù / 29#64 &&& 63#64) *
                                    BitVec.signExtend (2 * 64)
                                      299#64 =?= BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128
                                [Meta.isDefEq] [0.001358] ‚úÖÔ∏è instHMul.1
                                      (BitVec.signExtend (2 * 64) (x‚úù / 29#64 &&& 63#64))
                                      (BitVec.signExtend (2 * 64)
                                        299#64) =?= instHMul.1 (BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64)) 299#128
                                  [Meta.isDefEq] [0.001306] ‚úÖÔ∏è Mul.mul
                                        (BitVec.signExtend (2 * 64) (x‚úù / 29#64 &&& 63#64))
                                        (BitVec.signExtend (2 * 64)
                                          299#64) =?= Mul.mul (BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64)) 299#128
                                    [Meta.isDefEq] [0.001286] ‚úÖÔ∏è BitVec.instMul.1
                                          (BitVec.signExtend (2 * 64) (x‚úù / 29#64 &&& 63#64))
                                          (BitVec.signExtend (2 * 64)
                                            299#64) =?= BitVec.instMul.1 (BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64))
                                          299#128
                                      [Meta.isDefEq] [0.001239] ‚úÖÔ∏è (BitVec.signExtend (2 * 64)
                                                (x‚úù / 29#64 &&& 63#64)).mul
                                            (BitVec.signExtend (2 * 64)
                                              299#64) =?= (BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64)).mul 299#128
                                        [Meta.isDefEq.delta] [0.001229] ‚úÖÔ∏è (BitVec.signExtend (2 * 64)
                                                  (x‚úù / 29#64 &&& 63#64)).mul
                                              (BitVec.signExtend (2 * 64)
                                                299#64) =?= (BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64)).mul 299#128
                                          [Meta.isDefEq] [0.001125] ‚úÖÔ∏è BitVec.signExtend (2 * 64) 299#64 =?= 299#128
                                            [Meta.isDefEq] [0.001106] ‚úÖÔ∏è BitVec.ofInt (2 * 64)
                                                  (299#64).toInt =?= 299#128
                                              [Meta.isDefEq] [0.001092] ‚úÖÔ∏è ((299#64).toInt %
                                                        Int.ofNat (2 ^ (2 * 64))).toNat#'‚ãØ =?= 299#128
                                                [Meta.isDefEq] [0.001076] ‚úÖÔ∏è ((299#64).toInt %
                                                          Int.ofNat
                                                            (2 ^
                                                              (2 *
                                                                64))).toNat#'‚ãØ =?= { toFin := Fin.ofNat' (2 ^ 128) 299 }
                                                  [Meta.isDefEq] [0.001063] ‚úÖÔ∏è {
                                                        toFin :=
                                                          ‚ü®((299#64).toInt % Int.ofNat (2 ^ (2 * 64))).toNat,
                                                            ‚ãØ‚ü© } =?= { toFin := Fin.ofNat' (2 ^ 128) 299 }
                                                    [Meta.isDefEq] [0.001025] ‚úÖÔ∏è ‚ü®((299#64).toInt %
                                                              Int.ofNat (2 ^ (2 * 64))).toNat,
                                                          ‚ãØ‚ü© =?= Fin.ofNat' (2 ^ 128) 299
                                                      [Meta.isDefEq] [0.001007] ‚úÖÔ∏è ‚ü®((299#64).toInt %
                                                                Int.ofNat (2 ^ (2 * 64))).toNat,
                                                            ‚ãØ‚ü© =?= ‚ü®299 % 2 ^ 128, ‚ãØ‚ü©
  [Meta.isDefEq] [0.001825] ‚úÖÔ∏è ?h‚ÇÅ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 128 63 <<< 1)
                (BitVec.zeroExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                      (BitVec.zeroExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128) (BitVec.twoPow 128 63 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 128 63 <<< 1 >·µ§ BitVec.zeroExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 128 63 <<< 1 >·µ§ BitVec.zeroExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128)))))))
        (true_and ((!BitVec.twoPow 128 63 <<< 1 >·µ§ BitVec.zeroExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128) = true))
    [Meta.isDefEq.assign] [0.001821] ‚úÖÔ∏è ?h‚ÇÅ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 128 63 <<< 1)
                  (BitVec.zeroExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                        (BitVec.zeroExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128) (BitVec.twoPow 128 63 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 128 63 <<< 1 >·µ§ BitVec.zeroExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true
                      (BitVec.twoPow 128 63 <<< 1 >·µ§ BitVec.zeroExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128)))))))
          (true_and ((!BitVec.twoPow 128 63 <<< 1 >·µ§ BitVec.zeroExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001800] ‚úÖÔ∏è (?h‚ÇÅ : (True ‚àß
              BitVec.zeroExtend (2 * 64) (x‚úù / 29#64 &&& 63#64) * BitVec.zeroExtend (2 * 64) 299#64 ‚â•
                BitVec.twoPow (2 * 64) (64 - 1) <<< 1) =
            ((!BitVec.twoPow 128 63 <<< 1 >·µ§ BitVec.zeroExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 128 63 <<< 1)
                    (BitVec.zeroExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                          (BitVec.zeroExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128) (BitVec.twoPow 128 63 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 128 63 <<< 1 >·µ§ BitVec.zeroExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true
                        (BitVec.twoPow 128 63 <<< 1 >·µ§ BitVec.zeroExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128)))))))
            (true_and
              ((!BitVec.twoPow 128 63 <<< 1 >·µ§ BitVec.zeroExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128) =
                true)) : (True ‚àß BitVec.zeroExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128 ‚â• BitVec.twoPow 128 63 <<< 1) =
            ((!BitVec.twoPow 128 63 <<< 1 >·µ§ BitVec.zeroExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128) = true))
        [Meta.isDefEq] [0.001795] ‚úÖÔ∏è (True ‚àß
                BitVec.zeroExtend (2 * 64) (x‚úù / 29#64 &&& 63#64) * BitVec.zeroExtend (2 * 64) 299#64 ‚â•
                  BitVec.twoPow (2 * 64) (64 - 1) <<< 1) =
              ((!BitVec.twoPow 128 63 <<< 1 >·µ§ BitVec.zeroExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128) =
                true) =?= (True ‚àß BitVec.zeroExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128 ‚â• BitVec.twoPow 128 63 <<< 1) =
              ((!BitVec.twoPow 128 63 <<< 1 >·µ§ BitVec.zeroExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128) = true)
          [Meta.isDefEq] [0.001760] ‚úÖÔ∏è True ‚àß
                BitVec.zeroExtend (2 * 64) (x‚úù / 29#64 &&& 63#64) * BitVec.zeroExtend (2 * 64) 299#64 ‚â•
                  BitVec.twoPow (2 * 64) (64 - 1) <<<
                    1 =?= True ‚àß BitVec.zeroExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128 ‚â• BitVec.twoPow 128 63 <<< 1
            [Meta.isDefEq] [0.001741] ‚úÖÔ∏è BitVec.zeroExtend (2 * 64) (x‚úù / 29#64 &&& 63#64) *
                    BitVec.zeroExtend (2 * 64) 299#64 ‚â•
                  BitVec.twoPow (2 * 64) (64 - 1) <<<
                    1 =?= BitVec.zeroExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128 ‚â• BitVec.twoPow 128 63 <<< 1
              [Meta.isDefEq.delta] [0.001709] ‚úÖÔ∏è BitVec.zeroExtend (2 * 64) (x‚úù / 29#64 &&& 63#64) *
                      BitVec.zeroExtend (2 * 64) 299#64 ‚â•
                    BitVec.twoPow (2 * 64) (64 - 1) <<<
                      1 =?= BitVec.zeroExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128 ‚â• BitVec.twoPow 128 63 <<< 1
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      x‚úù : BitVec 64
      a‚úù :
        ¬¨some (x‚úù % 299#64 + x‚úù / 29#64 % 64#64 * 299#64) ‚äë
            if
                (!((!BitVec.signExtend 128 (BitVec.twoPow 64 63) >·µ§
                          BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128) &&
                      BitVec.twoPow 128 63 >·µ§ BitVec.signExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128)) =
                  true then
              none
            else
              if (!BitVec.twoPow 128 63 <<< 1 >·µ§ BitVec.zeroExtend 128 (x‚úù / 29#64 &&& 63#64) * 299#128) = true then
                none
              else
                if
                    ((x‚úù % 299#64).getLsbD 63 == ((x‚úù / 29#64 &&& 63#64) * 299#64).getLsbD 63 &&
                        !(x‚úù % 299#64 + (x‚úù / 29#64 &&& 63#64) * 299#64).getLsbD 63 == (x‚úù % 299#64).getLsbD 63) =
                      true then
                  none
                else
                  if
                      (!((!x‚úù % 299#64 >·µ§ x‚úù % 299#64 + (x‚úù / 29#64 &&& 63#64) * 299#64) &&
                            !(x‚úù / 29#64 &&& 63#64) * 299#64 >·µ§ x‚úù % 299#64 + (x‚úù / 29#64 &&& 63#64) * 299#64)) =
                        true then
                    none
                  else some (x‚úù % 299#64 + (x‚úù / 29#64 &&& 63#64) * 299#64)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gadd4_proof.lean:78:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gadd4_proof.lean:71:8: error: (kernel) declaration has metavariables 'fold_add_udiv_urem_thm'
[bv] [0.031750] Normalizing goal
  [Meta.synthInstance] [0.001651] ‚úÖÔ∏è Decidable
        ((if 10#32 = 0 then none
          else if 4#32 ‚â• ‚Üë32 then none else if 10#32 = 0 then none else some ((x‚úù / 10#32) <<< 4#32 + x‚úù % 10#32)) ‚äë
          if 10#32 = 0 then none
          else
            if
                True ‚àß
                  BitVec.zeroExtend (2 * 32) (x‚úù / 10#32) * BitVec.zeroExtend (2 * 32) 6#32 ‚â•
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else some (x‚úù / 10#32 * 6#32 + x‚úù))
    [Meta.check] [0.001052] ‚úÖÔ∏è BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if 10#32 = 0 then none
          else if 4#32 ‚â• ‚Üë32 then none else if 10#32 = 0 then none else some ((x‚úù / 10#32) <<< 4#32 + x‚úù % 10#32))
          (if 10#32 = 0 then none
          else
            if
                True ‚àß
                  BitVec.zeroExtend (2 * 32) (x‚úù / 10#32) * BitVec.zeroExtend (2 * 32) 6#32 ‚â•
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else some (x‚úù / 10#32 * 6#32 + x‚úù))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if 10#32 = 0 then none
            else if 4#32 ‚â• ‚Üë32 then none else if 10#32 = 0 then none else some ((x‚úù / 10#32) <<< 4#32 + x‚úù % 10#32)) ‚äë
            if 10#32 = 0 then none
            else
              if
                  True ‚àß
                    BitVec.zeroExtend (2 * 32) (x‚úù / 10#32) * BitVec.zeroExtend (2 * 32) 6#32 ‚â•
                      BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                none
              else some (x‚úù / 10#32 * 6#32 + x‚úù)
      ‚ä¢ False
  [Meta.isDefEq] [0.001338] ‚úÖÔ∏è ?h‚ÇÅ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                (BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64)
                      (BitVec.twoPow 64 31 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64)))))))
        (true_and ((!BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64) = true))
    [Meta.isDefEq.assign] [0.001335] ‚úÖÔ∏è ?h‚ÇÅ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                  (BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64)
                        (BitVec.twoPow 64 31 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64)))))))
          (true_and ((!BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001322] ‚úÖÔ∏è (?h‚ÇÅ : (True ‚àß
              BitVec.zeroExtend (2 * 32) (x‚úù / 10#32) * BitVec.zeroExtend (2 * 32) 6#32 ‚â•
                BitVec.twoPow (2 * 32) (32 - 1) <<< 1) =
            ((!BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                    (BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64)
                          (BitVec.twoPow 64 31 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64)))))))
            (true_and
              ((!BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64) =
                true)) : (True ‚àß BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64 ‚â• BitVec.twoPow 64 31 <<< 1) =
            ((!BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64) = true))
        [Meta.isDefEq] [0.001319] ‚úÖÔ∏è (True ‚àß
                BitVec.zeroExtend (2 * 32) (x‚úù / 10#32) * BitVec.zeroExtend (2 * 32) 6#32 ‚â•
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1) =
              ((!BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64) =
                true) =?= (True ‚àß BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64 ‚â• BitVec.twoPow 64 31 <<< 1) =
              ((!BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64) = true)
          [Meta.isDefEq] [0.001299] ‚úÖÔ∏è True ‚àß
                BitVec.zeroExtend (2 * 32) (x‚úù / 10#32) * BitVec.zeroExtend (2 * 32) 6#32 ‚â•
                  BitVec.twoPow (2 * 32) (32 - 1) <<<
                    1 =?= True ‚àß BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64 ‚â• BitVec.twoPow 64 31 <<< 1
            [Meta.isDefEq] [0.001285] ‚úÖÔ∏è BitVec.zeroExtend (2 * 32) (x‚úù / 10#32) * BitVec.zeroExtend (2 * 32) 6#32 ‚â•
                  BitVec.twoPow (2 * 32) (32 - 1) <<<
                    1 =?= BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64 ‚â• BitVec.twoPow 64 31 <<< 1
              [Meta.isDefEq.delta] [0.001260] ‚úÖÔ∏è BitVec.zeroExtend (2 * 32) (x‚úù / 10#32) *
                      BitVec.zeroExtend (2 * 32) 6#32 ‚â•
                    BitVec.twoPow (2 * 32) (32 - 1) <<<
                      1 =?= BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64 ‚â• BitVec.twoPow 64 31 <<< 1
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨some ((x‚úù / 10#32) <<< 4 + x‚úù % 10#32) ‚äë
            if (!BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64) = true then none
            else some (x‚úù / 10#32 * 6#32 + x‚úù)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gadd4_proof.lean:89:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gadd4_proof.lean:82:8: error: (kernel) declaration has metavariables 'fold_add_sdiv_srem_thm'
[bv] [0.067087] Normalizing goal
  [Meta.synthInstance] [0.001974] ‚úÖÔ∏è Decidable
        ((if (10#32 == 0 || 32 != 1 && x‚úù == BitVec.intMin 32 && 10#32 == -1) = true then none
          else
            if 4#32 ‚â• ‚Üë32 then none
            else
              (Option.map (fun div => x‚úù - div * 10#32)
                    (if (10#32 == 0 || 32 != 1 && x‚úù == BitVec.intMin 32 && 10#32 == -1) = true then none
                    else some (x‚úù.sdiv 10#32))).bind
                fun y' => some (x‚úù.sdiv 10#32 <<< 4#32 + y')) ‚äë
          if (10#32 == 0 || 32 != 1 && x‚úù == BitVec.intMin 32 && 10#32 == -1) = true then none
          else
            if
                True ‚àß
                  (BitVec.signExtend (2 * 32) (x‚úù.sdiv 10#32) * BitVec.signExtend (2 * 32) 6#32 <
                      BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ‚à®
                    BitVec.signExtend (2 * 32) (x‚úù.sdiv 10#32) * BitVec.signExtend (2 * 32) 6#32 ‚â•
                      BitVec.twoPow (2 * 32) (32 - 1)) then
              none
            else some (x‚úù.sdiv 10#32 * 6#32 + x‚úù))
    [Meta.check] [0.001305] ‚úÖÔ∏è BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if (10#32 == 0 || 32 != 1 && x‚úù == BitVec.intMin 32 && 10#32 == -1) = true then none
          else
            if 4#32 ‚â• ‚Üë32 then none
            else
              (Option.map (fun div => x‚úù - div * 10#32)
                    (if (10#32 == 0 || 32 != 1 && x‚úù == BitVec.intMin 32 && 10#32 == -1) = true then none
                    else some (x‚úù.sdiv 10#32))).bind
                fun y' => some (x‚úù.sdiv 10#32 <<< 4#32 + y'))
          (if (10#32 == 0 || 32 != 1 && x‚úù == BitVec.intMin 32 && 10#32 == -1) = true then none
          else
            if
                True ‚àß
                  (BitVec.signExtend (2 * 32) (x‚úù.sdiv 10#32) * BitVec.signExtend (2 * 32) 6#32 <
                      BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ‚à®
                    BitVec.signExtend (2 * 32) (x‚úù.sdiv 10#32) * BitVec.signExtend (2 * 32) 6#32 ‚â•
                      BitVec.twoPow (2 * 32) (32 - 1)) then
              none
            else some (x‚úù.sdiv 10#32 * 6#32 + x‚úù))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if (10#32 == 0 || 32 != 1 && x‚úù == BitVec.intMin 32 && 10#32 == -1) = true then none
            else
              if 4#32 ‚â• ‚Üë32 then none
              else
                (Option.map (fun div => x‚úù - div * 10#32)
                      (if (10#32 == 0 || 32 != 1 && x‚úù == BitVec.intMin 32 && 10#32 == -1) = true then none
                      else some (x‚úù.sdiv 10#32))).bind
                  fun y' => some (x‚úù.sdiv 10#32 <<< 4#32 + y')) ‚äë
            if (10#32 == 0 || 32 != 1 && x‚úù == BitVec.intMin 32 && 10#32 == -1) = true then none
            else
              if
                  True ‚àß
                    (BitVec.signExtend (2 * 32) (x‚úù.sdiv 10#32) * BitVec.signExtend (2 * 32) 6#32 <
                        BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ‚à®
                      BitVec.signExtend (2 * 32) (x‚úù.sdiv 10#32) * BitVec.signExtend (2 * 32) 6#32 ‚â•
                        BitVec.twoPow (2 * 32) (32 - 1)) then
                none
              else some (x‚úù.sdiv 10#32 * 6#32 + x‚úù)
      ‚ä¢ False
  [Meta.isDefEq] [0.001771] ‚úÖÔ∏è ?h‚ÇÅ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Eq.trans
                    (congrArg (fun x => BitVec.signExtend 64 x * 6#64 < BitVec.signExtend 64 (BitVec.twoPow 32 31))
                      (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv x‚úù 10#32)
                        (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x‚úù))
                          (fun a =>
                            Eq.trans
                              (ite_cond_eq_false (-x‚úù / -10#32) (-(-x‚úù / 10#32))
                                (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 10#32))
                                  (eq_false' fun h => Bool.noConfusion h)))
                              (Eq.trans (congrArg (fun x => -(x / 10#32)) (BitVec.neg_eq_not_add x‚úù))
                                (BitVec.neg_eq_not_add ((~~~x‚úù + 1#32) / 10#32))))
                          fun a =>
                          ite_cond_eq_false (-(x‚úù / -10#32)) (x‚úù / 10#32)
                            (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 10#32))
                              (eq_false' fun h => Bool.noConfusion h)))))
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                      (BitVec.signExtend 64
                          (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                        6#64)
                      (BitVec.signExtend 64 (BitVec.twoPow 32 31)))))
                (Eq.trans
                  (Eq.trans
                    (congrArg (fun x => BitVec.signExtend 64 x * 6#64 ‚â• BitVec.twoPow 64 31)
                      (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv x‚úù 10#32)
                        (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x‚úù))
                          (fun a =>
                            Eq.trans
                              (ite_cond_eq_false (-x‚úù / -10#32) (-(-x‚úù / 10#32))
                                (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 10#32))
                                  (eq_false' fun h => Bool.noConfusion h)))
                              (Eq.trans (congrArg (fun x => -(x / 10#32)) (BitVec.neg_eq_not_add x‚úù))
                                (BitVec.neg_eq_not_add ((~~~x‚úù + 1#32) / 10#32))))
                          fun a =>
                          ite_cond_eq_false (-(x‚úù / -10#32)) (x‚úù / 10#32)
                            (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 10#32))
                              (eq_false' fun h => Bool.noConfusion h)))))
                    Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31)
                      (BitVec.signExtend 64
                          (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                        6#64))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                            (BitVec.signExtend 64
                                (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                              6#64)
                            (BitVec.twoPow 64 31)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 64 31 >·µ§
                            BitVec.signExtend 64
                                (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                              6#64)
                          true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true
                          (BitVec.twoPow 64 31 >·µ§
                            BitVec.signExtend 64
                                (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                              6#64)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 64 (BitVec.twoPow 32 31) >·µ§
                  BitVec.signExtend 64
                      (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                    6#64)
                !BitVec.twoPow 64 31 >·µ§
                    BitVec.signExtend 64
                        (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                      6#64))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 64 (BitVec.twoPow 32 31) >·µ§
                    BitVec.signExtend 64
                        (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                      6#64)
                  !BitVec.twoPow 64 31 >·µ§
                      BitVec.signExtend 64
                          (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                        6#64)
                (congrArg
                  (fun x =>
                    !((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >·µ§
                            BitVec.signExtend 64
                                (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                              6#64) &&
                        x))
                  (Bool.not_not
                    (BitVec.twoPow 64 31 >·µ§
                      BitVec.signExtend 64
                          (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                        6#64)))))))
        (true_and
          ((!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >·µ§
                    BitVec.signExtend 64
                        (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                      6#64) &&
                BitVec.twoPow 64 31 >·µ§
                  BitVec.signExtend 64
                      (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                    6#64)) =
            true))
    [Meta.isDefEq.assign] [0.001769] ‚úÖÔ∏è ?h‚ÇÅ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Eq.trans
                      (congrArg (fun x => BitVec.signExtend 64 x * 6#64 < BitVec.signExtend 64 (BitVec.twoPow 32 31))
                        (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv x‚úù 10#32)
                          (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x‚úù))
                            (fun a =>
                              Eq.trans
                                (ite_cond_eq_false (-x‚úù / -10#32) (-(-x‚úù / 10#32))
                                  (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 10#32))
                                    (eq_false' fun h => Bool.noConfusion h)))
                                (Eq.trans (congrArg (fun x => -(x / 10#32)) (BitVec.neg_eq_not_add x‚úù))
                                  (BitVec.neg_eq_not_add ((~~~x‚úù + 1#32) / 10#32))))
                            fun a =>
                            ite_cond_eq_false (-(x‚úù / -10#32)) (x‚úù / 10#32)
                              (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 10#32))
                                (eq_false' fun h => Bool.noConfusion h)))))
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                        (BitVec.signExtend 64
                            (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                          6#64)
                        (BitVec.signExtend 64 (BitVec.twoPow 32 31)))))
                  (Eq.trans
                    (Eq.trans
                      (congrArg (fun x => BitVec.signExtend 64 x * 6#64 ‚â• BitVec.twoPow 64 31)
                        (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv x‚úù 10#32)
                          (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x‚úù))
                            (fun a =>
                              Eq.trans
                                (ite_cond_eq_false (-x‚úù / -10#32) (-(-x‚úù / 10#32))
                                  (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 10#32))
                                    (eq_false' fun h => Bool.noConfusion h)))
                                (Eq.trans (congrArg (fun x => -(x / 10#32)) (BitVec.neg_eq_not_add x‚úù))
                                  (BitVec.neg_eq_not_add ((~~~x‚úù + 1#32) / 10#32))))
                            fun a =>
                            ite_cond_eq_false (-(x‚úù / -10#32)) (x‚úù / 10#32)
                              (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 10#32))
                                (eq_false' fun h => Bool.noConfusion h)))))
                      Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2)
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31)
                        (BitVec.signExtend 64
                            (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                          6#64))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                              (BitVec.signExtend 64
                                  (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                                6#64)
                              (BitVec.twoPow 64 31)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 64 31 >·µ§
                              BitVec.signExtend 64
                                  (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                                6#64)
                            true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true
                            (BitVec.twoPow 64 31 >·µ§
                              BitVec.signExtend 64
                                  (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                                6#64)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 64 (BitVec.twoPow 32 31) >·µ§
                    BitVec.signExtend 64
                        (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                      6#64)
                  !BitVec.twoPow 64 31 >·µ§
                      BitVec.signExtend 64
                          (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                        6#64))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 64 (BitVec.twoPow 32 31) >·µ§
                      BitVec.signExtend 64
                          (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                        6#64)
                    !BitVec.twoPow 64 31 >·µ§
                        BitVec.signExtend 64
                            (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                          6#64)
                  (congrArg
                    (fun x =>
                      !((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >·µ§
                              BitVec.signExtend 64
                                  (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                                6#64) &&
                          x))
                    (Bool.not_not
                      (BitVec.twoPow 64 31 >·µ§
                        BitVec.signExtend 64
                            (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                          6#64)))))))
          (true_and
            ((!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >·µ§
                      BitVec.signExtend 64
                          (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                        6#64) &&
                  BitVec.twoPow 64 31 >·µ§
                    BitVec.signExtend 64
                        (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                      6#64)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.001715] ‚úÖÔ∏è (?h‚ÇÅ : (True ‚àß
              (BitVec.signExtend (2 * 32) (x‚úù.sdiv 10#32) * BitVec.signExtend (2 * 32) 6#32 <
                  BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ‚à®
                BitVec.signExtend (2 * 32) (x‚úù.sdiv 10#32) * BitVec.signExtend (2 * 32) 6#32 ‚â•
                  BitVec.twoPow (2 * 32) (32 - 1))) =
            ((!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >·µ§
                      BitVec.signExtend 64
                          (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                        6#64) &&
                  BitVec.twoPow 64 31 >·µ§
                    BitVec.signExtend 64
                        (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                      6#64)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Eq.trans
                        (congrArg (fun x => BitVec.signExtend 64 x * 6#64 < BitVec.signExtend 64 (BitVec.twoPow 32 31))
                          (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv x‚úù 10#32)
                            (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x‚úù))
                              (fun a =>
                                Eq.trans
                                  (ite_cond_eq_false (-x‚úù / -10#32) (-(-x‚úù / 10#32))
                                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 10#32))
                                      (eq_false' fun h => Bool.noConfusion h)))
                                  (Eq.trans (congrArg (fun x => -(x / 10#32)) (BitVec.neg_eq_not_add x‚úù))
                                    (BitVec.neg_eq_not_add ((~~~x‚úù + 1#32) / 10#32))))
                              fun a =>
                              ite_cond_eq_false (-(x‚úù / -10#32)) (x‚úù / 10#32)
                                (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 10#32))
                                  (eq_false' fun h => Bool.noConfusion h)))))
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                          (BitVec.signExtend 64
                              (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                            6#64)
                          (BitVec.signExtend 64 (BitVec.twoPow 32 31)))))
                    (Eq.trans
                      (Eq.trans
                        (congrArg (fun x => BitVec.signExtend 64 x * 6#64 ‚â• BitVec.twoPow 64 31)
                          (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv x‚úù 10#32)
                            (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last x‚úù))
                              (fun a =>
                                Eq.trans
                                  (ite_cond_eq_false (-x‚úù / -10#32) (-(-x‚úù / 10#32))
                                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 10#32))
                                      (eq_false' fun h => Bool.noConfusion h)))
                                  (Eq.trans (congrArg (fun x => -(x / 10#32)) (BitVec.neg_eq_not_add x‚úù))
                                    (BitVec.neg_eq_not_add ((~~~x‚úù + 1#32) / 10#32))))
                              fun a =>
                              ite_cond_eq_false (-(x‚úù / -10#32)) (x‚úù / 10#32)
                                (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 10#32))
                                  (eq_false' fun h => Bool.noConfusion h)))))
                        Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2)
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31)
                          (BitVec.signExtend 64
                              (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                            6#64))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult
                                (BitVec.signExtend 64
                                    (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                                  6#64)
                                (BitVec.twoPow 64 31)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 64 31 >·µ§
                                BitVec.signExtend 64
                                    (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                                  6#64)
                              true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true
                              (BitVec.twoPow 64 31 >·µ§
                                BitVec.signExtend 64
                                    (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                                  6#64)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 64 (BitVec.twoPow 32 31) >·µ§
                      BitVec.signExtend 64
                          (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                        6#64)
                    !BitVec.twoPow 64 31 >·µ§
                        BitVec.signExtend 64
                            (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                          6#64))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 64 (BitVec.twoPow 32 31) >·µ§
                        BitVec.signExtend 64
                            (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                          6#64)
                      !BitVec.twoPow 64 31 >·µ§
                          BitVec.signExtend 64
                              (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                            6#64)
                    (congrArg
                      (fun x =>
                        !((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >·µ§
                                BitVec.signExtend 64
                                    (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                                  6#64) &&
                            x))
                      (Bool.not_not
                        (BitVec.twoPow 64 31 >·µ§
                          BitVec.signExtend 64
                              (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                            6#64)))))))
            (true_and
              ((!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >·µ§
                        BitVec.signExtend 64
                            (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                          6#64) &&
                    BitVec.twoPow 64 31 >·µ§
                      BitVec.signExtend 64
                          (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                        6#64)) =
                true)) : (True ‚àß
              (BitVec.signExtend 64 (x‚úù.sdiv 10#32) * 6#64 < BitVec.signExtend 64 (BitVec.twoPow 32 31) ‚à®
                BitVec.signExtend 64 (x‚úù.sdiv 10#32) * 6#64 ‚â• BitVec.twoPow 64 31)) =
            ((!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >·µ§
                      BitVec.signExtend 64
                          (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                        6#64) &&
                  BitVec.twoPow 64 31 >·µ§
                    BitVec.signExtend 64
                        (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                      6#64)) =
              true))
        [Meta.isDefEq] [0.001712] ‚úÖÔ∏è (True ‚àß
                (BitVec.signExtend (2 * 32) (x‚úù.sdiv 10#32) * BitVec.signExtend (2 * 32) 6#32 <
                    BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ‚à®
                  BitVec.signExtend (2 * 32) (x‚úù.sdiv 10#32) * BitVec.signExtend (2 * 32) 6#32 ‚â•
                    BitVec.twoPow (2 * 32) (32 - 1))) =
              ((!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >·µ§
                        BitVec.signExtend 64
                            (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                          6#64) &&
                    BitVec.twoPow 64 31 >·µ§
                      BitVec.signExtend 64
                          (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                        6#64)) =
                true) =?= (True ‚àß
                (BitVec.signExtend 64 (x‚úù.sdiv 10#32) * 6#64 < BitVec.signExtend 64 (BitVec.twoPow 32 31) ‚à®
                  BitVec.signExtend 64 (x‚úù.sdiv 10#32) * 6#64 ‚â• BitVec.twoPow 64 31)) =
              ((!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >·µ§
                        BitVec.signExtend 64
                            (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                          6#64) &&
                    BitVec.twoPow 64 31 >·µ§
                      BitVec.signExtend 64
                          (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                        6#64)) =
                true)
          [Meta.isDefEq] [0.001693] ‚úÖÔ∏è True ‚àß
                (BitVec.signExtend (2 * 32) (x‚úù.sdiv 10#32) * BitVec.signExtend (2 * 32) 6#32 <
                    BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ‚à®
                  BitVec.signExtend (2 * 32) (x‚úù.sdiv 10#32) * BitVec.signExtend (2 * 32) 6#32 ‚â•
                    BitVec.twoPow (2 * 32)
                      (32 -
                        1)) =?= True ‚àß
                (BitVec.signExtend 64 (x‚úù.sdiv 10#32) * 6#64 < BitVec.signExtend 64 (BitVec.twoPow 32 31) ‚à®
                  BitVec.signExtend 64 (x‚úù.sdiv 10#32) * 6#64 ‚â• BitVec.twoPow 64 31)
            [Meta.isDefEq] [0.001676] ‚úÖÔ∏è BitVec.signExtend (2 * 32) (x‚úù.sdiv 10#32) * BitVec.signExtend (2 * 32) 6#32 <
                    BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ‚à®
                  BitVec.signExtend (2 * 32) (x‚úù.sdiv 10#32) * BitVec.signExtend (2 * 32) 6#32 ‚â•
                    BitVec.twoPow (2 * 32)
                      (32 -
                        1) =?= BitVec.signExtend 64 (x‚úù.sdiv 10#32) * 6#64 <
                    BitVec.signExtend 64 (BitVec.twoPow 32 31) ‚à®
                  BitVec.signExtend 64 (x‚úù.sdiv 10#32) * 6#64 ‚â• BitVec.twoPow 64 31
              [Meta.isDefEq] [0.001562] ‚úÖÔ∏è BitVec.signExtend (2 * 32) (x‚úù.sdiv 10#32) *
                      BitVec.signExtend (2 * 32) 6#32 <
                    BitVec.signExtend (2 * 32)
                      (BitVec.twoPow 32
                        (32 -
                          1)) =?= BitVec.signExtend 64 (x‚úù.sdiv 10#32) * 6#64 <
                    BitVec.signExtend 64 (BitVec.twoPow 32 31)
                [Meta.isDefEq] [0.001540] ‚úÖÔ∏è instLTBitVec.1
                      (BitVec.signExtend (2 * 32) (x‚úù.sdiv 10#32) * BitVec.signExtend (2 * 32) 6#32)
                      (BitVec.signExtend (2 * 32)
                        (BitVec.twoPow 32
                          (32 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 64 (x‚úù.sdiv 10#32) * 6#64)
                      (BitVec.signExtend 64 (BitVec.twoPow 32 31))
                  [Meta.isDefEq] [0.001492] ‚úÖÔ∏è (BitVec.signExtend (2 * 32) (x‚úù.sdiv 10#32) *
                            BitVec.signExtend (2 * 32) 6#32).toNat <
                        (BitVec.signExtend (2 * 32)
                            (BitVec.twoPow 32
                              (32 -
                                1))).toNat =?= (BitVec.signExtend 64 (x‚úù.sdiv 10#32) * 6#64).toNat <
                        (BitVec.signExtend 64 (BitVec.twoPow 32 31)).toNat
                    [Meta.isDefEq] [0.001479] ‚úÖÔ∏è instLTNat.1
                          (BitVec.signExtend (2 * 32) (x‚úù.sdiv 10#32) * BitVec.signExtend (2 * 32) 6#32).toNat
                          (BitVec.signExtend (2 * 32)
                              (BitVec.twoPow 32
                                (32 -
                                  1))).toNat =?= instLTNat.1 (BitVec.signExtend 64 (x‚úù.sdiv 10#32) * 6#64).toNat
                          (BitVec.signExtend 64 (BitVec.twoPow 32 31)).toNat
                      [Meta.isDefEq] [0.001448] ‚úÖÔ∏è (BitVec.signExtend (2 * 32) (x‚úù.sdiv 10#32) *
                                  BitVec.signExtend (2 * 32) 6#32).toNat.lt
                            (BitVec.signExtend (2 * 32)
                                (BitVec.twoPow 32
                                  (32 -
                                    1))).toNat =?= (BitVec.signExtend 64 (x‚úù.sdiv 10#32) * 6#64).toNat.lt
                            (BitVec.signExtend 64 (BitVec.twoPow 32 31)).toNat
                        [Meta.isDefEq.delta] [0.001437] ‚úÖÔ∏è (BitVec.signExtend (2 * 32) (x‚úù.sdiv 10#32) *
                                    BitVec.signExtend (2 * 32) 6#32).toNat.lt
                              (BitVec.signExtend (2 * 32)
                                  (BitVec.twoPow 32
                                    (32 -
                                      1))).toNat =?= (BitVec.signExtend 64 (x‚úù.sdiv 10#32) * 6#64).toNat.lt
                              (BitVec.signExtend 64 (BitVec.twoPow 32 31)).toNat
                          [Meta.isDefEq] [0.001345] ‚úÖÔ∏è (BitVec.signExtend (2 * 32) (x‚úù.sdiv 10#32) *
                                  BitVec.signExtend (2 * 32)
                                    6#32).toNat =?= (BitVec.signExtend 64 (x‚úù.sdiv 10#32) * 6#64).toNat
                            [Meta.isDefEq.delta] [0.001334] ‚úÖÔ∏è (BitVec.signExtend (2 * 32) (x‚úù.sdiv 10#32) *
                                    BitVec.signExtend (2 * 32)
                                      6#32).toNat =?= (BitVec.signExtend 64 (x‚úù.sdiv 10#32) * 6#64).toNat
                              [Meta.isDefEq] [0.001317] ‚úÖÔ∏è BitVec.signExtend (2 * 32) (x‚úù.sdiv 10#32) *
                                    BitVec.signExtend (2 * 32) 6#32 =?= BitVec.signExtend 64 (x‚úù.sdiv 10#32) * 6#64
                                [Meta.isDefEq] [0.001293] ‚úÖÔ∏è instHMul.1 (BitVec.signExtend (2 * 32) (x‚úù.sdiv 10#32))
                                      (BitVec.signExtend (2 * 32)
                                        6#32) =?= instHMul.1 (BitVec.signExtend 64 (x‚úù.sdiv 10#32)) 6#64
                                  [Meta.isDefEq] [0.001245] ‚úÖÔ∏è Mul.mul (BitVec.signExtend (2 * 32) (x‚úù.sdiv 10#32))
                                        (BitVec.signExtend (2 * 32)
                                          6#32) =?= Mul.mul (BitVec.signExtend 64 (x‚úù.sdiv 10#32)) 6#64
                                    [Meta.isDefEq] [0.001226] ‚úÖÔ∏è BitVec.instMul.1
                                          (BitVec.signExtend (2 * 32) (x‚úù.sdiv 10#32))
                                          (BitVec.signExtend (2 * 32)
                                            6#32) =?= BitVec.instMul.1 (BitVec.signExtend 64 (x‚úù.sdiv 10#32)) 6#64
                                      [Meta.isDefEq] [0.001182] ‚úÖÔ∏è (BitVec.signExtend (2 * 32) (x‚úù.sdiv 10#32)).mul
                                            (BitVec.signExtend (2 * 32)
                                              6#32) =?= (BitVec.signExtend 64 (x‚úù.sdiv 10#32)).mul 6#64
                                        [Meta.isDefEq.delta] [0.001172] ‚úÖÔ∏è (BitVec.signExtend (2 * 32)
                                                  (x‚úù.sdiv 10#32)).mul
                                              (BitVec.signExtend (2 * 32)
                                                6#32) =?= (BitVec.signExtend 64 (x‚úù.sdiv 10#32)).mul 6#64
                                          [Meta.isDefEq] [0.001100] ‚úÖÔ∏è BitVec.signExtend (2 * 32) 6#32 =?= 6#64
                                            [Meta.isDefEq] [0.001087] ‚úÖÔ∏è BitVec.ofInt (2 * 32) (6#32).toInt =?= 6#64
                                              [Meta.isDefEq] [0.001073] ‚úÖÔ∏è ((6#32).toInt %
                                                        Int.ofNat (2 ^ (2 * 32))).toNat#'‚ãØ =?= 6#64
                                                [Meta.isDefEq] [0.001056] ‚úÖÔ∏è ((6#32).toInt %
                                                          Int.ofNat
                                                            (2 ^
                                                              (2 * 32))).toNat#'‚ãØ =?= { toFin := Fin.ofNat' (2 ^ 64) 6 }
                                                  [Meta.isDefEq] [0.001043] ‚úÖÔ∏è {
                                                        toFin :=
                                                          ‚ü®((6#32).toInt % Int.ofNat (2 ^ (2 * 32))).toNat,
                                                            ‚ãØ‚ü© } =?= { toFin := Fin.ofNat' (2 ^ 64) 6 }
                                                    [Meta.isDefEq] [0.001011] ‚úÖÔ∏è ‚ü®((6#32).toInt %
                                                              Int.ofNat (2 ^ (2 * 32))).toNat,
                                                          ‚ãØ‚ü© =?= Fin.ofNat' (2 ^ 64) 6
  [Meta.isDefEq] [0.002882] ‚úÖÔ∏è if ?b then ?x
      else ?y =?= if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨((Option.map (fun div => x‚úù + (~~~(div * 10#32) + 1#32))
                  (some (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32))).bind
              fun a =>
              some ((if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) <<< 4 + a)) ‚äë
            if
                (!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >·µ§
                          BitVec.signExtend 64
                              (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                            6#64) &&
                      BitVec.twoPow 64 31 >·µ§
                        BitVec.signExtend 64
                            (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) *
                          6#64)) =
                  true then
              none
            else some ((if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 10#32) + 1#32 else x‚úù / 10#32) * 6#32 + x‚úù)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gadd4_proof.lean:100:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gadd4_proof.lean:93:8: error: (kernel) declaration has metavariables 'fold_add_udiv_urem_to_mul_thm'
[bv] [0.011063] Normalizing goal
  [Meta.synthInstance] [0.001143] ‚úÖÔ∏è Decidable
        ((if 7#32 = 0 then none else if 7#32 = 0 then none else some (x‚úù / 7#32 * 21#32 + x‚úù % 7#32 * 3#32)) ‚äë
          some (x‚úù * 3#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if 7#32 = 0 then none else if 7#32 = 0 then none else some (x‚úù / 7#32 * 21#32 + x‚úù % 7#32 * 3#32)) ‚äë
            some (x‚úù * 3#32)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù : ¬¨some (x‚úù / 7#32 * 21#32 + x‚úù % 7#32 * 3#32) ‚äë some (x‚úù * 3#32)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gadd4_proof.lean:111:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gadd4_proof.lean:104:8: error: (kernel) declaration has metavariables 'fold_add_udiv_urem_commuted_thm'
[bv] [0.031577] Normalizing goal
  [Meta.synthInstance] [0.001679] ‚úÖÔ∏è Decidable
        ((if 10#32 = 0 then none
          else if 10#32 = 0 then none else if 4#32 ‚â• ‚Üë32 then none else some (x‚úù % 10#32 + (x‚úù / 10#32) <<< 4#32)) ‚äë
          if 10#32 = 0 then none
          else
            if
                True ‚àß
                  BitVec.zeroExtend (2 * 32) (x‚úù / 10#32) * BitVec.zeroExtend (2 * 32) 6#32 ‚â•
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else some (x‚úù / 10#32 * 6#32 + x‚úù))
    [Meta.check] [0.001060] ‚úÖÔ∏è BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if 10#32 = 0 then none
          else if 10#32 = 0 then none else if 4#32 ‚â• ‚Üë32 then none else some (x‚úù % 10#32 + (x‚úù / 10#32) <<< 4#32))
          (if 10#32 = 0 then none
          else
            if
                True ‚àß
                  BitVec.zeroExtend (2 * 32) (x‚úù / 10#32) * BitVec.zeroExtend (2 * 32) 6#32 ‚â•
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else some (x‚úù / 10#32 * 6#32 + x‚úù))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if 10#32 = 0 then none
            else if 10#32 = 0 then none else if 4#32 ‚â• ‚Üë32 then none else some (x‚úù % 10#32 + (x‚úù / 10#32) <<< 4#32)) ‚äë
            if 10#32 = 0 then none
            else
              if
                  True ‚àß
                    BitVec.zeroExtend (2 * 32) (x‚úù / 10#32) * BitVec.zeroExtend (2 * 32) 6#32 ‚â•
                      BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                none
              else some (x‚úù / 10#32 * 6#32 + x‚úù)
      ‚ä¢ False
  [Meta.isDefEq] [0.001375] ‚úÖÔ∏è ?h‚ÇÅ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                (BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64)
                      (BitVec.twoPow 64 31 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64)))))))
        (true_and ((!BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64) = true))
    [Meta.isDefEq.assign] [0.001372] ‚úÖÔ∏è ?h‚ÇÅ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                  (BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64)
                        (BitVec.twoPow 64 31 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64)))))))
          (true_and ((!BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001360] ‚úÖÔ∏è (?h‚ÇÅ : (True ‚àß
              BitVec.zeroExtend (2 * 32) (x‚úù / 10#32) * BitVec.zeroExtend (2 * 32) 6#32 ‚â•
                BitVec.twoPow (2 * 32) (32 - 1) <<< 1) =
            ((!BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                    (BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64)
                          (BitVec.twoPow 64 31 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64)))))))
            (true_and
              ((!BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64) =
                true)) : (True ‚àß BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64 ‚â• BitVec.twoPow 64 31 <<< 1) =
            ((!BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64) = true))
        [Meta.isDefEq] [0.001356] ‚úÖÔ∏è (True ‚àß
                BitVec.zeroExtend (2 * 32) (x‚úù / 10#32) * BitVec.zeroExtend (2 * 32) 6#32 ‚â•
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1) =
              ((!BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64) =
                true) =?= (True ‚àß BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64 ‚â• BitVec.twoPow 64 31 <<< 1) =
              ((!BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64) = true)
          [Meta.isDefEq] [0.001337] ‚úÖÔ∏è True ‚àß
                BitVec.zeroExtend (2 * 32) (x‚úù / 10#32) * BitVec.zeroExtend (2 * 32) 6#32 ‚â•
                  BitVec.twoPow (2 * 32) (32 - 1) <<<
                    1 =?= True ‚àß BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64 ‚â• BitVec.twoPow 64 31 <<< 1
            [Meta.isDefEq] [0.001322] ‚úÖÔ∏è BitVec.zeroExtend (2 * 32) (x‚úù / 10#32) * BitVec.zeroExtend (2 * 32) 6#32 ‚â•
                  BitVec.twoPow (2 * 32) (32 - 1) <<<
                    1 =?= BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64 ‚â• BitVec.twoPow 64 31 <<< 1
              [Meta.isDefEq.delta] [0.001303] ‚úÖÔ∏è BitVec.zeroExtend (2 * 32) (x‚úù / 10#32) *
                      BitVec.zeroExtend (2 * 32) 6#32 ‚â•
                    BitVec.twoPow (2 * 32) (32 - 1) <<<
                      1 =?= BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64 ‚â• BitVec.twoPow 64 31 <<< 1
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨some (x‚úù % 10#32 + (x‚úù / 10#32) <<< 4) ‚äë
            if (!BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64) = true then none
            else some (x‚úù / 10#32 * 6#32 + x‚úù)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gadd4_proof.lean:122:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gadd4_proof.lean:115:8: error: (kernel) declaration has metavariables 'fold_add_udiv_urem_or_disjoint_thm'
[bv] [0.031627] Normalizing goal
  [Meta.synthInstance] [0.001680] ‚úÖÔ∏è Decidable
        ((if 10#32 = 0 then none
          else if 4#32 ‚â• ‚Üë32 then none else if 10#32 = 0 then none else some ((x‚úù / 10#32) <<< 4#32 ||| x‚úù % 10#32)) ‚äë
          if 10#32 = 0 then none
          else
            if
                True ‚àß
                  BitVec.zeroExtend (2 * 32) (x‚úù / 10#32) * BitVec.zeroExtend (2 * 32) 6#32 ‚â•
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else some (x‚úù / 10#32 * 6#32 + x‚úù))
    [Meta.check] [0.001073] ‚úÖÔ∏è BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if 10#32 = 0 then none
          else if 4#32 ‚â• ‚Üë32 then none else if 10#32 = 0 then none else some ((x‚úù / 10#32) <<< 4#32 ||| x‚úù % 10#32))
          (if 10#32 = 0 then none
          else
            if
                True ‚àß
                  BitVec.zeroExtend (2 * 32) (x‚úù / 10#32) * BitVec.zeroExtend (2 * 32) 6#32 ‚â•
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else some (x‚úù / 10#32 * 6#32 + x‚úù))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if 10#32 = 0 then none
            else if 4#32 ‚â• ‚Üë32 then none else if 10#32 = 0 then none else some ((x‚úù / 10#32) <<< 4#32 ||| x‚úù % 10#32)) ‚äë
            if 10#32 = 0 then none
            else
              if
                  True ‚àß
                    BitVec.zeroExtend (2 * 32) (x‚úù / 10#32) * BitVec.zeroExtend (2 * 32) 6#32 ‚â•
                      BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                none
              else some (x‚úù / 10#32 * 6#32 + x‚úù)
      ‚ä¢ False
  [Meta.isDefEq] [0.001442] ‚úÖÔ∏è ?h‚ÇÅ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                (BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64)
                      (BitVec.twoPow 64 31 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64)))))))
        (true_and ((!BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64) = true))
    [Meta.isDefEq.assign] [0.001440] ‚úÖÔ∏è ?h‚ÇÅ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                  (BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64)
                        (BitVec.twoPow 64 31 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64)))))))
          (true_and ((!BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001426] ‚úÖÔ∏è (?h‚ÇÅ : (True ‚àß
              BitVec.zeroExtend (2 * 32) (x‚úù / 10#32) * BitVec.zeroExtend (2 * 32) 6#32 ‚â•
                BitVec.twoPow (2 * 32) (32 - 1) <<< 1) =
            ((!BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                    (BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64)
                          (BitVec.twoPow 64 31 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64)))))))
            (true_and
              ((!BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64) =
                true)) : (True ‚àß BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64 ‚â• BitVec.twoPow 64 31 <<< 1) =
            ((!BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64) = true))
        [Meta.isDefEq] [0.001422] ‚úÖÔ∏è (True ‚àß
                BitVec.zeroExtend (2 * 32) (x‚úù / 10#32) * BitVec.zeroExtend (2 * 32) 6#32 ‚â•
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1) =
              ((!BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64) =
                true) =?= (True ‚àß BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64 ‚â• BitVec.twoPow 64 31 <<< 1) =
              ((!BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64) = true)
          [Meta.isDefEq] [0.001404] ‚úÖÔ∏è True ‚àß
                BitVec.zeroExtend (2 * 32) (x‚úù / 10#32) * BitVec.zeroExtend (2 * 32) 6#32 ‚â•
                  BitVec.twoPow (2 * 32) (32 - 1) <<<
                    1 =?= True ‚àß BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64 ‚â• BitVec.twoPow 64 31 <<< 1
            [Meta.isDefEq] [0.001389] ‚úÖÔ∏è BitVec.zeroExtend (2 * 32) (x‚úù / 10#32) * BitVec.zeroExtend (2 * 32) 6#32 ‚â•
                  BitVec.twoPow (2 * 32) (32 - 1) <<<
                    1 =?= BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64 ‚â• BitVec.twoPow 64 31 <<< 1
              [Meta.isDefEq.delta] [0.001369] ‚úÖÔ∏è BitVec.zeroExtend (2 * 32) (x‚úù / 10#32) *
                      BitVec.zeroExtend (2 * 32) 6#32 ‚â•
                    BitVec.twoPow (2 * 32) (32 - 1) <<<
                      1 =?= BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64 ‚â• BitVec.twoPow 64 31 <<< 1
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨some ((x‚úù / 10#32) <<< 4 ||| x‚úù % 10#32) ‚äë
            if (!BitVec.twoPow 64 31 <<< 1 >·µ§ BitVec.zeroExtend 64 (x‚úù / 10#32) * 6#64) = true then none
            else some (x‚úù / 10#32 * 6#32 + x‚úù)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gadd4_proof.lean:133:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gadd4_proof.lean:126:8: error: (kernel) declaration has metavariables 'fold_add_udiv_urem_without_noundef_thm'
[bv] [0.013331] Normalizing goal
  [Meta.synthInstance] [0.001221] ‚úÖÔ∏è Decidable
        ((if 10#32 = 0 then none
          else if 4#32 ‚â• ‚Üë32 then none else if 10#32 = 0 then none else some ((x‚úù / 10#32) <<< 4#32 + x‚úù % 10#32)) ‚äë
          if 10#32 = 0 then none
          else if 4#32 ‚â• ‚Üë32 then none else if 10#32 = 0 then none else some ((x‚úù / 10#32) <<< 4#32 ||| x‚úù % 10#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if 10#32 = 0 then none
            else if 4#32 ‚â• ‚Üë32 then none else if 10#32 = 0 then none else some ((x‚úù / 10#32) <<< 4#32 + x‚úù % 10#32)) ‚äë
            if 10#32 = 0 then none
            else if 4#32 ‚â• ‚Üë32 then none else if 10#32 = 0 then none else some ((x‚úù / 10#32) <<< 4#32 ||| x‚úù % 10#32)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù : ¬¨some ((x‚úù / 10#32) <<< 4 + x‚úù % 10#32) ‚äë some ((x‚úù / 10#32) <<< 4 ||| x‚úù % 10#32)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
