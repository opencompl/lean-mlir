âš  [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
âš  [878/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
âš  [881/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
âš  [887/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
âš  [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:16:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:11:8: error: (kernel) declaration has metavariables 'test1_thm'
[bv] [0.044024] Normalizing goal
  [Meta.synthInstance] [0.001619] âœ…ï¸ Decidable
        (Option.map (fun div => xâœ - div * 1#32)
            (if (1#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 1#32 == -1) = true then none
            else some (xâœ.sdiv 1#32)) âŠ‘
          some 0#32)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬Option.map (fun div => xâœ - div * 1#32)
              (if (1#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 1#32 == -1) = true then none
              else some (xâœ.sdiv 1#32)) âŠ‘
            some 0#32
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ : Â¬Option.map (fun div => xâœ + (~~~div + 1#32)) (some xâœ) âŠ‘ some 0#32
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:25:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:20:8: error: (kernel) declaration has metavariables 'test3_thm'
[bv] [0.009031] Normalizing goal
  [Meta.synthInstance] [0.001010] âœ…ï¸ Decidable ((if 8#32 = 0 then none else some (xâœ % 8#32)) âŠ‘ some (xâœ &&& 7#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ : Â¬(if 8#32 = 0 then none else some (xâœ % 8#32)) âŠ‘ some (xâœ &&& 7#32)
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ : Â¬some (xâœ % 8#32) âŠ‘ some (xâœ &&& 7#32)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:36:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:29:8: error: (kernel) declaration has metavariables 'test3a_thm'
[bv] [0.056061] Normalizing goal
  [Meta.synthInstance] [0.001284] âœ…ï¸ Decidable
        (((Option.map (fun div => xâœ - div * 4294967288#32)
                (if (4294967288#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 4294967288#32 == -1) = true then none
                else some (xâœ.sdiv 4294967288#32))).bind
            fun x' => some (BitVec.ofBool (x' != 0#32))) âŠ‘
          some (BitVec.ofBool (xâœ &&& 7#32 != 0#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬((Option.map (fun div => xâœ - div * 4294967288#32)
                  (if (4294967288#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 4294967288#32 == -1) = true then none
                  else some (xâœ.sdiv 4294967288#32))).bind
              fun x' => some (BitVec.ofBool (x' != 0#32))) âŠ‘
            some (BitVec.ofBool (xâœ &&& 7#32 != 0#32))
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬((Option.map (fun div => xâœ + (~~~(div * 4294967288#32) + 1#32))
                  (some (if xâœ.getLsbD 31 = true then (~~~xâœ + 1#32) / 8#32 else ~~~(xâœ / 8#32) + 1#32))).bind
              fun a => some (if (!a == 0#32) = true then 1#1 else 0#1)) âŠ‘
            some (if (!xâœ &&& 7#32 == 0#32) = true then 1#1 else 0#1)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:46:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:40:8: error: (kernel) declaration has metavariables 'test4_thm'
[bv] [0.055903] Normalizing goal
  [Meta.synthInstance] [0.001451] âœ…ï¸ Decidable
        ((Option.bind
            (match some xâœÂ¹ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some 1#32
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some 8#32)
            fun y' => if y' = 0 then none else some (xâœ % y')) âŠ‘
          Option.bind
            (match some xâœÂ¹ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some 0#32
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some 7#32)
            fun y' => some (xâœ &&& y'))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 1
      e_1 : LLVM.IntW 32
      xâœÂ¹ : BitVec 1
      xâœ : BitVec 32
      aâœ :
        Â¬(Option.bind
              (match some xâœÂ¹ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some 1#32
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some 8#32)
              fun y' => if y' = 0 then none else some (xâœ % y')) âŠ‘
            Option.bind
              (match some xâœÂ¹ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some 0#32
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some 7#32)
              fun y' => some (xâœ &&& y')
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 1
      e_1 : LLVM.IntW 32
      xâœÂ¹ : BitVec 1
      xâœ : BitVec 32
      aâœ :
        Â¬(Option.bind
              (match some xâœÂ¹ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some 1#32
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some 8#32)
              fun a => if (a == 0#32) = true then none else some (xâœ % a)) âŠ‘
            Option.bind
              (match some xâœÂ¹ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some 0#32
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some 7#32)
              fun y' => some (xâœ &&& y')
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:57:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:50:8: error: (kernel) declaration has metavariables 'test5_thm'
[bv] [0.043267] Normalizing goal
  [Meta.synthInstance] [0.001456] âœ…ï¸ Decidable
        ((if BitVec.zeroExtend 32 xâœÂ¹ â‰¥ â†‘32 then none
          else
            if 32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ = 0 then none else some (xâœ % 32#32 <<< BitVec.zeroExtend 32 xâœÂ¹)) âŠ‘
          if True âˆ§ 32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ >>> BitVec.zeroExtend 32 xâœÂ¹ = 32#32 then none
          else
            if BitVec.zeroExtend 32 xâœÂ¹ â‰¥ â†‘32 then none else some (xâœ &&& 32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ + -1#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 32
      xâœÂ¹ : BitVec 8
      xâœ : BitVec 32
      aâœ :
        Â¬(if BitVec.zeroExtend 32 xâœÂ¹ â‰¥ â†‘32 then none
            else
              if 32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ = 0 then none else some (xâœ % 32#32 <<< BitVec.zeroExtend 32 xâœÂ¹)) âŠ‘
            if True âˆ§ 32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ >>> BitVec.zeroExtend 32 xâœÂ¹ = 32#32 then none
            else
              if BitVec.zeroExtend 32 xâœÂ¹ â‰¥ â†‘32 then none else some (xâœ &&& 32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ + -1#32)
      âŠ¢ False
  [Meta.isDefEq] [0.001992] âœ…ï¸ ?x > ?y =?= BitVec.zeroExtend 32 xâœÂ¹ < 32#32
  [Meta.isDefEq] [0.001333] âœ…ï¸ ?hâ‚ƒ =?= fun a =>
        Eq.refl (some (xâœ &&& 32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ + 4294967295#32))
    [Meta.isDefEq.assign] [0.001330] âœ…ï¸ ?hâ‚ƒ := fun a =>
          Eq.refl (some (xâœ &&& 32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ + 4294967295#32))
      [Meta.isDefEq.assign.checkTypes] [0.001304] âœ…ï¸ (?hâ‚ƒ : Â¬(!32#32 >áµ¤ BitVec.zeroExtend 32 xâœÂ¹) = true â†’
            some (xâœ &&& 32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ + -1#32) =
              some
                (xâœ &&&
                  32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ +
                    4294967295#32)) := (fun a =>
            Eq.refl
              (some
                (xâœ &&&
                  32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ +
                    4294967295#32)) : Â¬(!32#32 >áµ¤ BitVec.zeroExtend 32 xâœÂ¹) = true â†’
            some (xâœ &&& 32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ + 4294967295#32) =
              some (xâœ &&& 32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ + 4294967295#32))
        [Meta.isDefEq] [0.001301] âœ…ï¸ Â¬(!32#32 >áµ¤ BitVec.zeroExtend 32 xâœÂ¹) = true â†’
              some (xâœ &&& 32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ + -1#32) =
                some
                  (xâœ &&&
                    32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ +
                      4294967295#32) =?= Â¬(!32#32 >áµ¤ BitVec.zeroExtend 32 xâœÂ¹) = true â†’
              some (xâœ &&& 32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ + 4294967295#32) =
                some (xâœ &&& 32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ + 4294967295#32)
          [Meta.isDefEq] [0.001270] âœ…ï¸ some (xâœ &&& 32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ + -1#32) =
                some
                  (xâœ &&&
                    32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ +
                      4294967295#32) =?= some (xâœ &&& 32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ + 4294967295#32) =
                some (xâœ &&& 32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ + 4294967295#32)
            [Meta.isDefEq] [0.001252] âœ…ï¸ some
                  (xâœ &&&
                    32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ +
                      -1#32) =?= some (xâœ &&& 32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ + 4294967295#32)
              [Meta.isDefEq] [0.001231] âœ…ï¸ xâœ &&&
                    32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ +
                      -1#32 =?= xâœ &&& 32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ + 4294967295#32
                [Meta.isDefEq] [0.001206] âœ…ï¸ instHAndOfAndOp.1 xâœ
                      (32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ +
                        -1#32) =?= instHAndOfAndOp.1 xâœ (32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ + 4294967295#32)
                  [Meta.isDefEq] [0.001150] âœ…ï¸ AndOp.and xâœ
                        (32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ +
                          -1#32) =?= AndOp.and xâœ (32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ + 4294967295#32)
                    [Meta.isDefEq] [0.001118] âœ…ï¸ BitVec.instAndOp.1 xâœ
                          (32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ +
                            -1#32) =?= BitVec.instAndOp.1 xâœ (32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ + 4294967295#32)
                      [Meta.isDefEq] [0.001076] âœ…ï¸ xâœ.and
                            (32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ +
                              -1#32) =?= xâœ.and (32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ + 4294967295#32)
                        [Meta.isDefEq.delta] [0.001066] âœ…ï¸ xâœ.and
                              (32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ +
                                -1#32) =?= xâœ.and (32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ + 4294967295#32)
                          [Meta.isDefEq] [0.001039] âœ…ï¸ 32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ +
                                -1#32 =?= 32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ + 4294967295#32
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 32
      xâœÂ¹ : BitVec 8
      xâœ : BitVec 32
      aâœ :
        Â¬(if (!32#32 >áµ¤ BitVec.zeroExtend 32 xâœÂ¹) = true then none
            else
              if (32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ == 0#32) = true then none
              else some (xâœ % 32#32 <<< BitVec.zeroExtend 32 xâœÂ¹)) âŠ‘
            if (32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ >>> BitVec.zeroExtend 32 xâœÂ¹ == 32#32) = true then none
            else
              if (!32#32 >áµ¤ BitVec.zeroExtend 32 xâœÂ¹) = true then none
              else some (xâœ &&& 32#32 <<< BitVec.zeroExtend 32 xâœÂ¹ + 4294967295#32)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:66:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:61:8: error: (kernel) declaration has metavariables 'test7_thm'
[bv] [0.035499] Normalizing goal
  [Meta.synthInstance] [0.001220] âœ…ï¸ Decidable
        (Option.map (fun div => xâœ * 8#32 - div * 4#32)
            (if (4#32 == 0 || 32 != 1 && xâœ * 8#32 == BitVec.intMin 32 && 4#32 == -1) = true then none
            else some ((xâœ * 8#32).sdiv 4#32)) âŠ‘
          some 0#32)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬Option.map (fun div => xâœ * 8#32 - div * 4#32)
              (if (4#32 == 0 || 32 != 1 && xâœ * 8#32 == BitVec.intMin 32 && 4#32 == -1) = true then none
              else some ((xâœ * 8#32).sdiv 4#32)) âŠ‘
            some 0#32
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬Option.map (fun div => xâœ * 8#32 + (~~~(div * 4#32) + 1#32))
              (some
                (if (xâœ * 8#32).getLsbD 31 = true then ~~~((~~~(xâœ * 8#32) + 1#32) / 4#32) + 1#32
                else xâœ * 8#32 / 4#32)) âŠ‘
            some 0#32
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:75:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:70:8: error: (kernel) declaration has metavariables 'test8_thm'
[bv] [0.040048] Normalizing goal
  [Meta.synthInstance] [0.001437] âœ…ï¸ Decidable
        ((if 4#32 â‰¥ â†‘32 then none
          else
            Option.map (fun div => xâœ <<< 4#32 - div * 8#32)
              (if (8#32 == 0 || 32 != 1 && xâœ <<< 4#32 == BitVec.intMin 32 && 8#32 == -1) = true then none
              else some ((xâœ <<< 4#32).sdiv 8#32))) âŠ‘
          some 0#32)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(if 4#32 â‰¥ â†‘32 then none
            else
              Option.map (fun div => xâœ <<< 4#32 - div * 8#32)
                (if (8#32 == 0 || 32 != 1 && xâœ <<< 4#32 == BitVec.intMin 32 && 8#32 == -1) = true then none
                else some ((xâœ <<< 4#32).sdiv 8#32))) âŠ‘
            some 0#32
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬Option.map (fun div => xâœ <<< 4 + (~~~(div * 8#32) + 1#32))
              (some
                (if (xâœ <<< 4).getLsbD 31 = true then ~~~((~~~(xâœ <<< 4) + 1#32) / 8#32) + 1#32 else xâœ <<< 4 / 8#32)) âŠ‘
            some 0#32
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:84:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:79:8: error: (kernel) declaration has metavariables 'test9_thm'
[bv] [0.011832] Normalizing goal
  [Meta.synthInstance] [0.001609] âœ…ï¸ Decidable ((if 32#32 = 0 then none else some (xâœ * 64#32 % 32#32)) âŠ‘ some 0#32)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ : Â¬(if 32#32 = 0 then none else some (xâœ * 64#32 % 32#32)) âŠ‘ some 0#32
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ : Â¬some (xâœ * 64#32 % 32#32) âŠ‘ some 0#32
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:94:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:88:8: error: (kernel) declaration has metavariables 'test10_thm'
[bv] [0.013704] Normalizing goal
  [Meta.synthInstance] [0.001623] âœ…ï¸ Decidable
        ((if 4#64 = 0 then none
          else some (BitVec.truncate 32 (BitVec.signExtend 64 (BitVec.zeroExtend 32 xâœ * 4#32) % 4#64))) âŠ‘
          some 0#32)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      xâœ : BitVec 8
      aâœ :
        Â¬(if 4#64 = 0 then none
            else some (BitVec.truncate 32 (BitVec.signExtend 64 (BitVec.zeroExtend 32 xâœ * 4#32) % 4#64))) âŠ‘
            some 0#32
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      xâœ : BitVec 8
      aâœ : Â¬some (BitVec.zeroExtend 32 (BitVec.signExtend 64 (BitVec.zeroExtend 32 xâœ * 4#32) % 4#64)) âŠ‘ some 0#32
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:104:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:98:8: error: (kernel) declaration has metavariables 'test11_thm'
[bv] [0.008428] Normalizing goal
  [Meta.synthInstance] [0.001046] âœ…ï¸ Decidable
        ((if 4#32 = 0 then none else some ((xâœ &&& 4294967294#32) * 2#32 % 4#32)) âŠ‘ some 0#32)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ : Â¬(if 4#32 = 0 then none else some ((xâœ &&& 4294967294#32) * 2#32 % 4#32)) âŠ‘ some 0#32
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ : Â¬some ((xâœ &&& 4294967294#32) * 2#32 % 4#32) âŠ‘ some 0#32
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:113:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:108:8: error: (kernel) declaration has metavariables 'test12_thm'
[bv] [0.053178] Normalizing goal
  [Meta.synthInstance] [0.001230] âœ…ï¸ Decidable
        (Option.map (fun div => (xâœ &&& 4294967292#32) - div * 2#32)
            (if (2#32 == 0 || 32 != 1 && xâœ &&& 4294967292#32 == BitVec.intMin 32 && 2#32 == -1) = true then none
            else some ((xâœ &&& 4294967292#32).sdiv 2#32)) âŠ‘
          some 0#32)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬Option.map (fun div => (xâœ &&& 4294967292#32) - div * 2#32)
              (if (2#32 == 0 || 32 != 1 && xâœ &&& 4294967292#32 == BitVec.intMin 32 && 2#32 == -1) = true then none
              else some ((xâœ &&& 4294967292#32).sdiv 2#32)) âŠ‘
            some 0#32
      âŠ¢ False
  [Meta.isDefEq] [0.002488] âŒï¸ ?a == ?a =?= 2#32 == 0#32
    [Meta.isDefEq.onFailure] [0.002214] âŒï¸ ?a == ?a =?= 2#32 == 0#32
      [Meta.synthInstance] [0.002193] ğŸ’¥ï¸ BEq ?Î±
        [Meta.synthInstance] [0.002113] new goal BEq ?Î±
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬Option.map (fun div => (xâœ &&& 4294967292#32) + (~~~(div * 2#32) + 1#32))
              (some
                (if (xâœ &&& 4294967292#32).getLsbD 31 = true then ~~~((~~~(xâœ &&& 4294967292#32) + 1#32) / 2#32) + 1#32
                else (xâœ &&& 4294967292#32) / 2#32)) âŠ‘
            some 0#32
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:122:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:117:8: error: (kernel) declaration has metavariables 'test13_thm'
[bv] [0.084286] Normalizing goal
  [Meta.synthInstance] [0.001820] âœ…ï¸ Decidable
        (Option.map (fun div => xâœ - div * xâœ)
            (if (xâœ == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && xâœ == -1) = true then none else some (xâœ.sdiv xâœ)) âŠ‘
          some 0#32)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬Option.map (fun div => xâœ - div * xâœ)
              (if (xâœ == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && xâœ == -1) = true then none else some (xâœ.sdiv xâœ)) âŠ‘
            some 0#32
      âŠ¢ False
  [Meta.isDefEq] [0.002148] âœ…ï¸ ?hâ‚ =?= congrArg (fun x => x = true)
        (Eq.trans (congrArg (fun x => xâœ == 0#32 || x && xâœ == 4294967295#32) (Bool.true_and (xâœ == BitVec.intMin 32)))
          (Std.Tactic.BVDecide.Normalize.Bool.or_elim (xâœ == 0#32) (xâœ == BitVec.intMin 32 && xâœ == 4294967295#32)))
    [Meta.isDefEq.assign] [0.002144] âœ…ï¸ ?hâ‚ := congrArg (fun x => x = true)
          (Eq.trans
            (congrArg (fun x => xâœ == 0#32 || x && xâœ == 4294967295#32) (Bool.true_and (xâœ == BitVec.intMin 32)))
            (Std.Tactic.BVDecide.Normalize.Bool.or_elim (xâœ == 0#32) (xâœ == BitVec.intMin 32 && xâœ == 4294967295#32)))
      [Meta.isDefEq.assign.checkTypes] [0.002125] âœ…ï¸ (?hâ‚ : ((xâœ == 0 ||
                32 != 1 && xâœ == BitVec.intMin 32 && xâœ == -1) =
              true) =
            ((!(!xâœ == 0#32 && !(xâœ == BitVec.intMin 32 && xâœ == 4294967295#32))) =
              true)) := (congrArg (fun x => x = true)
            (Eq.trans
              (congrArg (fun x => xâœ == 0#32 || x && xâœ == 4294967295#32) (Bool.true_and (xâœ == BitVec.intMin 32)))
              (Std.Tactic.BVDecide.Normalize.Bool.or_elim (xâœ == 0#32)
                (xâœ == BitVec.intMin 32 &&
                  xâœ ==
                    4294967295#32))) : ((xâœ == 0#32 || true && xâœ == BitVec.intMin 32 && xâœ == 4294967295#32) = true) =
            ((!(!xâœ == 0#32 && !(xâœ == BitVec.intMin 32 && xâœ == 4294967295#32))) = true))
        [Meta.isDefEq] [0.002121] âœ…ï¸ ((xâœ == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && xâœ == -1) = true) =
              ((!(!xâœ == 0#32 && !(xâœ == BitVec.intMin 32 && xâœ == 4294967295#32))) =
                true) =?= ((xâœ == 0#32 || true && xâœ == BitVec.intMin 32 && xâœ == 4294967295#32) = true) =
              ((!(!xâœ == 0#32 && !(xâœ == BitVec.intMin 32 && xâœ == 4294967295#32))) = true)
          [Meta.isDefEq] [0.002092] âœ…ï¸ (xâœ == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && xâœ == -1) =
                true =?= (xâœ == 0#32 || true && xâœ == BitVec.intMin 32 && xâœ == 4294967295#32) = true
            [Meta.isDefEq] [0.002069] âœ…ï¸ xâœ == 0 ||
                  32 != 1 && xâœ == BitVec.intMin 32 &&
                    xâœ == -1 =?= xâœ == 0#32 || true && xâœ == BitVec.intMin 32 && xâœ == 4294967295#32
              [Meta.isDefEq.delta] [0.002049] âœ…ï¸ xâœ == 0 ||
                    32 != 1 && xâœ == BitVec.intMin 32 &&
                      xâœ == -1 =?= xâœ == 0#32 || true && xâœ == BitVec.intMin 32 && xâœ == 4294967295#32
                [Meta.isDefEq] [0.001648] âœ…ï¸ 32 != 1 && xâœ == BitVec.intMin 32 &&
                      xâœ == -1 =?= true && xâœ == BitVec.intMin 32 && xâœ == 4294967295#32
                  [Meta.isDefEq.delta] [0.001608] âœ…ï¸ 32 != 1 && xâœ == BitVec.intMin 32 &&
                        xâœ == -1 =?= true && xâœ == BitVec.intMin 32 && xâœ == 4294967295#32
                    [Meta.isDefEq] [0.001122] âœ…ï¸ xâœ == -1 =?= xâœ == 4294967295#32
                      [Meta.isDefEq] [0.001093] âœ…ï¸ instBEqOfDecidableEq.1 xâœ
                            (-1) =?= instBEqOfDecidableEq.1 xâœ 4294967295#32
                        [Meta.isDefEq] [0.001048] âœ…ï¸ Decidable.decide
                              (xâœ = -1) =?= Decidable.decide (xâœ = 4294967295#32)
                          [Meta.isDefEq.delta] [0.001027] âœ…ï¸ Decidable.decide
                                (xâœ = -1) =?= Decidable.decide (xâœ = 4294967295#32)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬Option.map (fun div => xâœ + (~~~(div * xâœ) + 1#32))
              (if (!(!xâœ == 0#32 && !(xâœ == BitVec.intMin 32 && xâœ == 4294967295#32))) = true then none
              else
                some
                  (if xâœ.getLsbD 31 = true then
                    if xâœ.getLsbD 31 = true then (~~~xâœ + 1#32) / (~~~xâœ + 1#32) else ~~~((~~~xâœ + 1#32) / xâœ) + 1#32
                  else if xâœ.getLsbD 31 = true then ~~~(xâœ / (~~~xâœ + 1#32)) + 1#32 else xâœ / xâœ)) âŠ‘
            some 0#32
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:135:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:126:8: error: (kernel) declaration has metavariables 'test14_thm'
[bv] [0.079956] Normalizing goal
  [Meta.synthInstance] [0.002631] âœ…ï¸ Decidable
        ((if xâœÂ¹ â‰¥ â†‘32 then none
          else
            if BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) = 0 then none else some (xâœ % BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹))) âŠ‘
          if True âˆ§ 1#32 <<< xâœÂ¹ >>> xâœÂ¹ = 1#32 then none
          else
            if xâœÂ¹ â‰¥ â†‘32 then none
            else
              if
                  True âˆ§
                    (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).msb = (-1#64).msb âˆ§
                      (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + -1#64).msb â‰  (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).msb then
                none
              else some (xâœ &&& BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + -1#64))
    [Meta.check] [0.001630] âœ…ï¸ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if xâœÂ¹ â‰¥ â†‘32 then none
          else
            if BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) = 0 then none else some (xâœ % BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)))
          (if True âˆ§ 1#32 <<< xâœÂ¹ >>> xâœÂ¹ = 1#32 then none
          else
            if xâœÂ¹ â‰¥ â†‘32 then none
            else
              if
                  True âˆ§
                    (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).msb = (-1#64).msb âˆ§
                      (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + -1#64).msb â‰  (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).msb then
                none
              else some (xâœ &&& BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + -1#64))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      e_1 : LLVM.IntW 64
      xâœÂ¹ : BitVec 32
      xâœ : BitVec 64
      aâœ :
        Â¬(if xâœÂ¹ â‰¥ â†‘32 then none
            else
              if BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) = 0 then none
              else some (xâœ % BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹))) âŠ‘
            if True âˆ§ 1#32 <<< xâœÂ¹ >>> xâœÂ¹ = 1#32 then none
            else
              if xâœÂ¹ â‰¥ â†‘32 then none
              else
                if
                    True âˆ§
                      (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).msb = (-1#64).msb âˆ§
                        (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + -1#64).msb â‰ 
                          (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).msb then
                  none
                else some (xâœ &&& BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + -1#64)
      âŠ¢ False
  [Meta.isDefEq] [0.001002] âŒï¸ ?a == ?a =?= (32#32 >áµ¤ xâœÂ¹) == true
  [Meta.isDefEq] [0.005822] âœ…ï¸ ?hâ‚ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (congr
              (congrArg And
                (congr (congrArg Eq (BitVec.msb_eq_getLsbD_last (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹))))
                  (BitVec.msb_eq_getLsbD_last 18446744073709551615#64)))
              (Eq.trans
                (congr
                  (congrArg Ne
                    (BitVec.msb_eq_getLsbD_last (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64)))
                  (BitVec.msb_eq_getLsbD_last (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹))))
                (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                  ((BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64).getLsbD 63)
                  ((BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).getLsbD 63))))
            (Std.Tactic.BVDecide.Normalize.Bool.and_to_and ((BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).getLsbD 63)
              !(BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64).getLsbD 63 ==
                  (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).getLsbD 63)))
        (true_and
          (((BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).getLsbD 63 &&
              !(BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64).getLsbD 63 ==
                  (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).getLsbD 63) =
            true))
    [Meta.isDefEq.assign] [0.005818] âœ…ï¸ ?hâ‚ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (congr
                (congrArg And
                  (congr (congrArg Eq (BitVec.msb_eq_getLsbD_last (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹))))
                    (BitVec.msb_eq_getLsbD_last 18446744073709551615#64)))
                (Eq.trans
                  (congr
                    (congrArg Ne
                      (BitVec.msb_eq_getLsbD_last (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64)))
                    (BitVec.msb_eq_getLsbD_last (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹))))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    ((BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64).getLsbD 63)
                    ((BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).getLsbD 63))))
              (Std.Tactic.BVDecide.Normalize.Bool.and_to_and ((BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).getLsbD 63)
                !(BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64).getLsbD 63 ==
                    (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).getLsbD 63)))
          (true_and
            (((BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).getLsbD 63 &&
                !(BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64).getLsbD 63 ==
                    (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).getLsbD 63) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.005773] âœ…ï¸ (?hâ‚ : (True âˆ§
              (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).msb = (-1#64).msb âˆ§
                (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + -1#64).msb â‰  (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).msb) =
            (((BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).getLsbD 63 &&
                !(BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64).getLsbD 63 ==
                    (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).getLsbD 63) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (congr
                  (congrArg And
                    (congr (congrArg Eq (BitVec.msb_eq_getLsbD_last (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹))))
                      (BitVec.msb_eq_getLsbD_last 18446744073709551615#64)))
                  (Eq.trans
                    (congr
                      (congrArg Ne
                        (BitVec.msb_eq_getLsbD_last (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64)))
                      (BitVec.msb_eq_getLsbD_last (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹))))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      ((BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64).getLsbD 63)
                      ((BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).getLsbD 63))))
                (Std.Tactic.BVDecide.Normalize.Bool.and_to_and ((BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).getLsbD 63)
                  !(BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64).getLsbD 63 ==
                      (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).getLsbD 63)))
            (true_and
              (((BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).getLsbD 63 &&
                  !(BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64).getLsbD 63 ==
                      (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).getLsbD 63) =
                true)) : (True âˆ§
              (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).msb = (18446744073709551615#64).msb âˆ§
                (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64).msb â‰ 
                  (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).msb) =
            (((BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).getLsbD 63 &&
                !(BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64).getLsbD 63 ==
                    (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).getLsbD 63) =
              true))
        [Meta.isDefEq] [0.005768] âœ…ï¸ (True âˆ§
                (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).msb = (-1#64).msb âˆ§
                  (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + -1#64).msb â‰  (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).msb) =
              (((BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).getLsbD 63 &&
                  !(BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64).getLsbD 63 ==
                      (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).getLsbD 63) =
                true) =?= (True âˆ§
                (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).msb = (18446744073709551615#64).msb âˆ§
                  (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64).msb â‰ 
                    (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).msb) =
              (((BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).getLsbD 63 &&
                  !(BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64).getLsbD 63 ==
                      (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).getLsbD 63) =
                true)
          [Meta.isDefEq] [0.005737] âœ…ï¸ True âˆ§
                (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).msb = (-1#64).msb âˆ§
                  (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + -1#64).msb â‰ 
                    (BitVec.zeroExtend 64
                        (1#32 <<<
                          xâœÂ¹)).msb =?= True âˆ§
                (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).msb = (18446744073709551615#64).msb âˆ§
                  (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64).msb â‰ 
                    (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).msb
            [Meta.isDefEq] [0.005716] âœ…ï¸ (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).msb = (-1#64).msb âˆ§
                  (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + -1#64).msb â‰ 
                    (BitVec.zeroExtend 64
                        (1#32 <<<
                          xâœÂ¹)).msb =?= (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).msb = (18446744073709551615#64).msb âˆ§
                  (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64).msb â‰ 
                    (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).msb
              [Meta.isDefEq] [0.004832] âœ…ï¸ (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + -1#64).msb â‰ 
                    (BitVec.zeroExtend 64
                        (1#32 <<<
                          xâœÂ¹)).msb =?= (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64).msb â‰ 
                    (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).msb
                [Meta.isDefEq.delta] [0.004810] âœ…ï¸ (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + -1#64).msb â‰ 
                      (BitVec.zeroExtend 64
                          (1#32 <<<
                            xâœÂ¹)).msb =?= (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64).msb â‰ 
                      (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).msb
                  [Meta.isDefEq] [0.004778] âœ…ï¸ (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) +
                          -1#64).msb =?= (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64).msb
                    [Meta.isDefEq.delta] [0.004764] âœ…ï¸ (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) +
                            -1#64).msb =?= (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64).msb
                      [Meta.isDefEq] [0.004738] âœ…ï¸ BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) +
                            -1#64 =?= BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64
                        [Meta.isDefEq] [0.004584] âœ…ï¸ instHAdd.1 (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹))
                              (-1#64) =?= instHAdd.1 (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)) 18446744073709551615#64
                          [Meta.isDefEq] [0.004528] âœ…ï¸ Add.add (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹))
                                (-1#64) =?= Add.add (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)) 18446744073709551615#64
                            [Meta.isDefEq] [0.004093] âŒï¸ BitVec.instAdd =?= instAddNat
  [Meta.isDefEq] [0.001062] âœ…ï¸ ?hâ‚ƒ =?= fun a =>
        Eq.refl (some (xâœ &&& BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64))
    [Meta.isDefEq.assign] [0.001058] âœ…ï¸ ?hâ‚ƒ := fun a =>
          Eq.refl (some (xâœ &&& BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64))
      [Meta.isDefEq.assign.checkTypes] [0.001021] âœ…ï¸ (?hâ‚ƒ : Â¬((BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).getLsbD 63 &&
                  !(BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64).getLsbD 63 ==
                      (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).getLsbD 63) =
                true â†’
            some (xâœ &&& BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + -1#64) =
              some
                (xâœ &&&
                  BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) +
                    18446744073709551615#64)) := (fun a =>
            Eq.refl
              (some
                (xâœ &&&
                  BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) +
                    18446744073709551615#64)) : Â¬((BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).getLsbD 63 &&
                  !(BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64).getLsbD 63 ==
                      (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).getLsbD 63) =
                true â†’
            some (xâœ &&& BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64) =
              some (xâœ &&& BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64))
        [Meta.isDefEq] [0.001015] âœ…ï¸ Â¬((BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).getLsbD 63 &&
                    !(BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64).getLsbD 63 ==
                        (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).getLsbD 63) =
                  true â†’
              some (xâœ &&& BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + -1#64) =
                some
                  (xâœ &&&
                    BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) +
                      18446744073709551615#64) =?= Â¬((BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).getLsbD 63 &&
                    !(BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64).getLsbD 63 ==
                        (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).getLsbD 63) =
                  true â†’
              some (xâœ &&& BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64) =
                some (xâœ &&& BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      e_1 : LLVM.IntW 64
      xâœÂ¹ : BitVec 32
      xâœ : BitVec 64
      aâœ :
        Â¬(if (!32#32 >áµ¤ xâœÂ¹) = true then none
            else
              if (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) == 0#64) = true then none
              else some (xâœ % BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹))) âŠ‘
            if (1#32 <<< xâœÂ¹ >>> xâœÂ¹ == 1#32) = true then none
            else
              if (!32#32 >áµ¤ xâœÂ¹) = true then none
              else
                if
                    ((BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).getLsbD 63 &&
                        !(BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64).getLsbD 63 ==
                            (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹)).getLsbD 63) =
                      true then
                  none
                else some (xâœ &&& BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) + 18446744073709551615#64)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:147:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:139:8: error: (kernel) declaration has metavariables 'test15_thm'
[bv] [0.039488] Normalizing goal
  [Meta.synthInstance] [0.001516] âœ…ï¸ Decidable
        ((if xâœÂ¹ â‰¥ â†‘32 then none
          else
            if BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) = 0 then none
            else some (BitVec.zeroExtend 64 xâœ % BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹))) âŠ‘
          if True âˆ§ ((-1#32) <<< xâœÂ¹).sshiftRight xâœÂ¹.toNat = -1#32 then none
          else if xâœÂ¹ â‰¥ â†‘32 then none else some (BitVec.zeroExtend 64 (xâœ &&& ((-1#32) <<< xâœÂ¹ ^^^ -1#32))))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      xâœÂ¹ xâœ : BitVec 32
      aâœ :
        Â¬(if xâœÂ¹ â‰¥ â†‘32 then none
            else
              if BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) = 0 then none
              else some (BitVec.zeroExtend 64 xâœ % BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹))) âŠ‘
            if True âˆ§ ((-1#32) <<< xâœÂ¹).sshiftRight xâœÂ¹.toNat = -1#32 then none
            else if xâœÂ¹ â‰¥ â†‘32 then none else some (BitVec.zeroExtend 64 (xâœ &&& ((-1#32) <<< xâœÂ¹ ^^^ -1#32)))
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      xâœÂ¹ xâœ : BitVec 32
      aâœ :
        Â¬(if (!32#32 >áµ¤ xâœÂ¹) = true then none
            else
              if (BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹) == 0#64) = true then none
              else some (BitVec.zeroExtend 64 xâœ % BitVec.zeroExtend 64 (1#32 <<< xâœÂ¹))) âŠ‘
            if ((4294967295#32 <<< xâœÂ¹).sshiftRight xâœÂ¹.toNat == 4294967295#32) = true then none
            else
              if (!32#32 >áµ¤ xâœÂ¹) = true then none
              else some (BitVec.zeroExtend 64 (xâœ &&& (4294967295#32 <<< xâœÂ¹ ^^^ 4294967295#32)))
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:158:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:151:8: error: (kernel) declaration has metavariables 'test16_thm'
[bv] [0.024981] Normalizing goal
  [Meta.synthInstance] [0.001288] âœ…ï¸ Decidable
        ((if 11#32 â‰¥ â†‘32 then none
          else if (xâœÂ¹ >>> 11#32 &&& 4#32) + 4#32 = 0 then none else some (xâœ % ((xâœÂ¹ >>> 11#32 &&& 4#32) + 4#32))) âŠ‘
          if 11#32 â‰¥ â†‘32 then none else some (xâœ &&& (xâœÂ¹ >>> 11#32 &&& 4#32 ||| 3#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      xâœÂ¹ xâœ : BitVec 32
      aâœ :
        Â¬(if 11#32 â‰¥ â†‘32 then none
            else if (xâœÂ¹ >>> 11#32 &&& 4#32) + 4#32 = 0 then none else some (xâœ % ((xâœÂ¹ >>> 11#32 &&& 4#32) + 4#32))) âŠ‘
            if 11#32 â‰¥ â†‘32 then none else some (xâœ &&& (xâœÂ¹ >>> 11#32 &&& 4#32 ||| 3#32))
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      xâœÂ¹ xâœ : BitVec 32
      aâœ :
        Â¬(if ((xâœÂ¹ >>> 11 &&& 4#32) + 4#32 == 0#32) = true then none else some (xâœ % ((xâœÂ¹ >>> 11 &&& 4#32) + 4#32))) âŠ‘
            some (xâœ &&& (xâœÂ¹ >>> 11 &&& 4#32 ||| 3#32))
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:167:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:162:8: error: (kernel) declaration has metavariables 'test17_thm'
[bv] [0.018987] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ : Â¬(if xâœ = 0 then none else some (1#32 % xâœ)) âŠ‘ some (BitVec.zeroExtend 32 (BitVec.ofBool (xâœ != 1#32)))
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(if (xâœ == 0#32) = true then none else some (1#32 % xâœ)) âŠ‘
            some (BitVec.zeroExtend 32 (if (!xâœ == 1#32) = true then 1#1 else 0#1))
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:179:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:171:8: error: (kernel) declaration has metavariables 'test18_thm'
[bv] [0.069407] Normalizing goal
  [Meta.synthInstance] [0.001609] âœ…ï¸ Decidable
        ((Option.bind
            (match some (BitVec.ofBool (xâœÂ¹ &&& 4#16 != 0#16)) with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some 32#32
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some 64#32)
            fun y' => if y' = 0 then none else some (xâœ % y')) âŠ‘
          Option.bind
            (match some (BitVec.ofBool (xâœÂ¹ &&& 4#16 == 0#16)) with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some 63#32
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some 31#32)
            fun y' => some (xâœ &&& y'))
    [Meta.check] [0.001001] âœ…ï¸ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (Option.bind
            (match some (BitVec.ofBool (xâœÂ¹ &&& 4#16 != 0#16)) with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some 32#32
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some 64#32)
            fun y' => if y' = 0 then none else some (xâœ % y'))
          (Option.bind
            (match some (BitVec.ofBool (xâœÂ¹ &&& 4#16 == 0#16)) with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some 63#32
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some 31#32)
            fun y' => some (xâœ &&& y'))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 16
      e_1 : LLVM.IntW 32
      xâœÂ¹ : BitVec 16
      xâœ : BitVec 32
      aâœ :
        Â¬(Option.bind
              (match some (BitVec.ofBool (xâœÂ¹ &&& 4#16 != 0#16)) with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some 32#32
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some 64#32)
              fun y' => if y' = 0 then none else some (xâœ % y')) âŠ‘
            Option.bind
              (match some (BitVec.ofBool (xâœÂ¹ &&& 4#16 == 0#16)) with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some 63#32
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some 31#32)
              fun y' => some (xâœ &&& y')
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 16
      e_1 : LLVM.IntW 32
      xâœÂ¹ : BitVec 16
      xâœ : BitVec 32
      aâœ :
        Â¬(Option.bind
              (match some (if (!xâœÂ¹ &&& 4#16 == 0#16) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some 32#32
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some 64#32)
              fun a => if (a == 0#32) = true then none else some (xâœ % a)) âŠ‘
            Option.bind
              (match some (if (xâœÂ¹ &&& 4#16 == 0#16) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some 63#32
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some 31#32)
              fun a => some (xâœ &&& a)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:196:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:183:8: error: (kernel) declaration has metavariables 'test19_thm'
[bv] [0.067323] Normalizing goal
  [Meta.synthInstance] [0.001461] âœ…ï¸ Decidable
        ((if xâœÂ¹ â‰¥ â†‘32 then none
          else
            if xâœ â‰¥ â†‘32 then none
            else
              if xâœÂ¹ â‰¥ â†‘32 then none
              else
                if (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + 1#32 <<< xâœÂ¹ = 0 then none
                else some (xâœ % ((1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + 1#32 <<< xâœÂ¹))) âŠ‘
          if True âˆ§ 1#32 <<< xâœÂ¹ >>> xâœÂ¹ = 1#32 then none
          else
            if xâœÂ¹ â‰¥ â†‘32 then none
            else
              if True âˆ§ 1#32 <<< xâœ >>> xâœ = 1#32 then none
              else
                if xâœ â‰¥ â†‘32 then none
                else
                  if True âˆ§ 1#32 <<< xâœÂ¹ >>> xâœÂ¹ = 1#32 then none
                  else if xâœÂ¹ â‰¥ â†‘32 then none else some (xâœ &&& (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + 1#32 <<< xâœÂ¹ + -1#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      xâœÂ¹ xâœ : BitVec 32
      aâœ :
        Â¬(if xâœÂ¹ â‰¥ â†‘32 then none
            else
              if xâœ â‰¥ â†‘32 then none
              else
                if xâœÂ¹ â‰¥ â†‘32 then none
                else
                  if (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + 1#32 <<< xâœÂ¹ = 0 then none
                  else some (xâœ % ((1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + 1#32 <<< xâœÂ¹))) âŠ‘
            if True âˆ§ 1#32 <<< xâœÂ¹ >>> xâœÂ¹ = 1#32 then none
            else
              if xâœÂ¹ â‰¥ â†‘32 then none
              else
                if True âˆ§ 1#32 <<< xâœ >>> xâœ = 1#32 then none
                else
                  if xâœ â‰¥ â†‘32 then none
                  else
                    if True âˆ§ 1#32 <<< xâœÂ¹ >>> xâœÂ¹ = 1#32 then none
                    else if xâœÂ¹ â‰¥ â†‘32 then none else some (xâœ &&& (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + 1#32 <<< xâœÂ¹ + -1#32)
      âŠ¢ False
  [Meta.isDefEq] [0.001034] âœ…ï¸ ?hâ‚ƒ =?= fun a =>
        Eq.refl (some (xâœ &&& (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + 1#32 <<< xâœÂ¹ + 4294967295#32))
    [Meta.isDefEq.assign] [0.001031] âœ…ï¸ ?hâ‚ƒ := fun a =>
          Eq.refl (some (xâœ &&& (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + 1#32 <<< xâœÂ¹ + 4294967295#32))
      [Meta.isDefEq.assign.checkTypes] [0.001005] âœ…ï¸ (?hâ‚ƒ : Â¬(!32#32 >áµ¤ xâœÂ¹) = true â†’
            some (xâœ &&& (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + 1#32 <<< xâœÂ¹ + -1#32) =
              some
                (xâœ &&&
                  (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + 1#32 <<< xâœÂ¹ +
                    4294967295#32)) := (fun a =>
            Eq.refl
              (some
                (xâœ &&&
                  (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + 1#32 <<< xâœÂ¹ +
                    4294967295#32)) : Â¬(!32#32 >áµ¤ xâœÂ¹) = true â†’
            some (xâœ &&& (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + 1#32 <<< xâœÂ¹ + 4294967295#32) =
              some (xâœ &&& (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + 1#32 <<< xâœÂ¹ + 4294967295#32))
        [Meta.isDefEq] [0.001001] âœ…ï¸ Â¬(!32#32 >áµ¤ xâœÂ¹) = true â†’
              some (xâœ &&& (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + 1#32 <<< xâœÂ¹ + -1#32) =
                some
                  (xâœ &&&
                    (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + 1#32 <<< xâœÂ¹ +
                      4294967295#32) =?= Â¬(!32#32 >áµ¤ xâœÂ¹) = true â†’
              some (xâœ &&& (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + 1#32 <<< xâœÂ¹ + 4294967295#32) =
                some (xâœ &&& (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + 1#32 <<< xâœÂ¹ + 4294967295#32)
  [Meta.isDefEq] [0.001974] âœ…ï¸ if ?b then ?x
      else
        ?y =?= if (1#32 <<< xâœ >>> xâœ == 1#32) = true then none
      else
        if (!32#32 >áµ¤ xâœ) = true then none
        else
          if (1#32 <<< xâœÂ¹ >>> xâœÂ¹ == 1#32) = true then none
          else
            if (!32#32 >áµ¤ xâœÂ¹) = true then none
            else some (xâœ &&& (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + 1#32 <<< xâœÂ¹ + 4294967295#32)
    [Meta.isDefEq] [0.001881] âœ…ï¸ ?s =?= instDecidableEqBool (1#32 <<< xâœ >>> xâœ == 1#32) true
      [Meta.isDefEq.assign] [0.001879] âœ…ï¸ ?s := instDecidableEqBool (1#32 <<< xâœ >>> xâœ == 1#32) true
        [Meta.isDefEq.assign.checkTypes] [0.001875] âœ…ï¸ (?s : Decidable
              ((1#32 <<< xâœ >>> xâœ == 1#32) =
                true)) := (instDecidableEqBool (1#32 <<< xâœ >>> xâœ == 1#32)
              true : Decidable ((1#32 <<< xâœ >>> xâœ == 1#32) = true))
          [Meta.isDefEq] [0.001871] âœ…ï¸ Decidable
                ((1#32 <<< xâœ >>> xâœ == 1#32) = true) =?= Decidable ((1#32 <<< xâœ >>> xâœ == 1#32) = true)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      xâœÂ¹ xâœ : BitVec 32
      aâœ :
        Â¬(if (!32#32 >áµ¤ xâœÂ¹) = true then none
            else
              if (!32#32 >áµ¤ xâœ) = true then none
              else
                if (!32#32 >áµ¤ xâœÂ¹) = true then none
                else
                  if ((1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + 1#32 <<< xâœÂ¹ == 0#32) = true then none
                  else some (xâœ % ((1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + 1#32 <<< xâœÂ¹))) âŠ‘
            if (1#32 <<< xâœÂ¹ >>> xâœÂ¹ == 1#32) = true then none
            else
              if (!32#32 >áµ¤ xâœÂ¹) = true then none
              else
                if (1#32 <<< xâœ >>> xâœ == 1#32) = true then none
                else
                  if (!32#32 >áµ¤ xâœ) = true then none
                  else
                    if (1#32 <<< xâœÂ¹ >>> xâœÂ¹ == 1#32) = true then none
                    else
                      if (!32#32 >áµ¤ xâœÂ¹) = true then none
                      else some (xâœ &&& (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + 1#32 <<< xâœÂ¹ + 4294967295#32)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:213:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:213:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:200:8: error: (kernel) declaration has metavariables 'test19_commutative0_thm'
[bv] [0.065407] Normalizing goal
  [Meta.synthInstance] [0.001360] âœ…ï¸ Decidable
        ((if xâœ â‰¥ â†‘32 then none
          else
            if xâœÂ¹ â‰¥ â†‘32 then none
            else
              if xâœÂ¹ â‰¥ â†‘32 then none
              else
                if (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 1#32 <<< xâœÂ¹ = 0 then none
                else some (xâœ % ((1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 1#32 <<< xâœÂ¹))) âŠ‘
          if True âˆ§ 1#32 <<< xâœ >>> xâœ = 1#32 then none
          else
            if xâœ â‰¥ â†‘32 then none
            else
              if True âˆ§ 1#32 <<< xâœÂ¹ >>> xâœÂ¹ = 1#32 then none
              else
                if xâœÂ¹ â‰¥ â†‘32 then none
                else
                  if True âˆ§ 1#32 <<< xâœÂ¹ >>> xâœÂ¹ = 1#32 then none
                  else if xâœÂ¹ â‰¥ â†‘32 then none else some (xâœ &&& (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 1#32 <<< xâœÂ¹ + -1#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      xâœÂ¹ xâœ : BitVec 32
      aâœ :
        Â¬(if xâœ â‰¥ â†‘32 then none
            else
              if xâœÂ¹ â‰¥ â†‘32 then none
              else
                if xâœÂ¹ â‰¥ â†‘32 then none
                else
                  if (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 1#32 <<< xâœÂ¹ = 0 then none
                  else some (xâœ % ((1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 1#32 <<< xâœÂ¹))) âŠ‘
            if True âˆ§ 1#32 <<< xâœ >>> xâœ = 1#32 then none
            else
              if xâœ â‰¥ â†‘32 then none
              else
                if True âˆ§ 1#32 <<< xâœÂ¹ >>> xâœÂ¹ = 1#32 then none
                else
                  if xâœÂ¹ â‰¥ â†‘32 then none
                  else
                    if True âˆ§ 1#32 <<< xâœÂ¹ >>> xâœÂ¹ = 1#32 then none
                    else if xâœÂ¹ â‰¥ â†‘32 then none else some (xâœ &&& (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 1#32 <<< xâœÂ¹ + -1#32)
      âŠ¢ False
  [Meta.isDefEq] [0.001199] âœ…ï¸ ?hâ‚ƒ =?= fun a =>
        Eq.refl (some (xâœ &&& (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 1#32 <<< xâœÂ¹ + 4294967295#32))
    [Meta.isDefEq.assign] [0.001196] âœ…ï¸ ?hâ‚ƒ := fun a =>
          Eq.refl (some (xâœ &&& (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 1#32 <<< xâœÂ¹ + 4294967295#32))
      [Meta.isDefEq.assign.checkTypes] [0.001164] âœ…ï¸ (?hâ‚ƒ : Â¬(!32#32 >áµ¤ xâœÂ¹) = true â†’
            some (xâœ &&& (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 1#32 <<< xâœÂ¹ + -1#32) =
              some
                (xâœ &&&
                  (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 1#32 <<< xâœÂ¹ +
                    4294967295#32)) := (fun a =>
            Eq.refl
              (some
                (xâœ &&&
                  (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 1#32 <<< xâœÂ¹ +
                    4294967295#32)) : Â¬(!32#32 >áµ¤ xâœÂ¹) = true â†’
            some (xâœ &&& (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 1#32 <<< xâœÂ¹ + 4294967295#32) =
              some (xâœ &&& (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 1#32 <<< xâœÂ¹ + 4294967295#32))
        [Meta.isDefEq] [0.001160] âœ…ï¸ Â¬(!32#32 >áµ¤ xâœÂ¹) = true â†’
              some (xâœ &&& (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 1#32 <<< xâœÂ¹ + -1#32) =
                some
                  (xâœ &&&
                    (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 1#32 <<< xâœÂ¹ +
                      4294967295#32) =?= Â¬(!32#32 >áµ¤ xâœÂ¹) = true â†’
              some (xâœ &&& (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 1#32 <<< xâœÂ¹ + 4294967295#32) =
                some (xâœ &&& (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 1#32 <<< xâœÂ¹ + 4294967295#32)
          [Meta.isDefEq] [0.001123] âœ…ï¸ some (xâœ &&& (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 1#32 <<< xâœÂ¹ + -1#32) =
                some
                  (xâœ &&&
                    (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 1#32 <<< xâœÂ¹ +
                      4294967295#32) =?= some (xâœ &&& (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 1#32 <<< xâœÂ¹ + 4294967295#32) =
                some (xâœ &&& (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 1#32 <<< xâœÂ¹ + 4294967295#32)
            [Meta.isDefEq] [0.001104] âœ…ï¸ some
                  (xâœ &&&
                    (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 1#32 <<< xâœÂ¹ +
                      -1#32) =?= some (xâœ &&& (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 1#32 <<< xâœÂ¹ + 4294967295#32)
              [Meta.isDefEq] [0.001083] âœ…ï¸ xâœ &&&
                    (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 1#32 <<< xâœÂ¹ +
                      -1#32 =?= xâœ &&& (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 1#32 <<< xâœÂ¹ + 4294967295#32
                [Meta.isDefEq] [0.001054] âœ…ï¸ instHAndOfAndOp.1 xâœ
                      ((1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 1#32 <<< xâœÂ¹ +
                        -1#32) =?= instHAndOfAndOp.1 xâœ ((1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 1#32 <<< xâœÂ¹ + 4294967295#32)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      xâœÂ¹ xâœ : BitVec 32
      aâœ :
        Â¬(if (!32#32 >áµ¤ xâœ) = true then none
            else
              if (!32#32 >áµ¤ xâœÂ¹) = true then none
              else
                if (!32#32 >áµ¤ xâœÂ¹) = true then none
                else
                  if ((1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 1#32 <<< xâœÂ¹ == 0#32) = true then none
                  else some (xâœ % ((1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 1#32 <<< xâœÂ¹))) âŠ‘
            if (1#32 <<< xâœ >>> xâœ == 1#32) = true then none
            else
              if (!32#32 >áµ¤ xâœ) = true then none
              else
                if (1#32 <<< xâœÂ¹ >>> xâœÂ¹ == 1#32) = true then none
                else
                  if (!32#32 >áµ¤ xâœÂ¹) = true then none
                  else
                    if (1#32 <<< xâœÂ¹ >>> xâœÂ¹ == 1#32) = true then none
                    else
                      if (!32#32 >áµ¤ xâœÂ¹) = true then none
                      else some (xâœ &&& (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 1#32 <<< xâœÂ¹ + 4294967295#32)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:229:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:217:8: error: (kernel) declaration has metavariables 'test19_commutative1_thm'
[bv] [0.064938] Normalizing goal
  [Meta.synthInstance] [0.001453] âœ…ï¸ Decidable
        ((if xâœÂ¹ â‰¥ â†‘32 then none
          else
            if xâœÂ¹ â‰¥ â†‘32 then none
            else
              if xâœ â‰¥ â†‘32 then none
              else
                if 1#32 <<< xâœÂ¹ + (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) = 0 then none
                else some (xâœ % (1#32 <<< xâœÂ¹ + (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ)))) âŠ‘
          if True âˆ§ 1#32 <<< xâœÂ¹ >>> xâœÂ¹ = 1#32 then none
          else
            if xâœÂ¹ â‰¥ â†‘32 then none
            else
              if True âˆ§ 1#32 <<< xâœÂ¹ >>> xâœÂ¹ = 1#32 then none
              else
                if xâœÂ¹ â‰¥ â†‘32 then none
                else
                  if True âˆ§ 1#32 <<< xâœ >>> xâœ = 1#32 then none
                  else if xâœ â‰¥ â†‘32 then none else some (xâœ &&& 1#32 <<< xâœÂ¹ + (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + -1#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      xâœÂ¹ xâœ : BitVec 32
      aâœ :
        Â¬(if xâœÂ¹ â‰¥ â†‘32 then none
            else
              if xâœÂ¹ â‰¥ â†‘32 then none
              else
                if xâœ â‰¥ â†‘32 then none
                else
                  if 1#32 <<< xâœÂ¹ + (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) = 0 then none
                  else some (xâœ % (1#32 <<< xâœÂ¹ + (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ)))) âŠ‘
            if True âˆ§ 1#32 <<< xâœÂ¹ >>> xâœÂ¹ = 1#32 then none
            else
              if xâœÂ¹ â‰¥ â†‘32 then none
              else
                if True âˆ§ 1#32 <<< xâœÂ¹ >>> xâœÂ¹ = 1#32 then none
                else
                  if xâœÂ¹ â‰¥ â†‘32 then none
                  else
                    if True âˆ§ 1#32 <<< xâœ >>> xâœ = 1#32 then none
                    else if xâœ â‰¥ â†‘32 then none else some (xâœ &&& 1#32 <<< xâœÂ¹ + (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + -1#32)
      âŠ¢ False
  [Meta.isDefEq] [0.001153] âœ…ï¸ ?hâ‚ƒ =?= fun a =>
        Eq.refl (some (xâœ &&& 1#32 <<< xâœÂ¹ + (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + 4294967295#32))
    [Meta.isDefEq.assign] [0.001150] âœ…ï¸ ?hâ‚ƒ := fun a =>
          Eq.refl (some (xâœ &&& 1#32 <<< xâœÂ¹ + (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + 4294967295#32))
      [Meta.isDefEq.assign.checkTypes] [0.001125] âœ…ï¸ (?hâ‚ƒ : Â¬(!32#32 >áµ¤ xâœ) = true â†’
            some (xâœ &&& 1#32 <<< xâœÂ¹ + (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + -1#32) =
              some
                (xâœ &&&
                  1#32 <<< xâœÂ¹ + (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) +
                    4294967295#32)) := (fun a =>
            Eq.refl
              (some
                (xâœ &&&
                  1#32 <<< xâœÂ¹ + (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) +
                    4294967295#32)) : Â¬(!32#32 >áµ¤ xâœ) = true â†’
            some (xâœ &&& 1#32 <<< xâœÂ¹ + (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + 4294967295#32) =
              some (xâœ &&& 1#32 <<< xâœÂ¹ + (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + 4294967295#32))
        [Meta.isDefEq] [0.001122] âœ…ï¸ Â¬(!32#32 >áµ¤ xâœ) = true â†’
              some (xâœ &&& 1#32 <<< xâœÂ¹ + (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + -1#32) =
                some
                  (xâœ &&&
                    1#32 <<< xâœÂ¹ + (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) +
                      4294967295#32) =?= Â¬(!32#32 >áµ¤ xâœ) = true â†’
              some (xâœ &&& 1#32 <<< xâœÂ¹ + (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + 4294967295#32) =
                some (xâœ &&& 1#32 <<< xâœÂ¹ + (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + 4294967295#32)
          [Meta.isDefEq] [0.001091] âœ…ï¸ some (xâœ &&& 1#32 <<< xâœÂ¹ + (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + -1#32) =
                some
                  (xâœ &&&
                    1#32 <<< xâœÂ¹ + (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) +
                      4294967295#32) =?= some (xâœ &&& 1#32 <<< xâœÂ¹ + (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + 4294967295#32) =
                some (xâœ &&& 1#32 <<< xâœÂ¹ + (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + 4294967295#32)
            [Meta.isDefEq] [0.001073] âœ…ï¸ some
                  (xâœ &&&
                    1#32 <<< xâœÂ¹ + (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) +
                      -1#32) =?= some (xâœ &&& 1#32 <<< xâœÂ¹ + (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + 4294967295#32)
              [Meta.isDefEq] [0.001052] âœ…ï¸ xâœ &&&
                    1#32 <<< xâœÂ¹ + (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) +
                      -1#32 =?= xâœ &&& 1#32 <<< xâœÂ¹ + (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + 4294967295#32
                [Meta.isDefEq] [0.001024] âœ…ï¸ instHAndOfAndOp.1 xâœ
                      (1#32 <<< xâœÂ¹ + (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) +
                        -1#32) =?= instHAndOfAndOp.1 xâœ (1#32 <<< xâœÂ¹ + (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + 4294967295#32)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      xâœÂ¹ xâœ : BitVec 32
      aâœ :
        Â¬(if (!32#32 >áµ¤ xâœÂ¹) = true then none
            else
              if (!32#32 >áµ¤ xâœÂ¹) = true then none
              else
                if (!32#32 >áµ¤ xâœ) = true then none
                else
                  if (1#32 <<< xâœÂ¹ + (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) == 0#32) = true then none
                  else some (xâœ % (1#32 <<< xâœÂ¹ + (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ)))) âŠ‘
            if (1#32 <<< xâœÂ¹ >>> xâœÂ¹ == 1#32) = true then none
            else
              if (!32#32 >áµ¤ xâœÂ¹) = true then none
              else
                if (1#32 <<< xâœÂ¹ >>> xâœÂ¹ == 1#32) = true then none
                else
                  if (!32#32 >áµ¤ xâœÂ¹) = true then none
                  else
                    if (1#32 <<< xâœ >>> xâœ == 1#32) = true then none
                    else
                      if (!32#32 >áµ¤ xâœ) = true then none
                      else some (xâœ &&& 1#32 <<< xâœÂ¹ + (1#32 <<< xâœÂ¹ &&& 1#32 <<< xâœ) + 4294967295#32)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:245:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:233:8: error: (kernel) declaration has metavariables 'test19_commutative2_thm'
[bv] [0.064946] Normalizing goal
  [Meta.synthInstance] [0.001478] âœ…ï¸ Decidable
        ((if xâœÂ¹ â‰¥ â†‘32 then none
          else
            if xâœ â‰¥ â†‘32 then none
            else
              if xâœÂ¹ â‰¥ â†‘32 then none
              else
                if 1#32 <<< xâœÂ¹ + (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) = 0 then none
                else some (xâœ % (1#32 <<< xâœÂ¹ + (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹)))) âŠ‘
          if True âˆ§ 1#32 <<< xâœÂ¹ >>> xâœÂ¹ = 1#32 then none
          else
            if xâœÂ¹ â‰¥ â†‘32 then none
            else
              if True âˆ§ 1#32 <<< xâœ >>> xâœ = 1#32 then none
              else
                if xâœ â‰¥ â†‘32 then none
                else
                  if True âˆ§ 1#32 <<< xâœÂ¹ >>> xâœÂ¹ = 1#32 then none
                  else if xâœÂ¹ â‰¥ â†‘32 then none else some (xâœ &&& 1#32 <<< xâœÂ¹ + (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + -1#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      xâœÂ¹ xâœ : BitVec 32
      aâœ :
        Â¬(if xâœÂ¹ â‰¥ â†‘32 then none
            else
              if xâœ â‰¥ â†‘32 then none
              else
                if xâœÂ¹ â‰¥ â†‘32 then none
                else
                  if 1#32 <<< xâœÂ¹ + (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) = 0 then none
                  else some (xâœ % (1#32 <<< xâœÂ¹ + (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹)))) âŠ‘
            if True âˆ§ 1#32 <<< xâœÂ¹ >>> xâœÂ¹ = 1#32 then none
            else
              if xâœÂ¹ â‰¥ â†‘32 then none
              else
                if True âˆ§ 1#32 <<< xâœ >>> xâœ = 1#32 then none
                else
                  if xâœ â‰¥ â†‘32 then none
                  else
                    if True âˆ§ 1#32 <<< xâœÂ¹ >>> xâœÂ¹ = 1#32 then none
                    else if xâœÂ¹ â‰¥ â†‘32 then none else some (xâœ &&& 1#32 <<< xâœÂ¹ + (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + -1#32)
      âŠ¢ False
  [Meta.isDefEq] [0.001139] âœ…ï¸ ?hâ‚ƒ =?= fun a =>
        Eq.refl (some (xâœ &&& 1#32 <<< xâœÂ¹ + (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 4294967295#32))
    [Meta.isDefEq.assign] [0.001136] âœ…ï¸ ?hâ‚ƒ := fun a =>
          Eq.refl (some (xâœ &&& 1#32 <<< xâœÂ¹ + (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 4294967295#32))
      [Meta.isDefEq.assign.checkTypes] [0.001112] âœ…ï¸ (?hâ‚ƒ : Â¬(!32#32 >áµ¤ xâœÂ¹) = true â†’
            some (xâœ &&& 1#32 <<< xâœÂ¹ + (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + -1#32) =
              some
                (xâœ &&&
                  1#32 <<< xâœÂ¹ + (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) +
                    4294967295#32)) := (fun a =>
            Eq.refl
              (some
                (xâœ &&&
                  1#32 <<< xâœÂ¹ + (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) +
                    4294967295#32)) : Â¬(!32#32 >áµ¤ xâœÂ¹) = true â†’
            some (xâœ &&& 1#32 <<< xâœÂ¹ + (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 4294967295#32) =
              some (xâœ &&& 1#32 <<< xâœÂ¹ + (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 4294967295#32))
        [Meta.isDefEq] [0.001110] âœ…ï¸ Â¬(!32#32 >áµ¤ xâœÂ¹) = true â†’
              some (xâœ &&& 1#32 <<< xâœÂ¹ + (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + -1#32) =
                some
                  (xâœ &&&
                    1#32 <<< xâœÂ¹ + (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) +
                      4294967295#32) =?= Â¬(!32#32 >áµ¤ xâœÂ¹) = true â†’
              some (xâœ &&& 1#32 <<< xâœÂ¹ + (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 4294967295#32) =
                some (xâœ &&& 1#32 <<< xâœÂ¹ + (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 4294967295#32)
          [Meta.isDefEq] [0.001078] âœ…ï¸ some (xâœ &&& 1#32 <<< xâœÂ¹ + (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + -1#32) =
                some
                  (xâœ &&&
                    1#32 <<< xâœÂ¹ + (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) +
                      4294967295#32) =?= some (xâœ &&& 1#32 <<< xâœÂ¹ + (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 4294967295#32) =
                some (xâœ &&& 1#32 <<< xâœÂ¹ + (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 4294967295#32)
            [Meta.isDefEq] [0.001060] âœ…ï¸ some
                  (xâœ &&&
                    1#32 <<< xâœÂ¹ + (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) +
                      -1#32) =?= some (xâœ &&& 1#32 <<< xâœÂ¹ + (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 4294967295#32)
              [Meta.isDefEq] [0.001040] âœ…ï¸ xâœ &&&
                    1#32 <<< xâœÂ¹ + (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) +
                      -1#32 =?= xâœ &&& 1#32 <<< xâœÂ¹ + (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 4294967295#32
                [Meta.isDefEq] [0.001010] âœ…ï¸ instHAndOfAndOp.1 xâœ
                      (1#32 <<< xâœÂ¹ + (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) +
                        -1#32) =?= instHAndOfAndOp.1 xâœ (1#32 <<< xâœÂ¹ + (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 4294967295#32)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      xâœÂ¹ xâœ : BitVec 32
      aâœ :
        Â¬(if (!32#32 >áµ¤ xâœÂ¹) = true then none
            else
              if (!32#32 >áµ¤ xâœ) = true then none
              else
                if (!32#32 >áµ¤ xâœÂ¹) = true then none
                else
                  if (1#32 <<< xâœÂ¹ + (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) == 0#32) = true then none
                  else some (xâœ % (1#32 <<< xâœÂ¹ + (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹)))) âŠ‘
            if (1#32 <<< xâœÂ¹ >>> xâœÂ¹ == 1#32) = true then none
            else
              if (!32#32 >áµ¤ xâœÂ¹) = true then none
              else
                if (1#32 <<< xâœ >>> xâœ == 1#32) = true then none
                else
                  if (!32#32 >áµ¤ xâœ) = true then none
                  else
                    if (1#32 <<< xâœÂ¹ >>> xâœÂ¹ == 1#32) = true then none
                    else
                      if (!32#32 >áµ¤ xâœÂ¹) = true then none
                      else some (xâœ &&& 1#32 <<< xâœÂ¹ + (1#32 <<< xâœ &&& 1#32 <<< xâœÂ¹) + 4294967295#32)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:256:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:249:8: error: (kernel) declaration has metavariables 'test22_thm'
[bv] [0.037519] Normalizing goal
  [Meta.synthInstance] [0.001338] âœ…ï¸ Decidable
        (Option.map (fun div => (xâœ &&& 2147483647#32) - div * 2147483647#32)
            (if
                (2147483647#32 == 0 || 32 != 1 && xâœ &&& 2147483647#32 == BitVec.intMin 32 && 2147483647#32 == -1) =
                  true then
              none
            else some ((xâœ &&& 2147483647#32).sdiv 2147483647#32)) âŠ‘
          if 2147483647#32 = 0 then none else some ((xâœ &&& 2147483647#32) % 2147483647#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬Option.map (fun div => (xâœ &&& 2147483647#32) - div * 2147483647#32)
              (if
                  (2147483647#32 == 0 || 32 != 1 && xâœ &&& 2147483647#32 == BitVec.intMin 32 && 2147483647#32 == -1) =
                    true then
                none
              else some ((xâœ &&& 2147483647#32).sdiv 2147483647#32)) âŠ‘
            if 2147483647#32 = 0 then none else some ((xâœ &&& 2147483647#32) % 2147483647#32)
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬Option.map (fun div => (xâœ &&& 2147483647#32) + (~~~(div * 2147483647#32) + 1#32))
              (some
                (if (xâœ &&& 2147483647#32).getLsbD 31 = true then
                  ~~~((~~~(xâœ &&& 2147483647#32) + 1#32) / 2147483647#32) + 1#32
                else (xâœ &&& 2147483647#32) / 2147483647#32)) âŠ‘
            some ((xâœ &&& 2147483647#32) % 2147483647#32)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:267:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:260:8: error: (kernel) declaration has metavariables 'test24_thm'
[bv] [0.019679] Normalizing goal
  [Meta.synthInstance] [0.001005] âœ…ï¸ Decidable
        ((if 2147483648#32 = 0 then none else some (BitVec.ofBool (xâœ % 2147483648#32 != 0#32))) âŠ‘
          some (BitVec.ofBool (xâœ &&& 2147483647#32 != 0#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(if 2147483648#32 = 0 then none else some (BitVec.ofBool (xâœ % 2147483648#32 != 0#32))) âŠ‘
            some (BitVec.ofBool (xâœ &&& 2147483647#32 != 0#32))
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬some (if (!xâœ % 2147483648#32 == 0#32) = true then 1#1 else 0#1) âŠ‘
            some (if (!xâœ &&& 2147483647#32 == 0#32) = true then 1#1 else 0#1)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:278:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:271:8: error: (kernel) declaration has metavariables 'test25_thm'
[bv] [0.054538] Normalizing goal
  [Meta.synthInstance] [0.001213] âœ…ï¸ Decidable
        (((Option.map (fun div => xâœ - div * 2147483648#32)
                (if (2147483648#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 2147483648#32 == -1) = true then none
                else some (xâœ.sdiv 2147483648#32))).bind
            fun x' => some (BitVec.ofBool (x' != 0#32))) âŠ‘
          some (BitVec.ofBool (xâœ &&& 2147483647#32 != 0#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬((Option.map (fun div => xâœ - div * 2147483648#32)
                  (if (2147483648#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 2147483648#32 == -1) = true then none
                  else some (xâœ.sdiv 2147483648#32))).bind
              fun x' => some (BitVec.ofBool (x' != 0#32))) âŠ‘
            some (BitVec.ofBool (xâœ &&& 2147483647#32 != 0#32))
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬((Option.map (fun div => xâœ + (~~~(div * 2147483648#32) + 1#32))
                  (some
                    (if xâœ.getLsbD 31 = true then (~~~xâœ + 1#32) / 2147483648#32
                    else ~~~(xâœ / 2147483648#32) + 1#32))).bind
              fun a => some (if (!a == 0#32) = true then 1#1 else 0#1)) âŠ‘
            some (if (!xâœ &&& 2147483647#32 == 0#32) = true then 1#1 else 0#1)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:291:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:282:8: error: (kernel) declaration has metavariables 'test26_thm'
[bv] [0.100827] Normalizing goal
  [Meta.synthInstance] [0.001637] âœ…ï¸ Decidable
        ((if xâœÂ¹ â‰¥ â†‘32 then none
          else
            (Option.map (fun div => xâœ - div * 1#32 <<< xâœÂ¹)
                  (if (1#32 <<< xâœÂ¹ == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 1#32 <<< xâœÂ¹ == -1) = true then none
                  else some (xâœ.sdiv (1#32 <<< xâœÂ¹)))).bind
              fun x' => some (BitVec.ofBool (x' != 0#32))) âŠ‘
          if True âˆ§ ((-1#32) <<< xâœÂ¹).sshiftRight xâœÂ¹.toNat = -1#32 then none
          else if xâœÂ¹ â‰¥ â†‘32 then none else some (BitVec.ofBool (xâœ &&& ((-1#32) <<< xâœÂ¹ ^^^ -1#32) != 0#32)))
    [Meta.check] [0.001010] âœ…ï¸ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if xâœÂ¹ â‰¥ â†‘32 then none
          else
            (Option.map (fun div => xâœ - div * 1#32 <<< xâœÂ¹)
                  (if (1#32 <<< xâœÂ¹ == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 1#32 <<< xâœÂ¹ == -1) = true then none
                  else some (xâœ.sdiv (1#32 <<< xâœÂ¹)))).bind
              fun x' => some (BitVec.ofBool (x' != 0#32)))
          (if True âˆ§ ((-1#32) <<< xâœÂ¹).sshiftRight xâœÂ¹.toNat = -1#32 then none
          else if xâœÂ¹ â‰¥ â†‘32 then none else some (BitVec.ofBool (xâœ &&& ((-1#32) <<< xâœÂ¹ ^^^ -1#32) != 0#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      xâœÂ¹ xâœ : BitVec 32
      aâœ :
        Â¬(if xâœÂ¹ â‰¥ â†‘32 then none
            else
              (Option.map (fun div => xâœ - div * 1#32 <<< xâœÂ¹)
                    (if (1#32 <<< xâœÂ¹ == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 1#32 <<< xâœÂ¹ == -1) = true then none
                    else some (xâœ.sdiv (1#32 <<< xâœÂ¹)))).bind
                fun x' => some (BitVec.ofBool (x' != 0#32))) âŠ‘
            if True âˆ§ ((-1#32) <<< xâœÂ¹).sshiftRight xâœÂ¹.toNat = -1#32 then none
            else if xâœÂ¹ â‰¥ â†‘32 then none else some (BitVec.ofBool (xâœ &&& ((-1#32) <<< xâœÂ¹ ^^^ -1#32) != 0#32))
      âŠ¢ False
  [Meta.isDefEq] [0.001350] âœ…ï¸ ?hâ‚ =?= congrArg (fun x => x = true)
        (Eq.trans
          (congrArg (fun x => 1#32 <<< xâœÂ¹ == 0#32 || x && 1#32 <<< xâœÂ¹ == 4294967295#32)
            (Bool.true_and (xâœ == BitVec.intMin 32)))
          (Std.Tactic.BVDecide.Normalize.Bool.or_elim (1#32 <<< xâœÂ¹ == 0#32)
            (xâœ == BitVec.intMin 32 && 1#32 <<< xâœÂ¹ == 4294967295#32)))
    [Meta.isDefEq.assign] [0.001347] âœ…ï¸ ?hâ‚ := congrArg (fun x => x = true)
          (Eq.trans
            (congrArg (fun x => 1#32 <<< xâœÂ¹ == 0#32 || x && 1#32 <<< xâœÂ¹ == 4294967295#32)
              (Bool.true_and (xâœ == BitVec.intMin 32)))
            (Std.Tactic.BVDecide.Normalize.Bool.or_elim (1#32 <<< xâœÂ¹ == 0#32)
              (xâœ == BitVec.intMin 32 && 1#32 <<< xâœÂ¹ == 4294967295#32)))
      [Meta.isDefEq.assign.checkTypes] [0.001336] âœ…ï¸ (?hâ‚ : ((1#32 <<< xâœÂ¹ == 0 ||
                32 != 1 && xâœ == BitVec.intMin 32 && 1#32 <<< xâœÂ¹ == -1) =
              true) =
            ((!(!1#32 <<< xâœÂ¹ == 0#32 && !(xâœ == BitVec.intMin 32 && 1#32 <<< xâœÂ¹ == 4294967295#32))) =
              true)) := (congrArg (fun x => x = true)
            (Eq.trans
              (congrArg (fun x => 1#32 <<< xâœÂ¹ == 0#32 || x && 1#32 <<< xâœÂ¹ == 4294967295#32)
                (Bool.true_and (xâœ == BitVec.intMin 32)))
              (Std.Tactic.BVDecide.Normalize.Bool.or_elim (1#32 <<< xâœÂ¹ == 0#32)
                (xâœ == BitVec.intMin 32 &&
                  1#32 <<< xâœÂ¹ ==
                    4294967295#32))) : ((1#32 <<< xâœÂ¹ == 0#32 ||
                true && xâœ == BitVec.intMin 32 && 1#32 <<< xâœÂ¹ == 4294967295#32) =
              true) =
            ((!(!1#32 <<< xâœÂ¹ == 0#32 && !(xâœ == BitVec.intMin 32 && 1#32 <<< xâœÂ¹ == 4294967295#32))) = true))
        [Meta.isDefEq] [0.001332] âœ…ï¸ ((1#32 <<< xâœÂ¹ == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 1#32 <<< xâœÂ¹ == -1) =
                true) =
              ((!(!1#32 <<< xâœÂ¹ == 0#32 && !(xâœ == BitVec.intMin 32 && 1#32 <<< xâœÂ¹ == 4294967295#32))) =
                true) =?= ((1#32 <<< xâœÂ¹ == 0#32 || true && xâœ == BitVec.intMin 32 && 1#32 <<< xâœÂ¹ == 4294967295#32) =
                true) =
              ((!(!1#32 <<< xâœÂ¹ == 0#32 && !(xâœ == BitVec.intMin 32 && 1#32 <<< xâœÂ¹ == 4294967295#32))) = true)
          [Meta.isDefEq] [0.001315] âœ…ï¸ (1#32 <<< xâœÂ¹ == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 1#32 <<< xâœÂ¹ == -1) =
                true =?= (1#32 <<< xâœÂ¹ == 0#32 || true && xâœ == BitVec.intMin 32 && 1#32 <<< xâœÂ¹ == 4294967295#32) =
                true
            [Meta.isDefEq] [0.001302] âœ…ï¸ 1#32 <<< xâœÂ¹ == 0 ||
                  32 != 1 && xâœ == BitVec.intMin 32 &&
                    1#32 <<< xâœÂ¹ ==
                      -1 =?= 1#32 <<< xâœÂ¹ == 0#32 || true && xâœ == BitVec.intMin 32 && 1#32 <<< xâœÂ¹ == 4294967295#32
              [Meta.isDefEq.delta] [0.001289] âœ…ï¸ 1#32 <<< xâœÂ¹ == 0 ||
                    32 != 1 && xâœ == BitVec.intMin 32 &&
                      1#32 <<< xâœÂ¹ ==
                        -1 =?= 1#32 <<< xâœÂ¹ == 0#32 || true && xâœ == BitVec.intMin 32 && 1#32 <<< xâœÂ¹ == 4294967295#32
                [Meta.isDefEq] [0.001008] âœ…ï¸ 32 != 1 && xâœ == BitVec.intMin 32 &&
                      1#32 <<< xâœÂ¹ == -1 =?= true && xâœ == BitVec.intMin 32 && 1#32 <<< xâœÂ¹ == 4294967295#32
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      xâœÂ¹ xâœ : BitVec 32
      aâœ :
        Â¬(if (!32#32 >áµ¤ xâœÂ¹) = true then none
            else
              (Option.map (fun div => xâœ + (~~~(div * 1#32 <<< xâœÂ¹) + 1#32))
                    (if
                        (!(!1#32 <<< xâœÂ¹ == 0#32 && !(xâœ == BitVec.intMin 32 && 1#32 <<< xâœÂ¹ == 4294967295#32))) =
                          true then
                      none
                    else
                      some
                        (if xâœ.getLsbD 31 = true then
                          if (1#32 <<< xâœÂ¹).getLsbD 31 = true then (~~~xâœ + 1#32) / (~~~(1#32 <<< xâœÂ¹) + 1#32)
                          else ~~~((~~~xâœ + 1#32) / 1#32 <<< xâœÂ¹) + 1#32
                        else
                          if (1#32 <<< xâœÂ¹).getLsbD 31 = true then ~~~(xâœ / (~~~(1#32 <<< xâœÂ¹) + 1#32)) + 1#32
                          else xâœ / 1#32 <<< xâœÂ¹))).bind
                fun a => some (if (!a == 0#32) = true then 1#1 else 0#1)) âŠ‘
            if ((4294967295#32 <<< xâœÂ¹).sshiftRight xâœÂ¹.toNat == 4294967295#32) = true then none
            else
              if (!32#32 >áµ¤ xâœÂ¹) = true then none
              else some (if (!xâœ &&& (4294967295#32 <<< xâœÂ¹ ^^^ 4294967295#32) == 0#32) = true then 1#1 else 0#1)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:302:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:295:8: error: (kernel) declaration has metavariables 'test28_thm'
[bv] [0.054264] Normalizing goal
  [Meta.synthInstance] [0.001212] âœ…ï¸ Decidable
        (((Option.map (fun div => xâœ - div * 2147483648#32)
                (if (2147483648#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 2147483648#32 == -1) = true then none
                else some (xâœ.sdiv 2147483648#32))).bind
            fun x' => some (BitVec.ofBool (x' == 0#32))) âŠ‘
          some (BitVec.ofBool (xâœ &&& 2147483647#32 == 0#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬((Option.map (fun div => xâœ - div * 2147483648#32)
                  (if (2147483648#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 2147483648#32 == -1) = true then none
                  else some (xâœ.sdiv 2147483648#32))).bind
              fun x' => some (BitVec.ofBool (x' == 0#32))) âŠ‘
            some (BitVec.ofBool (xâœ &&& 2147483647#32 == 0#32))
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬((Option.map (fun div => xâœ + (~~~(div * 2147483648#32) + 1#32))
                  (some
                    (if xâœ.getLsbD 31 = true then (~~~xâœ + 1#32) / 2147483648#32
                    else ~~~(xâœ / 2147483648#32) + 1#32))).bind
              fun a => some (if (a == 0#32) = true then 1#1 else 0#1)) âŠ‘
            some (if (xâœ &&& 2147483647#32 == 0#32) = true then 1#1 else 0#1)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:313:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:306:8: error: (kernel) declaration has metavariables 'positive_and_odd_eq_thm'
[bv] [0.053286] Normalizing goal
  [Meta.synthInstance] [0.001245] âœ…ï¸ Decidable
        (((Option.map (fun div => xâœ - div * 2#32)
                (if (2#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 2#32 == -1) = true then none
                else some (xâœ.sdiv 2#32))).bind
            fun x' => some (BitVec.ofBool (x' == 1#32))) âŠ‘
          some (BitVec.ofBool (xâœ &&& 2147483649#32 == 1#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬((Option.map (fun div => xâœ - div * 2#32)
                  (if (2#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 2#32 == -1) = true then none
                  else some (xâœ.sdiv 2#32))).bind
              fun x' => some (BitVec.ofBool (x' == 1#32))) âŠ‘
            some (BitVec.ofBool (xâœ &&& 2147483649#32 == 1#32))
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬((Option.map (fun div => xâœ + (~~~(div * 2#32) + 1#32))
                  (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 2#32) + 1#32 else xâœ / 2#32))).bind
              fun a => some (if (a == 1#32) = true then 1#1 else 0#1)) âŠ‘
            some (if (xâœ &&& 2147483649#32 == 1#32) = true then 1#1 else 0#1)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:324:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:317:8: error: (kernel) declaration has metavariables 'positive_and_odd_ne_thm'
[bv] [0.054584] Normalizing goal
  [Meta.synthInstance] [0.001253] âœ…ï¸ Decidable
        (((Option.map (fun div => xâœ - div * 2#32)
                (if (2#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 2#32 == -1) = true then none
                else some (xâœ.sdiv 2#32))).bind
            fun x' => some (BitVec.ofBool (x' != 1#32))) âŠ‘
          some (BitVec.ofBool (xâœ &&& 2147483649#32 != 1#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬((Option.map (fun div => xâœ - div * 2#32)
                  (if (2#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 2#32 == -1) = true then none
                  else some (xâœ.sdiv 2#32))).bind
              fun x' => some (BitVec.ofBool (x' != 1#32))) âŠ‘
            some (BitVec.ofBool (xâœ &&& 2147483649#32 != 1#32))
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬((Option.map (fun div => xâœ + (~~~(div * 2#32) + 1#32))
                  (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 2#32) + 1#32 else xâœ / 2#32))).bind
              fun a => some (if (!a == 1#32) = true then 1#1 else 0#1)) âŠ‘
            some (if (!xâœ &&& 2147483649#32 == 1#32) = true then 1#1 else 0#1)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:334:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:328:8: error: (kernel) declaration has metavariables 'srem_constant_dividend_select_of_constants_divisor_thm'
[bv] [0.100050] Normalizing goal
  [Meta.synthInstance] [0.001757] âœ…ï¸ Decidable
        ((Option.bind
            (match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some 12#32
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some 4294967293#32)
            fun y' =>
            Option.map (fun div => 42#32 - div * y')
              (if (y' == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && y' == -1) = true then none
              else some ((42#32).sdiv y'))) âŠ‘
          match some xâœ with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } => some 6#32
          | some { toFin := âŸ¨0, â‹¯âŸ© } => some 0#32)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 1
      xâœ : BitVec 1
      aâœ :
        Â¬(Option.bind
              (match some xâœ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some 12#32
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some 4294967293#32)
              fun y' =>
              Option.map (fun div => 42#32 - div * y')
                (if (y' == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && y' == -1) = true then none
                else some ((42#32).sdiv y'))) âŠ‘
            match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some 6#32
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some 0#32
      âŠ¢ False
  [Meta.isDefEq] [0.001322] âœ…ï¸ ?hâ‚ =?= congrArg (fun x => x = true)
        (Eq.trans (congrArg (fun x => a == 0#32 || x && a == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
          (Std.Tactic.BVDecide.Normalize.Bool.or_elim (a == 0#32) (42#32 == BitVec.intMin 32 && a == 4294967295#32)))
    [Meta.isDefEq.assign] [0.001319] âœ…ï¸ ?hâ‚ := congrArg (fun x => x = true)
          (Eq.trans
            (congrArg (fun x => a == 0#32 || x && a == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
            (Std.Tactic.BVDecide.Normalize.Bool.or_elim (a == 0#32) (42#32 == BitVec.intMin 32 && a == 4294967295#32)))
      [Meta.isDefEq.assign.checkTypes] [0.001309] âœ…ï¸ (?hâ‚ : ((a == 0 ||
                32 != 1 && 42#32 == BitVec.intMin 32 && a == -1) =
              true) =
            ((!(!a == 0#32 && !(42#32 == BitVec.intMin 32 && a == 4294967295#32))) =
              true)) := (congrArg (fun x => x = true)
            (Eq.trans
              (congrArg (fun x => a == 0#32 || x && a == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
              (Std.Tactic.BVDecide.Normalize.Bool.or_elim (a == 0#32)
                (42#32 == BitVec.intMin 32 &&
                  a ==
                    4294967295#32))) : ((a == 0#32 || true && 42#32 == BitVec.intMin 32 && a == 4294967295#32) = true) =
            ((!(!a == 0#32 && !(42#32 == BitVec.intMin 32 && a == 4294967295#32))) = true))
        [Meta.isDefEq] [0.001305] âœ…ï¸ ((a == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && a == -1) = true) =
              ((!(!a == 0#32 && !(42#32 == BitVec.intMin 32 && a == 4294967295#32))) =
                true) =?= ((a == 0#32 || true && 42#32 == BitVec.intMin 32 && a == 4294967295#32) = true) =
              ((!(!a == 0#32 && !(42#32 == BitVec.intMin 32 && a == 4294967295#32))) = true)
          [Meta.isDefEq] [0.001288] âœ…ï¸ (a == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && a == -1) =
                true =?= (a == 0#32 || true && 42#32 == BitVec.intMin 32 && a == 4294967295#32) = true
            [Meta.isDefEq] [0.001274] âœ…ï¸ a == 0 ||
                  32 != 1 && 42#32 == BitVec.intMin 32 &&
                    a == -1 =?= a == 0#32 || true && 42#32 == BitVec.intMin 32 && a == 4294967295#32
              [Meta.isDefEq.delta] [0.001260] âœ…ï¸ a == 0 ||
                    32 != 1 && 42#32 == BitVec.intMin 32 &&
                      a == -1 =?= a == 0#32 || true && 42#32 == BitVec.intMin 32 && a == 4294967295#32
  [Meta.isDefEq] [0.001049] âœ…ï¸ ?hf =?= fun a a_1 =>
        congr
          (congrArg Option.map
            (funext fun div =>
              Eq.trans (BitVec.sub_toAdd (42#32) (div * a))
                (Eq.trans (congrArg (HAdd.hAdd 42#32) (BitVec.neg_eq_not_add (div * a)))
                  (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (42#32) (~~~(div * a)) 1#32))))
          (ite_congr
            (congrArg (fun x => x = true)
              (Eq.trans
                (congrArg (fun x => a == 0#32 || x && a == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim (a == 0#32)
                  (42#32 == BitVec.intMin 32 && a == 4294967295#32))))
            (fun a => Eq.refl none) fun a_2 =>
            congrArg some
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) a)
                (Eq.trans
                  (ite_cond_eq_false (if a.msb = true then -42#32 / -a else -(-42#32 / a))
                    (if a.msb = true then -(42#32 / -a) else 42#32 / a)
                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                      (eq_false' fun h => Bool.noConfusion h)))
                  (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last a))
                    (fun a_3 =>
                      Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add a))
                        (BitVec.neg_eq_not_add (42#32 / (~~~a + 1#32))))
                    fun a_3 => Eq.refl (42#32 / a)))))
    [Meta.isDefEq.assign] [0.001044] âœ…ï¸ ?hf := fun a a_1 =>
          congr
            (congrArg Option.map
              (funext fun div =>
                Eq.trans (BitVec.sub_toAdd (42#32) (div * a))
                  (Eq.trans (congrArg (HAdd.hAdd 42#32) (BitVec.neg_eq_not_add (div * a)))
                    (Std.Tactic.BVDecide.Normalize.BitVec.add_const_right (42#32) (~~~(div * a)) 1#32))))
            (ite_congr
              (congrArg (fun x => x = true)
                (Eq.trans
                  (congrArg (fun x => a == 0#32 || x && a == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim (a == 0#32)
                    (42#32 == BitVec.intMin 32 && a == 4294967295#32))))
              (fun a => Eq.refl none) fun a_2 =>
              congrArg some
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv (42#32) a)
                  (Eq.trans
                    (ite_cond_eq_false (if a.msb = true then -42#32 / -a else -(-42#32 / a))
                      (if a.msb = true then -(42#32 / -a) else 42#32 / a)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 42#32))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last a))
                      (fun a_3 =>
                        Eq.trans (congrArg (fun x => -(42#32 / x)) (BitVec.neg_eq_not_add a))
                          (BitVec.neg_eq_not_add (42#32 / (~~~a + 1#32))))
                      fun a_3 => Eq.refl (42#32 / a)))))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 1
      xâœ : BitVec 1
      aâœ :
        Â¬(Option.bind
              (match some xâœ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some 12#32
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some 4294967293#32)
              fun a =>
              Option.map (fun div => 43#32 + ~~~(div * a))
                (if (!(!a == 0#32 && !(42#32 == BitVec.intMin 32 && a == 4294967295#32))) = true then none
                else some (if a.getLsbD 31 = true then ~~~(42#32 / (~~~a + 1#32)) + 1#32 else 42#32 / a))) âŠ‘
            match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some 6#32
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some 0#32
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:344:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:338:8: error: (kernel) declaration has metavariables 'srem_constant_dividend_select_of_constants_divisor_0_arm_thm'
[bv] [0.088218] Normalizing goal
  [Meta.synthInstance] [0.001420] âœ…ï¸ Decidable
        ((Option.bind
            (match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some 12#32
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some 0#32)
            fun y' =>
            Option.map (fun div => 42#32 - div * y')
              (if (y' == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && y' == -1) = true then none
              else some ((42#32).sdiv y'))) âŠ‘
          some 6#32)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 1
      xâœ : BitVec 1
      aâœ :
        Â¬(Option.bind
              (match some xâœ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some 12#32
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some 0#32)
              fun y' =>
              Option.map (fun div => 42#32 - div * y')
                (if (y' == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && y' == -1) = true then none
                else some ((42#32).sdiv y'))) âŠ‘
            some 6#32
      âŠ¢ False
  [Meta.isDefEq] [0.001268] âœ…ï¸ ?hâ‚ =?= congrArg (fun x => x = true)
        (Eq.trans (congrArg (fun x => a == 0#32 || x && a == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
          (Std.Tactic.BVDecide.Normalize.Bool.or_elim (a == 0#32) (42#32 == BitVec.intMin 32 && a == 4294967295#32)))
    [Meta.isDefEq.assign] [0.001266] âœ…ï¸ ?hâ‚ := congrArg (fun x => x = true)
          (Eq.trans
            (congrArg (fun x => a == 0#32 || x && a == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
            (Std.Tactic.BVDecide.Normalize.Bool.or_elim (a == 0#32) (42#32 == BitVec.intMin 32 && a == 4294967295#32)))
      [Meta.isDefEq.assign.checkTypes] [0.001255] âœ…ï¸ (?hâ‚ : ((a == 0 ||
                32 != 1 && 42#32 == BitVec.intMin 32 && a == -1) =
              true) =
            ((!(!a == 0#32 && !(42#32 == BitVec.intMin 32 && a == 4294967295#32))) =
              true)) := (congrArg (fun x => x = true)
            (Eq.trans
              (congrArg (fun x => a == 0#32 || x && a == 4294967295#32) (Bool.true_and (42#32 == BitVec.intMin 32)))
              (Std.Tactic.BVDecide.Normalize.Bool.or_elim (a == 0#32)
                (42#32 == BitVec.intMin 32 &&
                  a ==
                    4294967295#32))) : ((a == 0#32 || true && 42#32 == BitVec.intMin 32 && a == 4294967295#32) = true) =
            ((!(!a == 0#32 && !(42#32 == BitVec.intMin 32 && a == 4294967295#32))) = true))
        [Meta.isDefEq] [0.001252] âœ…ï¸ ((a == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && a == -1) = true) =
              ((!(!a == 0#32 && !(42#32 == BitVec.intMin 32 && a == 4294967295#32))) =
                true) =?= ((a == 0#32 || true && 42#32 == BitVec.intMin 32 && a == 4294967295#32) = true) =
              ((!(!a == 0#32 && !(42#32 == BitVec.intMin 32 && a == 4294967295#32))) = true)
          [Meta.isDefEq] [0.001235] âœ…ï¸ (a == 0 || 32 != 1 && 42#32 == BitVec.intMin 32 && a == -1) =
                true =?= (a == 0#32 || true && 42#32 == BitVec.intMin 32 && a == 4294967295#32) = true
            [Meta.isDefEq] [0.001221] âœ…ï¸ a == 0 ||
                  32 != 1 && 42#32 == BitVec.intMin 32 &&
                    a == -1 =?= a == 0#32 || true && 42#32 == BitVec.intMin 32 && a == 4294967295#32
              [Meta.isDefEq.delta] [0.001207] âœ…ï¸ a == 0 ||
                    32 != 1 && 42#32 == BitVec.intMin 32 &&
                      a == -1 =?= a == 0#32 || true && 42#32 == BitVec.intMin 32 && a == 4294967295#32
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 1
      xâœ : BitVec 1
      aâœ :
        Â¬(Option.bind
              (match some xâœ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some 12#32
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some 0#32)
              fun a =>
              Option.map (fun div => 43#32 + ~~~(div * a))
                (if (!(!a == 0#32 && !(42#32 == BitVec.intMin 32 && a == 4294967295#32))) = true then none
                else some (if a.getLsbD 31 = true then ~~~(42#32 / (~~~a + 1#32)) + 1#32 else 42#32 / a))) âŠ‘
            some 6#32
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:354:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:348:8: error: (kernel) declaration has metavariables 'urem_constant_dividend_select_of_constants_divisor_thm'
[bv] [0.049841] Normalizing goal
  [Meta.synthInstance] [0.001565] âœ…ï¸ Decidable
        ((Option.bind
            (match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some 12#32
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some 4294967293#32)
            fun y' => if y' = 0 then none else some (42#32 % y')) âŠ‘
          match some xâœ with
          | none => none
          | some { toFin := âŸ¨1, â‹¯âŸ© } => some 6#32
          | some { toFin := âŸ¨0, â‹¯âŸ© } => some 42#32)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 1
      xâœ : BitVec 1
      aâœ :
        Â¬(Option.bind
              (match some xâœ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some 12#32
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some 4294967293#32)
              fun y' => if y' = 0 then none else some (42#32 % y')) âŠ‘
            match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some 6#32
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some 42#32
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 1
      xâœ : BitVec 1
      aâœ :
        Â¬(Option.bind
              (match some xâœ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some 12#32
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some 4294967293#32)
              fun a => if (a == 0#32) = true then none else some (42#32 % a)) âŠ‘
            match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some 6#32
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some 42#32
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:363:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/grem_proof.lean:358:8: error: (kernel) declaration has metavariables 'urem_constant_dividend_select_of_constants_divisor_0_arm_thm'
[bv] [0.038342] Normalizing goal
  [Meta.synthInstance] [0.001178] âœ…ï¸ Decidable
        ((Option.bind
            (match some xâœ with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some 12#32
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some 0#32)
            fun y' => if y' = 0 then none else some (42#32 % y')) âŠ‘
          some 6#32)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 1
      xâœ : BitVec 1
      aâœ :
        Â¬(Option.bind
              (match some xâœ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some 12#32
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some 0#32)
              fun y' => if y' = 0 then none else some (42#32 % y')) âŠ‘
            some 6#32
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 1
      xâœ : BitVec 1
      aâœ :
        Â¬(Option.bind
              (match some xâœ with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some 12#32
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some 0#32)
              fun a => if (a == 0#32) = true then none else some (42#32 % a)) âŠ‘
            some 6#32
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
