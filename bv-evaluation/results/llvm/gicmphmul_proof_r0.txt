⚠ [60/892] Replayed Mathlib.Algebra.Group.Defs
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Defs.lean:802:33: `pow_succ'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Defs.lean:807:6: `pow_mul_comm'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Defs.lean:816:6: `pow_three'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Defs.lean:839:6: `pow_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [72/892] Replayed Mathlib.Logic.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Basic.lean:155:8: `dec_em'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Basic.lean:159:8: `em'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Basic.lean:304:8: `or_congr_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Basic.lean:307:8: `or_congr_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Basic.lean:320:8: `imp_or'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Basic.lean:359:8: `xor_iff_not_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Basic.lean:418:8: `eqRec_heq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Basic.lean:515:8: `forall_true_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Basic.lean:536:8: `exists_apply_eq_apply'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Basic.lean:543:6: `exists_apply_eq_apply2'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Basic.lean:552:6: `exists_apply_eq_apply3'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Basic.lean:579:8: `forall_apply_eq_imp_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Basic.lean:582:8: `forall_eq_apply_imp_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Basic.lean:642:8: `forall_prop_congr'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Basic.lean:715:6: `Classical.choose_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Basic.lean:851:8: `dite_eq_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Basic.lean:855:8: `ite_eq_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [73/892] Replayed Mathlib.Logic.ExistsUnique
warning: ././.lake/packages/mathlib/././Mathlib/Logic/ExistsUnique.lean:109:16: `exists_unique_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [76/892] Replayed Mathlib.Logic.Function.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Function/Basic.lean:83:8: `Function.Injective.eq_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Function/Basic.lean:92:8: `Function.Injective.ne_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Function/Basic.lean:122:8: `Function.Injective.of_comp_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Function/Basic.lean:168:8: `Function.Surjective.of_comp_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Function/Basic.lean:242:8: `Function.Bijective.of_comp_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Function/Basic.lean:546:8: `Function.update_comp_eq_of_forall_ne'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Function/Basic.lean:557:8: `Function.update_comp_eq_of_injective'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Function/Basic.lean:654:8: `Function.extend_apply'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Function/Basic.lean:686:8: `Function.Injective.surjective_comp_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [78/892] Replayed Mathlib.Algebra.GroupWithZero.Defs
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/GroupWithZero/Defs.lean:110:8: `mul_left_inj'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/GroupWithZero/Defs.lean:113:8: `mul_right_inj'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [82/892] Replayed Mathlib.Algebra.Ring.Defs
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Ring/Defs.lean:233:6: `add_sq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [86/892] Replayed Mathlib.Algebra.Field.Defs
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Field/Defs.lean:201:6: `Rat.cast_mk'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [233/892] Replayed Mathlib.Data.Nat.Defs
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:89:6: `Nat.succ_pos'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:280:16: `Nat.sub_eq_of_eq_add'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:282:16: `Nat.eq_sub_of_add_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:285:16: `Nat.lt_sub_iff_add_lt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:287:16: `Nat.sub_lt_iff_lt_add'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:370:6: `Nat.mul_lt_mul''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:415:6: `Nat.le_div_iff_mul_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:417:6: `Nat.div_lt_iff_lt_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:451:16: `Nat.mul_div_cancel_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:503:16: `Nat.div_le_of_le_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:517:16: `Nat.div_le_self'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:628:6: `Nat.one_le_pow'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:634:6: `Nat.one_lt_pow'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:643:6: `Nat.one_lt_two_pow'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:726:6: `Nat.leRec_succ'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:770:6: `Nat.leRecOn_succ'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:877:6: `Nat.decreasingInduction_succ'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:1066:6: `Nat.mod_add_div'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:1068:6: `Nat.div_add_mod'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:1158:6: `Nat.mul_add_mod'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Defs.lean:1175:6: `Nat.dvd_sub'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [234/892] Replayed Mathlib.Logic.IsEmpty
warning: ././.lake/packages/mathlib/././Mathlib/Logic/IsEmpty.lean:36:9: `Fin.isEmpty'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [238/892] Replayed Mathlib.Tactic.Lift
warning: ././.lake/packages/mathlib/././Mathlib/Tactic/Lift.lean:49:9: `PiSubtype.canLift'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [239/892] Replayed Mathlib.Data.Int.Defs
warning: ././.lake/packages/mathlib/././Mathlib/Data/Int/Defs.lean:191:16: `Int.add_le_zero_iff_le_neg'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Int/Defs.lean:193:16: `Int.add_nonnneg_iff_neg_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Int/Defs.lean:324:14: `Int.natAbs_ofNat'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Int/Defs.lean:577:6: `Int.toNat_lt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [241/892] Replayed Mathlib.Algebra.Group.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Basic.lean:165:8: `mul_rotate'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Basic.lean:331:8: `mul_div_assoc'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Basic.lean:445:6: `inv_zpow'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Basic.lean:490:6: `zpow_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Basic.lean:516:8: `inv_div'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Basic.lean:527:8: `inv_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Basic.lean:707:8: `div_self'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Basic.lean:721:8: `eq_div_of_mul_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Basic.lean:724:8: `div_eq_of_eq_mul''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Basic.lean:767:8: `eq_div_iff_mul_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Basic.lean:869:8: `zpow_eq_zpow_emod'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Basic.lean:915:8: `div_eq_of_eq_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Basic.lean:924:8: `eq_div_of_mul_eq''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Basic.lean:927:8: `eq_mul_of_div_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Basic.lean:930:8: `mul_eq_of_eq_div'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Basic.lean:934:8: `div_div_self'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Basic.lean:947:8: `eq_div_iff_mul_eq''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Basic.lean:950:8: `div_eq_iff_eq_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Basic.lean:978:8: `div_mul_div_cancel'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [242/892] Replayed Mathlib.Algebra.Group.Units.Defs
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Units/Defs.lean:438:8: `isUnit_iff_exists_inv'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Units/Defs.lean:547:21: `IsUnit.val_inv_unit'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [244/892] Replayed Mathlib.Logic.Unique
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Unique.lean:131:18: `Unique.subsingleton_unique'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Unique.lean:259:9: `Unique.subtypeEq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [253/892] Replayed Mathlib.Logic.Function.Iterate
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Function/Iterate.lean:160:8: `Function.iterate_succ'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Function/Iterate.lean:163:8: `Function.iterate_succ_apply'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [254/892] Replayed Mathlib.Data.Prod.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Data/Prod/Basic.lean:31:8: `Prod.forall'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Prod/Basic.lean:34:8: `Prod.exists'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Prod/Basic.lean:51:8: `Prod.map_apply'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Prod/Basic.lean:54:8: `Prod.map_fst'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Prod/Basic.lean:57:8: `Prod.map_snd'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [260/892] Replayed Mathlib.Algebra.Group.Units.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Units/Basic.lean:210:8: `eq_one_of_mul_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Units/Basic.lean:213:8: `eq_one_of_mul_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Units/Basic.lean:216:8: `mul_eq_one'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Units/Basic.lean:219:8: `mul_ne_one'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [261/892] Replayed Mathlib.Algebra.Group.Semiconj.Units
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Semiconj/Units.lean:100:6: `Units.conj_pow'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [263/892] Replayed Mathlib.Algebra.Group.Invertible.Defs
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Invertible/Defs.lean:97:8: `invOf_mul_self'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Invertible/Defs.lean:103:8: `mul_invOf_self'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Invertible/Defs.lean:109:8: `invOf_mul_cancel_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Invertible/Defs.lean:120:8: `mul_invOf_cancel_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Invertible/Defs.lean:131:8: `invOf_mul_cancel_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Invertible/Defs.lean:142:8: `mul_invOf_cancel_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Invertible/Defs.lean:198:8: `invOf_one'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [272/892] Replayed Mathlib.Data.FunLike.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Data/FunLike/Basic.lean:187:8: `DFunLike.ext'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [273/892] Replayed Mathlib.Algebra.Group.Hom.Defs
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Hom/Defs.lean:407:8: `map_div'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Hom/Defs.lean:412:6: `map_comp_div'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Hom/Defs.lean:460:8: `map_zpow'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Hom/Defs.lean:466:6: `map_comp_zpow'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Hom/Defs.lean:842:18: `MonoidHom.map_zpow'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [278/892] Replayed Mathlib.Logic.Relation
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Relation.lean:351:8: `Relation.TransGen.head'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Relation.lean:354:8: `Relation.TransGen.tail'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Relation.lean:444:8: `Relation.TransGen.lift'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Relation.lean:453:6: `Relation.TransGen.closed'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Relation.lean:523:8: `Relation.ReflTransGen.lift'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [285/892] Replayed Mathlib.Data.Quot
warning: ././.lake/packages/mathlib/././Mathlib/Data/Quot.lean:563:18: `Quotient.liftOn'_mk''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Quot.lean:567:14: `Quotient.surjective_liftOn'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Quot.lean:578:18: `Quotient.liftOn₂'_mk''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Quot.lean:644:8: `Quotient.hrecOn'_mk''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Quot.lean:657:8: `Quotient.hrecOn₂'_mk''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Quot.lean:669:8: `Quotient.map'_mk''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Quot.lean:679:8: `Quotient.map₂'_mk''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Quot.lean:684:8: `Quotient.exact'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Quot.lean:688:8: `Quotient.sound'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Quot.lean:692:18: `Quotient.eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Quot.lean:696:18: `Quotient.eq''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Quot.lean:705:8: `Quotient.out_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Quot.lean:708:8: `Quotient.mk_out'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [286/892] Replayed Mathlib.Data.Bool.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Data/Bool/Basic.lean:156:8: `Bool.eq_true_of_not_eq_false'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Bool/Basic.lean:159:8: `Bool.eq_false_of_not_eq_true'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [288/892] Replayed Mathlib.Logic.Equiv.Defs
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Equiv/Defs.lean:138:9: `Equiv.inhabited'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Equiv/Defs.lean:153:8: `Equiv.left_inv'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Equiv/Defs.lean:154:8: `Equiv.right_inv'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Equiv/Defs.lean:725:16: `Equiv.forall_congr'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Equiv/Defs.lean:737:16: `Equiv.exists_congr'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Equiv/Defs.lean:757:16: `Equiv.existsUnique_congr'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Equiv/Defs.lean:772:18: `Equiv.forall₂_congr'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Equiv/Defs.lean:782:18: `Equiv.forall₃_congr'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [290/892] Replayed Mathlib.Algebra.NeZero
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/NeZero.lean:44:6: `zero_ne_one'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/NeZero.lean:46:6: `one_ne_zero'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/NeZero.lean:48:6: `two_ne_zero'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/NeZero.lean:50:6: `three_ne_zero'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/NeZero.lean:52:6: `four_ne_zero'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [292/892] Replayed Mathlib.Algebra.GroupWithZero.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/GroupWithZero/Basic.lean:185:14: `pow_eq_zero_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/GroupWithZero/Basic.lean:350:8: `div_self_mul_self'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/GroupWithZero/Basic.lean:417:6: `zpow_add'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [295/892] Replayed Mathlib.Algebra.GroupWithZero.Units.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/GroupWithZero/Units/Basic.lean:183:8: `Units.mul_inv'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/GroupWithZero/Units/Basic.lean:187:8: `Units.inv_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/GroupWithZero/Units/Basic.lean:300:6: `div_left_inj'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/GroupWithZero/Units/Basic.lean:395:8: `Ring.inverse_eq_inv'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/GroupWithZero/Units/Basic.lean:435:6: `mul_div_cancel_of_imp'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/GroupWithZero/Units/Basic.lean:457:6: `div_div_cancel'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/GroupWithZero/Units/Basic.lean:459:6: `div_div_cancel_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/GroupWithZero/Units/Basic.lean:464:6: `div_div_div_cancel_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/GroupWithZero/Units/Basic.lean:467:14: `div_mul_div_cancel₀'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [297/892] Replayed Mathlib.Data.Sigma.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Data/Sigma/Basic.lean:90:6: `Sigma.exists'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Sigma/Basic.lean:93:6: `Sigma.forall'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [313/892] Replayed Mathlib.Logic.Equiv.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Logic/Equiv/Basic.lean:1706:8: `Equiv.coe_piCongr'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [314/892] Replayed Mathlib.Algebra.Group.Equiv.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Equiv/Basic.lean:330:8: `MulEquiv.mk_coe'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [320/892] Replayed Mathlib.Algebra.Group.TypeTags
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/TypeTags.lean:494:6: `AddMonoidHom.coe_toMultiplicative'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/TypeTags.lean:504:6: `MonoidHom.coe_toAdditive'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/TypeTags.lean:525:6: `AddMonoidHom.coe_toMultiplicative''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/TypeTags.lean:535:6: `MonoidHom.coe_toAdditive''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [323/892] Replayed Mathlib.Data.Nat.Sqrt
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Sqrt.lean:114:6: `Nat.sqrt_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Sqrt.lean:118:6: `Nat.lt_succ_sqrt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Sqrt.lean:127:6: `Nat.le_sqrt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Sqrt.lean:131:6: `Nat.sqrt_lt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Sqrt.lean:150:6: `Nat.eq_sqrt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Sqrt.lean:170:6: `Nat.sqrt_add_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Sqrt.lean:175:6: `Nat.sqrt_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Sqrt.lean:185:6: `Nat.exists_mul_self'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Sqrt.lean:191:6: `Nat.sqrt_mul_sqrt_lt_succ'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Sqrt.lean:197:6: `Nat.succ_le_succ_sqrt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Sqrt.lean:207:6: `Nat.not_exists_sq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [324/892] Replayed Mathlib.Algebra.Group.Nat
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Nat.lean:128:6: `Nat.even_pow'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [336/892] Replayed Mathlib.Algebra.GroupWithZero.Commute
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/GroupWithZero/Commute.lean:22:8: `Ring.mul_inverse_rev'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [342/892] Replayed Mathlib.Algebra.Ring.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Ring/Basic.lean:92:8: `inv_neg'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [346/892] Replayed Mathlib.Algebra.Ring.Commute
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Ring/Commute.lean:47:8: `Commute.mul_self_sub_mul_self_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Ring/Commute.lean:131:6: `neg_pow'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Ring/Commute.lean:193:6: `sub_sq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [427/892] Replayed Mathlib.Control.Combinators
warning: ././.lake/packages/mathlib/././Mathlib/Control/Combinators.lean:35:4: `Monad.mapM'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Control/Combinators.lean:57:4: `Monad.sequence'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [428/892] Replayed Mathlib.Data.Option.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Data/Option/Basic.lean:80:8: `Option.none_bind'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Option/Basic.lean:84:8: `Option.some_bind'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Option/Basic.lean:87:8: `Option.bind_eq_some'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Option/Basic.lean:96:8: `Option.bind_congr'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Option/Basic.lean:103:8: `Option.bind_eq_bind'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Option/Basic.lean:110:8: `Option.map_coe'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Option/Basic.lean:140:8: `Option.map_bind'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Option/Basic.lean:207:8: `Option.some_orElse'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Option/Basic.lean:211:8: `Option.none_orElse'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Option/Basic.lean:214:8: `Option.orElse_none'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Option/Basic.lean:229:8: `Option.guard_eq_some'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Option/Basic.lean:276:8: `Option.orElse_eq_some'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Option/Basic.lean:287:8: `Option.orElse_eq_none'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [433/892] Replayed Mathlib.Algebra.Group.Action.Faithful
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Action/Faithful.lean:51:6: `smul_left_injective'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [435/892] Replayed Mathlib.Algebra.GroupWithZero.Action.Defs
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/GroupWithZero/Action/Defs.lean:237:9: `AddMonoid.nat_smulCommClass'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/GroupWithZero/Action/Defs.lean:250:9: `AddGroup.int_smulCommClass'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/GroupWithZero/Action/Defs.lean:278:8: `smul_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/GroupWithZero/Action/Defs.lean:318:14: `smul_pow'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/GroupWithZero/Action/Defs.lean:328:8: `smul_inv'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/GroupWithZero/Action/Defs.lean:331:8: `smul_div'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [439/892] Replayed Mathlib.Order.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:69:8: `le_trans'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:72:8: `lt_trans'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:75:8: `lt_of_le_of_lt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:78:8: `lt_of_lt_of_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:90:8: `lt_of_le_of_ne'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:95:8: `Ne.lt_of_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:155:8: `le_of_le_of_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:158:8: `le_of_eq_of_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:161:8: `lt_of_lt_of_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:164:8: `lt_of_eq_of_lt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:264:8: `LT.lt.ne'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:349:8: `min_def'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:358:8: `max_def'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:401:8: `lt_iff_lt_of_le_iff_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:419:8: `le_of_forall_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:428:8: `le_of_forall_lt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:431:8: `forall_lt_iff_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:850:8: `update_le_update_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:909:8: `min_rec'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Basic.lean:912:8: `max_rec'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [441/892] Replayed Mathlib.Algebra.Field.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Field/Basic.lean:56:8: `add_div'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Field/Basic.lean:60:8: `div_add'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Field/Basic.lean:103:8: `neg_div'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Field/Basic.lean:199:8: `sub_div'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Field/Basic.lean:203:8: `div_sub'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [444/892] Replayed Mathlib.Order.Compare
warning: ././.lake/packages/mathlib/././Mathlib/Order/Compare.lean:220:8: `Eq.cmp_eq_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [447/892] Replayed Mathlib.Order.RelClasses
warning: ././.lake/packages/mathlib/././Mathlib/Order/RelClasses.lean:35:8: `antisymm'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/RelClasses.lean:112:8: `ne_of_irrefl'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [448/892] Replayed Mathlib.Order.Monotone.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Order/Monotone/Basic.lean:457:8: `Subsingleton.monotone'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Monotone/Basic.lean:460:8: `Subsingleton.antitone'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Monotone/Basic.lean:549:18: `StrictMono.ite'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Monotone/Basic.lean:567:18: `StrictAnti.ite'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [455/892] Replayed Mathlib.Algebra.Order.Monoid.Unbundled.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:63:8: `mul_le_mul_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:68:8: `le_of_mul_le_mul_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:76:8: `mul_le_mul_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:82:8: `le_of_mul_le_mul_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:118:8: `mul_lt_mul_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:123:8: `lt_of_mul_lt_mul_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:129:8: `mul_lt_mul_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:135:8: `lt_of_mul_lt_mul_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:184:8: `mul_le_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:251:8: `mul_left_cancel''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:256:8: `mul_right_cancel''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:310:8: `max_mul_mul_le_max_mul_max'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:315:8: `min_mul_min_le_min_mul_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:332:8: `le_mul_of_one_le_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:339:8: `mul_le_of_le_one_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:346:8: `le_mul_of_one_le_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:353:8: `mul_le_of_le_one_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:382:8: `le_mul_iff_one_le_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:388:8: `le_mul_iff_one_le_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:394:8: `mul_le_iff_le_one_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:400:8: `mul_le_iff_le_one_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:412:8: `lt_mul_of_one_lt_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:419:8: `mul_lt_of_lt_one_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:426:8: `lt_mul_of_one_lt_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:434:8: `mul_lt_of_lt_one_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:464:8: `lt_mul_iff_one_lt_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:470:8: `lt_mul_iff_one_lt_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:475:8: `mul_lt_iff_lt_one_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:481:8: `mul_lt_iff_lt_one_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:532:8: `mul_lt_of_lt_of_lt_one'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:622:8: `lt_mul_of_lt_of_one_lt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:712:8: `mul_lt_of_lt_one_of_lt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:805:8: `lt_mul_of_one_lt_of_lt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:1058:8: `Monotone.const_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:1062:8: `MonotoneOn.const_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:1066:8: `Antitone.const_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:1070:8: `AntitoneOn.const_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:1074:8: `Monotone.mul_const'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:1078:8: `MonotoneOn.mul_const'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:1083:8: `Antitone.mul_const'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:1087:8: `AntitoneOn.mul_const'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:1122:8: `StrictMono.const_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:1126:8: `StrictMonoOn.const_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:1131:8: `StrictAnti.const_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:1135:8: `StrictAntiOn.const_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:1146:8: `StrictMono.mul_const'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:1150:8: `StrictMonoOn.mul_const'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:1155:8: `StrictAnti.mul_const'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:1159:8: `StrictAntiOn.mul_const'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:1259:8: `cmp_mul_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean:1265:8: `cmp_mul_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [456/892] Replayed Mathlib.Algebra.Order.Sub.Defs
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Sub/Defs.lean:200:8: `le_add_tsub'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [457/892] Replayed Mathlib.Algebra.Order.Group.Unbundled.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Unbundled/Basic.lean:60:8: `inv_le_iff_one_le_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Unbundled/Basic.lean:102:8: `inv_lt_iff_one_lt_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Unbundled/Basic.lean:106:8: `lt_inv_iff_mul_lt_one'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Unbundled/Basic.lean:257:8: `inv_lt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Unbundled/Basic.lean:260:8: `lt_inv'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Unbundled/Basic.lean:354:8: `inv_mul_le_iff_le_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Unbundled/Basic.lean:358:8: `mul_inv_le_iff_le_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Unbundled/Basic.lean:362:8: `mul_inv_le_mul_inv_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Unbundled/Basic.lean:372:8: `inv_mul_lt_iff_lt_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Unbundled/Basic.lean:376:8: `mul_inv_lt_iff_le_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Unbundled/Basic.lean:380:8: `mul_inv_lt_mul_inv_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Unbundled/Basic.lean:477:8: `div_le_div_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Unbundled/Basic.lean:481:8: `one_le_div'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Unbundled/Basic.lean:487:8: `div_le_one'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Unbundled/Basic.lean:525:8: `div_le_div_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Unbundled/Basic.lean:541:8: `div_le_div_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Unbundled/Basic.lean:545:8: `le_div_iff_mul_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Unbundled/Basic.lean:550:8: `div_le_iff_le_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Unbundled/Basic.lean:559:8: `inv_le_div_iff_le_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Unbundled/Basic.lean:576:8: `div_le_div''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Unbundled/Basic.lean:599:8: `div_lt_div_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Unbundled/Basic.lean:603:8: `one_lt_div'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Unbundled/Basic.lean:609:8: `div_lt_one'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Unbundled/Basic.lean:645:8: `div_lt_div_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Unbundled/Basic.lean:661:8: `div_lt_div_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Unbundled/Basic.lean:665:8: `lt_div_iff_mul_lt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Unbundled/Basic.lean:670:8: `div_lt_iff_lt_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Unbundled/Basic.lean:675:8: `inv_lt_div_iff_lt_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Unbundled/Basic.lean:693:8: `div_lt_div''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Unbundled/Basic.lean:713:8: `cmp_div_one'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [462/892] Replayed Mathlib.Order.BoundedOrder
warning: ././.lake/packages/mathlib/././Mathlib/Order/BoundedOrder.lean:146:8: `Ne.lt_top'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/BoundedOrder.lean:323:8: `Ne.bot_lt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [463/892] Replayed Mathlib.Order.Disjoint
warning: ././.lake/packages/mathlib/././Mathlib/Order/Disjoint.lean:139:8: `Disjoint.inf_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Disjoint.lean:145:8: `Disjoint.inf_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Disjoint.lean:153:8: `Disjoint.of_disjoint_inf_of_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Disjoint.lean:267:6: `Codisjoint.ne_bot_of_ne_top'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Disjoint.lean:302:8: `Codisjoint.sup_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Disjoint.lean:308:8: `Codisjoint.sup_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Disjoint.lean:317:8: `Codisjoint.of_codisjoint_sup_of_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [466/892] Replayed Mathlib.Order.WithBot
warning: ././.lake/packages/mathlib/././Mathlib/Order/WithBot.lean:361:8: `WithBot.le_coe_unbot'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [468/892] Replayed Mathlib.Order.Hom.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Order/Hom/Basic.lean:1079:8: `OrderIso.map_bot'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Hom/Basic.lean:1088:8: `OrderIso.map_top'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [469/892] Replayed Mathlib.Algebra.Order.Group.OrderIso
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/OrderIso.lean:42:8: `inv_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/OrderIso.lean:50:8: `le_inv'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [471/892] Replayed Mathlib.Algebra.Order.Group.Unbundled.Abs
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Unbundled/Abs.lean:60:21: `mabs_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Unbundled/Abs.lean:249:21: `max_div_min_eq_mabs'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [475/892] Replayed Mathlib.Algebra.Order.GroupWithZero.Unbundled
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/GroupWithZero/Unbundled.lean:258:8: `mul_le_mul_of_nonneg'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/GroupWithZero/Unbundled.lean:299:8: `mul_lt_mul_of_pos'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/GroupWithZero/Unbundled.lean:561:8: `mul_eq_mul_iff_eq_and_eq_of_pos'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/GroupWithZero/Unbundled.lean:741:8: `mul_le_of_le_of_le_one'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/GroupWithZero/Unbundled.lean:745:8: `mul_lt_of_lt_of_le_one'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/GroupWithZero/Unbundled.lean:749:8: `mul_lt_of_le_of_lt_one'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/GroupWithZero/Unbundled.lean:787:8: `le_mul_of_le_of_one_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/GroupWithZero/Unbundled.lean:791:8: `lt_mul_of_le_of_one_lt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/GroupWithZero/Unbundled.lean:795:8: `lt_mul_of_lt_of_one_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/GroupWithZero/Unbundled.lean:837:8: `mul_le_of_le_one_of_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/GroupWithZero/Unbundled.lean:841:8: `mul_lt_of_lt_one_of_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/GroupWithZero/Unbundled.lean:845:8: `mul_lt_of_le_one_of_lt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/GroupWithZero/Unbundled.lean:928:8: `exists_square_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/GroupWithZero/Unbundled.lean:1064:16: `Decidable.mul_lt_mul''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/GroupWithZero/Unbundled.lean:1497:14: `inv_neg''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [476/892] Replayed Mathlib.Algebra.Order.Group.Synonym
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Synonym.lean:39:9: `OrderDual.instPow'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Synonym.lean:156:9: `Lex.instPow'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [478/892] Replayed Mathlib.Algebra.Order.Monoid.Unbundled.Pow
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Pow.lean:68:8: `pow_le_pow_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Pow.lean:72:8: `pow_le_pow_right_of_le_one'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Pow.lean:76:8: `one_lt_pow'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Pow.lean:86:8: `pow_right_strictMono'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Pow.lean:90:8: `pow_lt_pow_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Pow.lean:140:6: `pow_lt_pow_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Pow.lean:150:8: `pow_le_pow_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Pow.lean:207:8: `pow_le_pow_iff_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Pow.lean:211:8: `pow_lt_pow_iff_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Pow.lean:221:8: `lt_of_pow_lt_pow_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Pow.lean:239:8: `le_of_pow_le_pow_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/Pow.lean:253:8: `Left.pow_lt_one_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [482/892] Replayed Mathlib.Order.Heyting.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Order/Heyting/Basic.lean:380:8: `sdiff_le_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Heyting/Basic.lean:431:8: `sup_sdiff_cancel'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Heyting/Basic.lean:766:8: `top_sdiff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [483/892] Replayed Mathlib.Order.BooleanAlgebra
warning: ././.lake/packages/mathlib/././Mathlib/Order/BooleanAlgebra.lean:287:8: `sdiff_eq_self_iff_disjoint'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/BooleanAlgebra.lean:337:8: `sdiff_sdiff_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/BooleanAlgebra.lean:367:8: `sdiff_sdiff_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/BooleanAlgebra.lean:379:8: `sdiff_sdiff_sup_sdiff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/BooleanAlgebra.lean:524:8: `inf_compl_eq_bot'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [485/892] Replayed Mathlib.Data.Set.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Basic.lean:127:9: `Set.PiSetCoe.canLift'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Basic.lean:153:8: `SetCoe.exists'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Basic.lean:157:8: `SetCoe.forall'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Basic.lean:391:8: `Set.nonempty_of_ssubset'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Basic.lean:1030:8: `Set.setOf_eq_eq_singleton'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Basic.lean:1209:8: `Set.eq_of_nonempty_of_subsingleton'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Basic.lean:1453:8: `Set.union_diff_cancel'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Basic.lean:2135:8: `Disjoint.inter_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Basic.lean:2141:8: `Disjoint.inter_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [488/892] Replayed Mathlib.Order.SymmDiff
warning: ././.lake/packages/mathlib/././Mathlib/Order/SymmDiff.lean:80:8: `symmDiff_eq_Xor'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/SymmDiff.lean:286:8: `symmDiff_top'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/SymmDiff.lean:289:8: `top_symmDiff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/SymmDiff.lean:349:8: `sdiff_symmDiff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/SymmDiff.lean:418:8: `symmDiff_symmDiff_self'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/SymmDiff.lean:588:8: `symmDiff_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/SymmDiff.lean:591:8: `bihimp_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/SymmDiff.lean:634:8: `symmDiff_symmDiff_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [490/892] Replayed Mathlib.Data.Set.Image
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Image.lean:107:8: `Set.preimage_id'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Image.lean:625:8: `Set.Nonempty.preimage'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Image.lean:718:8: `Set.preimage_eq_preimage'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Image.lean:745:8: `Set.range_id'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Image.lean:837:8: `Set.range_quotient_mk'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Image.lean:840:6: `Set.Quotient.range_mk''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Image.lean:844:8: `Set.range_quotient_lift_on'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Image.lean:910:8: `Set.range_ite_subset'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Image.lean:1255:8: `Subtype.preimage_coe_compl'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Image.lean:1404:6: `sigma_mk_preimage_image'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [491/892] Replayed Mathlib.Order.Directed
warning: ././.lake/packages/mathlib/././Mathlib/Order/Directed.lean:68:8: `DirectedOn.mono'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Directed.lean:208:8: `directedOn_pair'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Directed.lean:277:18: `IsMin.not_isMax'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Directed.lean:283:18: `IsMax.not_isMin'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [492/892] Replayed Mathlib.Order.Interval.Set.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Order/Interval/Set/Basic.lean:1003:8: `Set.Ioo_union_Ioi'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Interval/Set/Basic.lean:1031:8: `Set.Ico_union_Ici'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Interval/Set/Basic.lean:1051:8: `Set.Ioc_union_Ioi'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Interval/Set/Basic.lean:1086:8: `Set.Icc_union_Ici'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Interval/Set/Basic.lean:1121:8: `Set.Iio_union_Ico'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Interval/Set/Basic.lean:1142:8: `Set.Iic_union_Ioc'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Interval/Set/Basic.lean:1164:8: `Set.Iio_union_Ioo'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Interval/Set/Basic.lean:1186:8: `Set.Iic_union_Icc'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Interval/Set/Basic.lean:1231:8: `Set.Ico_union_Ico'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Interval/Set/Basic.lean:1305:8: `Set.Ioc_union_Ioc'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Interval/Set/Basic.lean:1353:8: `Set.Icc_union_Icc'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Interval/Set/Basic.lean:1384:8: `Set.Ioo_union_Ioo'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [493/892] Replayed Mathlib.Order.Bounds.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Order/Bounds/Basic.lean:894:8: `IsLUB.exists_between'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Bounds/Basic.lean:902:8: `IsGLB.exists_between'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [494/892] Replayed Mathlib.Data.Set.Prod
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Prod.lean:681:8: `Set.pi_eq_empty_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Prod.lean:700:8: `Set.singleton_pi'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Prod.lean:846:8: `Set.eval_preimage'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [495/892] Replayed Mathlib.Data.Set.Function
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Function.lean:278:8: `Set.mapsTo'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Function.lean:331:6: `Set.mapsTo_of_subsingleton'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Function.lean:767:6: `Set.surjOn_of_subsingleton'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Function.lean:914:6: `Set.bijOn_of_subsingleton'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Function.lean:1020:8: `Set.LeftInvOn.image_inter'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Function.lean:1036:8: `Set.LeftInvOn.image_image'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Function.lean:1400:8: `Set.EqOn.piecewise_ite'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Function.lean:1542:8: `Function.update_comp_eq_of_not_mem_range'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Function.lean:1636:6: `Equiv.bijOn'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [504/892] Replayed Mathlib.Order.Hom.Set
warning: ././.lake/packages/mathlib/././Mathlib/Order/Hom/Set.lean:141:9: `OrderIso.subsingleton_of_wellFoundedLT'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Hom/Set.lean:155:9: `OrderIso.subsingleton_of_wellFoundedGT'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [506/892] Replayed Mathlib.Order.CompleteLattice
warning: ././.lake/packages/mathlib/././Mathlib/Order/CompleteLattice.lean:438:6: `sSup_eq_bot'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/CompleteLattice.lean:508:8: `sSup_eq_iSup'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/CompleteLattice.lean:517:8: `biSup_congr'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/CompleteLattice.lean:553:8: `iSup_range'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/CompleteLattice.lean:557:8: `sSup_image'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/CompleteLattice.lean:569:8: `sInf_eq_iInf'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/CompleteLattice.lean:579:8: `biInf_congr'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/CompleteLattice.lean:610:8: `iInf_range'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/CompleteLattice.lean:613:8: `sInf_image'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/CompleteLattice.lean:628:8: `le_iSup'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/CompleteLattice.lean:631:8: `iInf_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/CompleteLattice.lean:700:8: `iSup_mono'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/CompleteLattice.lean:703:8: `iInf_mono'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/CompleteLattice.lean:706:8: `iSup₂_mono'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/CompleteLattice.lean:712:8: `iInf₂_mono'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/CompleteLattice.lean:993:8: `iSup_subtype'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/CompleteLattice.lean:997:8: `iInf_subtype'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/CompleteLattice.lean:1001:8: `iSup_subtype''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/CompleteLattice.lean:1004:8: `iInf_subtype''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/CompleteLattice.lean:1287:8: `iSup_of_empty'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/CompleteLattice.lean:1325:6: `iSup_sigma'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/CompleteLattice.lean:1328:6: `iInf_sigma'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/CompleteLattice.lean:1339:6: `iSup_psigma'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/CompleteLattice.lean:1342:6: `iInf_psigma'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/CompleteLattice.lean:1351:6: `iSup_prod'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/CompleteLattice.lean:1354:6: `iInf_prod'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [507/892] Replayed Mathlib.Order.CompleteBooleanAlgebra
warning: ././.lake/packages/mathlib/././Mathlib/Order/CompleteBooleanAlgebra.lean:231:6: `CompletelyDistribLattice.MinimalAxioms.iInf_iSup_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/CompleteBooleanAlgebra.lean:596:8: `compl_sInf'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/CompleteBooleanAlgebra.lean:599:8: `compl_sSup'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [509/892] Replayed Mathlib.Order.GaloisConnection
warning: ././.lake/packages/mathlib/././Mathlib/Order/GaloisConnection.lean:157:8: `GaloisConnection.u_l_u_eq_u'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/GaloisConnection.lean:184:8: `GaloisConnection.l_u_l_eq_l'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [515/892] Replayed Mathlib.Data.PNat.Defs
warning: ././.lake/packages/mathlib/././Mathlib/Data/PNat/Defs.lean:131:8: `PNat.coe_toPNat'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [521/892] Replayed Mathlib.Algebra.Order.Monoid.Unbundled.ExistsOfLE
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/ExistsOfLE.lean:51:21: `exists_one_lt_mul_of_lt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/ExistsOfLE.lean:77:8: `le_of_forall_one_lt_lt_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/ExistsOfLE.lean:81:8: `le_iff_forall_one_lt_lt_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [522/892] Replayed Mathlib.Algebra.Order.Monoid.Canonical.Defs
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean:103:8: `le_iff_exists_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean:189:26: `NeZero.of_gt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean:226:8: `min_mul_distrib'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [525/892] Replayed Mathlib.Algebra.Order.Group.Defs
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Defs.lean:115:8: `LinearOrderedCommGroup.mul_lt_mul_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Defs.lean:119:8: `eq_one_of_inv_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Defs.lean:130:8: `exists_one_lt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Defs.lean:177:8: `inv_le_inv'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Defs.lean:181:8: `inv_lt_inv'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [526/892] Replayed Mathlib.Algebra.Order.Monoid.Unbundled.WithTop
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/WithTop.lean:53:8: `WithTop.untop_one'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/Unbundled/WithTop.lean:418:8: `WithBot.unbot_one'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [536/892] Replayed Mathlib.Algebra.Order.Monoid.NatCast
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Monoid/NatCast.lean:49:6: `one_le_two'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [538/892] Replayed Mathlib.Algebra.Order.Ring.Unbundled.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Ring/Unbundled/Basic.lean:177:8: `mul_le_mul_of_nonneg_of_nonpos'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Ring/Unbundled/Basic.lean:187:8: `mul_le_mul_of_nonpos_of_nonneg'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Ring/Unbundled/Basic.lean:197:8: `mul_le_mul_of_nonpos_of_nonpos'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Ring/Unbundled/Basic.lean:484:8: `add_le_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [547/892] Replayed Mathlib.Data.List.Defs
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Defs.lean:241:9: `List.decidableChain'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [548/892] Replayed Mathlib.Data.Nat.Bits
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Bits.lean:225:8: `Nat.bit_add'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [549/892] Replayed Mathlib.Data.Nat.Size
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Size.lean:57:8: `Nat.size_shiftLeft'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [566/892] Replayed Mathlib.Data.Nat.Find
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Find.lean:71:18: `Nat.find_min'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [571/892] Replayed Mathlib.Control.Applicative
warning: ././.lake/packages/mathlib/././Mathlib/Control/Applicative.lean:34:8: `Applicative.pure_seq_eq_map'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [572/892] Replayed Mathlib.Control.Traversable.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Control/Traversable/Basic.lean:139:8: `ApplicativeTransformation.preserves_map'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [661/892] Replayed Mathlib.Algebra.Order.Group.Abs
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Abs.lean:72:8: `le_abs'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Abs.lean:81:8: `apply_abs_le_mul_of_one_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Group/Abs.lean:100:8: `abs_add'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [663/892] Replayed Mathlib.Order.Bounds.OrderIso
warning: ././.lake/packages/mathlib/././Mathlib/Order/Bounds/OrderIso.lean:34:8: `OrderIso.isLUB_image'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Bounds/OrderIso.lean:41:8: `OrderIso.isGLB_image'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Bounds/OrderIso.lean:48:8: `OrderIso.isLUB_preimage'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Bounds/OrderIso.lean:55:8: `OrderIso.isGLB_preimage'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [667/892] Replayed Mathlib.Order.Hom.Lattice
warning: ././.lake/packages/mathlib/././Mathlib/Order/Hom/Lattice.lean:1050:8: `LatticeHom.coe_comp_sup_hom'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Hom/Lattice.lean:1060:8: `LatticeHom.coe_comp_inf_hom'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Hom/Lattice.lean:1233:8: `BoundedLatticeHom.coe_comp_lattice_hom'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Hom/Lattice.lean:1244:8: `BoundedLatticeHom.coe_comp_sup_hom'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Hom/Lattice.lean:1254:8: `BoundedLatticeHom.coe_comp_inf_hom'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [668/892] Replayed Mathlib.Data.Setoid.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Data/Setoid/Basic.lean:61:8: `Setoid.ext'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Setoid/Basic.lean:81:8: `Setoid.refl'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Setoid/Basic.lean:84:8: `Setoid.symm'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Setoid/Basic.lean:87:8: `Setoid.trans'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Setoid/Basic.lean:89:8: `Setoid.comm'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Setoid/Basic.lean:104:8: `Setoid.ker_apply_mk_out'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [673/892] Replayed Mathlib.Data.SetLike.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Data/SetLike/Basic.lean:154:8: `SetLike.ext'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
⚠ [695/892] Replayed Mathlib.Data.Rat.Defs
warning: ././.lake/packages/mathlib/././Mathlib/Data/Rat/Defs.lean:111:8: `Rat.normalize_eq_mk'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Rat/Defs.lean:125:14: `Rat.divInt_self'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Rat/Defs.lean:172:8: `Rat.add_def''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Rat/Defs.lean:186:6: `Rat.sub_def''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Rat/Defs.lean:190:6: `Rat.divInt_mul_divInt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Rat/Defs.lean:199:6: `Rat.mk'_mul_mk'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Rat/Defs.lean:238:14: `Rat.inv_divInt'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Rat/Defs.lean:243:6: `Rat.inv_def'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Rat/Defs.lean:249:6: `Rat.div_def'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [697/892] Replayed Mathlib.Algebra.Group.Int
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Int.lean:115:6: `Int.eq_one_or_neg_one_of_mul_eq_one'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Int.lean:128:6: `Int.eq_one_or_neg_one_of_mul_eq_neg_one'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Int.lean:210:6: `Int.even_pow'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [698/892] Replayed Mathlib.Data.Nat.Cast.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Cast/Basic.lean:67:6: `nsmul_eq_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Cast/Basic.lean:98:8: `ext_nat'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Cast/Basic.lean:113:8: `eq_natCast'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Cast/Basic.lean:117:8: `map_natCast'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Cast/Basic.lean:124:8: `map_ofNat'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [699/892] Replayed Mathlib.Algebra.Ring.Parity
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Ring/Parity.lean:119:14: `odd_add_self_one'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Ring/Parity.lean:121:14: `odd_add_one_self'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Ring/Parity.lean:223:6: `Nat.even_or_odd'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Ring/Parity.lean:226:6: `Nat.even_xor_odd'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Ring/Parity.lean:244:6: `Nat.even_add'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Ring/Parity.lean:253:6: `Nat.even_sub'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Ring/Parity.lean:276:6: `Nat.odd_add'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Ring/Parity.lean:286:6: `Nat.odd_sub'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [700/892] Replayed Mathlib.Algebra.Ring.Int
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Ring/Int.lean:113:6: `Int.even_or_odd'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Ring/Int.lean:121:6: `Int.even_xor'_odd'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Ring/Int.lean:130:6: `Int.even_add'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Ring/Int.lean:136:6: `Int.even_sub'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Ring/Int.lean:148:6: `Int.odd_pow'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Ring/Int.lean:153:6: `Int.odd_add'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Ring/Int.lean:160:6: `Int.odd_sub'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [704/892] Replayed Mathlib.Data.Set.Lattice
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Lattice.lean:288:8: `Set.iUnion_mono''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Lattice.lean:301:8: `Set.iInter_mono''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Lattice.lean:310:8: `Set.iUnion_mono'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Lattice.lean:316:8: `Set.iUnion₂_mono'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Lattice.lean:320:8: `Set.iInter_mono'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Lattice.lean:328:8: `Set.iInter₂_mono'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Lattice.lean:628:8: `Set.iUnion_sigma'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Lattice.lean:635:8: `Set.iInter_sigma'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Lattice.lean:658:8: `Set.biUnion_and'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Lattice.lean:670:8: `Set.biInter_and'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Lattice.lean:1443:8: `Set.iUnion_iUnion_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Lattice.lean:1451:8: `Set.iInter_iInter_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [705/892] Replayed Mathlib.Order.ConditionallyCompleteLattice.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Order/ConditionallyCompleteLattice/Basic.lean:84:8: `WithTop.coe_sInf'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/ConditionallyCompleteLattice/Basic.lean:96:8: `WithTop.coe_sSup'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/ConditionallyCompleteLattice/Basic.lean:111:8: `WithBot.coe_sSup'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/ConditionallyCompleteLattice/Basic.lean:116:8: `WithBot.coe_sInf'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/ConditionallyCompleteLattice/Basic.lean:757:8: `le_csInf_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/ConditionallyCompleteLattice/Basic.lean:792:8: `isLUB_csSup'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/ConditionallyCompleteLattice/Basic.lean:802:8: `csSup_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/ConditionallyCompleteLattice/Basic.lean:810:8: `le_csSup_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/ConditionallyCompleteLattice/Basic.lean:814:8: `le_csInf_iff''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/ConditionallyCompleteLattice/Basic.lean:818:8: `csInf_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/ConditionallyCompleteLattice/Basic.lean:820:8: `exists_lt_of_lt_csSup'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/ConditionallyCompleteLattice/Basic.lean:824:8: `not_mem_of_lt_csInf'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/ConditionallyCompleteLattice/Basic.lean:827:8: `csInf_le_csInf'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/ConditionallyCompleteLattice/Basic.lean:830:8: `csSup_le_csSup'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [706/892] Replayed Mathlib.Order.Interval.Set.UnorderedInterval
warning: ././.lake/packages/mathlib/././Mathlib/Order/Interval/Set/UnorderedInterval.lean:82:6: `Set.Icc_subset_uIcc'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Interval/Set/UnorderedInterval.lean:103:6: `Set.uIcc_subset_uIcc_iff_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Interval/Set/UnorderedInterval.lean:140:6: `Set.eq_of_mem_uIcc_of_mem_uIcc'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Interval/Set/UnorderedInterval.lean:271:6: `Set.Ioc_subset_uIoc'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Interval/Set/UnorderedInterval.lean:279:6: `Set.eq_of_mem_uIoc_of_mem_uIoc'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [708/892] Replayed Mathlib.Data.Set.Pairwise.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Pairwise/Basic.lean:73:8: `Set.Pairwise.mono'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Pairwise/Basic.lean:311:8: `Set.PairwiseDisjoint.elim'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [709/892] Replayed Mathlib.Order.Antichain
warning: ././.lake/packages/mathlib/././Mathlib/Order/Antichain.lean:56:18: `IsAntichain.eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [710/892] Replayed Mathlib.Order.Interval.Set.OrdConnected
warning: ././.lake/packages/mathlib/././Mathlib/Order/Interval/Set/OrdConnected.lean:130:9: `Set.OrdConnected.inter'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Interval/Set/OrdConnected.lean:149:9: `Set.ordConnected_iInter'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Interval/Set/OrdConnected.lean:162:9: `Set.ordConnected_pi'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [714/892] Replayed Mathlib.Data.Int.Cast.Lemmas
warning: ././.lake/packages/mathlib/././Mathlib/Data/Int/Cast/Lemmas.lean:107:6: `zsmul_eq_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Int/Cast/Lemmas.lean:217:8: `eq_intCast'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Int/Cast/Lemmas.lean:354:8: `RingHom.eq_intCast'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [716/892] Replayed Mathlib.Algebra.GroupWithZero.Divisibility
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/GroupWithZero/Divisibility.lean:142:8: `dvd_antisymm'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/GroupWithZero/Divisibility.lean:152:8: `eq_of_forall_dvd'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [718/892] Replayed Mathlib.Data.Fin.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Data/Fin/Basic.lean:102:6: `Fin.size_positive'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Fin/Basic.lean:326:8: `Fin.last_pos'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Fin/Basic.lean:393:8: `Fin.val_one'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Fin/Basic.lean:397:8: `Fin.val_one''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Fin/Basic.lean:524:8: `Fin.succ_zero_eq_one'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Fin/Basic.lean:529:8: `Fin.one_pos'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Fin/Basic.lean:530:8: `Fin.zero_ne_one'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Fin/Basic.lean:701:8: `Fin.forall_fin_succ'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Fin/Basic.lean:709:8: `Fin.exists_fin_succ'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Fin/Basic.lean:796:8: `Fin.pred_one'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Fin/Basic.lean:903:8: `Fin.castPred_zero'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Fin/Basic.lean:1526:18: `Fin.mul_one'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Fin/Basic.lean:1533:18: `Fin.one_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Fin/Basic.lean:1536:18: `Fin.mul_zero'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Fin/Basic.lean:1538:18: `Fin.zero_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [721/892] Replayed Mathlib.Data.Int.GCD
warning: ././.lake/packages/mathlib/././Mathlib/Data/Int/GCD.lean:278:8: `Int.exists_gcd_one'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [722/892] Replayed Mathlib.Data.Nat.ModEq
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/ModEq.lean:95:18: `Nat.ModEq.mul_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/ModEq.lean:102:18: `Nat.ModEq.mul_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/ModEq.lean:141:18: `Nat.ModEq.add_left_cancel'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/ModEq.lean:149:18: `Nat.ModEq.add_right_cancel'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/ModEq.lean:160:18: `Nat.ModEq.mul_left_cancel_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/ModEq.lean:172:18: `Nat.ModEq.mul_right_cancel_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/ModEq.lean:254:6: `Nat.ModEq.cancel_left_div_gcd'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/ModEq.lean:258:6: `Nat.ModEq.cancel_right_div_gcd'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [723/892] Replayed Mathlib.Data.List.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Basic.lean:218:8: `List.replicate_succ'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Basic.lean:234:8: `List.replicate_right_inj'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Basic.lean:261:8: `List.reverse_cons'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Basic.lean:264:8: `List.reverse_concat'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Basic.lean:301:8: `List.getLast_append'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Basic.lean:307:8: `List.getLast_concat'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Basic.lean:311:8: `List.getLast_singleton'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Basic.lean:623:6: `List.cons_sublist_cons'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Basic.lean:766:8: `List.ext_get?'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Basic.lean:785:8: `List.ext_get?_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Basic.lean:827:8: `List.get_reverse'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Basic.lean:1045:8: `List.takeI_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Basic.lean:1069:8: `List.takeD_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Basic.lean:1100:8: `List.foldl_fixed'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Basic.lean:1104:8: `List.foldr_fixed'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Basic.lean:1284:8: `List.foldl_eq_of_comm'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Basic.lean:1288:8: `List.foldl_eq_foldr'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Basic.lean:1298:8: `List.foldr_eq_of_comm'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Basic.lean:1611:8: `List.lookmap_id'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Basic.lean:1688:8: `List.filter_subset'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Basic.lean:1722:6: `List.map_filter'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Basic.lean:1727:6: `List.filter_attach'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Basic.lean:2032:8: `List.map₂Left_eq_map₂Left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Basic.lean:2071:8: `List.map₂Right_eq_map₂Right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Basic.lean:2105:8: `List.zipLeft_eq_zipLeft'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Basic.lean:2141:8: `List.zipRight_eq_zipRight'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [724/892] Replayed Mathlib.Data.List.Forall2
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Forall2.lean:108:8: `List.left_unique_forall₂'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Forall2.lean:116:8: `List.right_unique_forall₂'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [726/892] Replayed Mathlib.Data.List.Lattice
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Lattice.lean:111:8: `List.inter_nil'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [730/892] Replayed Mathlib.Data.List.Pairwise
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Pairwise.lean:53:46: `List.pairwise_map'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [733/892] Replayed Mathlib.Data.List.Lex
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Lex.lean:158:9: `List.LT'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Lex.lean:168:9: `List.LE'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [734/892] Replayed Mathlib.Data.List.Chain
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Chain.lean:204:8: `List.chain'_map_of_chain'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Chain.lean:208:8: `List.Pairwise.chain'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Chain.lean:235:8: `List.Chain'.cons'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Chain.lean:239:8: `List.chain'_cons'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [736/892] Replayed Mathlib.Data.List.Rotate
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Rotate.lean:52:8: `List.length_rotate'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Rotate.lean:68:8: `List.rotate'_rotate'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Rotate.lean:96:8: `List.rotate_eq_rotate'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Rotate.lean:408:8: `List.isRotated_nil_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Rotate.lean:416:8: `List.isRotated_singleton_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [737/892] Replayed Mathlib.Data.List.Join
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Join.lean:137:8: `List.drop_take_succ_join_eq_get'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [738/892] Replayed Mathlib.Data.Fin.Tuple.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Data/Fin/Tuple/Basic.lean:853:8: `Fin.insertNth_zero'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Fin/Tuple/Basic.lean:869:8: `Fin.insertNth_last'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Fin/Tuple/Basic.lean:1013:8: `Fin.find_min'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [739/892] Replayed Mathlib.Data.List.OfFn
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/OfFn.lean:74:8: `List.ofFn_succ'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [746/892] Replayed Mathlib.Order.Cover
warning: ././.lake/packages/mathlib/././Mathlib/Order/Cover.lean:97:6: `WCovBy.of_le_of_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Order/Cover.lean:253:8: `CovBy.ne'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [747/892] Replayed Mathlib.Algebra.Group.Support
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Support.lean:52:8: `Function.mulSupport_subset_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Support.lean:135:8: `Function.mulSupport_one'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Support.lean:183:8: `Function.mulSupport_prod_mk'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Support.lean:198:8: `Function.mulSupport_curry'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Support.lean:226:8: `Function.mulSupport_inv'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [748/892] Replayed Mathlib.Data.Nat.Factorial.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Factorial/Basic.lean:114:8: `Nat.factorial_inj'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Factorial/Basic.lean:252:8: `Nat.pow_lt_ascFactorial'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Factorial/Basic.lean:338:8: `Nat.add_descFactorial_eq_ascFactorial'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Factorial/Basic.lean:391:8: `Nat.pow_sub_lt_descFactorial'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [752/892] Replayed Mathlib.Data.Set.Sigma
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Sigma.lean:124:8: `biSup_sigma'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Sigma.lean:132:8: `biInf_sigma'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Sigma.lean:142:8: `Set.biUnion_sigma'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Sigma.lean:150:8: `Set.biInter_sigma'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [754/892] Replayed Mathlib.Algebra.Group.Indicator
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Indicator.lean:103:8: `Set.mulIndicator_eq_one'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Indicator.lean:157:8: `Set.mulIndicator_empty'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Indicator.lean:167:8: `Set.mulIndicator_one'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Indicator.lean:305:8: `Set.mulIndicator_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Indicator.lean:367:8: `Set.mulIndicator_inv'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Indicator.lean:381:8: `Set.mulIndicator_div'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Indicator.lean:391:8: `Set.mulIndicator_compl'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Group/Indicator.lean:403:8: `Set.mulIndicator_diff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [756/892] Replayed Mathlib.Data.Nat.Choose.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Choose/Basic.lean:60:8: `Nat.choose_succ_succ'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Choose/Basic.lean:228:8: `Nat.ascFactorial_eq_factorial_mul_choose'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Nat/Choose/Basic.lean:247:8: `Nat.choose_eq_asc_factorial_div_factorial'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [757/892] Replayed Mathlib.Data.List.Zip
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Zip.lean:122:8: `List.get?_zipWith'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [761/892] Replayed Mathlib.Data.NNRat.Defs
warning: ././.lake/packages/mathlib/././Mathlib/Data/NNRat/Defs.lean:265:8: `Rat.toNNRat_lt_toNNRat_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/NNRat/Defs.lean:287:8: `Rat.le_toNNRat_iff_coe_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [763/892] Replayed Mathlib.Data.Rat.Lemmas
warning: ././.lake/packages/mathlib/././Mathlib/Data/Rat/Lemmas.lean:132:8: `Rat.mul_num_den'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Rat/Lemmas.lean:146:8: `Rat.add_num_den'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Rat/Lemmas.lean:165:8: `Rat.substr_num_den'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [768/892] Replayed Mathlib.Tactic.Ring.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Tactic/Ring/Basic.lean:942:8: `Mathlib.Tactic.Ring.atom_pf'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [771/892] Replayed Mathlib.Algebra.GroupWithZero.WithZero
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/GroupWithZero/WithZero.lean:132:6: `WithZero.map'_map'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [772/892] Replayed Mathlib.Algebra.Order.GroupWithZero.Canonical
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/GroupWithZero/Canonical.lean:69:14: `zero_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/GroupWithZero/Canonical.lean:73:8: `not_lt_zero'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [774/892] Replayed Mathlib.Data.PNat.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Data/PNat/Basic.lean:293:8: `PNat.mod_add_div'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/PNat/Basic.lean:297:8: `PNat.div_add_mod'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/PNat/Basic.lean:329:8: `PNat.dvd_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [777/892] Replayed Mathlib.Data.List.Dedup
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Dedup.lean:33:8: `List.dedup_cons_of_mem'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Dedup.lean:36:8: `List.dedup_cons_of_not_mem'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [778/892] Replayed Mathlib.Data.Multiset.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Data/Multiset/Basic.lean:51:8: `Multiset.quot_mk_to_coe'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Multiset/Basic.lean:55:8: `Multiset.quot_mk_to_coe''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Multiset/Basic.lean:398:8: `Multiset.induction_on'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Multiset/Basic.lean:1151:8: `Multiset.map_id'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Multiset/Basic.lean:1159:16: `Multiset.map_const'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Multiset/Basic.lean:1289:8: `Multiset.foldr_induction'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Multiset/Basic.lean:1303:8: `Multiset.foldl_induction'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Multiset/Basic.lean:1376:8: `Multiset.attach_map_val'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Multiset/Basic.lean:1871:6: `Multiset.map_filter'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Multiset/Basic.lean:2252:8: `Multiset.ext'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Multiset/Basic.lean:2303:8: `Multiset.filter_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Multiset/Basic.lean:2578:6: `Multiset.filter_attach'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [781/892] Replayed Mathlib.Data.Multiset.Dedup
warning: ././.lake/packages/mathlib/././Mathlib/Data/Multiset/Dedup.lean:56:8: `Multiset.dedup_subset'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Multiset/Dedup.lean:60:8: `Multiset.subset_dedup'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [783/892] Replayed Mathlib.Data.Finset.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Basic.lean:185:14: `Finset.forall_mem_not_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Basic.lean:213:9: `Finset.decidableMem'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Basic.lean:247:9: `Finset.PiFinsetCoe.canLift'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Basic.lean:679:8: `Finset.subset_singleton_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Basic.lean:977:8: `Finset.insert_val'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Basic.lean:1799:8: `Finset.erase_injOn'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Basic.lean:1953:6: `Finset.insert_sdiff_insert'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Basic.lean:2049:8: `Finset.sdiff_sdiff_left'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Basic.lean:2400:8: `Finset.disjoint_filter_filter'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Basic.lean:2549:8: `Finset.filter_ne'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Basic.lean:2567:6: `Finset.filter_inj'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Basic.lean:3051:8: `Finset.pairwise_subtype_iff_pairwise_finset'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Basic.lean:3059:8: `Finset.pairwise_cons'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [784/892] Replayed Mathlib.Algebra.BigOperators.Group.List
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/BigOperators/Group/List.lean:539:8: `List.alternatingProd_cons_cons'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/BigOperators/Group/List.lean:553:8: `List.alternatingProd_cons'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [785/892] Replayed Mathlib.Algebra.BigOperators.Group.Multiset
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/BigOperators/Group/Multiset.lean:137:8: `Multiset.prod_hom'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/BigOperators/Group/Multiset.lean:261:8: `Multiset.prod_map_inv'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [788/892] Replayed Mathlib.Data.Finset.Image
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Image.lean:83:8: `Finset.mem_map'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Image.lean:186:6: `Finset.map_filter'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Image.lean:191:6: `Finset.filter_attach'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Image.lean:283:8: `Finset.range_add_one'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Image.lean:379:8: `Finset.image_id'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Image.lean:498:8: `Finset.mem_range_iff_mem_finset_range_of_mod_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [790/892] Replayed Mathlib.Data.Fintype.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Data/Fintype/Basic.lean:293:8: `Finset.insert_inj_on'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Fintype/Basic.lean:827:16: `Fin.univ_image_getElem'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Fintype/Basic.lean:831:8: `Fin.univ_image_get'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [792/892] Replayed Mathlib.Data.Fintype.Card
warning: ././.lake/packages/mathlib/././Mathlib/Data/Fintype/Card.lean:128:8: `Fintype.card_of_finset'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Fintype/Card.lean:142:8: `Fintype.card_congr'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Fintype/Card.lean:310:8: `Fintype.card_subtype_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [799/892] Replayed Mathlib.Data.Finset.Piecewise
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Piecewise.lean:157:6: `Finset.piecewise_le_piecewise'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Piecewise.lean:170:6: `Finset.piecewise_mem_Icc'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [801/892] Replayed Mathlib.Data.Vector.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Data/Vector/Basic.lean:581:8: `Mathlib.Vector.prod_set'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [816/892] Replayed Mathlib.Algebra.Order.Ring.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Ring/Basic.lean:81:6: `pow_add_pow_le'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [822/892] Replayed Mathlib.Tactic.Positivity.Core
warning: ././.lake/packages/mathlib/././Mathlib/Tactic/Positivity/Core.lean:28:6: `ne_of_ne_of_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Tactic/Positivity/Core.lean:122:6: `Mathlib.Meta.Positivity.lt_of_le_of_ne'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [831/892] Replayed Mathlib.Algebra.CharZero.Lemmas
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/CharZero/Lemmas.lean:100:8: `nat_mul_inj'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [832/892] Replayed Mathlib.Algebra.Order.Ring.Abs
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Ring/Abs.lean:100:6: `sq_lt_sq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Ring/Abs.lean:107:6: `sq_le_sq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Ring/Abs.lean:113:6: `abs_lt_of_sq_lt_sq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Ring/Abs.lean:119:6: `abs_le_of_sq_le_sq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [833/892] Replayed Mathlib.Algebra.Order.Field.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Field/Basic.lean:34:8: `lt_div_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Field/Basic.lean:40:8: `div_lt_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Field/Basic.lean:46:8: `inv_mul_le_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Field/Basic.lean:52:8: `mul_inv_le_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Field/Basic.lean:58:8: `inv_mul_lt_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Field/Basic.lean:64:8: `mul_inv_lt_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Field/Basic.lean:70:8: `inv_pos_le_iff_one_le_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Field/Basic.lean:76:8: `inv_pos_lt_iff_one_lt_mul'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Field/Basic.lean:226:8: `div_lt_div'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Field/Basic.lean:495:8: `div_le_iff_of_neg'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Field/Basic.lean:501:8: `le_div_iff_of_neg'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Field/Basic.lean:507:8: `div_lt_iff_of_neg'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/Order/Field/Basic.lean:513:8: `lt_div_iff_of_neg'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [846/892] Replayed Mathlib.Data.Finset.Lattice
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Lattice.lean:706:8: `Finset.coe_sup'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Lattice.lean:731:8: `Finset.le_sup'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Lattice.lean:817:8: `map_finset_sup'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Lattice.lean:822:6: `Finset.nsmul_sup'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Lattice.lean:879:8: `Finset.coe_inf'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Lattice.lean:900:8: `Finset.le_inf'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Lattice.lean:972:8: `map_finset_inf'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Lattice.lean:977:6: `Finset.nsmul_inf'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Lattice.lean:1066:8: `Finset.toDual_sup'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Lattice.lean:1071:8: `Finset.toDual_inf'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Lattice.lean:1076:8: `Finset.ofDual_sup'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Lattice.lean:1081:8: `Finset.ofDual_inf'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Lattice.lean:1099:8: `Finset.sup'_inf_sup'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Lattice.lean:1109:8: `Finset.inf'_sup_inf'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Lattice.lean:1146:8: `Finset.exists_mem_eq_sup'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Lattice.lean:1156:8: `Finset.exists_mem_eq_inf'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Lattice.lean:1212:8: `Finset.sup_singleton''` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Lattice.lean:1219:8: `Finset.sup_singleton'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [849/892] Replayed Mathlib.Data.Finset.Sigma
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Sigma.lean:107:8: `biSup_finsetSigma'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Sigma.lean:115:8: `biInf_finsetSigma'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Sigma.lean:123:8: `Set.biUnion_finsetSigma'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Sigma.lean:131:8: `Set.biInter_finsetSigma'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [850/892] Replayed Mathlib.Data.Fintype.Sigma
warning: ././.lake/packages/mathlib/././Mathlib/Data/Fintype/Sigma.lean:27:6: `Set.biUnion_finsetSigma_univ'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [854/892] Replayed Mathlib.Data.Sym.Basic
warning: ././.lake/packages/mathlib/././Mathlib/Data/Sym/Basic.lean:307:9: `Sym.inhabitedSym'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [856/892] Replayed Mathlib.Data.Finset.Max
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Max.lean:190:8: `Finset.le_min'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Max.lean:193:8: `Finset.isLeast_min'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Max.lean:207:8: `Finset.le_max'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Max.lean:213:8: `Finset.isGreatest_max'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Max.lean:228:8: `Finset.max'_eq_sup'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Max.lean:230:8: `Finset.min'_eq_inf'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Max.lean:236:8: `Finset.min'_lt_max'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Max.lean:266:8: `Finset.ofDual_min'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Max.lean:273:8: `Finset.ofDual_max'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Max.lean:280:8: `Finset.toDual_min'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Max.lean:287:8: `Finset.toDual_max'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Max.lean:314:8: `Finset.lt_max'_of_mem_erase_max'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Max.lean:318:8: `Finset.min'_lt_of_mem_erase_min'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Max.lean:348:8: `Finset.coe_max'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Finset/Max.lean:351:8: `Finset.coe_min'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [857/892] Replayed Mathlib.Data.List.Sublists
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Sublists.lean:71:8: `List.mem_sublists'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Sublists.lean:85:8: `List.length_sublists'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Sublists.lean:161:8: `List.sublists_eq_sublists'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Sublists.lean:251:8: `List.sublistsLen_sublist_sublists'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Sublists.lean:308:8: `List.Pairwise.sublists'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Sublists.lean:330:8: `List.nodup_sublists'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Sublists.lean:356:8: `List.sublists_perm_sublists'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/List/Sublists.lean:390:8: `List.revzip_sublists'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [858/892] Replayed Mathlib.Data.Multiset.Powerset
warning: ././.lake/packages/mathlib/././Mathlib/Data/Multiset/Powerset.lean:40:8: `Multiset.powersetAux_perm_powersetAux'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Multiset/Powerset.lean:81:8: `Multiset.powerset_coe'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Multiset/Powerset.lean:113:8: `Multiset.revzip_powersetAux'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Multiset/Powerset.lean:133:8: `Multiset.revzip_powersetAux_perm_aux'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Multiset/Powerset.lean:205:8: `Multiset.powersetCard_coe'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [860/892] Replayed Mathlib.Data.Fintype.Powerset
warning: ././.lake/packages/mathlib/././Mathlib/Data/Fintype/Powerset.lean:59:9: `Set.finite'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [865/892] Replayed Mathlib.Data.Set.Finite
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Finite.lean:341:9: `Set.fintypeBiUnion'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Finite.lean:361:9: `Set.fintypeBind'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Finite.lean:455:9: `Set.fintypeSeq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Finite.lean:568:9: `Finite.Set.finite_biUnion'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Finite.lean:772:8: `Set.Finite.preimage'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Finite.lean:780:6: `Set.Infinite.preimage'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Finite.lean:861:8: `Set.Finite.seq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Finite.lean:960:8: `Set.Finite.toFinset_insert'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Finite.lean:1092:8: `Set.empty_card'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Set/Finite.lean:1546:6: `Set.finite_diff_iUnion_Ioo'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [867/892] Replayed Mathlib.Data.Sym.Sym2
warning: ././.lake/packages/mathlib/././Mathlib/Data/Sym/Sym2.lean:80:8: `Sym2.rel_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Sym/Sym2.lean:284:8: `Sym2.mem_iff'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Sym/Sym2.lean:587:9: `Sym2.instDecidableRel'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Sym/Sym2.lean:624:8: `Sym2.other_spec'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Sym/Sym2.lean:630:8: `Sym2.other_eq_other'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Sym/Sym2.lean:633:8: `Sym2.other_mem'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Data/Sym/Sym2.lean:637:8: `Sym2.other_invol'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [872/892] Replayed Mathlib.Algebra.BigOperators.Group.Finset
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/BigOperators/Group/Finset.lean:438:8: `Equiv.Perm.prod_comp'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/BigOperators/Group/Finset.lean:683:6: `Finset.prod_fiberwise_eq_prod_filter'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/BigOperators/Group/Finset.lean:696:6: `Finset.prod_fiberwise_of_maps_to'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/BigOperators/Group/Finset.lean:711:6: `Finset.prod_fiberwise'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/BigOperators/Group/Finset.lean:743:8: `Finset.prod_finset_product'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/BigOperators/Group/Finset.lean:756:8: `Finset.prod_finset_product_right'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/BigOperators/Group/Finset.lean:762:8: `Finset.prod_image'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/BigOperators/Group/Finset.lean:985:6: `Finset.prod_preimage'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/BigOperators/Group/Finset.lean:1125:8: `Finset.prod_dite_eq'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/BigOperators/Group/Finset.lean:1173:8: `Finset.prod_pi_mulSingle'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/BigOperators/Group/Finset.lean:1310:8: `Finset.prod_range_succ'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/BigOperators/Group/Finset.lean:1451:8: `Finset.prod_range_div'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/BigOperators/Group/Finset.lean:1459:8: `Finset.eq_prod_range_div'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/BigOperators/Group/Finset.lean:1967:6: `Fintype.prod_fiberwise'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
warning: ././.lake/packages/mathlib/././Mathlib/Algebra/BigOperators/Group/Finset.lean:2131:8: `Multiset.count_sum'` is missing a doc-string, please add one.
Declarations whose name ends with a `'` are expected to contain an explanation for the presence of a `'` in their doc-string. This may consist of discussion of the difference relative to the unprimed version, or an explanation as to why no better naming scheme is possible.
note: this linter can be disabled with `set_option linter.docPrime false`
⚠ [878/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [881/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
⚠ [887/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
⚠ [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:11:8: warning: declaration uses 'sorry'
[bv] [0.037404] Normalizing goal
  [Meta.synthInstance] [0.001825] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 5) x✝ * BitVec.signExtend (2 * 5) x✝ <
                    BitVec.signExtend (2 * 5) (BitVec.twoPow 5 (5 - 1)) ∨
                  BitVec.signExtend (2 * 5) x✝ * BitVec.signExtend (2 * 5) x✝ ≥ BitVec.twoPow (2 * 5) (5 - 1)) then
            none
          else some (BitVec.ofBool (x✝ * x✝ == 0#5))) ⊑
          some (BitVec.ofBool (x✝ == 0#5)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 5
      x✝ : BitVec 5
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 5) x✝ * BitVec.signExtend (2 * 5) x✝ <
                      BitVec.signExtend (2 * 5) (BitVec.twoPow 5 (5 - 1)) ∨
                    BitVec.signExtend (2 * 5) x✝ * BitVec.signExtend (2 * 5) x✝ ≥ BitVec.twoPow (2 * 5) (5 - 1)) then
              none
            else some (BitVec.ofBool (x✝ * x✝ == 0#5))) ⊑
            some (BitVec.ofBool (x✝ == 0#5))
      ⊢ False
  [Meta.isDefEq] [0.001364] ✅️ if ?b then ?x else ?y =?= if (x✝ * x✝ == 0#5) = true then 1#1 else 0#1
    [Meta.isDefEq] [0.001216] ✅️ ?s =?= instDecidableEqBool (x✝ * x✝ == 0#5) true
      [Meta.isDefEq.assign] [0.001212] ✅️ ?s := instDecidableEqBool (x✝ * x✝ == 0#5) true
        [Meta.isDefEq.assign.checkTypes] [0.001185] ✅️ (?s : Decidable
              ((x✝ * x✝ == 0#5) =
                true)) := (instDecidableEqBool (x✝ * x✝ == 0#5) true : Decidable ((x✝ * x✝ == 0#5) = true))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 5
      x✝ : BitVec 5
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 10 (BitVec.twoPow 5 4) >ᵤ BitVec.signExtend 10 x✝ * BitVec.signExtend 10 x✝) &&
                      BitVec.twoPow 10 4 >ᵤ BitVec.signExtend 10 x✝ * BitVec.signExtend 10 x✝)) =
                  true then
              none
            else some (if (x✝ * x✝ == 0#5) = true then 1#1 else 0#1)) ⊑
            some (if (x✝ == 0#5) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:22:8: warning: declaration uses 'sorry'
[bv] [0.039963] Normalizing goal
  [Meta.synthInstance] [0.001365] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 5) x✝ * BitVec.signExtend (2 * 5) x✝ <
                    BitVec.signExtend (2 * 5) (BitVec.twoPow 5 (5 - 1)) ∨
                  BitVec.signExtend (2 * 5) x✝ * BitVec.signExtend (2 * 5) x✝ ≥ BitVec.twoPow (2 * 5) (5 - 1)) then
            none
          else some (BitVec.ofBool (x✝ * x✝ >ₛ 0#5))) ⊑
          some (BitVec.ofBool (x✝ != 0#5)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 5
      x✝ : BitVec 5
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 5) x✝ * BitVec.signExtend (2 * 5) x✝ <
                      BitVec.signExtend (2 * 5) (BitVec.twoPow 5 (5 - 1)) ∨
                    BitVec.signExtend (2 * 5) x✝ * BitVec.signExtend (2 * 5) x✝ ≥ BitVec.twoPow (2 * 5) (5 - 1)) then
              none
            else some (BitVec.ofBool (x✝ * x✝ >ₛ 0#5))) ⊑
            some (BitVec.ofBool (x✝ != 0#5))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 5
      x✝ : BitVec 5
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 10 (BitVec.twoPow 5 4) >ᵤ BitVec.signExtend 10 x✝ * BitVec.signExtend 10 x✝) &&
                      BitVec.twoPow 10 4 >ᵤ BitVec.signExtend 10 x✝ * BitVec.signExtend 10 x✝)) =
                  true then
              none
            else some (if (!(x✝ * x✝).getLsbD 4 == !x✝ * x✝ == 0#5) = true then 1#1 else 0#1)) ⊑
            some (if (!x✝ == 0#5) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:33:8: warning: declaration uses 'sorry'
[bv] [0.108428] Normalizing goal
  [Meta.synthInstance] [0.001320] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else some (BitVec.ofBool (21#8 >ₛ x✝ * 7#8))) ⊑
          some (BitVec.ofBool (3#8 >ₛ x✝)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (21#8 >ₛ x✝ * 7#8))) ⊑
            some (BitVec.ofBool (3#8 >ₛ x✝))
      ⊢ False
  [Meta.isDefEq] [0.008483] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7) (BitVec.signExtend 16 x✝ * 7#16))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                            (BitVec.twoPow 16 7)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16) true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                (congrArg
                  (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) && x))
                  (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
        (true_and
          ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
            true))
    [Meta.isDefEq.assign] [0.008479] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                        (BitVec.signExtend 16 x✝ * 7#16))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                              (BitVec.twoPow 16 7)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16) true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                  (congrArg
                    (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) && x))
                    (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
          (true_and
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.008439] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                  BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                          (BitVec.signExtend 16 x✝ * 7#16))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                                (BitVec.twoPow 16 7)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16) true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                      !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                    (congrArg
                      (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) && x))
                      (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
            (true_and
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                true)) : (True ∧
              (BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7)) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
              true))
        [Meta.isDefEq] [0.008435] ✅️ (True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                true) =?= (True ∧
                (BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7)) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                true)
          [Meta.isDefEq] [0.008380] ✅️ True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1)) =?= True ∧
                (BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7)
            [Meta.isDefEq] [0.008361] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1) =?= BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7
              [Meta.isDefEq] [0.008231] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8)
                      (BitVec.twoPow 8
                        (8 - 1)) =?= BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7)
                [Meta.isDefEq] [0.008206] ✅️ instLTBitVec.1
                      (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8)
                      (BitVec.signExtend (2 * 8)
                        (BitVec.twoPow 8
                          (8 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 16 x✝ * 7#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                  [Meta.isDefEq] [0.008151] ✅️ (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8).toNat <
                        (BitVec.signExtend (2 * 8)
                            (BitVec.twoPow 8
                              (8 -
                                1))).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat <
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                    [Meta.isDefEq] [0.008136] ✅️ instLTNat.1
                          (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8).toNat
                          (BitVec.signExtend (2 * 8)
                              (BitVec.twoPow 8
                                (8 -
                                  1))).toNat =?= instLTNat.1 (BitVec.signExtend 16 x✝ * 7#16).toNat
                          (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                      [Meta.isDefEq] [0.008103] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 7#8).toNat.lt
                            (BitVec.signExtend (2 * 8)
                                (BitVec.twoPow 8
                                  (8 -
                                    1))).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat.lt
                            (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                        [Meta.isDefEq.delta] [0.008090] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 7#8).toNat.lt
                              (BitVec.signExtend (2 * 8)
                                  (BitVec.twoPow 8
                                    (8 -
                                      1))).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat.lt
                              (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                          [Meta.isDefEq] [0.007982] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 7#8).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat
                            [Meta.isDefEq.delta] [0.007958] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 7#8).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat
                              [Meta.isDefEq] [0.007935] ✅️ BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 7#8 =?= BitVec.signExtend 16 x✝ * 7#16
                                [Meta.isDefEq] [0.007907] ✅️ instHMul.1 (BitVec.signExtend (2 * 8) x✝)
                                      (BitVec.signExtend (2 * 8) 7#8) =?= instHMul.1 (BitVec.signExtend 16 x✝) 7#16
                                  [Meta.isDefEq] [0.007852] ✅️ Mul.mul (BitVec.signExtend (2 * 8) x✝)
                                        (BitVec.signExtend (2 * 8) 7#8) =?= Mul.mul (BitVec.signExtend 16 x✝) 7#16
                                    [Meta.isDefEq] [0.007831] ✅️ BitVec.instMul.1 (BitVec.signExtend (2 * 8) x✝)
                                          (BitVec.signExtend (2 * 8)
                                            7#8) =?= BitVec.instMul.1 (BitVec.signExtend 16 x✝) 7#16
                                      [Meta.isDefEq] [0.007784] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                            (BitVec.signExtend (2 * 8) 7#8) =?= (BitVec.signExtend 16 x✝).mul 7#16
                                        [Meta.isDefEq.delta] [0.007774] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                              (BitVec.signExtend (2 * 8) 7#8) =?= (BitVec.signExtend 16 x✝).mul 7#16
                                          [Meta.isDefEq] [0.007669] ✅️ BitVec.signExtend (2 * 8) 7#8 =?= 7#16
                                            [Meta.isDefEq] [0.007647] ✅️ BitVec.ofInt (2 * 8) (7#8).toInt =?= 7#16
                                              [Meta.isDefEq] [0.007628] ✅️ ((7#8).toInt %
                                                        Int.ofNat (2 ^ (2 * 8))).toNat#'⋯ =?= 7#16
                                                [Meta.isDefEq] [0.007608] ✅️ ((7#8).toInt %
                                                          Int.ofNat
                                                            (2 ^
                                                              (2 * 8))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 16) 7 }
                                                  [Meta.isDefEq] [0.007593] ✅️ {
                                                        toFin :=
                                                          ⟨((7#8).toInt % Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 16) 7 }
                                                    [Meta.isDefEq] [0.007554] ✅️ ⟨((7#8).toInt %
                                                              Int.ofNat (2 ^ (2 * 8))).toNat,
                                                          ⋯⟩ =?= Fin.ofNat' (2 ^ 16) 7
                                                      [Meta.isDefEq] [0.007534] ✅️ ⟨((7#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ =?= ⟨7 % 2 ^ 16, ⋯⟩
                                                        [Meta.isDefEq] [0.007420] ✅️ ((7#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat =?= 7 % 2 ^ 16
                                                          [Meta.isDefEq] [0.007336] ✅️ match
                                                                (7#8).toInt % Int.ofNat (2 ^ (2 * 8)) with
                                                              | Int.ofNat n => n
                                                              | Int.negSucc a => 0 =?= 7 % 2 ^ 16
                                                            [Meta.whnf] [0.001537] Non-easy whnf: (fun motive x h_1
                                                                      h_2 =>
                                                                    Int.casesOn x (fun a => h_1 a) fun a => h_2 a)
                                                                  (fun x => ℕ) ((7#8).toInt % Int.ofNat (2 ^ (2 * 8)))
                                                                  h_1 h_2
                                                              [Meta.whnf] [0.001513] Non-easy whnf: (7#8).toInt %
                                                                    Int.ofNat (2 ^ (2 * 8))
                                                                [Meta.whnf] [0.001504] Non-easy whnf: instHMod.1
                                                                      (7#8).toInt (Int.ofNat (2 ^ (2 * 8)))
                                                                  [Meta.whnf] [0.001478] Non-easy whnf: Int.instMod.1
                                                                        (7#8).toInt (Int.ofNat (2 ^ (2 * 8)))
                                                                    [Meta.whnf] [0.001454] Non-easy whnf: match
                                                                          (7#8).toInt, Int.ofNat (2 ^ (2 * 8)) with
                                                                        | Int.ofNat m, n => Int.ofNat (m % n.natAbs)
                                                                        | Int.negSucc m, n =>
                                                                          Int.subNatNat n.natAbs (m % n.natAbs).succ
                                                                      [Meta.whnf] [0.001399] Non-easy whnf: (fun motive
                                                                                x x_1 h_1 h_2 =>
                                                                              Int.casesOn x (fun a => h_1 a x_1)
                                                                                fun a => h_2 a x_1)
                                                                            (fun x x => ℤ) (7#8).toInt
                                                                            (Int.ofNat (2 ^ (2 * 8))) h_1 h_2
                                                                        [Meta.whnf] [0.001381] Non-easy whnf: (7#8).toInt
                                                                          [Meta.whnf] [0.001361] Non-easy whnf: if
                                                                                  2 * (7#8).toNat < 2 ^ 8 then
                                                                                ↑(7#8).toNat
                                                                              else ↑(7#8).toNat - ↑(2 ^ 8)
                                                                            [Meta.whnf] [0.001343] Non-easy whnf: Decidable.casesOn
                                                                                  ((2 * (7#8).toNat).decLt (2 ^ 8))
                                                                                  (fun x => ↑(7#8).toNat - ↑(2 ^ 8))
                                                                                  fun x => ↑(7#8).toNat
                                                                              [Meta.whnf] [0.001284] Non-easy whnf: (2 *
                                                                                        (7#8).toNat).decLt
                                                                                    (2 ^ 8)
                                                                                [Meta.whnf] [0.001273] Non-easy whnf: (2 *
                                                                                            (7#8).toNat).succ.decLe
                                                                                      (2 ^ 8)
                                                                                  [Meta.whnf] [0.001252] Non-easy whnf: if
                                                                                          h :
                                                                                          (2 * (7#8).toNat).succ.ble
                                                                                              (2 ^ 8) =
                                                                                            true then
                                                                                        isTrue ⋯
                                                                                      else isFalse ⋯
                                                                                    [Meta.whnf] [0.001238] Non-easy whnf: Decidable.casesOn
                                                                                          (instDecidableEqBool
                                                                                            ((2 * (7#8).toNat).succ.ble
                                                                                              (2 ^ 8))
                                                                                            true)
                                                                                          (fun h => isFalse ⋯) fun h =>
                                                                                          isTrue ⋯
                                                                                      [Meta.whnf] [0.001222] Non-easy whnf: instDecidableEqBool
                                                                                            ((2 * (7#8).toNat).succ.ble
                                                                                              (2 ^ 8))
                                                                                            true
                                                                                        [Meta.whnf] [0.001215] Non-easy whnf: ((2 *
                                                                                                        (7#8).toNat).succ.ble
                                                                                                  (2 ^ 8)).decEq
                                                                                              true
                                                                                          [Meta.whnf] [0.001200] Non-easy whnf: match
                                                                                                (2 *
                                                                                                        (7#8).toNat).succ.ble
                                                                                                  (2 ^ 8),
                                                                                                true with
                                                                                              | false, false => isTrue ⋯
                                                                                              | false, true => isFalse ⋯
                                                                                              | true, false => isFalse ⋯
                                                                                              | true, true => isTrue ⋯
                                                                                            [Meta.whnf] [0.001130] Non-easy whnf: (fun
                                                                                                      motive a b h_1 h_2
                                                                                                      h_3 h_4 =>
                                                                                                    Bool.casesOn a
                                                                                                      (Bool.casesOn b
                                                                                                        (h_1 ())
                                                                                                        (h_2 ()))
                                                                                                      (Bool.casesOn b
                                                                                                        (h_3 ())
                                                                                                        (h_4 ())))
                                                                                                  (fun a b =>
                                                                                                    Decidable (a = b))
                                                                                                  ((2 *
                                                                                                          (7#8).toNat).succ.ble
                                                                                                    (2 ^ 8))
                                                                                                  true h_1 h_2 h_3 h_4
                                                                                              [Meta.whnf] [0.001096] Non-easy whnf: (2 *
                                                                                                          (7#8).toNat).succ.ble
                                                                                                    (2 ^ 8)
                                                                                                [Meta.whnf] [0.001079] Non-easy whnf: (2 *
                                                                                                        (7#8).toNat).succ
                                                                                                  [Meta.whnf] [0.001074] Non-easy whnf: 2 *
                                                                                                        (7#8).toNat
                                                                                                    [Meta.whnf] [0.001066] Non-easy whnf: instHMul.1
                                                                                                          2 (7#8).toNat
                                                                                                      [Meta.whnf] [0.001042] Non-easy whnf: instMulNat.1
                                                                                                            2
                                                                                                            (7#8).toNat
                                                            [Meta.isDefEq] [0.005717] ✅️ (7#8).toNat %
                                                                  (Int.ofNat (2 ^ (2 * 8))).natAbs =?= 7 % 2 ^ 16
                                                              [Meta.isDefEq] [0.005684] ✅️ instHMod.1 (7#8).toNat
                                                                    (Int.ofNat
                                                                        (2 ^ (2 * 8))).natAbs =?= instHMod.1 7 (2 ^ 16)
                                                                [Meta.isDefEq] [0.005631] ✅️ Mod.mod (7#8).toNat
                                                                      (Int.ofNat
                                                                          (2 ^ (2 * 8))).natAbs =?= Mod.mod 7 (2 ^ 16)
  [Meta.isDefEq] [0.002812] ❌️ ?x ^^ ?x =?= x✝.getLsbD 7 != false
    [Meta.isDefEq] [0.002795] ❌️ ?x != ?x =?= x✝.getLsbD 7 != false
      [Meta.isDefEq] [0.002741] ❌️ x✝.getLsbD 7 =?= false
  [Meta.isDefEq] [0.010042] ✅️ ?v =?= some (if (!(x✝ * 7#8).getLsbD 7 == (21#8 >ᵤ x✝ * 7#8)) = true then 1#1 else 0#1)
    [Meta.isDefEq.assign] [0.010035] ✅️ ?v := some
          (if (!(x✝ * 7#8).getLsbD 7 == (21#8 >ᵤ x✝ * 7#8)) = true then 1#1 else 0#1)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                  true then
              none
            else some (if (!(x✝ * 7#8).getLsbD 7 == (21#8 >ᵤ x✝ * 7#8)) = true then 1#1 else 0#1)) ⊑
            some (if (!x✝.getLsbD 7 == (3#8 >ᵤ x✝)) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:44:8: warning: declaration uses 'sorry'
[bv] [0.054519] Normalizing goal
  [Meta.synthInstance] [0.001294] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else some (BitVec.ofBool (21#8 >ₛ x✝ * 249#8))) ⊑
          some (BitVec.ofBool (x✝ >ₛ 253#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (21#8 >ₛ x✝ * 249#8))) ⊑
            some (BitVec.ofBool (x✝ >ₛ 253#8))
      ⊢ False
  [Meta.isDefEq] [0.002247] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65529#16)
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                      (BitVec.signExtend 16 x✝ * 65529#16))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65529#16)
                            (BitVec.twoPow 16 7)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16) true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                (congrArg
                  (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) && x))
                  (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)))))))
        (true_and
          ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) &&
                BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)) =
            true))
    [Meta.isDefEq.assign] [0.002244] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65529#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                        (BitVec.signExtend 16 x✝ * 65529#16))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65529#16)
                              (BitVec.twoPow 16 7)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16) true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                  (congrArg
                    (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) && x))
                    (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)))))))
          (true_and
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.002208] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 <
                  BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65529#16)
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                          (BitVec.signExtend 16 x✝ * 65529#16))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65529#16)
                                (BitVec.twoPow 16 7)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16) true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                      !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                    (congrArg
                      (fun x =>
                        !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) && x))
                      (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)))))))
            (true_and
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)) =
                true)) : (True ∧
              (BitVec.signExtend 16 x✝ * 65529#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                BitVec.signExtend 16 x✝ * 65529#16 ≥ BitVec.twoPow 16 7)) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)) =
              true))
        [Meta.isDefEq] [0.002204] ✅️ (True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)) =
                true) =?= (True ∧
                (BitVec.signExtend 16 x✝ * 65529#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 65529#16 ≥ BitVec.twoPow 16 7)) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)) =
                true)
          [Meta.isDefEq] [0.002178] ✅️ True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1)) =?= True ∧
                (BitVec.signExtend 16 x✝ * 65529#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 65529#16 ≥ BitVec.twoPow 16 7)
            [Meta.isDefEq] [0.002139] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1) =?= BitVec.signExtend 16 x✝ * 65529#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 65529#16 ≥ BitVec.twoPow 16 7
              [Meta.isDefEq] [0.002033] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 <
                    BitVec.signExtend (2 * 8)
                      (BitVec.twoPow 8
                        (8 - 1)) =?= BitVec.signExtend 16 x✝ * 65529#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7)
                [Meta.isDefEq] [0.002005] ✅️ instLTBitVec.1
                      (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8)
                      (BitVec.signExtend (2 * 8)
                        (BitVec.twoPow 8
                          (8 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 16 x✝ * 65529#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                  [Meta.isDefEq] [0.001952] ✅️ (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8).toNat <
                        (BitVec.signExtend (2 * 8)
                            (BitVec.twoPow 8
                              (8 -
                                1))).toNat =?= (BitVec.signExtend 16 x✝ * 65529#16).toNat <
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                    [Meta.isDefEq] [0.001934] ✅️ instLTNat.1
                          (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8).toNat
                          (BitVec.signExtend (2 * 8)
                              (BitVec.twoPow 8
                                (8 -
                                  1))).toNat =?= instLTNat.1 (BitVec.signExtend 16 x✝ * 65529#16).toNat
                          (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                      [Meta.isDefEq] [0.001903] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 249#8).toNat.lt
                            (BitVec.signExtend (2 * 8)
                                (BitVec.twoPow 8
                                  (8 -
                                    1))).toNat =?= (BitVec.signExtend 16 x✝ * 65529#16).toNat.lt
                            (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                        [Meta.isDefEq.delta] [0.001886] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 249#8).toNat.lt
                              (BitVec.signExtend (2 * 8)
                                  (BitVec.twoPow 8
                                    (8 -
                                      1))).toNat =?= (BitVec.signExtend 16 x✝ * 65529#16).toNat.lt
                              (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                          [Meta.isDefEq] [0.001759] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 249#8).toNat =?= (BitVec.signExtend 16 x✝ * 65529#16).toNat
                            [Meta.isDefEq.delta] [0.001739] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8)
                                      249#8).toNat =?= (BitVec.signExtend 16 x✝ * 65529#16).toNat
                              [Meta.isDefEq] [0.001724] ✅️ BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 249#8 =?= BitVec.signExtend 16 x✝ * 65529#16
                                [Meta.isDefEq] [0.001696] ✅️ instHMul.1 (BitVec.signExtend (2 * 8) x✝)
                                      (BitVec.signExtend (2 * 8)
                                        249#8) =?= instHMul.1 (BitVec.signExtend 16 x✝) 65529#16
                                  [Meta.isDefEq] [0.001652] ✅️ Mul.mul (BitVec.signExtend (2 * 8) x✝)
                                        (BitVec.signExtend (2 * 8) 249#8) =?= Mul.mul (BitVec.signExtend 16 x✝) 65529#16
                                    [Meta.isDefEq] [0.001627] ✅️ BitVec.instMul.1 (BitVec.signExtend (2 * 8) x✝)
                                          (BitVec.signExtend (2 * 8)
                                            249#8) =?= BitVec.instMul.1 (BitVec.signExtend 16 x✝) 65529#16
                                      [Meta.isDefEq] [0.001584] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                            (BitVec.signExtend (2 * 8) 249#8) =?= (BitVec.signExtend 16 x✝).mul 65529#16
                                        [Meta.isDefEq.delta] [0.001570] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                              (BitVec.signExtend (2 * 8)
                                                249#8) =?= (BitVec.signExtend 16 x✝).mul 65529#16
                                          [Meta.isDefEq] [0.001497] ✅️ BitVec.signExtend (2 * 8) 249#8 =?= 65529#16
                                            [Meta.isDefEq] [0.001471] ✅️ BitVec.ofInt (2 * 8) (249#8).toInt =?= 65529#16
                                              [Meta.isDefEq] [0.001450] ✅️ ((249#8).toInt %
                                                        Int.ofNat (2 ^ (2 * 8))).toNat#'⋯ =?= 65529#16
                                                [Meta.isDefEq] [0.001427] ✅️ ((249#8).toInt %
                                                          Int.ofNat
                                                            (2 ^
                                                              (2 *
                                                                8))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 16) 65529 }
                                                  [Meta.isDefEq] [0.001410] ✅️ {
                                                        toFin :=
                                                          ⟨((249#8).toInt % Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 16) 65529 }
                                                    [Meta.isDefEq] [0.001381] ✅️ ⟨((249#8).toInt %
                                                              Int.ofNat (2 ^ (2 * 8))).toNat,
                                                          ⋯⟩ =?= Fin.ofNat' (2 ^ 16) 65529
                                                      [Meta.isDefEq] [0.001358] ✅️ ⟨((249#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ =?= ⟨65529 % 2 ^ 16, ⋯⟩
                                                        [Meta.isDefEq] [0.001295] ✅️ ((249#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat =?= 65529 % 2 ^ 16
                                                          [Meta.isDefEq] [0.001227] ✅️ match
                                                                (249#8).toInt % Int.ofNat (2 ^ (2 * 8)) with
                                                              | Int.ofNat n => n
                                                              | Int.negSucc a => 0 =?= 65529 % 2 ^ 16
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)) =
                  true then
              none
            else some (if (!(x✝ * 249#8).getLsbD 7 == (21#8 >ᵤ x✝ * 249#8)) = true then 1#1 else 0#1)) ⊑
            some (if (!(!x✝.getLsbD 7) == (x✝ >ᵤ 253#8)) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:55:8: warning: declaration uses 'sorry'
[bv] [0.049892] Normalizing goal
  [Meta.synthInstance] [0.001529] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else some (BitVec.ofBool (21#8 >ₛ x✝ * 5#8))) ⊑
          some (BitVec.ofBool (5#8 >ₛ x✝)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (21#8 >ₛ x✝ * 5#8))) ⊑
            some (BitVec.ofBool (5#8 >ₛ x✝))
      ⊢ False
  [Meta.isDefEq] [0.002299] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7) (BitVec.signExtend 16 x✝ * 5#16))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                            (BitVec.twoPow 16 7)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                (congrArg
                  (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                  (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
        (true_and
          ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
            true))
    [Meta.isDefEq.assign] [0.002296] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                        (BitVec.signExtend 16 x✝ * 5#16))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                              (BitVec.twoPow 16 7)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  (congrArg
                    (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                    (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
          (true_and
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.002265] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                  BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                          (BitVec.signExtend 16 x✝ * 5#16))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                                (BitVec.twoPow 16 7)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                      !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    (congrArg
                      (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                      (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
            (true_and
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true)) : (True ∧
              (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true))
        [Meta.isDefEq] [0.002261] ✅️ (True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true) =?= (True ∧
                (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true)
          [Meta.isDefEq] [0.002233] ✅️ True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1)) =?= True ∧
                (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)
            [Meta.isDefEq] [0.002214] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1) =?= BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7
              [Meta.isDefEq] [0.002082] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8)
                      (BitVec.twoPow 8
                        (8 - 1)) =?= BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7)
                [Meta.isDefEq] [0.002057] ✅️ instLTBitVec.1
                      (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8)
                      (BitVec.signExtend (2 * 8)
                        (BitVec.twoPow 8
                          (8 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 16 x✝ * 5#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                  [Meta.isDefEq] [0.001993] ✅️ (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8).toNat <
                        (BitVec.signExtend (2 * 8)
                            (BitVec.twoPow 8
                              (8 -
                                1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat <
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                    [Meta.isDefEq] [0.001978] ✅️ instLTNat.1
                          (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8).toNat
                          (BitVec.signExtend (2 * 8)
                              (BitVec.twoPow 8
                                (8 -
                                  1))).toNat =?= instLTNat.1 (BitVec.signExtend 16 x✝ * 5#16).toNat
                          (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                      [Meta.isDefEq] [0.001945] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 5#8).toNat.lt
                            (BitVec.signExtend (2 * 8)
                                (BitVec.twoPow 8
                                  (8 -
                                    1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat.lt
                            (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                        [Meta.isDefEq.delta] [0.001934] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8).toNat.lt
                              (BitVec.signExtend (2 * 8)
                                  (BitVec.twoPow 8
                                    (8 -
                                      1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat.lt
                              (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                          [Meta.isDefEq] [0.001824] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 5#8).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat
                            [Meta.isDefEq.delta] [0.001810] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat
                              [Meta.isDefEq] [0.001789] ✅️ BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8 =?= BitVec.signExtend 16 x✝ * 5#16
                                [Meta.isDefEq] [0.001759] ✅️ instHMul.1 (BitVec.signExtend (2 * 8) x✝)
                                      (BitVec.signExtend (2 * 8) 5#8) =?= instHMul.1 (BitVec.signExtend 16 x✝) 5#16
                                  [Meta.isDefEq] [0.001704] ✅️ Mul.mul (BitVec.signExtend (2 * 8) x✝)
                                        (BitVec.signExtend (2 * 8) 5#8) =?= Mul.mul (BitVec.signExtend 16 x✝) 5#16
                                    [Meta.isDefEq] [0.001679] ✅️ BitVec.instMul.1 (BitVec.signExtend (2 * 8) x✝)
                                          (BitVec.signExtend (2 * 8)
                                            5#8) =?= BitVec.instMul.1 (BitVec.signExtend 16 x✝) 5#16
                                      [Meta.isDefEq] [0.001628] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                            (BitVec.signExtend (2 * 8) 5#8) =?= (BitVec.signExtend 16 x✝).mul 5#16
                                        [Meta.isDefEq.delta] [0.001617] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                              (BitVec.signExtend (2 * 8) 5#8) =?= (BitVec.signExtend 16 x✝).mul 5#16
                                          [Meta.isDefEq] [0.001539] ✅️ BitVec.signExtend (2 * 8) 5#8 =?= 5#16
                                            [Meta.isDefEq] [0.001521] ✅️ BitVec.ofInt (2 * 8) (5#8).toInt =?= 5#16
                                              [Meta.isDefEq] [0.001503] ✅️ ((5#8).toInt %
                                                        Int.ofNat (2 ^ (2 * 8))).toNat#'⋯ =?= 5#16
                                                [Meta.isDefEq] [0.001482] ✅️ ((5#8).toInt %
                                                          Int.ofNat
                                                            (2 ^
                                                              (2 * 8))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 16) 5 }
                                                  [Meta.isDefEq] [0.001467] ✅️ {
                                                        toFin :=
                                                          ⟨((5#8).toInt % Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 16) 5 }
                                                    [Meta.isDefEq] [0.001430] ✅️ ⟨((5#8).toInt %
                                                              Int.ofNat (2 ^ (2 * 8))).toNat,
                                                          ⋯⟩ =?= Fin.ofNat' (2 ^ 16) 5
                                                      [Meta.isDefEq] [0.001405] ✅️ ⟨((5#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ =?= ⟨5 % 2 ^ 16, ⋯⟩
                                                        [Meta.isDefEq] [0.001289] ✅️ ((5#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat =?= 5 % 2 ^ 16
                                                          [Meta.isDefEq] [0.001174] ✅️ match
                                                                (5#8).toInt % Int.ofNat (2 ^ (2 * 8)) with
                                                              | Int.ofNat n => n
                                                              | Int.negSucc a => 0 =?= 5 % 2 ^ 16
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                  true then
              none
            else some (if (!(x✝ * 5#8).getLsbD 7 == (21#8 >ᵤ x✝ * 5#8)) = true then 1#1 else 0#1)) ⊑
            some (if (!x✝.getLsbD 7 == (5#8 >ᵤ x✝)) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:66:8: warning: declaration uses 'sorry'
[bv] [0.036391] Normalizing goal
  [Meta.synthInstance] [0.001342] ✅️ Decidable
        ((if
              True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
            none
          else some (BitVec.ofBool (21#8 >ᵤ x✝ * 7#8))) ⊑
          some (BitVec.ofBool (3#8 >ᵤ x✝)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else some (BitVec.ofBool (21#8 >ᵤ x✝ * 7#8))) ⊑
            some (BitVec.ofBool (3#8 >ᵤ x✝))
      ⊢ False
  [Meta.isDefEq] [0.001586] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1) (BitVec.zeroExtend 16 x✝ * 7#16))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 7#16)
                      (BitVec.twoPow 16 7 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16)))))))
        (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true))
    [Meta.isDefEq.assign] [0.001584] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                  (BitVec.zeroExtend 16 x✝ * 7#16))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 7#16)
                        (BitVec.twoPow 16 7 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16)))))))
          (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001570] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                    (BitVec.zeroExtend 16 x✝ * 7#16))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 7#16)
                          (BitVec.twoPow 16 7 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16)))))))
            (true_and
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) =
                true)) : (True ∧ BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true))
        [Meta.isDefEq] [0.001567] ✅️ (True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) =
                true) =?= (True ∧ BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true)
          [Meta.isDefEq] [0.001547] ✅️ True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1
            [Meta.isDefEq] [0.001531] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1
              [Meta.isDefEq.delta] [0.001508] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1
                [Meta.isDefEq] [0.001101] ✅️ BitVec.zeroExtend (2 * 8) x✝ *
                      BitVec.zeroExtend (2 * 8) 7#8 =?= BitVec.zeroExtend 16 x✝ * 7#16
                  [Meta.isDefEq] [0.001072] ✅️ instHMul.1 (BitVec.zeroExtend (2 * 8) x✝)
                        (BitVec.zeroExtend (2 * 8) 7#8) =?= instHMul.1 (BitVec.zeroExtend 16 x✝) 7#16
                    [Meta.isDefEq] [0.001004] ✅️ Mul.mul (BitVec.zeroExtend (2 * 8) x✝)
                          (BitVec.zeroExtend (2 * 8) 7#8) =?= Mul.mul (BitVec.zeroExtend 16 x✝) 7#16
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true then none
            else some (if (21#8 >ᵤ x✝ * 7#8) = true then 1#1 else 0#1)) ⊑
            some (if (3#8 >ᵤ x✝) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:77:8: warning: declaration uses 'sorry'
[bv] [0.046966] Normalizing goal
  [Meta.synthInstance] [0.001420] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else some (BitVec.ofBool (21#8 >ᵤ x✝ * 7#8))) ⊑
          some (BitVec.ofBool (3#8 >ᵤ x✝)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                      BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
                none
              else some (BitVec.ofBool (21#8 >ᵤ x✝ * 7#8))) ⊑
            some (BitVec.ofBool (3#8 >ᵤ x✝))
      ⊢ False
  [Meta.isDefEq] [0.001893] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7) (BitVec.signExtend 16 x✝ * 7#16))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                            (BitVec.twoPow 16 7)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16) true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                (congrArg
                  (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) && x))
                  (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
        (true_and
          ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
            true))
    [Meta.isDefEq.assign] [0.001891] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                        (BitVec.signExtend 16 x✝ * 7#16))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                              (BitVec.twoPow 16 7)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16) true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                  (congrArg
                    (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) && x))
                    (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
          (true_and
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.001864] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                  BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                          (BitVec.signExtend 16 x✝ * 7#16))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                                (BitVec.twoPow 16 7)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16) true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                      !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                    (congrArg
                      (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) && x))
                      (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
            (true_and
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                true)) : (True ∧
              (BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7)) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
              true))
        [Meta.isDefEq] [0.001861] ✅️ (True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                true) =?= (True ∧
                (BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7)) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                true)
          [Meta.isDefEq] [0.001840] ✅️ True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1)) =?= True ∧
                (BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7)
            [Meta.isDefEq] [0.001823] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1) =?= BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7
              [Meta.isDefEq] [0.001704] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8)
                      (BitVec.twoPow 8
                        (8 - 1)) =?= BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7)
                [Meta.isDefEq] [0.001681] ✅️ instLTBitVec.1
                      (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8)
                      (BitVec.signExtend (2 * 8)
                        (BitVec.twoPow 8
                          (8 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 16 x✝ * 7#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                  [Meta.isDefEq] [0.001635] ✅️ (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8).toNat <
                        (BitVec.signExtend (2 * 8)
                            (BitVec.twoPow 8
                              (8 -
                                1))).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat <
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                    [Meta.isDefEq] [0.001622] ✅️ instLTNat.1
                          (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8).toNat
                          (BitVec.signExtend (2 * 8)
                              (BitVec.twoPow 8
                                (8 -
                                  1))).toNat =?= instLTNat.1 (BitVec.signExtend 16 x✝ * 7#16).toNat
                          (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                      [Meta.isDefEq] [0.001591] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 7#8).toNat.lt
                            (BitVec.signExtend (2 * 8)
                                (BitVec.twoPow 8
                                  (8 -
                                    1))).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat.lt
                            (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                        [Meta.isDefEq.delta] [0.001580] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 7#8).toNat.lt
                              (BitVec.signExtend (2 * 8)
                                  (BitVec.twoPow 8
                                    (8 -
                                      1))).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat.lt
                              (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                          [Meta.isDefEq] [0.001462] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 7#8).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat
                            [Meta.isDefEq.delta] [0.001448] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 7#8).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat
                              [Meta.isDefEq] [0.001427] ✅️ BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 7#8 =?= BitVec.signExtend 16 x✝ * 7#16
                                [Meta.isDefEq] [0.001402] ✅️ instHMul.1 (BitVec.signExtend (2 * 8) x✝)
                                      (BitVec.signExtend (2 * 8) 7#8) =?= instHMul.1 (BitVec.signExtend 16 x✝) 7#16
                                  [Meta.isDefEq] [0.001346] ✅️ Mul.mul (BitVec.signExtend (2 * 8) x✝)
                                        (BitVec.signExtend (2 * 8) 7#8) =?= Mul.mul (BitVec.signExtend 16 x✝) 7#16
                                    [Meta.isDefEq] [0.001324] ✅️ BitVec.instMul.1 (BitVec.signExtend (2 * 8) x✝)
                                          (BitVec.signExtend (2 * 8)
                                            7#8) =?= BitVec.instMul.1 (BitVec.signExtend 16 x✝) 7#16
                                      [Meta.isDefEq] [0.001281] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                            (BitVec.signExtend (2 * 8) 7#8) =?= (BitVec.signExtend 16 x✝).mul 7#16
                                        [Meta.isDefEq.delta] [0.001251] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                              (BitVec.signExtend (2 * 8) 7#8) =?= (BitVec.signExtend 16 x✝).mul 7#16
                                          [Meta.isDefEq] [0.001173] ✅️ BitVec.signExtend (2 * 8) 7#8 =?= 7#16
                                            [Meta.isDefEq] [0.001157] ✅️ BitVec.ofInt (2 * 8) (7#8).toInt =?= 7#16
                                              [Meta.isDefEq] [0.001143] ✅️ ((7#8).toInt %
                                                        Int.ofNat (2 ^ (2 * 8))).toNat#'⋯ =?= 7#16
                                                [Meta.isDefEq] [0.001126] ✅️ ((7#8).toInt %
                                                          Int.ofNat
                                                            (2 ^
                                                              (2 * 8))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 16) 7 }
                                                  [Meta.isDefEq] [0.001112] ✅️ {
                                                        toFin :=
                                                          ⟨((7#8).toInt % Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 16) 7 }
                                                    [Meta.isDefEq] [0.001080] ✅️ ⟨((7#8).toInt %
                                                              Int.ofNat (2 ^ (2 * 8))).toNat,
                                                          ⋯⟩ =?= Fin.ofNat' (2 ^ 16) 7
                                                      [Meta.isDefEq] [0.001061] ✅️ ⟨((7#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ =?= ⟨7 % 2 ^ 16, ⋯⟩
  [Meta.isDefEq] [0.001079] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1) (BitVec.zeroExtend 16 x✝ * 7#16))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 7#16)
                      (BitVec.twoPow 16 7 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16)))))))
        (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true))
    [Meta.isDefEq.assign] [0.001077] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                  (BitVec.zeroExtend 16 x✝ * 7#16))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 7#16)
                        (BitVec.twoPow 16 7 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16)))))))
          (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001063] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                    (BitVec.zeroExtend 16 x✝ * 7#16))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 7#16)
                          (BitVec.twoPow 16 7 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16)))))))
            (true_and
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) =
                true)) : (True ∧ BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true))
        [Meta.isDefEq] [0.001053] ✅️ (True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) =
                true) =?= (True ∧ BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true)
          [Meta.isDefEq] [0.001033] ✅️ True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1
            [Meta.isDefEq] [0.001023] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1
              [Meta.isDefEq.delta] [0.001004] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                  true then
              none
            else
              if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true then none
              else some (if (21#8 >ᵤ x✝ * 7#8) = true then 1#1 else 0#1)) ⊑
            some (if (3#8 >ᵤ x✝) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:88:8: warning: declaration uses 'sorry'
[bv] [0.050104] Normalizing goal
  [Meta.synthInstance] [0.001771] ✅️ Decidable
        ((if
              True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
            none
          else some (BitVec.ofBool (21#8 >ᵤ x✝ * 5#8))) ⊑
          some (BitVec.ofBool (5#8 >ᵤ x✝)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else some (BitVec.ofBool (21#8 >ᵤ x✝ * 5#8))) ⊑
            some (BitVec.ofBool (5#8 >ᵤ x✝))
      ⊢ False
  [Meta.isDefEq] [0.003669] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1) (BitVec.zeroExtend 16 x✝ * 5#16))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                      (BitVec.twoPow 16 7 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
        (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
    [Meta.isDefEq.assign] [0.003665] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                  (BitVec.zeroExtend 16 x✝ * 5#16))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                        (BitVec.twoPow 16 7 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
          (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
      [Meta.isDefEq.assign.checkTypes] [0.003642] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                    (BitVec.zeroExtend 16 x✝ * 5#16))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                          (BitVec.twoPow 16 7 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
            (true_and
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
                true)) : (True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
        [Meta.isDefEq] [0.003637] ✅️ (True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
                true) =?= (True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true)
          [Meta.isDefEq] [0.003602] ✅️ True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1
            [Meta.isDefEq] [0.003577] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1
              [Meta.isDefEq.delta] [0.003545] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1
                [Meta.isDefEq] [0.002781] ✅️ BitVec.zeroExtend (2 * 8) x✝ *
                      BitVec.zeroExtend (2 * 8) 5#8 =?= BitVec.zeroExtend 16 x✝ * 5#16
                  [Meta.isDefEq] [0.002734] ✅️ instHMul.1 (BitVec.zeroExtend (2 * 8) x✝)
                        (BitVec.zeroExtend (2 * 8) 5#8) =?= instHMul.1 (BitVec.zeroExtend 16 x✝) 5#16
                    [Meta.isDefEq] [0.002614] ✅️ Mul.mul (BitVec.zeroExtend (2 * 8) x✝)
                          (BitVec.zeroExtend (2 * 8) 5#8) =?= Mul.mul (BitVec.zeroExtend 16 x✝) 5#16
                      [Meta.isDefEq] [0.002569] ✅️ BitVec.instMul.1 (BitVec.zeroExtend (2 * 8) x✝)
                            (BitVec.zeroExtend (2 * 8) 5#8) =?= BitVec.instMul.1 (BitVec.zeroExtend 16 x✝) 5#16
                        [Meta.isDefEq] [0.002482] ✅️ (BitVec.zeroExtend (2 * 8) x✝).mul
                              (BitVec.zeroExtend (2 * 8) 5#8) =?= (BitVec.zeroExtend 16 x✝).mul 5#16
                          [Meta.isDefEq.delta] [0.002462] ✅️ (BitVec.zeroExtend (2 * 8) x✝).mul
                                (BitVec.zeroExtend (2 * 8) 5#8) =?= (BitVec.zeroExtend 16 x✝).mul 5#16
                            [Meta.isDefEq] [0.002288] ✅️ BitVec.zeroExtend (2 * 8) 5#8 =?= 5#16
                              [Meta.isDefEq] [0.002263] ✅️ BitVec.setWidth (2 * 8) 5#8 =?= 5#16
                                [Meta.isDefEq] [0.002231] ✅️ if h : 8 ≤ 2 * 8 then BitVec.setWidth' h 5#8
                                    else BitVec.ofNat (2 * 8) (5#8).toNat =?= 5#16
                                  [Meta.isDefEq] [0.002190] ✅️ if h : 8 ≤ 2 * 8 then BitVec.setWidth' h 5#8
                                      else BitVec.ofNat (2 * 8) (5#8).toNat =?= { toFin := Fin.ofNat' (2 ^ 16) 5 }
                                    [Meta.isDefEq] [0.002160] ✅️ Decidable.casesOn (Nat.decLe 8 (2 * 8))
                                          (fun h => BitVec.ofNat (2 * 8) (5#8).toNat) fun h =>
                                          BitVec.setWidth' h 5#8 =?= { toFin := Fin.ofNat' (2 ^ 16) 5 }
                                      [Meta.isDefEq] [0.001762] ✅️ BitVec.setWidth' ⋯
                                            5#8 =?= { toFin := Fin.ofNat' (2 ^ 16) 5 }
                                        [Meta.isDefEq] [0.001735] ✅️ (5#8).toNat#'⋯ =?= {
                                              toFin := Fin.ofNat' (2 ^ 16) 5 }
                                          [Meta.isDefEq] [0.001707] ✅️ {
                                                toFin := ⟨(5#8).toNat, ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 16) 5 }
                                            [Meta.isDefEq] [0.001646] ✅️ ⟨(5#8).toNat, ⋯⟩ =?= Fin.ofNat' (2 ^ 16) 5
                                              [Meta.isDefEq] [0.001618] ✅️ ⟨(5#8).toNat, ⋯⟩ =?= ⟨5 % 2 ^ 16, ⋯⟩
                                                [Meta.isDefEq] [0.001442] ✅️ (5#8).toNat =?= 5 % 2 ^ 16
                                                  [Meta.isDefEq] [0.001318] ✅️ ↑(5#8).toFin =?= 5 % 2 ^ 16
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true then none
            else some (if (21#8 >ᵤ x✝ * 5#8) = true then 1#1 else 0#1)) ⊑
            some (if (5#8 >ᵤ x✝) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:99:8: warning: declaration uses 'sorry'
[bv] [0.047278] Normalizing goal
  [Meta.synthInstance] [0.001344] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else some (BitVec.ofBool (21#8 >ᵤ x✝ * 5#8))) ⊑
          some (BitVec.ofBool (5#8 >ᵤ x✝)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                      BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
                none
              else some (BitVec.ofBool (21#8 >ᵤ x✝ * 5#8))) ⊑
            some (BitVec.ofBool (5#8 >ᵤ x✝))
      ⊢ False
  [Meta.isDefEq] [0.001869] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7) (BitVec.signExtend 16 x✝ * 5#16))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                            (BitVec.twoPow 16 7)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                (congrArg
                  (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                  (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
        (true_and
          ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
            true))
    [Meta.isDefEq.assign] [0.001866] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                        (BitVec.signExtend 16 x✝ * 5#16))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                              (BitVec.twoPow 16 7)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  (congrArg
                    (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                    (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
          (true_and
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.001841] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                  BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                          (BitVec.signExtend 16 x✝ * 5#16))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                                (BitVec.twoPow 16 7)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                      !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    (congrArg
                      (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                      (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
            (true_and
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true)) : (True ∧
              (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true))
        [Meta.isDefEq] [0.001837] ✅️ (True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true) =?= (True ∧
                (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true)
          [Meta.isDefEq] [0.001812] ✅️ True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1)) =?= True ∧
                (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)
            [Meta.isDefEq] [0.001797] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1) =?= BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7
              [Meta.isDefEq] [0.001667] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8)
                      (BitVec.twoPow 8
                        (8 - 1)) =?= BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7)
                [Meta.isDefEq] [0.001646] ✅️ instLTBitVec.1
                      (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8)
                      (BitVec.signExtend (2 * 8)
                        (BitVec.twoPow 8
                          (8 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 16 x✝ * 5#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                  [Meta.isDefEq] [0.001598] ✅️ (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8).toNat <
                        (BitVec.signExtend (2 * 8)
                            (BitVec.twoPow 8
                              (8 -
                                1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat <
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                    [Meta.isDefEq] [0.001585] ✅️ instLTNat.1
                          (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8).toNat
                          (BitVec.signExtend (2 * 8)
                              (BitVec.twoPow 8
                                (8 -
                                  1))).toNat =?= instLTNat.1 (BitVec.signExtend 16 x✝ * 5#16).toNat
                          (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                      [Meta.isDefEq] [0.001554] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 5#8).toNat.lt
                            (BitVec.signExtend (2 * 8)
                                (BitVec.twoPow 8
                                  (8 -
                                    1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat.lt
                            (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                        [Meta.isDefEq.delta] [0.001544] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8).toNat.lt
                              (BitVec.signExtend (2 * 8)
                                  (BitVec.twoPow 8
                                    (8 -
                                      1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat.lt
                              (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                          [Meta.isDefEq] [0.001449] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 5#8).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat
                            [Meta.isDefEq.delta] [0.001428] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat
                              [Meta.isDefEq] [0.001407] ✅️ BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8 =?= BitVec.signExtend 16 x✝ * 5#16
                                [Meta.isDefEq] [0.001382] ✅️ instHMul.1 (BitVec.signExtend (2 * 8) x✝)
                                      (BitVec.signExtend (2 * 8) 5#8) =?= instHMul.1 (BitVec.signExtend 16 x✝) 5#16
                                  [Meta.isDefEq] [0.001331] ✅️ Mul.mul (BitVec.signExtend (2 * 8) x✝)
                                        (BitVec.signExtend (2 * 8) 5#8) =?= Mul.mul (BitVec.signExtend 16 x✝) 5#16
                                    [Meta.isDefEq] [0.001311] ✅️ BitVec.instMul.1 (BitVec.signExtend (2 * 8) x✝)
                                          (BitVec.signExtend (2 * 8)
                                            5#8) =?= BitVec.instMul.1 (BitVec.signExtend 16 x✝) 5#16
                                      [Meta.isDefEq] [0.001271] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                            (BitVec.signExtend (2 * 8) 5#8) =?= (BitVec.signExtend 16 x✝).mul 5#16
                                        [Meta.isDefEq.delta] [0.001260] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                              (BitVec.signExtend (2 * 8) 5#8) =?= (BitVec.signExtend 16 x✝).mul 5#16
                                          [Meta.isDefEq] [0.001187] ✅️ BitVec.signExtend (2 * 8) 5#8 =?= 5#16
                                            [Meta.isDefEq] [0.001170] ✅️ BitVec.ofInt (2 * 8) (5#8).toInt =?= 5#16
                                              [Meta.isDefEq] [0.001151] ✅️ ((5#8).toInt %
                                                        Int.ofNat (2 ^ (2 * 8))).toNat#'⋯ =?= 5#16
                                                [Meta.isDefEq] [0.001135] ✅️ ((5#8).toInt %
                                                          Int.ofNat
                                                            (2 ^
                                                              (2 * 8))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 16) 5 }
                                                  [Meta.isDefEq] [0.001122] ✅️ {
                                                        toFin :=
                                                          ⟨((5#8).toInt % Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 16) 5 }
                                                    [Meta.isDefEq] [0.001086] ✅️ ⟨((5#8).toInt %
                                                              Int.ofNat (2 ^ (2 * 8))).toNat,
                                                          ⋯⟩ =?= Fin.ofNat' (2 ^ 16) 5
                                                      [Meta.isDefEq] [0.001063] ✅️ ⟨((5#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ =?= ⟨5 % 2 ^ 16, ⋯⟩
  [Meta.isDefEq] [0.001049] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1) (BitVec.zeroExtend 16 x✝ * 5#16))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                      (BitVec.twoPow 16 7 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
        (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
    [Meta.isDefEq.assign] [0.001047] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                  (BitVec.zeroExtend 16 x✝ * 5#16))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                        (BitVec.twoPow 16 7 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
          (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001033] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                    (BitVec.zeroExtend 16 x✝ * 5#16))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                          (BitVec.twoPow 16 7 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
            (true_and
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
                true)) : (True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
        [Meta.isDefEq] [0.001029] ✅️ (True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
                true) =?= (True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true)
          [Meta.isDefEq] [0.001008] ✅️ True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                  true then
              none
            else
              if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true then none
              else some (if (21#8 >ᵤ x✝ * 5#8) = true then 1#1 else 0#1)) ⊑
            some (if (5#8 >ᵤ x✝) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.appBuilder] [0.001347] ✅️ f: Subsingleton.elim, xs: [h✝, h]
    [Meta.synthInstance] [0.001300] ✅️ Subsingleton (Decidable c✝)
      [Meta.synthInstance] [0.001235] ✅️ apply instSubsingletonDecidable to Subsingleton (Decidable c✝)
        [Meta.synthInstance.tryResolve] [0.001207] ✅️ Subsingleton (Decidable c✝) ≟ Subsingleton (Decidable c✝)
          [Meta.isDefEq] [0.001183] ✅️ Subsingleton (Decidable c✝) =?= Subsingleton (Decidable ?m.47759)
            [Meta.isDefEq] [0.001143] ✅️ Decidable c✝ =?= Decidable ?m.47759
              [Meta.isDefEq] [0.001130] ✅️ c✝ =?= ?m.47759
                [Meta.isDefEq.assign] [0.001122] ✅️ ?m.47759 := c✝
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:110:8: warning: declaration uses 'sorry'
[bv] [0.052196] Normalizing goal
  [Meta.synthInstance] [0.001919] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else some (BitVec.ofBool (x✝ * 7#8 >ₛ 21#8))) ⊑
          some (BitVec.ofBool (x✝ >ₛ 3#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (x✝ * 7#8 >ₛ 21#8))) ⊑
            some (BitVec.ofBool (x✝ >ₛ 3#8))
      ⊢ False
  [Meta.isDefEq] [0.002916] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7) (BitVec.signExtend 16 x✝ * 7#16))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                            (BitVec.twoPow 16 7)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16) true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                (congrArg
                  (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) && x))
                  (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
        (true_and
          ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
            true))
    [Meta.isDefEq.assign] [0.002912] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                        (BitVec.signExtend 16 x✝ * 7#16))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                              (BitVec.twoPow 16 7)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16) true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                  (congrArg
                    (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) && x))
                    (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
          (true_and
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.002874] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                  BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                          (BitVec.signExtend 16 x✝ * 7#16))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                                (BitVec.twoPow 16 7)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16) true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                      !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                    (congrArg
                      (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) && x))
                      (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
            (true_and
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                true)) : (True ∧
              (BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7)) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
              true))
        [Meta.isDefEq] [0.002870] ✅️ (True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                true) =?= (True ∧
                (BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7)) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                true)
          [Meta.isDefEq] [0.002838] ✅️ True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1)) =?= True ∧
                (BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7)
            [Meta.isDefEq] [0.002812] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1) =?= BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7
              [Meta.isDefEq] [0.002626] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8)
                      (BitVec.twoPow 8
                        (8 - 1)) =?= BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7)
                [Meta.isDefEq] [0.002593] ✅️ instLTBitVec.1
                      (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8)
                      (BitVec.signExtend (2 * 8)
                        (BitVec.twoPow 8
                          (8 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 16 x✝ * 7#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                  [Meta.isDefEq] [0.002522] ✅️ (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8).toNat <
                        (BitVec.signExtend (2 * 8)
                            (BitVec.twoPow 8
                              (8 -
                                1))).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat <
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                    [Meta.isDefEq] [0.002498] ✅️ instLTNat.1
                          (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8).toNat
                          (BitVec.signExtend (2 * 8)
                              (BitVec.twoPow 8
                                (8 -
                                  1))).toNat =?= instLTNat.1 (BitVec.signExtend 16 x✝ * 7#16).toNat
                          (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                      [Meta.isDefEq] [0.002447] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 7#8).toNat.lt
                            (BitVec.signExtend (2 * 8)
                                (BitVec.twoPow 8
                                  (8 -
                                    1))).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat.lt
                            (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                        [Meta.isDefEq.delta] [0.002425] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 7#8).toNat.lt
                              (BitVec.signExtend (2 * 8)
                                  (BitVec.twoPow 8
                                    (8 -
                                      1))).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat.lt
                              (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                          [Meta.isDefEq] [0.002239] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 7#8).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat
                            [Meta.isDefEq.delta] [0.002216] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 7#8).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat
                              [Meta.isDefEq] [0.002181] ✅️ BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 7#8 =?= BitVec.signExtend 16 x✝ * 7#16
                                [Meta.isDefEq] [0.002131] ✅️ instHMul.1 (BitVec.signExtend (2 * 8) x✝)
                                      (BitVec.signExtend (2 * 8) 7#8) =?= instHMul.1 (BitVec.signExtend 16 x✝) 7#16
                                  [Meta.isDefEq] [0.002051] ✅️ Mul.mul (BitVec.signExtend (2 * 8) x✝)
                                        (BitVec.signExtend (2 * 8) 7#8) =?= Mul.mul (BitVec.signExtend 16 x✝) 7#16
                                    [Meta.isDefEq] [0.002017] ✅️ BitVec.instMul.1 (BitVec.signExtend (2 * 8) x✝)
                                          (BitVec.signExtend (2 * 8)
                                            7#8) =?= BitVec.instMul.1 (BitVec.signExtend 16 x✝) 7#16
                                      [Meta.isDefEq] [0.001957] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                            (BitVec.signExtend (2 * 8) 7#8) =?= (BitVec.signExtend 16 x✝).mul 7#16
                                        [Meta.isDefEq.delta] [0.001940] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                              (BitVec.signExtend (2 * 8) 7#8) =?= (BitVec.signExtend 16 x✝).mul 7#16
                                          [Meta.isDefEq] [0.001791] ✅️ BitVec.signExtend (2 * 8) 7#8 =?= 7#16
                                            [Meta.isDefEq] [0.001764] ✅️ BitVec.ofInt (2 * 8) (7#8).toInt =?= 7#16
                                              [Meta.isDefEq] [0.001740] ✅️ ((7#8).toInt %
                                                        Int.ofNat (2 ^ (2 * 8))).toNat#'⋯ =?= 7#16
                                                [Meta.isDefEq] [0.001715] ✅️ ((7#8).toInt %
                                                          Int.ofNat
                                                            (2 ^
                                                              (2 * 8))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 16) 7 }
                                                  [Meta.isDefEq] [0.001695] ✅️ {
                                                        toFin :=
                                                          ⟨((7#8).toInt % Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 16) 7 }
                                                    [Meta.isDefEq] [0.001646] ✅️ ⟨((7#8).toInt %
                                                              Int.ofNat (2 ^ (2 * 8))).toNat,
                                                          ⋯⟩ =?= Fin.ofNat' (2 ^ 16) 7
                                                      [Meta.isDefEq] [0.001623] ✅️ ⟨((7#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ =?= ⟨7 % 2 ^ 16, ⋯⟩
                                                        [Meta.isDefEq] [0.001477] ✅️ ((7#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat =?= 7 % 2 ^ 16
                                                          [Meta.isDefEq] [0.001363] ✅️ match
                                                                (7#8).toInt % Int.ofNat (2 ^ (2 * 8)) with
                                                              | Int.ofNat n => n
                                                              | Int.negSucc a => 0 =?= 7 % 2 ^ 16
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                  true then
              none
            else some (if (!(x✝ * 7#8).getLsbD 7 == (x✝ * 7#8 >ᵤ 21#8)) = true then 1#1 else 0#1)) ⊑
            some (if (!x✝.getLsbD 7 == (x✝ >ᵤ 3#8)) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:121:8: warning: declaration uses 'sorry'
[bv] [0.045134] Normalizing goal
  [Meta.synthInstance] [0.001502] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else some (BitVec.ofBool (x✝ * 249#8 >ₛ 21#8))) ⊑
          some (BitVec.ofBool (253#8 >ₛ x✝)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (x✝ * 249#8 >ₛ 21#8))) ⊑
            some (BitVec.ofBool (253#8 >ₛ x✝))
      ⊢ False
  [Meta.isDefEq] [0.002374] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65529#16)
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                      (BitVec.signExtend 16 x✝ * 65529#16))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65529#16)
                            (BitVec.twoPow 16 7)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16) true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                (congrArg
                  (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) && x))
                  (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)))))))
        (true_and
          ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) &&
                BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)) =
            true))
    [Meta.isDefEq.assign] [0.002370] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65529#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                        (BitVec.signExtend 16 x✝ * 65529#16))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65529#16)
                              (BitVec.twoPow 16 7)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16) true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                  (congrArg
                    (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) && x))
                    (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)))))))
          (true_and
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.002315] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 <
                  BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65529#16)
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                          (BitVec.signExtend 16 x✝ * 65529#16))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65529#16)
                                (BitVec.twoPow 16 7)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16) true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                      !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                    (congrArg
                      (fun x =>
                        !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) && x))
                      (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)))))))
            (true_and
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)) =
                true)) : (True ∧
              (BitVec.signExtend 16 x✝ * 65529#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                BitVec.signExtend 16 x✝ * 65529#16 ≥ BitVec.twoPow 16 7)) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)) =
              true))
        [Meta.isDefEq] [0.002310] ✅️ (True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)) =
                true) =?= (True ∧
                (BitVec.signExtend 16 x✝ * 65529#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 65529#16 ≥ BitVec.twoPow 16 7)) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)) =
                true)
          [Meta.isDefEq] [0.002281] ✅️ True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1)) =?= True ∧
                (BitVec.signExtend 16 x✝ * 65529#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 65529#16 ≥ BitVec.twoPow 16 7)
            [Meta.isDefEq] [0.002267] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1) =?= BitVec.signExtend 16 x✝ * 65529#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 65529#16 ≥ BitVec.twoPow 16 7
              [Meta.isDefEq] [0.002133] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 <
                    BitVec.signExtend (2 * 8)
                      (BitVec.twoPow 8
                        (8 - 1)) =?= BitVec.signExtend 16 x✝ * 65529#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7)
                [Meta.isDefEq] [0.002108] ✅️ instLTBitVec.1
                      (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8)
                      (BitVec.signExtend (2 * 8)
                        (BitVec.twoPow 8
                          (8 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 16 x✝ * 65529#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                  [Meta.isDefEq] [0.002065] ✅️ (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8).toNat <
                        (BitVec.signExtend (2 * 8)
                            (BitVec.twoPow 8
                              (8 -
                                1))).toNat =?= (BitVec.signExtend 16 x✝ * 65529#16).toNat <
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                    [Meta.isDefEq] [0.002046] ✅️ instLTNat.1
                          (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8).toNat
                          (BitVec.signExtend (2 * 8)
                              (BitVec.twoPow 8
                                (8 -
                                  1))).toNat =?= instLTNat.1 (BitVec.signExtend 16 x✝ * 65529#16).toNat
                          (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                      [Meta.isDefEq] [0.002018] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 249#8).toNat.lt
                            (BitVec.signExtend (2 * 8)
                                (BitVec.twoPow 8
                                  (8 -
                                    1))).toNat =?= (BitVec.signExtend 16 x✝ * 65529#16).toNat.lt
                            (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                        [Meta.isDefEq.delta] [0.002002] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 249#8).toNat.lt
                              (BitVec.signExtend (2 * 8)
                                  (BitVec.twoPow 8
                                    (8 -
                                      1))).toNat =?= (BitVec.signExtend 16 x✝ * 65529#16).toNat.lt
                              (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                          [Meta.isDefEq] [0.001880] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 249#8).toNat =?= (BitVec.signExtend 16 x✝ * 65529#16).toNat
                            [Meta.isDefEq.delta] [0.001863] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8)
                                      249#8).toNat =?= (BitVec.signExtend 16 x✝ * 65529#16).toNat
                              [Meta.isDefEq] [0.001848] ✅️ BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 249#8 =?= BitVec.signExtend 16 x✝ * 65529#16
                                [Meta.isDefEq] [0.001825] ✅️ instHMul.1 (BitVec.signExtend (2 * 8) x✝)
                                      (BitVec.signExtend (2 * 8)
                                        249#8) =?= instHMul.1 (BitVec.signExtend 16 x✝) 65529#16
                                  [Meta.isDefEq] [0.001787] ✅️ Mul.mul (BitVec.signExtend (2 * 8) x✝)
                                        (BitVec.signExtend (2 * 8) 249#8) =?= Mul.mul (BitVec.signExtend 16 x✝) 65529#16
                                    [Meta.isDefEq] [0.001765] ✅️ BitVec.instMul.1 (BitVec.signExtend (2 * 8) x✝)
                                          (BitVec.signExtend (2 * 8)
                                            249#8) =?= BitVec.instMul.1 (BitVec.signExtend 16 x✝) 65529#16
                                      [Meta.isDefEq] [0.001732] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                            (BitVec.signExtend (2 * 8) 249#8) =?= (BitVec.signExtend 16 x✝).mul 65529#16
                                        [Meta.isDefEq.delta] [0.001720] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                              (BitVec.signExtend (2 * 8)
                                                249#8) =?= (BitVec.signExtend 16 x✝).mul 65529#16
                                          [Meta.isDefEq] [0.001656] ✅️ BitVec.signExtend (2 * 8) 249#8 =?= 65529#16
                                            [Meta.isDefEq] [0.001629] ✅️ BitVec.ofInt (2 * 8) (249#8).toInt =?= 65529#16
                                              [Meta.isDefEq] [0.001591] ✅️ ((249#8).toInt %
                                                        Int.ofNat (2 ^ (2 * 8))).toNat#'⋯ =?= 65529#16
                                                [Meta.isDefEq] [0.001572] ✅️ ((249#8).toInt %
                                                          Int.ofNat
                                                            (2 ^
                                                              (2 *
                                                                8))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 16) 65529 }
                                                  [Meta.isDefEq] [0.001556] ✅️ {
                                                        toFin :=
                                                          ⟨((249#8).toInt % Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 16) 65529 }
                                                    [Meta.isDefEq] [0.001531] ✅️ ⟨((249#8).toInt %
                                                              Int.ofNat (2 ^ (2 * 8))).toNat,
                                                          ⋯⟩ =?= Fin.ofNat' (2 ^ 16) 65529
                                                      [Meta.isDefEq] [0.001511] ✅️ ⟨((249#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ =?= ⟨65529 % 2 ^ 16, ⋯⟩
                                                        [Meta.isDefEq] [0.001453] ✅️ ((249#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat =?= 65529 % 2 ^ 16
                                                          [Meta.isDefEq] [0.001407] ✅️ match
                                                                (249#8).toInt % Int.ofNat (2 ^ (2 * 8)) with
                                                              | Int.ofNat n => n
                                                              | Int.negSucc a => 0 =?= 65529 % 2 ^ 16
                                                            [Meta.whnf] [0.001140] Non-easy whnf: (fun motive x h_1
                                                                      h_2 =>
                                                                    Int.casesOn x (fun a => h_1 a) fun a => h_2 a)
                                                                  (fun x => ℕ) ((249#8).toInt % Int.ofNat (2 ^ (2 * 8)))
                                                                  h_1 h_2
                                                              [Meta.whnf] [0.001119] Non-easy whnf: (249#8).toInt %
                                                                    Int.ofNat (2 ^ (2 * 8))
                                                                [Meta.whnf] [0.001111] Non-easy whnf: instHMod.1
                                                                      (249#8).toInt (Int.ofNat (2 ^ (2 * 8)))
                                                                  [Meta.whnf] [0.001102] Non-easy whnf: Int.instMod.1
                                                                        (249#8).toInt (Int.ofNat (2 ^ (2 * 8)))
                                                                    [Meta.whnf] [0.001087] Non-easy whnf: match
                                                                          (249#8).toInt, Int.ofNat (2 ^ (2 * 8)) with
                                                                        | Int.ofNat m, n => Int.ofNat (m % n.natAbs)
                                                                        | Int.negSucc m, n =>
                                                                          Int.subNatNat n.natAbs (m % n.natAbs).succ
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)) =
                  true then
              none
            else some (if (!(x✝ * 249#8).getLsbD 7 == (x✝ * 249#8 >ᵤ 21#8)) = true then 1#1 else 0#1)) ⊑
            some (if (!(!x✝.getLsbD 7) == (253#8 >ᵤ x✝)) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:132:8: warning: declaration uses 'sorry'
[bv] [0.040940] Normalizing goal
  [Meta.synthInstance] [0.001259] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else some (BitVec.ofBool (x✝ * 5#8 >ₛ 21#8))) ⊑
          some (BitVec.ofBool (x✝ >ₛ 4#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (x✝ * 5#8 >ₛ 21#8))) ⊑
            some (BitVec.ofBool (x✝ >ₛ 4#8))
      ⊢ False
  [Meta.isDefEq] [0.002017] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7) (BitVec.signExtend 16 x✝ * 5#16))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                            (BitVec.twoPow 16 7)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                (congrArg
                  (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                  (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
        (true_and
          ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
            true))
    [Meta.isDefEq.assign] [0.002015] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                        (BitVec.signExtend 16 x✝ * 5#16))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                              (BitVec.twoPow 16 7)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  (congrArg
                    (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                    (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
          (true_and
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.001986] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                  BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                          (BitVec.signExtend 16 x✝ * 5#16))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                                (BitVec.twoPow 16 7)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                      !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    (congrArg
                      (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                      (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
            (true_and
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true)) : (True ∧
              (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true))
        [Meta.isDefEq] [0.001983] ✅️ (True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true) =?= (True ∧
                (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true)
          [Meta.isDefEq] [0.001963] ✅️ True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1)) =?= True ∧
                (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)
            [Meta.isDefEq] [0.001947] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1) =?= BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7
              [Meta.isDefEq] [0.001836] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8)
                      (BitVec.twoPow 8
                        (8 - 1)) =?= BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7)
                [Meta.isDefEq] [0.001793] ✅️ instLTBitVec.1
                      (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8)
                      (BitVec.signExtend (2 * 8)
                        (BitVec.twoPow 8
                          (8 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 16 x✝ * 5#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                  [Meta.isDefEq] [0.001743] ✅️ (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8).toNat <
                        (BitVec.signExtend (2 * 8)
                            (BitVec.twoPow 8
                              (8 -
                                1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat <
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                    [Meta.isDefEq] [0.001728] ✅️ instLTNat.1
                          (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8).toNat
                          (BitVec.signExtend (2 * 8)
                              (BitVec.twoPow 8
                                (8 -
                                  1))).toNat =?= instLTNat.1 (BitVec.signExtend 16 x✝ * 5#16).toNat
                          (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                      [Meta.isDefEq] [0.001696] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 5#8).toNat.lt
                            (BitVec.signExtend (2 * 8)
                                (BitVec.twoPow 8
                                  (8 -
                                    1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat.lt
                            (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                        [Meta.isDefEq.delta] [0.001684] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8).toNat.lt
                              (BitVec.signExtend (2 * 8)
                                  (BitVec.twoPow 8
                                    (8 -
                                      1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat.lt
                              (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                          [Meta.isDefEq] [0.001587] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 5#8).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat
                            [Meta.isDefEq.delta] [0.001574] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat
                              [Meta.isDefEq] [0.001546] ✅️ BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8 =?= BitVec.signExtend 16 x✝ * 5#16
                                [Meta.isDefEq] [0.001521] ✅️ instHMul.1 (BitVec.signExtend (2 * 8) x✝)
                                      (BitVec.signExtend (2 * 8) 5#8) =?= instHMul.1 (BitVec.signExtend 16 x✝) 5#16
                                  [Meta.isDefEq] [0.001470] ✅️ Mul.mul (BitVec.signExtend (2 * 8) x✝)
                                        (BitVec.signExtend (2 * 8) 5#8) =?= Mul.mul (BitVec.signExtend 16 x✝) 5#16
                                    [Meta.isDefEq] [0.001449] ✅️ BitVec.instMul.1 (BitVec.signExtend (2 * 8) x✝)
                                          (BitVec.signExtend (2 * 8)
                                            5#8) =?= BitVec.instMul.1 (BitVec.signExtend 16 x✝) 5#16
                                      [Meta.isDefEq] [0.001409] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                            (BitVec.signExtend (2 * 8) 5#8) =?= (BitVec.signExtend 16 x✝).mul 5#16
                                        [Meta.isDefEq.delta] [0.001398] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                              (BitVec.signExtend (2 * 8) 5#8) =?= (BitVec.signExtend 16 x✝).mul 5#16
                                          [Meta.isDefEq] [0.001320] ✅️ BitVec.signExtend (2 * 8) 5#8 =?= 5#16
                                            [Meta.isDefEq] [0.001305] ✅️ BitVec.ofInt (2 * 8) (5#8).toInt =?= 5#16
                                              [Meta.isDefEq] [0.001290] ✅️ ((5#8).toInt %
                                                        Int.ofNat (2 ^ (2 * 8))).toNat#'⋯ =?= 5#16
                                                [Meta.isDefEq] [0.001273] ✅️ ((5#8).toInt %
                                                          Int.ofNat
                                                            (2 ^
                                                              (2 * 8))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 16) 5 }
                                                  [Meta.isDefEq] [0.001260] ✅️ {
                                                        toFin :=
                                                          ⟨((5#8).toInt % Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 16) 5 }
                                                    [Meta.isDefEq] [0.001227] ✅️ ⟨((5#8).toInt %
                                                              Int.ofNat (2 ^ (2 * 8))).toNat,
                                                          ⋯⟩ =?= Fin.ofNat' (2 ^ 16) 5
                                                      [Meta.isDefEq] [0.001212] ✅️ ⟨((5#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ =?= ⟨5 % 2 ^ 16, ⋯⟩
                                                        [Meta.isDefEq] [0.001118] ✅️ ((5#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat =?= 5 % 2 ^ 16
                                                          [Meta.isDefEq] [0.001048] ✅️ match
                                                                (5#8).toInt % Int.ofNat (2 ^ (2 * 8)) with
                                                              | Int.ofNat n => n
                                                              | Int.negSucc a => 0 =?= 5 % 2 ^ 16
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                  true then
              none
            else some (if (!(x✝ * 5#8).getLsbD 7 == (x✝ * 5#8 >ᵤ 21#8)) = true then 1#1 else 0#1)) ⊑
            some (if (!x✝.getLsbD 7 == (x✝ >ᵤ 4#8)) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:143:8: warning: declaration uses 'sorry'
[bv] [0.030788] Normalizing goal
  [Meta.synthInstance] [0.001212] ✅️ Decidable
        ((if
              True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
            none
          else some (BitVec.ofBool (x✝ * 7#8 >ᵤ 21#8))) ⊑
          some (BitVec.ofBool (x✝ >ᵤ 3#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else some (BitVec.ofBool (x✝ * 7#8 >ᵤ 21#8))) ⊑
            some (BitVec.ofBool (x✝ >ᵤ 3#8))
      ⊢ False
  [Meta.isDefEq] [0.001546] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1) (BitVec.zeroExtend 16 x✝ * 7#16))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 7#16)
                      (BitVec.twoPow 16 7 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16)))))))
        (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true))
    [Meta.isDefEq.assign] [0.001543] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                  (BitVec.zeroExtend 16 x✝ * 7#16))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 7#16)
                        (BitVec.twoPow 16 7 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16)))))))
          (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001523] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                    (BitVec.zeroExtend 16 x✝ * 7#16))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 7#16)
                          (BitVec.twoPow 16 7 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16)))))))
            (true_and
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) =
                true)) : (True ∧ BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true))
        [Meta.isDefEq] [0.001519] ✅️ (True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) =
                true) =?= (True ∧ BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true)
          [Meta.isDefEq] [0.001494] ✅️ True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1
            [Meta.isDefEq] [0.001472] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1
              [Meta.isDefEq.delta] [0.001448] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1
                [Meta.isDefEq] [0.001012] ✅️ BitVec.zeroExtend (2 * 8) x✝ *
                      BitVec.zeroExtend (2 * 8) 7#8 =?= BitVec.zeroExtend 16 x✝ * 7#16
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true then none
            else some (if (x✝ * 7#8 >ᵤ 21#8) = true then 1#1 else 0#1)) ⊑
            some (if (x✝ >ᵤ 3#8) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:154:8: warning: declaration uses 'sorry'
[bv] [0.054689] Normalizing goal
  [Meta.synthInstance] [0.001738] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else some (BitVec.ofBool (x✝ * 7#8 >ᵤ 21#8))) ⊑
          some (BitVec.ofBool (x✝ >ᵤ 3#8)))
    [Meta.check] [0.001100] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else some (BitVec.ofBool (x✝ * 7#8 >ᵤ 21#8)))
          (some (BitVec.ofBool (x✝ >ᵤ 3#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                      BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
                none
              else some (BitVec.ofBool (x✝ * 7#8 >ᵤ 21#8))) ⊑
            some (BitVec.ofBool (x✝ >ᵤ 3#8))
      ⊢ False
  [Meta.isDefEq] [0.002740] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7) (BitVec.signExtend 16 x✝ * 7#16))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                            (BitVec.twoPow 16 7)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16) true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                (congrArg
                  (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) && x))
                  (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
        (true_and
          ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
            true))
    [Meta.isDefEq.assign] [0.002737] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                        (BitVec.signExtend 16 x✝ * 7#16))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                              (BitVec.twoPow 16 7)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16) true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                  (congrArg
                    (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) && x))
                    (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
          (true_and
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.002711] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                  BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                          (BitVec.signExtend 16 x✝ * 7#16))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                                (BitVec.twoPow 16 7)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16) true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                      !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                    (congrArg
                      (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) && x))
                      (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
            (true_and
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                true)) : (True ∧
              (BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7)) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
              true))
        [Meta.isDefEq] [0.002707] ✅️ (True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                true) =?= (True ∧
                (BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7)) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                true)
          [Meta.isDefEq] [0.002682] ✅️ True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1)) =?= True ∧
                (BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7)
            [Meta.isDefEq] [0.002665] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1) =?= BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7
              [Meta.isDefEq] [0.002441] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8)
                      (BitVec.twoPow 8
                        (8 - 1)) =?= BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7)
                [Meta.isDefEq] [0.002417] ✅️ instLTBitVec.1
                      (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8)
                      (BitVec.signExtend (2 * 8)
                        (BitVec.twoPow 8
                          (8 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 16 x✝ * 7#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                  [Meta.isDefEq] [0.002368] ✅️ (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8).toNat <
                        (BitVec.signExtend (2 * 8)
                            (BitVec.twoPow 8
                              (8 -
                                1))).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat <
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                    [Meta.isDefEq] [0.002354] ✅️ instLTNat.1
                          (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8).toNat
                          (BitVec.signExtend (2 * 8)
                              (BitVec.twoPow 8
                                (8 -
                                  1))).toNat =?= instLTNat.1 (BitVec.signExtend 16 x✝ * 7#16).toNat
                          (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                      [Meta.isDefEq] [0.002320] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 7#8).toNat.lt
                            (BitVec.signExtend (2 * 8)
                                (BitVec.twoPow 8
                                  (8 -
                                    1))).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat.lt
                            (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                        [Meta.isDefEq.delta] [0.002307] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 7#8).toNat.lt
                              (BitVec.signExtend (2 * 8)
                                  (BitVec.twoPow 8
                                    (8 -
                                      1))).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat.lt
                              (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                          [Meta.isDefEq] [0.002144] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 7#8).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat
                            [Meta.isDefEq.delta] [0.002127] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 7#8).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat
                              [Meta.isDefEq] [0.002098] ✅️ BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 7#8 =?= BitVec.signExtend 16 x✝ * 7#16
                                [Meta.isDefEq] [0.002068] ✅️ instHMul.1 (BitVec.signExtend (2 * 8) x✝)
                                      (BitVec.signExtend (2 * 8) 7#8) =?= instHMul.1 (BitVec.signExtend 16 x✝) 7#16
                                  [Meta.isDefEq] [0.002013] ✅️ Mul.mul (BitVec.signExtend (2 * 8) x✝)
                                        (BitVec.signExtend (2 * 8) 7#8) =?= Mul.mul (BitVec.signExtend 16 x✝) 7#16
                                    [Meta.isDefEq] [0.001990] ✅️ BitVec.instMul.1 (BitVec.signExtend (2 * 8) x✝)
                                          (BitVec.signExtend (2 * 8)
                                            7#8) =?= BitVec.instMul.1 (BitVec.signExtend 16 x✝) 7#16
                                      [Meta.isDefEq] [0.001946] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                            (BitVec.signExtend (2 * 8) 7#8) =?= (BitVec.signExtend 16 x✝).mul 7#16
                                        [Meta.isDefEq.delta] [0.001935] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                              (BitVec.signExtend (2 * 8) 7#8) =?= (BitVec.signExtend 16 x✝).mul 7#16
                                          [Meta.isDefEq] [0.001841] ✅️ BitVec.signExtend (2 * 8) 7#8 =?= 7#16
                                            [Meta.isDefEq] [0.001816] ✅️ BitVec.ofInt (2 * 8) (7#8).toInt =?= 7#16
                                              [Meta.isDefEq] [0.001795] ✅️ ((7#8).toInt %
                                                        Int.ofNat (2 ^ (2 * 8))).toNat#'⋯ =?= 7#16
                                                [Meta.isDefEq] [0.001770] ✅️ ((7#8).toInt %
                                                          Int.ofNat
                                                            (2 ^
                                                              (2 * 8))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 16) 7 }
                                                  [Meta.isDefEq] [0.001752] ✅️ {
                                                        toFin :=
                                                          ⟨((7#8).toInt % Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 16) 7 }
                                                    [Meta.isDefEq] [0.001705] ✅️ ⟨((7#8).toInt %
                                                              Int.ofNat (2 ^ (2 * 8))).toNat,
                                                          ⋯⟩ =?= Fin.ofNat' (2 ^ 16) 7
                                                      [Meta.isDefEq] [0.001685] ✅️ ⟨((7#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ =?= ⟨7 % 2 ^ 16, ⋯⟩
                                                        [Meta.isDefEq] [0.001542] ✅️ ((7#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat =?= 7 % 2 ^ 16
                                                          [Meta.isDefEq] [0.001439] ✅️ match
                                                                (7#8).toInt % Int.ofNat (2 ^ (2 * 8)) with
                                                              | Int.ofNat n => n
                                                              | Int.negSucc a => 0 =?= 7 % 2 ^ 16
  [Meta.isDefEq] [0.001068] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1) (BitVec.zeroExtend 16 x✝ * 7#16))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 7#16)
                      (BitVec.twoPow 16 7 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16)))))))
        (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true))
    [Meta.isDefEq.assign] [0.001065] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                  (BitVec.zeroExtend 16 x✝ * 7#16))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 7#16)
                        (BitVec.twoPow 16 7 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16)))))))
          (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001046] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                    (BitVec.zeroExtend 16 x✝ * 7#16))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 7#16)
                          (BitVec.twoPow 16 7 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16)))))))
            (true_and
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) =
                true)) : (True ∧ BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true))
        [Meta.isDefEq] [0.001042] ✅️ (True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) =
                true) =?= (True ∧ BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true)
          [Meta.isDefEq] [0.001019] ✅️ True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1
            [Meta.isDefEq] [0.001004] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                  true then
              none
            else
              if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true then none
              else some (if (x✝ * 7#8 >ᵤ 21#8) = true then 1#1 else 0#1)) ⊑
            some (if (x✝ >ᵤ 3#8) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:165:8: warning: declaration uses 'sorry'
[bv] [0.046726] Normalizing goal
  [Meta.synthInstance] [0.001902] ✅️ Decidable
        ((if
              True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
            none
          else some (BitVec.ofBool (x✝ * 5#8 >ᵤ 21#8))) ⊑
          some (BitVec.ofBool (x✝ >ᵤ 4#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else some (BitVec.ofBool (x✝ * 5#8 >ᵤ 21#8))) ⊑
            some (BitVec.ofBool (x✝ >ᵤ 4#8))
      ⊢ False
  [Meta.isDefEq] [0.002254] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1) (BitVec.zeroExtend 16 x✝ * 5#16))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                      (BitVec.twoPow 16 7 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
        (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
    [Meta.isDefEq.assign] [0.002250] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                  (BitVec.zeroExtend 16 x✝ * 5#16))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                        (BitVec.twoPow 16 7 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
          (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
      [Meta.isDefEq.assign.checkTypes] [0.002230] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                    (BitVec.zeroExtend 16 x✝ * 5#16))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                          (BitVec.twoPow 16 7 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
            (true_and
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
                true)) : (True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
        [Meta.isDefEq] [0.002225] ✅️ (True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
                true) =?= (True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true)
          [Meta.isDefEq] [0.002194] ✅️ True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1
            [Meta.isDefEq] [0.002170] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1
              [Meta.isDefEq.delta] [0.002141] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1
                [Meta.isDefEq] [0.001467] ✅️ BitVec.zeroExtend (2 * 8) x✝ *
                      BitVec.zeroExtend (2 * 8) 5#8 =?= BitVec.zeroExtend 16 x✝ * 5#16
                  [Meta.isDefEq] [0.001427] ✅️ instHMul.1 (BitVec.zeroExtend (2 * 8) x✝)
                        (BitVec.zeroExtend (2 * 8) 5#8) =?= instHMul.1 (BitVec.zeroExtend 16 x✝) 5#16
                    [Meta.isDefEq] [0.001322] ✅️ Mul.mul (BitVec.zeroExtend (2 * 8) x✝)
                          (BitVec.zeroExtend (2 * 8) 5#8) =?= Mul.mul (BitVec.zeroExtend 16 x✝) 5#16
                      [Meta.isDefEq] [0.001288] ✅️ BitVec.instMul.1 (BitVec.zeroExtend (2 * 8) x✝)
                            (BitVec.zeroExtend (2 * 8) 5#8) =?= BitVec.instMul.1 (BitVec.zeroExtend 16 x✝) 5#16
                        [Meta.isDefEq] [0.001230] ✅️ (BitVec.zeroExtend (2 * 8) x✝).mul
                              (BitVec.zeroExtend (2 * 8) 5#8) =?= (BitVec.zeroExtend 16 x✝).mul 5#16
                          [Meta.isDefEq.delta] [0.001213] ✅️ (BitVec.zeroExtend (2 * 8) x✝).mul
                                (BitVec.zeroExtend (2 * 8) 5#8) =?= (BitVec.zeroExtend 16 x✝).mul 5#16
                            [Meta.isDefEq] [0.001074] ✅️ BitVec.zeroExtend (2 * 8) 5#8 =?= 5#16
                              [Meta.isDefEq] [0.001054] ✅️ BitVec.setWidth (2 * 8) 5#8 =?= 5#16
                                [Meta.isDefEq] [0.001023] ✅️ if h : 8 ≤ 2 * 8 then BitVec.setWidth' h 5#8
                                    else BitVec.ofNat (2 * 8) (5#8).toNat =?= 5#16
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true then none
            else some (if (x✝ * 5#8 >ᵤ 21#8) = true then 1#1 else 0#1)) ⊑
            some (if (x✝ >ᵤ 4#8) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:176:8: warning: declaration uses 'sorry'
[bv] [0.045054] Normalizing goal
  [Meta.synthInstance] [0.001416] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else some (BitVec.ofBool (x✝ * 5#8 >ᵤ 21#8))) ⊑
          some (BitVec.ofBool (x✝ >ᵤ 4#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                      BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
                none
              else some (BitVec.ofBool (x✝ * 5#8 >ᵤ 21#8))) ⊑
            some (BitVec.ofBool (x✝ >ᵤ 4#8))
      ⊢ False
  [Meta.isDefEq] [0.002072] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7) (BitVec.signExtend 16 x✝ * 5#16))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                            (BitVec.twoPow 16 7)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                (congrArg
                  (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                  (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
        (true_and
          ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
            true))
    [Meta.isDefEq.assign] [0.002070] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                        (BitVec.signExtend 16 x✝ * 5#16))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                              (BitVec.twoPow 16 7)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  (congrArg
                    (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                    (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
          (true_and
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.002048] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                  BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                          (BitVec.signExtend 16 x✝ * 5#16))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                                (BitVec.twoPow 16 7)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                      !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    (congrArg
                      (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                      (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
            (true_and
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true)) : (True ∧
              (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true))
        [Meta.isDefEq] [0.002045] ✅️ (True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true) =?= (True ∧
                (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true)
          [Meta.isDefEq] [0.002026] ✅️ True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1)) =?= True ∧
                (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)
            [Meta.isDefEq] [0.002011] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1) =?= BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7
              [Meta.isDefEq] [0.001900] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8)
                      (BitVec.twoPow 8
                        (8 - 1)) =?= BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7)
                [Meta.isDefEq] [0.001879] ✅️ instLTBitVec.1
                      (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8)
                      (BitVec.signExtend (2 * 8)
                        (BitVec.twoPow 8
                          (8 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 16 x✝ * 5#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                  [Meta.isDefEq] [0.001813] ✅️ (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8).toNat <
                        (BitVec.signExtend (2 * 8)
                            (BitVec.twoPow 8
                              (8 -
                                1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat <
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                    [Meta.isDefEq] [0.001792] ✅️ instLTNat.1
                          (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8).toNat
                          (BitVec.signExtend (2 * 8)
                              (BitVec.twoPow 8
                                (8 -
                                  1))).toNat =?= instLTNat.1 (BitVec.signExtend 16 x✝ * 5#16).toNat
                          (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                      [Meta.isDefEq] [0.001751] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 5#8).toNat.lt
                            (BitVec.signExtend (2 * 8)
                                (BitVec.twoPow 8
                                  (8 -
                                    1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat.lt
                            (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                        [Meta.isDefEq.delta] [0.001740] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8).toNat.lt
                              (BitVec.signExtend (2 * 8)
                                  (BitVec.twoPow 8
                                    (8 -
                                      1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat.lt
                              (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                          [Meta.isDefEq] [0.001640] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 5#8).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat
                            [Meta.isDefEq.delta] [0.001627] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat
                              [Meta.isDefEq] [0.001609] ✅️ BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8 =?= BitVec.signExtend 16 x✝ * 5#16
                                [Meta.isDefEq] [0.001583] ✅️ instHMul.1 (BitVec.signExtend (2 * 8) x✝)
                                      (BitVec.signExtend (2 * 8) 5#8) =?= instHMul.1 (BitVec.signExtend 16 x✝) 5#16
                                  [Meta.isDefEq] [0.001533] ✅️ Mul.mul (BitVec.signExtend (2 * 8) x✝)
                                        (BitVec.signExtend (2 * 8) 5#8) =?= Mul.mul (BitVec.signExtend 16 x✝) 5#16
                                    [Meta.isDefEq] [0.001513] ✅️ BitVec.instMul.1 (BitVec.signExtend (2 * 8) x✝)
                                          (BitVec.signExtend (2 * 8)
                                            5#8) =?= BitVec.instMul.1 (BitVec.signExtend 16 x✝) 5#16
                                      [Meta.isDefEq] [0.001472] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                            (BitVec.signExtend (2 * 8) 5#8) =?= (BitVec.signExtend 16 x✝).mul 5#16
                                        [Meta.isDefEq.delta] [0.001461] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                              (BitVec.signExtend (2 * 8) 5#8) =?= (BitVec.signExtend 16 x✝).mul 5#16
                                          [Meta.isDefEq] [0.001390] ✅️ BitVec.signExtend (2 * 8) 5#8 =?= 5#16
                                            [Meta.isDefEq] [0.001374] ✅️ BitVec.ofInt (2 * 8) (5#8).toInt =?= 5#16
                                              [Meta.isDefEq] [0.001358] ✅️ ((5#8).toInt %
                                                        Int.ofNat (2 ^ (2 * 8))).toNat#'⋯ =?= 5#16
                                                [Meta.isDefEq] [0.001340] ✅️ ((5#8).toInt %
                                                          Int.ofNat
                                                            (2 ^
                                                              (2 * 8))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 16) 5 }
                                                  [Meta.isDefEq] [0.001324] ✅️ {
                                                        toFin :=
                                                          ⟨((5#8).toInt % Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 16) 5 }
                                                    [Meta.isDefEq] [0.001289] ✅️ ⟨((5#8).toInt %
                                                              Int.ofNat (2 ^ (2 * 8))).toNat,
                                                          ⋯⟩ =?= Fin.ofNat' (2 ^ 16) 5
                                                      [Meta.isDefEq] [0.001240] ✅️ ⟨((5#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ =?= ⟨5 % 2 ^ 16, ⋯⟩
                                                        [Meta.isDefEq] [0.001144] ✅️ ((5#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat =?= 5 % 2 ^ 16
                                                          [Meta.isDefEq] [0.001046] ✅️ match
                                                                (5#8).toInt % Int.ofNat (2 ^ (2 * 8)) with
                                                              | Int.ofNat n => n
                                                              | Int.negSucc a => 0 =?= 5 % 2 ^ 16
  [Meta.isDefEq] [0.001050] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1) (BitVec.zeroExtend 16 x✝ * 5#16))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                      (BitVec.twoPow 16 7 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
        (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
    [Meta.isDefEq.assign] [0.001048] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                  (BitVec.zeroExtend 16 x✝ * 5#16))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                        (BitVec.twoPow 16 7 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
          (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001033] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                    (BitVec.zeroExtend 16 x✝ * 5#16))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                          (BitVec.twoPow 16 7 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
            (true_and
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
                true)) : (True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
        [Meta.isDefEq] [0.001029] ✅️ (True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
                true) =?= (True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true)
          [Meta.isDefEq] [0.001008] ✅️ True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                  true then
              none
            else
              if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true then none
              else some (if (x✝ * 5#8 >ᵤ 21#8) = true then 1#1 else 0#1)) ⊑
            some (if (x✝ >ᵤ 4#8) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.isDefEq] [0.001941] ❌️ ?a = ?a =?= (x✝ * 5#8 >ᵤ 21#8) = true
    [Meta.isDefEq] [0.001852] ✅️ ?α =?= Bool
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:187:8: warning: declaration uses 'sorry'
[bv] [0.033487] Normalizing goal
  [Meta.synthInstance] [0.001284] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 251#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 251#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else some (BitVec.ofBool (x✝ * 251#8 == 20#8))) ⊑
          some (BitVec.ofBool (x✝ == 252#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 251#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 251#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (x✝ * 251#8 == 20#8))) ⊑
            some (BitVec.ofBool (x✝ == 252#8))
      ⊢ False
  [Meta.isDefEq] [0.001944] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65531#16)
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                      (BitVec.signExtend 16 x✝ * 65531#16))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65531#16)
                            (BitVec.twoPow 16 7)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16) true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65531#16)
                !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65531#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16)
                (congrArg
                  (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65531#16) && x))
                  (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16)))))))
        (true_and
          ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65531#16) &&
                BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16)) =
            true))
    [Meta.isDefEq.assign] [0.001942] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65531#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                        (BitVec.signExtend 16 x✝ * 65531#16))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65531#16)
                              (BitVec.twoPow 16 7)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16) true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65531#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65531#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16)
                  (congrArg
                    (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65531#16) && x))
                    (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16)))))))
          (true_and
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65531#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.001916] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 251#8 <
                  BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 251#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65531#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65531#16)
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                          (BitVec.signExtend 16 x✝ * 65531#16))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65531#16)
                                (BitVec.twoPow 16 7)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16) true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65531#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65531#16)
                      !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16)
                    (congrArg
                      (fun x =>
                        !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65531#16) && x))
                      (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16)))))))
            (true_and
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65531#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16)) =
                true)) : (True ∧
              (BitVec.signExtend 16 x✝ * 65531#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                BitVec.signExtend 16 x✝ * 65531#16 ≥ BitVec.twoPow 16 7)) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65531#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16)) =
              true))
        [Meta.isDefEq] [0.001914] ✅️ (True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 251#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 251#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65531#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16)) =
                true) =?= (True ∧
                (BitVec.signExtend 16 x✝ * 65531#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 65531#16 ≥ BitVec.twoPow 16 7)) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65531#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16)) =
                true)
          [Meta.isDefEq] [0.001894] ✅️ True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 251#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 251#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1)) =?= True ∧
                (BitVec.signExtend 16 x✝ * 65531#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 65531#16 ≥ BitVec.twoPow 16 7)
            [Meta.isDefEq] [0.001884] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 251#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 251#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1) =?= BitVec.signExtend 16 x✝ * 65531#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 65531#16 ≥ BitVec.twoPow 16 7
              [Meta.isDefEq] [0.001789] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 251#8 <
                    BitVec.signExtend (2 * 8)
                      (BitVec.twoPow 8
                        (8 - 1)) =?= BitVec.signExtend 16 x✝ * 65531#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7)
                [Meta.isDefEq] [0.001769] ✅️ instLTBitVec.1
                      (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 251#8)
                      (BitVec.signExtend (2 * 8)
                        (BitVec.twoPow 8
                          (8 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 16 x✝ * 65531#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                  [Meta.isDefEq] [0.001734] ✅️ (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 251#8).toNat <
                        (BitVec.signExtend (2 * 8)
                            (BitVec.twoPow 8
                              (8 -
                                1))).toNat =?= (BitVec.signExtend 16 x✝ * 65531#16).toNat <
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                    [Meta.isDefEq] [0.001721] ✅️ instLTNat.1
                          (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 251#8).toNat
                          (BitVec.signExtend (2 * 8)
                              (BitVec.twoPow 8
                                (8 -
                                  1))).toNat =?= instLTNat.1 (BitVec.signExtend 16 x✝ * 65531#16).toNat
                          (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                      [Meta.isDefEq] [0.001692] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 251#8).toNat.lt
                            (BitVec.signExtend (2 * 8)
                                (BitVec.twoPow 8
                                  (8 -
                                    1))).toNat =?= (BitVec.signExtend 16 x✝ * 65531#16).toNat.lt
                            (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                        [Meta.isDefEq.delta] [0.001681] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 251#8).toNat.lt
                              (BitVec.signExtend (2 * 8)
                                  (BitVec.twoPow 8
                                    (8 -
                                      1))).toNat =?= (BitVec.signExtend 16 x✝ * 65531#16).toNat.lt
                              (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                          [Meta.isDefEq] [0.001590] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 251#8).toNat =?= (BitVec.signExtend 16 x✝ * 65531#16).toNat
                            [Meta.isDefEq.delta] [0.001577] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8)
                                      251#8).toNat =?= (BitVec.signExtend 16 x✝ * 65531#16).toNat
                              [Meta.isDefEq] [0.001566] ✅️ BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 251#8 =?= BitVec.signExtend 16 x✝ * 65531#16
                                [Meta.isDefEq] [0.001548] ✅️ instHMul.1 (BitVec.signExtend (2 * 8) x✝)
                                      (BitVec.signExtend (2 * 8)
                                        251#8) =?= instHMul.1 (BitVec.signExtend 16 x✝) 65531#16
                                  [Meta.isDefEq] [0.001518] ✅️ Mul.mul (BitVec.signExtend (2 * 8) x✝)
                                        (BitVec.signExtend (2 * 8) 251#8) =?= Mul.mul (BitVec.signExtend 16 x✝) 65531#16
                                    [Meta.isDefEq] [0.001503] ✅️ BitVec.instMul.1 (BitVec.signExtend (2 * 8) x✝)
                                          (BitVec.signExtend (2 * 8)
                                            251#8) =?= BitVec.instMul.1 (BitVec.signExtend 16 x✝) 65531#16
                                      [Meta.isDefEq] [0.001471] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                            (BitVec.signExtend (2 * 8) 251#8) =?= (BitVec.signExtend 16 x✝).mul 65531#16
                                        [Meta.isDefEq.delta] [0.001461] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                              (BitVec.signExtend (2 * 8)
                                                251#8) =?= (BitVec.signExtend 16 x✝).mul 65531#16
                                          [Meta.isDefEq] [0.001412] ✅️ BitVec.signExtend (2 * 8) 251#8 =?= 65531#16
                                            [Meta.isDefEq] [0.001395] ✅️ BitVec.ofInt (2 * 8) (251#8).toInt =?= 65531#16
                                              [Meta.isDefEq] [0.001382] ✅️ ((251#8).toInt %
                                                        Int.ofNat (2 ^ (2 * 8))).toNat#'⋯ =?= 65531#16
                                                [Meta.isDefEq] [0.001365] ✅️ ((251#8).toInt %
                                                          Int.ofNat
                                                            (2 ^
                                                              (2 *
                                                                8))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 16) 65531 }
                                                  [Meta.isDefEq] [0.001352] ✅️ {
                                                        toFin :=
                                                          ⟨((251#8).toInt % Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 16) 65531 }
                                                    [Meta.isDefEq] [0.001334] ✅️ ⟨((251#8).toInt %
                                                              Int.ofNat (2 ^ (2 * 8))).toNat,
                                                          ⋯⟩ =?= Fin.ofNat' (2 ^ 16) 65531
                                                      [Meta.isDefEq] [0.001315] ✅️ ⟨((251#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ =?= ⟨65531 % 2 ^ 16, ⋯⟩
                                                        [Meta.isDefEq] [0.001267] ✅️ ((251#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat =?= 65531 % 2 ^ 16
                                                          [Meta.isDefEq] [0.001224] ✅️ match
                                                                (251#8).toInt % Int.ofNat (2 ^ (2 * 8)) with
                                                              | Int.ofNat n => n
                                                              | Int.negSucc a => 0 =?= 65531 % 2 ^ 16
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65531#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16)) =
                  true then
              none
            else some (if (x✝ * 251#8 == 20#8) = true then 1#1 else 0#1)) ⊑
            some (if (x✝ == 252#8) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:198:8: warning: declaration uses 'sorry'
[bv] [0.046393] Normalizing goal
  [Meta.synthInstance] [0.002026] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else some (BitVec.ofBool (x✝ * 5#8 == 245#8))) ⊑
          some 0#1)
    [Meta.check] [0.001038] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else some (BitVec.ofBool (x✝ * 5#8 == 245#8)))
          (some 0#1)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (x✝ * 5#8 == 245#8))) ⊑
            some 0#1
      ⊢ False
  [Meta.isDefEq] [0.002744] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7) (BitVec.signExtend 16 x✝ * 5#16))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                            (BitVec.twoPow 16 7)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                (congrArg
                  (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                  (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
        (true_and
          ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
            true))
    [Meta.isDefEq.assign] [0.002739] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                        (BitVec.signExtend 16 x✝ * 5#16))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                              (BitVec.twoPow 16 7)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  (congrArg
                    (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                    (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
          (true_and
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.002702] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                  BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                          (BitVec.signExtend 16 x✝ * 5#16))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                                (BitVec.twoPow 16 7)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                      !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    (congrArg
                      (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                      (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
            (true_and
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true)) : (True ∧
              (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true))
        [Meta.isDefEq] [0.002697] ✅️ (True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true) =?= (True ∧
                (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true)
          [Meta.isDefEq] [0.002661] ✅️ True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1)) =?= True ∧
                (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)
            [Meta.isDefEq] [0.002633] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1) =?= BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7
              [Meta.isDefEq] [0.002404] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8)
                      (BitVec.twoPow 8
                        (8 - 1)) =?= BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7)
                [Meta.isDefEq] [0.002373] ✅️ instLTBitVec.1
                      (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8)
                      (BitVec.signExtend (2 * 8)
                        (BitVec.twoPow 8
                          (8 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 16 x✝ * 5#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                  [Meta.isDefEq] [0.002292] ✅️ (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8).toNat <
                        (BitVec.signExtend (2 * 8)
                            (BitVec.twoPow 8
                              (8 -
                                1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat <
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                    [Meta.isDefEq] [0.002266] ✅️ instLTNat.1
                          (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8).toNat
                          (BitVec.signExtend (2 * 8)
                              (BitVec.twoPow 8
                                (8 -
                                  1))).toNat =?= instLTNat.1 (BitVec.signExtend 16 x✝ * 5#16).toNat
                          (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                      [Meta.isDefEq] [0.002215] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 5#8).toNat.lt
                            (BitVec.signExtend (2 * 8)
                                (BitVec.twoPow 8
                                  (8 -
                                    1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat.lt
                            (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                        [Meta.isDefEq.delta] [0.002194] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8).toNat.lt
                              (BitVec.signExtend (2 * 8)
                                  (BitVec.twoPow 8
                                    (8 -
                                      1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat.lt
                              (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                          [Meta.isDefEq] [0.002017] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 5#8).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat
                            [Meta.isDefEq.delta] [0.001993] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat
                              [Meta.isDefEq] [0.001959] ✅️ BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8 =?= BitVec.signExtend 16 x✝ * 5#16
                                [Meta.isDefEq] [0.001917] ✅️ instHMul.1 (BitVec.signExtend (2 * 8) x✝)
                                      (BitVec.signExtend (2 * 8) 5#8) =?= instHMul.1 (BitVec.signExtend 16 x✝) 5#16
                                  [Meta.isDefEq] [0.001809] ✅️ Mul.mul (BitVec.signExtend (2 * 8) x✝)
                                        (BitVec.signExtend (2 * 8) 5#8) =?= Mul.mul (BitVec.signExtend 16 x✝) 5#16
                                    [Meta.isDefEq] [0.001768] ✅️ BitVec.instMul.1 (BitVec.signExtend (2 * 8) x✝)
                                          (BitVec.signExtend (2 * 8)
                                            5#8) =?= BitVec.instMul.1 (BitVec.signExtend 16 x✝) 5#16
                                      [Meta.isDefEq] [0.001697] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                            (BitVec.signExtend (2 * 8) 5#8) =?= (BitVec.signExtend 16 x✝).mul 5#16
                                        [Meta.isDefEq.delta] [0.001677] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                              (BitVec.signExtend (2 * 8) 5#8) =?= (BitVec.signExtend 16 x✝).mul 5#16
                                          [Meta.isDefEq] [0.001546] ✅️ BitVec.signExtend (2 * 8) 5#8 =?= 5#16
                                            [Meta.isDefEq] [0.001517] ✅️ BitVec.ofInt (2 * 8) (5#8).toInt =?= 5#16
                                              [Meta.isDefEq] [0.001495] ✅️ ((5#8).toInt %
                                                        Int.ofNat (2 ^ (2 * 8))).toNat#'⋯ =?= 5#16
                                                [Meta.isDefEq] [0.001468] ✅️ ((5#8).toInt %
                                                          Int.ofNat
                                                            (2 ^
                                                              (2 * 8))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 16) 5 }
                                                  [Meta.isDefEq] [0.001447] ✅️ {
                                                        toFin :=
                                                          ⟨((5#8).toInt % Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 16) 5 }
                                                    [Meta.isDefEq] [0.001414] ✅️ ⟨((5#8).toInt %
                                                              Int.ofNat (2 ^ (2 * 8))).toNat,
                                                          ⋯⟩ =?= Fin.ofNat' (2 ^ 16) 5
                                                      [Meta.isDefEq] [0.001389] ✅️ ⟨((5#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ =?= ⟨5 % 2 ^ 16, ⋯⟩
                                                        [Meta.isDefEq] [0.001314] ✅️ ((5#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat =?= 5 % 2 ^ 16
                                                          [Meta.isDefEq] [0.001254] ✅️ match
                                                                (5#8).toInt % Int.ofNat (2 ^ (2 * 8)) with
                                                              | Int.ofNat n => n
                                                              | Int.negSucc a => 0 =?= 5 % 2 ^ 16
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                  true then
              none
            else some (if (x✝ * 5#8 == 245#8) = true then 1#1 else 0#1)) ⊑
            some 0#1
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:208:8: warning: declaration uses 'sorry'
[bv] [0.048346] Normalizing goal
  [Meta.synthInstance] [0.001971] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else some (BitVec.ofBool (x✝ * 5#8 != 130#8))) ⊑
          some 1#1)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (x✝ * 5#8 != 130#8))) ⊑
            some 1#1
      ⊢ False
  [Meta.isDefEq] [0.002808] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7) (BitVec.signExtend 16 x✝ * 5#16))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                            (BitVec.twoPow 16 7)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                (congrArg
                  (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                  (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
        (true_and
          ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
            true))
    [Meta.isDefEq.assign] [0.002803] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                        (BitVec.signExtend 16 x✝ * 5#16))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                              (BitVec.twoPow 16 7)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  (congrArg
                    (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                    (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
          (true_and
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.002764] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                  BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                          (BitVec.signExtend 16 x✝ * 5#16))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                                (BitVec.twoPow 16 7)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                      !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    (congrArg
                      (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                      (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
            (true_and
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true)) : (True ∧
              (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true))
        [Meta.isDefEq] [0.002758] ✅️ (True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true) =?= (True ∧
                (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true)
          [Meta.isDefEq] [0.002721] ✅️ True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1)) =?= True ∧
                (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)
            [Meta.isDefEq] [0.002694] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1) =?= BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7
              [Meta.isDefEq] [0.002483] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8)
                      (BitVec.twoPow 8
                        (8 - 1)) =?= BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7)
                [Meta.isDefEq] [0.002453] ✅️ instLTBitVec.1
                      (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8)
                      (BitVec.signExtend (2 * 8)
                        (BitVec.twoPow 8
                          (8 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 16 x✝ * 5#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                  [Meta.isDefEq] [0.002363] ✅️ (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8).toNat <
                        (BitVec.signExtend (2 * 8)
                            (BitVec.twoPow 8
                              (8 -
                                1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat <
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                    [Meta.isDefEq] [0.002337] ✅️ instLTNat.1
                          (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8).toNat
                          (BitVec.signExtend (2 * 8)
                              (BitVec.twoPow 8
                                (8 -
                                  1))).toNat =?= instLTNat.1 (BitVec.signExtend 16 x✝ * 5#16).toNat
                          (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                      [Meta.isDefEq] [0.002286] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 5#8).toNat.lt
                            (BitVec.signExtend (2 * 8)
                                (BitVec.twoPow 8
                                  (8 -
                                    1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat.lt
                            (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                        [Meta.isDefEq.delta] [0.002264] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8).toNat.lt
                              (BitVec.signExtend (2 * 8)
                                  (BitVec.twoPow 8
                                    (8 -
                                      1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat.lt
                              (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                          [Meta.isDefEq] [0.002095] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 5#8).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat
                            [Meta.isDefEq.delta] [0.002069] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat
                              [Meta.isDefEq] [0.002032] ✅️ BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8 =?= BitVec.signExtend 16 x✝ * 5#16
                                [Meta.isDefEq] [0.001987] ✅️ instHMul.1 (BitVec.signExtend (2 * 8) x✝)
                                      (BitVec.signExtend (2 * 8) 5#8) =?= instHMul.1 (BitVec.signExtend 16 x✝) 5#16
                                  [Meta.isDefEq] [0.001894] ✅️ Mul.mul (BitVec.signExtend (2 * 8) x✝)
                                        (BitVec.signExtend (2 * 8) 5#8) =?= Mul.mul (BitVec.signExtend 16 x✝) 5#16
                                    [Meta.isDefEq] [0.001849] ✅️ BitVec.instMul.1 (BitVec.signExtend (2 * 8) x✝)
                                          (BitVec.signExtend (2 * 8)
                                            5#8) =?= BitVec.instMul.1 (BitVec.signExtend 16 x✝) 5#16
                                      [Meta.isDefEq] [0.001759] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                            (BitVec.signExtend (2 * 8) 5#8) =?= (BitVec.signExtend 16 x✝).mul 5#16
                                        [Meta.isDefEq.delta] [0.001739] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                              (BitVec.signExtend (2 * 8) 5#8) =?= (BitVec.signExtend 16 x✝).mul 5#16
                                          [Meta.isDefEq] [0.001607] ✅️ BitVec.signExtend (2 * 8) 5#8 =?= 5#16
                                            [Meta.isDefEq] [0.001579] ✅️ BitVec.ofInt (2 * 8) (5#8).toInt =?= 5#16
                                              [Meta.isDefEq] [0.001556] ✅️ ((5#8).toInt %
                                                        Int.ofNat (2 ^ (2 * 8))).toNat#'⋯ =?= 5#16
                                                [Meta.isDefEq] [0.001527] ✅️ ((5#8).toInt %
                                                          Int.ofNat
                                                            (2 ^
                                                              (2 * 8))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 16) 5 }
                                                  [Meta.isDefEq] [0.001505] ✅️ {
                                                        toFin :=
                                                          ⟨((5#8).toInt % Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 16) 5 }
                                                    [Meta.isDefEq] [0.001447] ✅️ ⟨((5#8).toInt %
                                                              Int.ofNat (2 ^ (2 * 8))).toNat,
                                                          ⋯⟩ =?= Fin.ofNat' (2 ^ 16) 5
                                                      [Meta.isDefEq] [0.001421] ✅️ ⟨((5#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ =?= ⟨5 % 2 ^ 16, ⋯⟩
                                                        [Meta.isDefEq] [0.001341] ✅️ ((5#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat =?= 5 % 2 ^ 16
                                                          [Meta.isDefEq] [0.001269] ✅️ match
                                                                (5#8).toInt % Int.ofNat (2 ^ (2 * 8)) with
                                                              | Int.ofNat n => n
                                                              | Int.negSucc a => 0 =?= 5 % 2 ^ 16
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                  true then
              none
            else some (if (!x✝ * 5#8 == 130#8) = true then 1#1 else 0#1)) ⊑
            some 1#1
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:218:8: warning: declaration uses 'sorry'
[bv] [0.034342] Normalizing goal
  [Meta.synthInstance] [0.001185] ✅️ Decidable
        ((if
              True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
            none
          else some (BitVec.ofBool (x✝ * 5#8 != 130#8))) ⊑
          some (BitVec.ofBool (x✝ != 26#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else some (BitVec.ofBool (x✝ * 5#8 != 130#8))) ⊑
            some (BitVec.ofBool (x✝ != 26#8))
      ⊢ False
  [Meta.isDefEq] [0.001295] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1) (BitVec.zeroExtend 16 x✝ * 5#16))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                      (BitVec.twoPow 16 7 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
        (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
    [Meta.isDefEq.assign] [0.001292] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                  (BitVec.zeroExtend 16 x✝ * 5#16))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                        (BitVec.twoPow 16 7 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
          (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001278] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                    (BitVec.zeroExtend 16 x✝ * 5#16))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                          (BitVec.twoPow 16 7 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
            (true_and
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
                true)) : (True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
        [Meta.isDefEq] [0.001275] ✅️ (True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
                true) =?= (True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true)
          [Meta.isDefEq] [0.001256] ✅️ True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1
            [Meta.isDefEq] [0.001241] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1
              [Meta.isDefEq.delta] [0.001221] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true then none
            else some (if (!x✝ * 5#8 == 130#8) = true then 1#1 else 0#1)) ⊑
            some (if (!x✝ == 26#8) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.appBuilder] [0.002152] ✅️ f: Subsingleton.elim, xs: [h✝, h]
    [Meta.synthInstance] [0.002079] ✅️ Subsingleton (Decidable c✝)
      [Meta.synthInstance] [0.002023] ✅️ apply instSubsingletonDecidable to Subsingleton (Decidable c✝)
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:229:8: warning: declaration uses 'sorry'
[bv] [0.030325] Normalizing goal
  [Meta.synthInstance] [0.001156] ✅️ Decidable
        ((if
              True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 251#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
            none
          else some (BitVec.ofBool (x✝ * 251#8 == 20#8))) ⊑
          some 0#1)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 251#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else some (BitVec.ofBool (x✝ * 251#8 == 20#8))) ⊑
            some 0#1
      ⊢ False
  [Meta.isDefEq] [0.001189] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                (BitVec.zeroExtend 16 x✝ * 251#16))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 251#16)
                      (BitVec.twoPow 16 7 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 251#16) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 251#16)))))))
        (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 251#16) = true))
    [Meta.isDefEq.assign] [0.001187] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                  (BitVec.zeroExtend 16 x✝ * 251#16))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 251#16)
                        (BitVec.twoPow 16 7 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 251#16) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 251#16)))))))
          (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 251#16) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001174] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 251#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 251#16) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                    (BitVec.zeroExtend 16 x✝ * 251#16))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 251#16)
                          (BitVec.twoPow 16 7 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 251#16) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 251#16)))))))
            (true_and
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 251#16) =
                true)) : (True ∧ BitVec.zeroExtend 16 x✝ * 251#16 ≥ BitVec.twoPow 16 7 <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 251#16) = true))
        [Meta.isDefEq] [0.001171] ✅️ (True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 251#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 251#16) =
                true) =?= (True ∧ BitVec.zeroExtend 16 x✝ * 251#16 ≥ BitVec.twoPow 16 7 <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 251#16) = true)
          [Meta.isDefEq] [0.001152] ✅️ True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 251#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 16 x✝ * 251#16 ≥ BitVec.twoPow 16 7 <<< 1
            [Meta.isDefEq] [0.001142] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 251#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 251#16 ≥ BitVec.twoPow 16 7 <<< 1
              [Meta.isDefEq.delta] [0.001123] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 251#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 251#16 ≥ BitVec.twoPow 16 7 <<< 1
  [Meta.isDefEq] [0.002290] ✅️ ?h₁ =?= Eq.refl ((x✝ * 251#8 == 20#8) = true)
    [Meta.isDefEq.assign] [0.002286] ✅️ ?h₁ := Eq.refl ((x✝ * 251#8 == 20#8) = true)
      [Meta.isDefEq.assign.checkTypes] [0.002275] ✅️ (?h₁ : ((x✝ * 251#8 == 20#8) = true) =
            ((x✝ * 251#8 == 20#8) =
              true)) := (Eq.refl
            ((x✝ * 251#8 == 20#8) = true) : ((x✝ * 251#8 == 20#8) = true) = ((x✝ * 251#8 == 20#8) = true))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 251#16) = true then none
            else some (if (x✝ * 251#8 == 20#8) = true then 1#1 else 0#1)) ⊑
            some 0#1
      ⊢ False
  [Meta.whnf] [0.001160] Non-easy whnf: ((x✝ * 251#8 == 20#8) = true) = ?c
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:239:8: warning: declaration uses 'sorry'
[bv] [0.042849] Normalizing goal
  [Meta.synthInstance] [0.001921] ✅️ Decidable
        ((if
              True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
            none
          else some (BitVec.ofBool (x✝ * 5#8 != 226#8))) ⊑
          some 1#1)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else some (BitVec.ofBool (x✝ * 5#8 != 226#8))) ⊑
            some 1#1
      ⊢ False
  [Meta.isDefEq] [0.001942] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1) (BitVec.zeroExtend 16 x✝ * 5#16))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                      (BitVec.twoPow 16 7 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
        (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
    [Meta.isDefEq.assign] [0.001938] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                  (BitVec.zeroExtend 16 x✝ * 5#16))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                        (BitVec.twoPow 16 7 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
          (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001917] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                    (BitVec.zeroExtend 16 x✝ * 5#16))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                          (BitVec.twoPow 16 7 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
            (true_and
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
                true)) : (True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
        [Meta.isDefEq] [0.001913] ✅️ (True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
                true) =?= (True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true)
          [Meta.isDefEq] [0.001881] ✅️ True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1
            [Meta.isDefEq] [0.001856] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1
              [Meta.isDefEq.delta] [0.001826] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1
                [Meta.isDefEq] [0.001242] ✅️ BitVec.zeroExtend (2 * 8) x✝ *
                      BitVec.zeroExtend (2 * 8) 5#8 =?= BitVec.zeroExtend 16 x✝ * 5#16
                  [Meta.isDefEq] [0.001202] ✅️ instHMul.1 (BitVec.zeroExtend (2 * 8) x✝)
                        (BitVec.zeroExtend (2 * 8) 5#8) =?= instHMul.1 (BitVec.zeroExtend 16 x✝) 5#16
                    [Meta.isDefEq] [0.001119] ✅️ Mul.mul (BitVec.zeroExtend (2 * 8) x✝)
                          (BitVec.zeroExtend (2 * 8) 5#8) =?= Mul.mul (BitVec.zeroExtend 16 x✝) 5#16
                      [Meta.isDefEq] [0.001082] ✅️ BitVec.instMul.1 (BitVec.zeroExtend (2 * 8) x✝)
                            (BitVec.zeroExtend (2 * 8) 5#8) =?= BitVec.instMul.1 (BitVec.zeroExtend 16 x✝) 5#16
                        [Meta.isDefEq] [0.001009] ✅️ (BitVec.zeroExtend (2 * 8) x✝).mul
                              (BitVec.zeroExtend (2 * 8) 5#8) =?= (BitVec.zeroExtend 16 x✝).mul 5#16
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true then none
            else some (if (!x✝ * 5#8 == 226#8) = true then 1#1 else 0#1)) ⊑
            some 1#1
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:249:8: warning: declaration uses 'sorry'
[bv] [0.037815] Normalizing goal
  [Meta.synthInstance] [0.001372] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else some (BitVec.ofBool (x✝ * 7#8 >ₛ 128#8))) ⊑
          some 1#1)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (x✝ * 7#8 >ₛ 128#8))) ⊑
            some 1#1
      ⊢ False
  [Meta.isDefEq] [0.001774] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7) (BitVec.signExtend 16 x✝ * 7#16))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                            (BitVec.twoPow 16 7)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16) true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                (congrArg
                  (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) && x))
                  (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
        (true_and
          ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
            true))
    [Meta.isDefEq.assign] [0.001771] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                        (BitVec.signExtend 16 x✝ * 7#16))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                              (BitVec.twoPow 16 7)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16) true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                  (congrArg
                    (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) && x))
                    (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
          (true_and
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.001732] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                  BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                          (BitVec.signExtend 16 x✝ * 7#16))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                                (BitVec.twoPow 16 7)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16) true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                      !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                    (congrArg
                      (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) && x))
                      (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
            (true_and
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                true)) : (True ∧
              (BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7)) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
              true))
        [Meta.isDefEq] [0.001728] ✅️ (True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                true) =?= (True ∧
                (BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7)) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                true)
          [Meta.isDefEq] [0.001699] ✅️ True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1)) =?= True ∧
                (BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7)
            [Meta.isDefEq] [0.001675] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1) =?= BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7
              [Meta.isDefEq] [0.001553] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8)
                      (BitVec.twoPow 8
                        (8 - 1)) =?= BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7)
                [Meta.isDefEq] [0.001517] ✅️ instLTBitVec.1
                      (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8)
                      (BitVec.signExtend (2 * 8)
                        (BitVec.twoPow 8
                          (8 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 16 x✝ * 7#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                  [Meta.isDefEq] [0.001436] ✅️ (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8).toNat <
                        (BitVec.signExtend (2 * 8)
                            (BitVec.twoPow 8
                              (8 -
                                1))).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat <
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                    [Meta.isDefEq] [0.001413] ✅️ instLTNat.1
                          (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8).toNat
                          (BitVec.signExtend (2 * 8)
                              (BitVec.twoPow 8
                                (8 -
                                  1))).toNat =?= instLTNat.1 (BitVec.signExtend 16 x✝ * 7#16).toNat
                          (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                      [Meta.isDefEq] [0.001370] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 7#8).toNat.lt
                            (BitVec.signExtend (2 * 8)
                                (BitVec.twoPow 8
                                  (8 -
                                    1))).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat.lt
                            (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                        [Meta.isDefEq.delta] [0.001353] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 7#8).toNat.lt
                              (BitVec.signExtend (2 * 8)
                                  (BitVec.twoPow 8
                                    (8 -
                                      1))).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat.lt
                              (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                          [Meta.isDefEq] [0.001222] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 7#8).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat
                            [Meta.isDefEq.delta] [0.001202] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 7#8).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat
                              [Meta.isDefEq] [0.001179] ✅️ BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 7#8 =?= BitVec.signExtend 16 x✝ * 7#16
                                [Meta.isDefEq] [0.001143] ✅️ instHMul.1 (BitVec.signExtend (2 * 8) x✝)
                                      (BitVec.signExtend (2 * 8) 7#8) =?= instHMul.1 (BitVec.signExtend 16 x✝) 7#16
                                  [Meta.isDefEq] [0.001076] ✅️ Mul.mul (BitVec.signExtend (2 * 8) x✝)
                                        (BitVec.signExtend (2 * 8) 7#8) =?= Mul.mul (BitVec.signExtend 16 x✝) 7#16
                                    [Meta.isDefEq] [0.001053] ✅️ BitVec.instMul.1 (BitVec.signExtend (2 * 8) x✝)
                                          (BitVec.signExtend (2 * 8)
                                            7#8) =?= BitVec.instMul.1 (BitVec.signExtend 16 x✝) 7#16
                                      [Meta.isDefEq] [0.001006] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                            (BitVec.signExtend (2 * 8) 7#8) =?= (BitVec.signExtend 16 x✝).mul 7#16
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                  true then
              none
            else some (if (!(!(x✝ * 7#8).getLsbD 7) == (x✝ * 7#8 >ᵤ 128#8)) = true then 1#1 else 0#1)) ⊑
            some 1#1
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 106.086089ms, solving context: 0.000000ms
LeanSAT proved the goal after 136.193180ms: rewriting 37.332570ms, bitblasting 0.000000ms, SAT solving 58.171980ms, LRAT trimming 3.485470ms, LRAT checking 10.809540ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:269:8: warning: declaration uses 'sorry'
[bv] [0.029358] Normalizing goal
  [Meta.synthInstance] [0.001170] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 0#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 0#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else some (BitVec.ofBool (x✝ * 0#8 >ₛ 21#8))) ⊑
          some 0#1)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 0#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 0#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (x✝ * 0#8 >ₛ 21#8))) ⊑
            some 0#1
      ⊢ False
  [Meta.isDefEq] [0.002059] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Eq.trans
                    (Eq.trans (congrArg (fun x => x < BitVec.signExtend 16 (BitVec.twoPow 8 7)) BitVec.mul_zero)
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (0#16) (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                    (congrArg (fun x => x = true)
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.zero_ult' (BitVec.signExtend 16 (BitVec.twoPow 8 7)))
                        (Std.Tactic.BVDecide.Normalize.BitVec.bne_to_beq (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                          0#16)))))
                (Eq.trans
                  (Eq.trans (congrArg (fun x => x ≥ BitVec.twoPow 16 7) BitVec.mul_zero)
                    Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2)
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7) 0#16)
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (0#16) (BitVec.twoPow 16 7))
                            (congrArg (fun x => x = true)
                              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.zero_ult' (BitVec.twoPow 16 7))
                                (Std.Tactic.BVDecide.Normalize.BitVec.bne_to_beq (BitVec.twoPow 16 7) 0#16)))))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq (!BitVec.twoPow 16 7 == 0#16) true))
                      (congrArg (fun x => x = true)
                        (Eq.trans (congrArg not (beq_true !BitVec.twoPow 16 7 == 0#16))
                          (Bool.not_not (BitVec.twoPow 16 7 == 0#16))))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or (!BitVec.signExtend 16 (BitVec.twoPow 8 7) == 0#16)
                (BitVec.twoPow 16 7 == 0#16)))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim (!BitVec.signExtend 16 (BitVec.twoPow 8 7) == 0#16)
                  (BitVec.twoPow 16 7 == 0#16))
                (congrArg (fun x => !(x && !BitVec.twoPow 16 7 == 0#16))
                  (Bool.not_not (BitVec.signExtend 16 (BitVec.twoPow 8 7) == 0#16)))))))
        (true_and ((!(BitVec.signExtend 16 (BitVec.twoPow 8 7) == 0#16 && !BitVec.twoPow 16 7 == 0#16)) = true))
    [Meta.isDefEq.assign] [0.002056] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Eq.trans
                      (Eq.trans (congrArg (fun x => x < BitVec.signExtend 16 (BitVec.twoPow 8 7)) BitVec.mul_zero)
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (0#16) (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                      (congrArg (fun x => x = true)
                        (Eq.trans
                          (Std.Tactic.BVDecide.Normalize.BitVec.zero_ult' (BitVec.signExtend 16 (BitVec.twoPow 8 7)))
                          (Std.Tactic.BVDecide.Normalize.BitVec.bne_to_beq (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                            0#16)))))
                  (Eq.trans
                    (Eq.trans (congrArg (fun x => x ≥ BitVec.twoPow 16 7) BitVec.mul_zero)
                      Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2)
                    (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7) 0#16)
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (0#16) (BitVec.twoPow 16 7))
                              (congrArg (fun x => x = true)
                                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.zero_ult' (BitVec.twoPow 16 7))
                                  (Std.Tactic.BVDecide.Normalize.BitVec.bne_to_beq (BitVec.twoPow 16 7) 0#16)))))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq (!BitVec.twoPow 16 7 == 0#16) true))
                        (congrArg (fun x => x = true)
                          (Eq.trans (congrArg not (beq_true !BitVec.twoPow 16 7 == 0#16))
                            (Bool.not_not (BitVec.twoPow 16 7 == 0#16))))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or (!BitVec.signExtend 16 (BitVec.twoPow 8 7) == 0#16)
                  (BitVec.twoPow 16 7 == 0#16)))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim (!BitVec.signExtend 16 (BitVec.twoPow 8 7) == 0#16)
                    (BitVec.twoPow 16 7 == 0#16))
                  (congrArg (fun x => !(x && !BitVec.twoPow 16 7 == 0#16))
                    (Bool.not_not (BitVec.signExtend 16 (BitVec.twoPow 8 7) == 0#16)))))))
          (true_and ((!(BitVec.signExtend 16 (BitVec.twoPow 8 7) == 0#16 && !BitVec.twoPow 16 7 == 0#16)) = true))
      [Meta.isDefEq.assign.checkTypes] [0.002045] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 0#8 <
                  BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 0#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
            ((!(BitVec.signExtend 16 (BitVec.twoPow 8 7) == 0#16 && !BitVec.twoPow 16 7 == 0#16)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Eq.trans
                        (Eq.trans (congrArg (fun x => x < BitVec.signExtend 16 (BitVec.twoPow 8 7)) BitVec.mul_zero)
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (0#16)
                            (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                        (congrArg (fun x => x = true)
                          (Eq.trans
                            (Std.Tactic.BVDecide.Normalize.BitVec.zero_ult' (BitVec.signExtend 16 (BitVec.twoPow 8 7)))
                            (Std.Tactic.BVDecide.Normalize.BitVec.bne_to_beq (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                              0#16)))))
                    (Eq.trans
                      (Eq.trans (congrArg (fun x => x ≥ BitVec.twoPow 16 7) BitVec.mul_zero)
                        Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2)
                      (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7) 0#16)
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (0#16) (BitVec.twoPow 16 7))
                                (congrArg (fun x => x = true)
                                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.zero_ult' (BitVec.twoPow 16 7))
                                    (Std.Tactic.BVDecide.Normalize.BitVec.bne_to_beq (BitVec.twoPow 16 7) 0#16)))))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq (!BitVec.twoPow 16 7 == 0#16) true))
                          (congrArg (fun x => x = true)
                            (Eq.trans (congrArg not (beq_true !BitVec.twoPow 16 7 == 0#16))
                              (Bool.not_not (BitVec.twoPow 16 7 == 0#16))))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or (!BitVec.signExtend 16 (BitVec.twoPow 8 7) == 0#16)
                    (BitVec.twoPow 16 7 == 0#16)))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim (!BitVec.signExtend 16 (BitVec.twoPow 8 7) == 0#16)
                      (BitVec.twoPow 16 7 == 0#16))
                    (congrArg (fun x => !(x && !BitVec.twoPow 16 7 == 0#16))
                      (Bool.not_not (BitVec.signExtend 16 (BitVec.twoPow 8 7) == 0#16)))))))
            (true_and
              ((!(BitVec.signExtend 16 (BitVec.twoPow 8 7) == 0#16 && !BitVec.twoPow 16 7 == 0#16)) =
                true)) : (True ∧
              (BitVec.signExtend 16 x✝ * 0#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                BitVec.signExtend 16 x✝ * 0#16 ≥ BitVec.twoPow 16 7)) =
            ((!(BitVec.signExtend 16 (BitVec.twoPow 8 7) == 0#16 && !BitVec.twoPow 16 7 == 0#16)) = true))
        [Meta.isDefEq] [0.002042] ✅️ (True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 0#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 0#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
              ((!(BitVec.signExtend 16 (BitVec.twoPow 8 7) == 0#16 && !BitVec.twoPow 16 7 == 0#16)) =
                true) =?= (True ∧
                (BitVec.signExtend 16 x✝ * 0#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 0#16 ≥ BitVec.twoPow 16 7)) =
              ((!(BitVec.signExtend 16 (BitVec.twoPow 8 7) == 0#16 && !BitVec.twoPow 16 7 == 0#16)) = true)
          [Meta.isDefEq] [0.002023] ✅️ True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 0#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 0#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1)) =?= True ∧
                (BitVec.signExtend 16 x✝ * 0#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 0#16 ≥ BitVec.twoPow 16 7)
            [Meta.isDefEq] [0.002004] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 0#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 0#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1) =?= BitVec.signExtend 16 x✝ * 0#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 0#16 ≥ BitVec.twoPow 16 7
              [Meta.isDefEq] [0.001896] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 0#8 <
                    BitVec.signExtend (2 * 8)
                      (BitVec.twoPow 8
                        (8 - 1)) =?= BitVec.signExtend 16 x✝ * 0#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7)
                [Meta.isDefEq] [0.001875] ✅️ instLTBitVec.1
                      (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 0#8)
                      (BitVec.signExtend (2 * 8)
                        (BitVec.twoPow 8
                          (8 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 16 x✝ * 0#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                  [Meta.isDefEq] [0.001825] ✅️ (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 0#8).toNat <
                        (BitVec.signExtend (2 * 8)
                            (BitVec.twoPow 8
                              (8 -
                                1))).toNat =?= (BitVec.signExtend 16 x✝ * 0#16).toNat <
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                    [Meta.isDefEq] [0.001811] ✅️ instLTNat.1
                          (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 0#8).toNat
                          (BitVec.signExtend (2 * 8)
                              (BitVec.twoPow 8
                                (8 -
                                  1))).toNat =?= instLTNat.1 (BitVec.signExtend 16 x✝ * 0#16).toNat
                          (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                      [Meta.isDefEq] [0.001751] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 0#8).toNat.lt
                            (BitVec.signExtend (2 * 8)
                                (BitVec.twoPow 8
                                  (8 -
                                    1))).toNat =?= (BitVec.signExtend 16 x✝ * 0#16).toNat.lt
                            (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                        [Meta.isDefEq.delta] [0.001736] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 0#8).toNat.lt
                              (BitVec.signExtend (2 * 8)
                                  (BitVec.twoPow 8
                                    (8 -
                                      1))).toNat =?= (BitVec.signExtend 16 x✝ * 0#16).toNat.lt
                              (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                          [Meta.isDefEq] [0.001641] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 0#8).toNat =?= (BitVec.signExtend 16 x✝ * 0#16).toNat
                            [Meta.isDefEq.delta] [0.001623] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 0#8).toNat =?= (BitVec.signExtend 16 x✝ * 0#16).toNat
                              [Meta.isDefEq] [0.001603] ✅️ BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 0#8 =?= BitVec.signExtend 16 x✝ * 0#16
                                [Meta.isDefEq] [0.001578] ✅️ instHMul.1 (BitVec.signExtend (2 * 8) x✝)
                                      (BitVec.signExtend (2 * 8) 0#8) =?= instHMul.1 (BitVec.signExtend 16 x✝) 0#16
                                  [Meta.isDefEq] [0.001515] ✅️ Mul.mul (BitVec.signExtend (2 * 8) x✝)
                                        (BitVec.signExtend (2 * 8) 0#8) =?= Mul.mul (BitVec.signExtend 16 x✝) 0#16
                                    [Meta.isDefEq] [0.001491] ✅️ BitVec.instMul.1 (BitVec.signExtend (2 * 8) x✝)
                                          (BitVec.signExtend (2 * 8)
                                            0#8) =?= BitVec.instMul.1 (BitVec.signExtend 16 x✝) 0#16
                                      [Meta.isDefEq] [0.001441] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                            (BitVec.signExtend (2 * 8) 0#8) =?= (BitVec.signExtend 16 x✝).mul 0#16
                                        [Meta.isDefEq.delta] [0.001430] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                              (BitVec.signExtend (2 * 8) 0#8) =?= (BitVec.signExtend 16 x✝).mul 0#16
                                          [Meta.isDefEq] [0.001356] ✅️ BitVec.signExtend (2 * 8) 0#8 =?= 0#16
                                            [Meta.isDefEq] [0.001342] ✅️ BitVec.ofInt (2 * 8) (0#8).toInt =?= 0#16
                                              [Meta.isDefEq] [0.001327] ✅️ ((0#8).toInt %
                                                        Int.ofNat (2 ^ (2 * 8))).toNat#'⋯ =?= 0#16
                                                [Meta.isDefEq] [0.001306] ✅️ ((0#8).toInt %
                                                          Int.ofNat
                                                            (2 ^
                                                              (2 * 8))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 16) 0 }
                                                  [Meta.isDefEq] [0.001288] ✅️ {
                                                        toFin :=
                                                          ⟨((0#8).toInt % Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 16) 0 }
                                                    [Meta.isDefEq] [0.001255] ✅️ ⟨((0#8).toInt %
                                                              Int.ofNat (2 ^ (2 * 8))).toNat,
                                                          ⋯⟩ =?= Fin.ofNat' (2 ^ 16) 0
                                                      [Meta.isDefEq] [0.001231] ✅️ ⟨((0#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ =?= ⟨0 % 2 ^ 16, ⋯⟩
                                                        [Meta.isDefEq] [0.001145] ✅️ ((0#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat =?= 0 % 2 ^ 16
                                                          [Meta.isDefEq] [0.001032] ✅️ match
                                                                (0#8).toInt % Int.ofNat (2 ^ (2 * 8)) with
                                                              | Int.ofNat n => n
                                                              | Int.negSucc a => 0 =?= 0 % 2 ^ 16
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if (!(BitVec.signExtend 16 (BitVec.twoPow 8 7) == 0#16 && !BitVec.twoPow 16 7 == 0#16)) = true then none
            else some 0#1) ⊑
            some 0#1
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 89.628979ms, solving context: 1.000000ms
LeanSAT proved the goal after 98.113210ms: rewriting 21.195080ms, bitblasting 0.000000ms, SAT solving 60.833570ms, LRAT trimming 0.000000ms, LRAT checking 5.624800ms
Bitwuzla proved the goal after 89.404280ms, solving context: 0.000000ms
LeanSAT proved the goal after 90.516879ms: rewriting 20.998299ms, bitblasting 0.000000ms, SAT solving 56.201039ms, LRAT trimming 0.000000ms, LRAT checking 5.664090ms
Bitwuzla proved the goal after 237.766309ms, solving context: 143.000000ms
LeanSAT proved the goal after 1111.527625ms: rewriting 21.300910ms, bitblasting 19.924270ms, SAT solving 708.929128ms, LRAT trimming 194.782599ms, LRAT checking 117.580309ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:309:8: warning: declaration uses 'sorry'
[bv] [0.044074] Normalizing goal
  [Meta.synthInstance] [0.001268] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 32) x✝ * BitVec.signExtend (2 * 32) 6#32 <
                    BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                  BitVec.signExtend (2 * 32) x✝ * BitVec.signExtend (2 * 32) 6#32 ≥
                    BitVec.twoPow (2 * 32) (32 - 1)) then
            none
          else
            if
                True ∧
                  (BitVec.signExtend (2 * 32) x✝¹ * BitVec.signExtend (2 * 32) 6#32 <
                      BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                    BitVec.signExtend (2 * 32) x✝¹ * BitVec.signExtend (2 * 32) 6#32 ≥
                      BitVec.twoPow (2 * 32) (32 - 1)) then
              none
            else some (BitVec.ofBool (x✝ * 6#32 == x✝¹ * 6#32))) ⊑
          some (BitVec.ofBool (x✝ == x✝¹)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 32) x✝ * BitVec.signExtend (2 * 32) 6#32 <
                      BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                    BitVec.signExtend (2 * 32) x✝ * BitVec.signExtend (2 * 32) 6#32 ≥
                      BitVec.twoPow (2 * 32) (32 - 1)) then
              none
            else
              if
                  True ∧
                    (BitVec.signExtend (2 * 32) x✝¹ * BitVec.signExtend (2 * 32) 6#32 <
                        BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                      BitVec.signExtend (2 * 32) x✝¹ * BitVec.signExtend (2 * 32) 6#32 ≥
                        BitVec.twoPow (2 * 32) (32 - 1)) then
                none
              else some (BitVec.ofBool (x✝ * 6#32 == x✝¹ * 6#32))) ⊑
            some (BitVec.ofBool (x✝ == x✝¹))
      ⊢ False
  [Meta.isDefEq] [0.001019] ✅️ ?x > ?y =?= BitVec.signExtend 64 x✝¹ * 6#64 < BitVec.signExtend 64 (BitVec.twoPow 32 31)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ BitVec.signExtend 64 x✝ * 6#64) &&
                      BitVec.twoPow 64 31 >ᵤ BitVec.signExtend 64 x✝ * 6#64)) =
                  true then
              none
            else
              if
                  (!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ BitVec.signExtend 64 x✝¹ * 6#64) &&
                        BitVec.twoPow 64 31 >ᵤ BitVec.signExtend 64 x✝¹ * 6#64)) =
                    true then
                none
              else some (if (x✝ * 6#32 == x✝¹ * 6#32) = true then 1#1 else 0#1)) ⊑
            some (if (x✝ == x✝¹) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:321:8: warning: declaration uses 'sorry'
[bv] [0.041216] Normalizing goal
  [Meta.synthInstance] [0.001198] ✅️ Decidable
        ((if
              True ∧
                BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 22#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
            none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 32) x✝¹ * BitVec.zeroExtend (2 * 32) 22#32 ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else some (BitVec.ofBool (x✝ * 22#32 == x✝¹ * 22#32))) ⊑
          some (BitVec.ofBool (x✝ == x✝¹)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if
                True ∧
                  BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 22#32 ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 32) x✝¹ * BitVec.zeroExtend (2 * 32) 22#32 ≥
                      BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                none
              else some (BitVec.ofBool (x✝ * 22#32 == x✝¹ * 22#32))) ⊑
            some (BitVec.ofBool (x✝ == x✝¹))
      ⊢ False
  [Meta.isDefEq] [0.001069] ❌️ ?a == ?a =?= (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 22#64) == true
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 22#64) = true then none
            else
              if (!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 22#64) = true then none
              else some (if (x✝ * 22#32 == x✝¹ * 22#32) = true then 1#1 else 0#1)) ⊑
            some (if (x✝ == x✝¹) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:333:8: warning: declaration uses 'sorry'
[bv] [0.034439] Normalizing goal
  [Meta.synthInstance] [0.001426] ✅️ Decidable
        ((if
              True ∧
                BitVec.zeroExtend (2 * 32) x✝¹ * BitVec.zeroExtend (2 * 32) 44#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
            none
          else some (BitVec.ofBool (x✝ * 44#32 == x✝¹ * 44#32))) ⊑
          some (BitVec.ofBool ((x✝ ^^^ x✝¹) &&& 1073741823#32 == 0#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if
                True ∧
                  BitVec.zeroExtend (2 * 32) x✝¹ * BitVec.zeroExtend (2 * 32) 44#32 ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else some (BitVec.ofBool (x✝ * 44#32 == x✝¹ * 44#32))) ⊑
            some (BitVec.ofBool ((x✝ ^^^ x✝¹) &&& 1073741823#32 == 0#32))
      ⊢ False
  [Meta.isDefEq] [0.001381] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                (BitVec.zeroExtend 64 x✝¹ * 44#64))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 x✝¹ * 44#64)
                      (BitVec.twoPow 64 31 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 44#64) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 44#64)))))))
        (true_and ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 44#64) = true))
    [Meta.isDefEq.assign] [0.001378] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                  (BitVec.zeroExtend 64 x✝¹ * 44#64))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 x✝¹ * 44#64)
                        (BitVec.twoPow 64 31 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 44#64) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 44#64)))))))
          (true_and ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 44#64) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001364] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 32) x✝¹ * BitVec.zeroExtend (2 * 32) 44#32 ≥
                BitVec.twoPow (2 * 32) (32 - 1) <<< 1) =
            ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 44#64) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                    (BitVec.zeroExtend 64 x✝¹ * 44#64))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 x✝¹ * 44#64)
                          (BitVec.twoPow 64 31 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 44#64) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 44#64)))))))
            (true_and
              ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 44#64) =
                true)) : (True ∧ BitVec.zeroExtend 64 x✝¹ * 44#64 ≥ BitVec.twoPow 64 31 <<< 1) =
            ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 44#64) = true))
        [Meta.isDefEq] [0.001361] ✅️ (True ∧
                BitVec.zeroExtend (2 * 32) x✝¹ * BitVec.zeroExtend (2 * 32) 44#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1) =
              ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 44#64) =
                true) =?= (True ∧ BitVec.zeroExtend 64 x✝¹ * 44#64 ≥ BitVec.twoPow 64 31 <<< 1) =
              ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 44#64) = true)
          [Meta.isDefEq] [0.001342] ✅️ True ∧
                BitVec.zeroExtend (2 * 32) x✝¹ * BitVec.zeroExtend (2 * 32) 44#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 64 x✝¹ * 44#64 ≥ BitVec.twoPow 64 31 <<< 1
            [Meta.isDefEq] [0.001328] ✅️ BitVec.zeroExtend (2 * 32) x✝¹ * BitVec.zeroExtend (2 * 32) 44#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1 =?= BitVec.zeroExtend 64 x✝¹ * 44#64 ≥ BitVec.twoPow 64 31 <<< 1
              [Meta.isDefEq.delta] [0.001309] ✅️ BitVec.zeroExtend (2 * 32) x✝¹ * BitVec.zeroExtend (2 * 32) 44#32 ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<<
                      1 =?= BitVec.zeroExtend 64 x✝¹ * 44#64 ≥ BitVec.twoPow 64 31 <<< 1
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 44#64) = true then none
            else some (if (x✝ * 44#32 == x✝¹ * 44#32) = true then 1#1 else 0#1)) ⊑
            some (if ((x✝ ^^^ x✝¹) &&& 1073741823#32 == 0#32) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:344:8: warning: declaration uses 'sorry'
[bv] [0.046771] Normalizing goal
  [Meta.synthInstance] [0.001412] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 32) x✝ * BitVec.signExtend (2 * 32) 54#32 <
                    BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                  BitVec.signExtend (2 * 32) x✝ * BitVec.signExtend (2 * 32) 54#32 ≥
                    BitVec.twoPow (2 * 32) (32 - 1)) then
            none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 32) x✝¹ * BitVec.zeroExtend (2 * 32) 54#32 ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else some (BitVec.ofBool (x✝ * 54#32 == x✝¹ * 54#32))) ⊑
          some (BitVec.ofBool ((x✝ ^^^ x✝¹) &&& 2147483647#32 == 0#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 32) x✝ * BitVec.signExtend (2 * 32) 54#32 <
                      BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                    BitVec.signExtend (2 * 32) x✝ * BitVec.signExtend (2 * 32) 54#32 ≥
                      BitVec.twoPow (2 * 32) (32 - 1)) then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 32) x✝¹ * BitVec.zeroExtend (2 * 32) 54#32 ≥
                      BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                none
              else some (BitVec.ofBool (x✝ * 54#32 == x✝¹ * 54#32))) ⊑
            some (BitVec.ofBool ((x✝ ^^^ x✝¹) &&& 2147483647#32 == 0#32))
      ⊢ False
  [Meta.isDefEq] [0.001021] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                (BitVec.zeroExtend 64 x✝¹ * 54#64))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 x✝¹ * 54#64)
                      (BitVec.twoPow 64 31 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 54#64) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 54#64)))))))
        (true_and ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 54#64) = true))
    [Meta.isDefEq.assign] [0.001019] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                  (BitVec.zeroExtend 64 x✝¹ * 54#64))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 x✝¹ * 54#64)
                        (BitVec.twoPow 64 31 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 54#64) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 54#64)))))))
          (true_and ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 54#64) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001006] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 32) x✝¹ * BitVec.zeroExtend (2 * 32) 54#32 ≥
                BitVec.twoPow (2 * 32) (32 - 1) <<< 1) =
            ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 54#64) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                    (BitVec.zeroExtend 64 x✝¹ * 54#64))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 x✝¹ * 54#64)
                          (BitVec.twoPow 64 31 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 54#64) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 54#64)))))))
            (true_and
              ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 54#64) =
                true)) : (True ∧ BitVec.zeroExtend 64 x✝¹ * 54#64 ≥ BitVec.twoPow 64 31 <<< 1) =
            ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 54#64) = true))
        [Meta.isDefEq] [0.001002] ✅️ (True ∧
                BitVec.zeroExtend (2 * 32) x✝¹ * BitVec.zeroExtend (2 * 32) 54#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1) =
              ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 54#64) =
                true) =?= (True ∧ BitVec.zeroExtend 64 x✝¹ * 54#64 ≥ BitVec.twoPow 64 31 <<< 1) =
              ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 54#64) = true)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ BitVec.signExtend 64 x✝ * 54#64) &&
                      BitVec.twoPow 64 31 >ᵤ BitVec.signExtend 64 x✝ * 54#64)) =
                  true then
              none
            else
              if (!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 54#64) = true then none
              else some (if (x✝ * 54#32 == x✝¹ * 54#32) = true then 1#1 else 0#1)) ⊑
            some (if ((x✝ ^^^ x✝¹) &&& 2147483647#32 == 0#32) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 138.715989ms, solving context: 77.000000ms
LeanSAT proved the goal after 761.435728ms: rewriting 40.609690ms, bitblasting 18.499170ms, SAT solving 508.917379ms, LRAT trimming 89.761319ms, LRAT checking 81.381800ms
Bitwuzla proved the goal after 76.866420ms, solving context: 0.000000ms
LeanSAT proved the goal after 93.052089ms: rewriting 15.861840ms, bitblasting 4.810480ms, SAT solving 55.539049ms, LRAT trimming 0.000000ms, LRAT checking 11.070790ms
Bitwuzla proved the goal after 76.431890ms, solving context: 0.000000ms
LeanSAT proved the goal after 91.029519ms: rewriting 15.923520ms, bitblasting 4.634990ms, SAT solving 55.076719ms, LRAT trimming 0.000000ms, LRAT checking 9.625980ms
Bitwuzla proved the goal after 77.375751ms, solving context: 0.000000ms
LeanSAT proved the goal after 139.102709ms: rewriting 15.819739ms, bitblasting 4.628800ms, SAT solving 105.418530ms, LRAT trimming 0.000000ms, LRAT checking 8.314330ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:399:8: warning: declaration uses 'sorry'
[bv] [0.040637] Normalizing goal
  [Meta.synthInstance] [0.001589] ✅️ Decidable
        (some (BitVec.ofBool ((x✝ &&& 3#32) * BitVec.zeroExtend 32 x✝¹ >ᵤ 255#32)) ⊑
          if
              True ∧
                (BitVec.signExtend (2 * 32) (x✝ &&& 3#32) * BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝¹) <
                    BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                  BitVec.signExtend (2 * 32) (x✝ &&& 3#32) * BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝¹) ≥
                    BitVec.twoPow (2 * 32) (32 - 1)) then
            none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 32) (x✝ &&& 3#32) * BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝¹) ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else some (BitVec.ofBool ((x✝ &&& 3#32) * BitVec.zeroExtend 32 x✝¹ >ᵤ 255#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 32
      x✝¹ : BitVec 8
      x✝ : BitVec 32
      a✝ :
        ¬some (BitVec.ofBool ((x✝ &&& 3#32) * BitVec.zeroExtend 32 x✝¹ >ᵤ 255#32)) ⊑
            if
                True ∧
                  (BitVec.signExtend (2 * 32) (x✝ &&& 3#32) * BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝¹) <
                      BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                    BitVec.signExtend (2 * 32) (x✝ &&& 3#32) * BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝¹) ≥
                      BitVec.twoPow (2 * 32) (32 - 1)) then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 32) (x✝ &&& 3#32) * BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝¹) ≥
                      BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                none
              else some (BitVec.ofBool ((x✝ &&& 3#32) * BitVec.zeroExtend 32 x✝¹ >ᵤ 255#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 32
      x✝¹ : BitVec 8
      x✝ : BitVec 32
      a✝ :
        ¬some (if ((x✝ &&& 3#32) * BitVec.zeroExtend 32 x✝¹ >ᵤ 255#32) = true then 1#1 else 0#1) ⊑
            if
                (!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                          BitVec.signExtend 64 (x✝ &&& 3#32) * BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝¹)) &&
                      BitVec.twoPow 64 31 >ᵤ
                        BitVec.signExtend 64 (x✝ &&& 3#32) * BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝¹))) =
                  true then
              none
            else
              if
                  (!BitVec.twoPow 64 31 <<< 1 >ᵤ
                        BitVec.zeroExtend 64 (x✝ &&& 3#32) * BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝¹)) =
                    true then
                none
              else some (if ((x✝ &&& 3#32) * BitVec.zeroExtend 32 x✝¹ >ᵤ 255#32) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:411:8: warning: declaration uses 'sorry'
[bv] [0.043341] Normalizing goal
  [Meta.synthInstance] [0.001678] ✅️ Decidable
        ((if 30#32 ≥ ↑32 then none else some (BitVec.ofBool ((x✝ &&& 255#32) * x✝¹ >>> 30#32 >ᵤ 255#32))) ⊑
          if 30#32 ≥ ↑32 then none
          else
            if
                True ∧
                  (BitVec.signExtend (2 * 32) (x✝ &&& 255#32) * BitVec.signExtend (2 * 32) (x✝¹ >>> 30#32) <
                      BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                    BitVec.signExtend (2 * 32) (x✝ &&& 255#32) * BitVec.signExtend (2 * 32) (x✝¹ >>> 30#32) ≥
                      BitVec.twoPow (2 * 32) (32 - 1)) then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 32) (x✝ &&& 255#32) * BitVec.zeroExtend (2 * 32) (x✝¹ >>> 30#32) ≥
                      BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                none
              else some (BitVec.ofBool ((x✝ &&& 255#32) * x✝¹ >>> 30#32 >ᵤ 255#32)))
    [Meta.check] [0.001067] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if 30#32 ≥ ↑32 then none else some (BitVec.ofBool ((x✝ &&& 255#32) * x✝¹ >>> 30#32 >ᵤ 255#32)))
          (if 30#32 ≥ ↑32 then none
          else
            if
                True ∧
                  (BitVec.signExtend (2 * 32) (x✝ &&& 255#32) * BitVec.signExtend (2 * 32) (x✝¹ >>> 30#32) <
                      BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                    BitVec.signExtend (2 * 32) (x✝ &&& 255#32) * BitVec.signExtend (2 * 32) (x✝¹ >>> 30#32) ≥
                      BitVec.twoPow (2 * 32) (32 - 1)) then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 32) (x✝ &&& 255#32) * BitVec.zeroExtend (2 * 32) (x✝¹ >>> 30#32) ≥
                      BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                none
              else some (BitVec.ofBool ((x✝ &&& 255#32) * x✝¹ >>> 30#32 >ᵤ 255#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if 30#32 ≥ ↑32 then none else some (BitVec.ofBool ((x✝ &&& 255#32) * x✝¹ >>> 30#32 >ᵤ 255#32))) ⊑
            if 30#32 ≥ ↑32 then none
            else
              if
                  True ∧
                    (BitVec.signExtend (2 * 32) (x✝ &&& 255#32) * BitVec.signExtend (2 * 32) (x✝¹ >>> 30#32) <
                        BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                      BitVec.signExtend (2 * 32) (x✝ &&& 255#32) * BitVec.signExtend (2 * 32) (x✝¹ >>> 30#32) ≥
                        BitVec.twoPow (2 * 32) (32 - 1)) then
                none
              else
                if
                    True ∧
                      BitVec.zeroExtend (2 * 32) (x✝ &&& 255#32) * BitVec.zeroExtend (2 * 32) (x✝¹ >>> 30#32) ≥
                        BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                  none
                else some (BitVec.ofBool ((x✝ &&& 255#32) * x✝¹ >>> 30#32 >ᵤ 255#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬some (if ((x✝ &&& 255#32) * x✝¹ >>> 30 >ᵤ 255#32) = true then 1#1 else 0#1) ⊑
            if
                (!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                          BitVec.signExtend 64 (x✝ &&& 255#32) * BitVec.signExtend 64 (x✝¹ >>> 30)) &&
                      BitVec.twoPow 64 31 >ᵤ
                        BitVec.signExtend 64 (x✝ &&& 255#32) * BitVec.signExtend 64 (x✝¹ >>> 30))) =
                  true then
              none
            else
              if
                  (!BitVec.twoPow 64 31 <<< 1 >ᵤ
                        BitVec.zeroExtend 64 (x✝ &&& 255#32) * BitVec.zeroExtend 64 (x✝¹ >>> 30)) =
                    true then
                none
              else some (if ((x✝ &&& 255#32) * x✝¹ >>> 30 >ᵤ 255#32) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:423:8: warning: declaration uses 'sorry'
[bv] [0.046825] Normalizing goal
  [Meta.synthInstance] [0.001531] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 32) (x✝ &&& 1#32) * BitVec.signExtend (2 * 32) (BitVec.signExtend 32 x✝¹) <
                    BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                  BitVec.signExtend (2 * 32) (x✝ &&& 1#32) * BitVec.signExtend (2 * 32) (BitVec.signExtend 32 x✝¹) ≥
                    BitVec.twoPow (2 * 32) (32 - 1)) then
            none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 32) (x✝ &&& 1#32) * BitVec.zeroExtend (2 * 32) (BitVec.signExtend 32 x✝¹) ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else some (BitVec.ofBool ((x✝ &&& 1#32) * BitVec.signExtend 32 x✝¹ >ₛ 127#32))) ⊑
          some 0#1)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 32
      x✝¹ : BitVec 8
      x✝ : BitVec 32
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 32) (x✝ &&& 1#32) * BitVec.signExtend (2 * 32) (BitVec.signExtend 32 x✝¹) <
                      BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                    BitVec.signExtend (2 * 32) (x✝ &&& 1#32) * BitVec.signExtend (2 * 32) (BitVec.signExtend 32 x✝¹) ≥
                      BitVec.twoPow (2 * 32) (32 - 1)) then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 32) (x✝ &&& 1#32) * BitVec.zeroExtend (2 * 32) (BitVec.signExtend 32 x✝¹) ≥
                      BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                none
              else some (BitVec.ofBool ((x✝ &&& 1#32) * BitVec.signExtend 32 x✝¹ >ₛ 127#32))) ⊑
            some 0#1
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 32
      x✝¹ : BitVec 8
      x✝ : BitVec 32
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                          BitVec.signExtend 64 (x✝ &&& 1#32) * BitVec.signExtend 64 (BitVec.signExtend 32 x✝¹)) &&
                      BitVec.twoPow 64 31 >ᵤ
                        BitVec.signExtend 64 (x✝ &&& 1#32) * BitVec.signExtend 64 (BitVec.signExtend 32 x✝¹))) =
                  true then
              none
            else
              if
                  (!BitVec.twoPow 64 31 <<< 1 >ᵤ
                        BitVec.zeroExtend 64 (x✝ &&& 1#32) * BitVec.zeroExtend 64 (BitVec.signExtend 32 x✝¹)) =
                    true then
                none
              else
                some
                  (if
                      (!((x✝ &&& 1#32) * BitVec.signExtend 32 x✝¹).getLsbD 31 ==
                            ((x✝ &&& 1#32) * BitVec.signExtend 32 x✝¹ >ᵤ 127#32)) =
                        true then
                    1#1
                  else 0#1)) ⊑
            some 0#1
      ⊢ False
  [Meta.isDefEq] [0.002158] ❌️ ?a ==
        ?a =?= ((x✝ &&& 1#32) * BitVec.signExtend 32 x✝¹).getLsbD 31 ==
        ((x✝ &&& 1#32) * BitVec.signExtend 32 x✝¹ >ᵤ 127#32)
    [Meta.isDefEq.onFailure] [0.001717] ❌️ ?a ==
          ?a =?= ((x✝ &&& 1#32) * BitVec.signExtend 32 x✝¹).getLsbD 31 ==
          ((x✝ &&& 1#32) * BitVec.signExtend 32 x✝¹ >ᵤ 127#32)
      [Meta.synthInstance] [0.001675] 💥️ BEq ?α
        [Meta.synthInstance] [0.001551] 💥️ apply Nat.Linear.instBEqPolyCnstr to BEq ?α
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 76.765230ms, solving context: 0.000000ms
LeanSAT proved the goal after 150.599140ms: rewriting 15.480650ms, bitblasting 4.765680ms, SAT solving 105.267970ms, LRAT trimming 2.950870ms, LRAT checking 14.587660ms
Bitwuzla proved the goal after 78.058750ms, solving context: 1.000000ms
LeanSAT proved the goal after 152.248270ms: rewriting 16.059260ms, bitblasting 5.247490ms, SAT solving 105.596260ms, LRAT trimming 2.934910ms, LRAT checking 14.793030ms
Bitwuzla proved the goal after 67.616990ms, solving context: 0.000000ms
LeanSAT proved the goal after 139.993060ms: rewriting 10.739430ms, bitblasting 3.106480ms, SAT solving 105.847240ms, LRAT trimming 3.247180ms, LRAT checking 12.964550ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:466:8: warning: declaration uses 'sorry'
[bv] [0.040327] Normalizing goal
  [Meta.synthInstance] [0.001630] ✅️ Decidable
        (some (BitVec.ofBool ((x✝ &&& 6#32) * BitVec.zeroExtend 32 x✝¹ >ᵤ 1530#32)) ⊑
          if
              True ∧
                (BitVec.signExtend (2 * 32) (x✝ &&& 6#32) * BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝¹) <
                    BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                  BitVec.signExtend (2 * 32) (x✝ &&& 6#32) * BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝¹) ≥
                    BitVec.twoPow (2 * 32) (32 - 1)) then
            none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 32) (x✝ &&& 6#32) * BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝¹) ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else some (BitVec.ofBool ((x✝ &&& 6#32) * BitVec.zeroExtend 32 x✝¹ >ᵤ 1530#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 32
      x✝¹ : BitVec 8
      x✝ : BitVec 32
      a✝ :
        ¬some (BitVec.ofBool ((x✝ &&& 6#32) * BitVec.zeroExtend 32 x✝¹ >ᵤ 1530#32)) ⊑
            if
                True ∧
                  (BitVec.signExtend (2 * 32) (x✝ &&& 6#32) * BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝¹) <
                      BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                    BitVec.signExtend (2 * 32) (x✝ &&& 6#32) * BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝¹) ≥
                      BitVec.twoPow (2 * 32) (32 - 1)) then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 32) (x✝ &&& 6#32) * BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝¹) ≥
                      BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                none
              else some (BitVec.ofBool ((x✝ &&& 6#32) * BitVec.zeroExtend 32 x✝¹ >ᵤ 1530#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 32
      x✝¹ : BitVec 8
      x✝ : BitVec 32
      a✝ :
        ¬some (if ((x✝ &&& 6#32) * BitVec.zeroExtend 32 x✝¹ >ᵤ 1530#32) = true then 1#1 else 0#1) ⊑
            if
                (!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                          BitVec.signExtend 64 (x✝ &&& 6#32) * BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝¹)) &&
                      BitVec.twoPow 64 31 >ᵤ
                        BitVec.signExtend 64 (x✝ &&& 6#32) * BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝¹))) =
                  true then
              none
            else
              if
                  (!BitVec.twoPow 64 31 <<< 1 >ᵤ
                        BitVec.zeroExtend 64 (x✝ &&& 6#32) * BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝¹)) =
                    true then
                none
              else some (if ((x✝ &&& 6#32) * BitVec.zeroExtend 32 x✝¹ >ᵤ 1530#32) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:478:8: warning: declaration uses 'sorry'
[bv] [0.040124] Normalizing goal
  [Meta.synthInstance] [0.001525] ✅️ Decidable
        (some (BitVec.ofBool ((x✝ &&& 255#32) * (x✝¹ &&& 12#32) >ᵤ 3060#32)) ⊑
          if
              True ∧
                (BitVec.signExtend (2 * 32) (x✝ &&& 255#32) * BitVec.signExtend (2 * 32) (x✝¹ &&& 12#32) <
                    BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                  BitVec.signExtend (2 * 32) (x✝ &&& 255#32) * BitVec.signExtend (2 * 32) (x✝¹ &&& 12#32) ≥
                    BitVec.twoPow (2 * 32) (32 - 1)) then
            none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 32) (x✝ &&& 255#32) * BitVec.zeroExtend (2 * 32) (x✝¹ &&& 12#32) ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else some (BitVec.ofBool ((x✝ &&& 255#32) * (x✝¹ &&& 12#32) >ᵤ 3060#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬some (BitVec.ofBool ((x✝ &&& 255#32) * (x✝¹ &&& 12#32) >ᵤ 3060#32)) ⊑
            if
                True ∧
                  (BitVec.signExtend (2 * 32) (x✝ &&& 255#32) * BitVec.signExtend (2 * 32) (x✝¹ &&& 12#32) <
                      BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                    BitVec.signExtend (2 * 32) (x✝ &&& 255#32) * BitVec.signExtend (2 * 32) (x✝¹ &&& 12#32) ≥
                      BitVec.twoPow (2 * 32) (32 - 1)) then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 32) (x✝ &&& 255#32) * BitVec.zeroExtend (2 * 32) (x✝¹ &&& 12#32) ≥
                      BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                none
              else some (BitVec.ofBool ((x✝ &&& 255#32) * (x✝¹ &&& 12#32) >ᵤ 3060#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬some (if ((x✝ &&& 255#32) * (x✝¹ &&& 12#32) >ᵤ 3060#32) = true then 1#1 else 0#1) ⊑
            if
                (!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                          BitVec.signExtend 64 (x✝ &&& 255#32) * BitVec.signExtend 64 (x✝¹ &&& 12#32)) &&
                      BitVec.twoPow 64 31 >ᵤ
                        BitVec.signExtend 64 (x✝ &&& 255#32) * BitVec.signExtend 64 (x✝¹ &&& 12#32))) =
                  true then
              none
            else
              if
                  (!BitVec.twoPow 64 31 <<< 1 >ᵤ
                        BitVec.zeroExtend 64 (x✝ &&& 255#32) * BitVec.zeroExtend 64 (x✝¹ &&& 12#32)) =
                    true then
                none
              else some (if ((x✝ &&& 255#32) * (x✝¹ &&& 12#32) >ᵤ 3060#32) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:491:8: warning: declaration uses 'sorry'
[bv] [0.017321] Normalizing goal
  [Meta.synthInstance] [0.001095] ✅️ Decidable
        ((if 96#128 ≥ ↑128 then none
          else some (BitVec.ofBool ((BitVec.zeroExtend 128 x✝ * 18446744078004518913#128) >>> 96#128 == 0#128))) ⊑
          some 1#1)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if 96#128 ≥ ↑128 then none
            else some (BitVec.ofBool ((BitVec.zeroExtend 128 x✝ * 18446744078004518913#128) >>> 96#128 == 0#128))) ⊑
            some 1#1
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬some (if ((BitVec.zeroExtend 128 x✝ * 18446744078004518913#128) >>> 96 == 0#128) = true then 1#1 else 0#1) ⊑
            some 1#1
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:502:8: warning: declaration uses 'sorry'
[bv] [0.025629] Normalizing goal
  [Meta.synthInstance] [0.001152] ✅️ Decidable
        ((if 95#128 ≥ ↑128 then none
          else some (BitVec.ofBool ((BitVec.zeroExtend 128 x✝ * 18446744078004518913#128) >>> 95#128 == 0#128))) ⊑
          some (BitVec.ofBool (x✝ >ₛ -1#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if 95#128 ≥ ↑128 then none
            else some (BitVec.ofBool ((BitVec.zeroExtend 128 x✝ * 18446744078004518913#128) >>> 95#128 == 0#128))) ⊑
            some (BitVec.ofBool (x✝ >ₛ -1#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬some (if ((BitVec.zeroExtend 128 x✝ * 18446744078004518913#128) >>> 95 == 0#128) = true then 1#1 else 0#1) ⊑
            some (if (!x✝.getLsbD 31) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:513:8: warning: declaration uses 'sorry'
[bv] [0.077035] Normalizing goal
  [Meta.synthInstance] [0.002108] ✅️ Decidable
        ((match some (BitVec.ofBool (x✝ != 0#8)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } =>
            if
                True ∧
                  BitVec.zeroExtend (2 * 8) x✝¹ * BitVec.zeroExtend (2 * 8) x✝ ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 8) x✝² * BitVec.zeroExtend (2 * 8) x✝ ≥
                      BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
                none
              else some (BitVec.ofBool (x✝¹ * x✝ >ᵤ x✝² * x✝))
          | some { toFin := ⟨0, ⋯⟩ } => some 1#1) ⊑
          match some (BitVec.ofBool (x✝ == 0#8)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some 1#1
          | some { toFin := ⟨0, ⋯⟩ } =>
            if
                True ∧
                  BitVec.zeroExtend (2 * 8) x✝¹ * BitVec.zeroExtend (2 * 8) x✝ ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 8) x✝² * BitVec.zeroExtend (2 * 8) x✝ ≥
                      BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
                none
              else some (BitVec.ofBool (x✝¹ * x✝ >ᵤ x✝² * x✝)))
    [Meta.check] [0.001039] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (match some (BitVec.ofBool (x✝ != 0#8)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } =>
            if
                True ∧
                  BitVec.zeroExtend (2 * 8) x✝¹ * BitVec.zeroExtend (2 * 8) x✝ ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 8) x✝² * BitVec.zeroExtend (2 * 8) x✝ ≥
                      BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
                none
              else some (BitVec.ofBool (x✝¹ * x✝ >ᵤ x✝² * x✝))
          | some { toFin := ⟨0, ⋯⟩ } => some 1#1)
          (match some (BitVec.ofBool (x✝ == 0#8)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some 1#1
          | some { toFin := ⟨0, ⋯⟩ } =>
            if
                True ∧
                  BitVec.zeroExtend (2 * 8) x✝¹ * BitVec.zeroExtend (2 * 8) x✝ ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 8) x✝² * BitVec.zeroExtend (2 * 8) x✝ ≥
                      BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
                none
              else some (BitVec.ofBool (x✝¹ * x✝ >ᵤ x✝² * x✝)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x✝² x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(match some (BitVec.ofBool (x✝ != 0#8)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } =>
              if
                  True ∧
                    BitVec.zeroExtend (2 * 8) x✝¹ * BitVec.zeroExtend (2 * 8) x✝ ≥
                      BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
                none
              else
                if
                    True ∧
                      BitVec.zeroExtend (2 * 8) x✝² * BitVec.zeroExtend (2 * 8) x✝ ≥
                        BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
                  none
                else some (BitVec.ofBool (x✝¹ * x✝ >ᵤ x✝² * x✝))
            | some { toFin := ⟨0, ⋯⟩ } => some 1#1) ⊑
            match some (BitVec.ofBool (x✝ == 0#8)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 1#1
            | some { toFin := ⟨0, ⋯⟩ } =>
              if
                  True ∧
                    BitVec.zeroExtend (2 * 8) x✝¹ * BitVec.zeroExtend (2 * 8) x✝ ≥
                      BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
                none
              else
                if
                    True ∧
                      BitVec.zeroExtend (2 * 8) x✝² * BitVec.zeroExtend (2 * 8) x✝ ≥
                        BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
                  none
                else some (BitVec.ofBool (x✝¹ * x✝ >ᵤ x✝² * x✝))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x✝² x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(match some (if (!x✝ == 0#8) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } =>
              if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝¹ * BitVec.zeroExtend 16 x✝) = true then none
              else
                if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝² * BitVec.zeroExtend 16 x✝) = true then none
                else some (if (x✝¹ * x✝ >ᵤ x✝² * x✝) = true then 1#1 else 0#1)
            | some { toFin := ⟨0, ⋯⟩ } => some 1#1) ⊑
            match some (if (x✝ == 0#8) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 1#1
            | some { toFin := ⟨0, ⋯⟩ } =>
              if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝¹ * BitVec.zeroExtend 16 x✝) = true then none
              else
                if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝² * BitVec.zeroExtend 16 x✝) = true then none
                else some (if (x✝¹ * x✝ >ᵤ x✝² * x✝) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:529:8: warning: declaration uses 'sorry'
[bv] [0.044336] Normalizing goal
  [Meta.synthInstance] [0.001373] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) x✝¹ <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) x✝¹ ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else
            if
                True ∧
                  (BitVec.signExtend (2 * 8) (x✝ + 1#8) * BitVec.signExtend (2 * 8) x✝¹ <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) (x✝ + 1#8) * BitVec.signExtend (2 * 8) x✝¹ ≥
                      BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (x✝ * x✝¹ == (x✝ + 1#8) * x✝¹))) ⊑
          some (BitVec.ofBool (x✝¹ == 0#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) x✝¹ <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) x✝¹ ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else
              if
                  True ∧
                    (BitVec.signExtend (2 * 8) (x✝ + 1#8) * BitVec.signExtend (2 * 8) x✝¹ <
                        BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                      BitVec.signExtend (2 * 8) (x✝ + 1#8) * BitVec.signExtend (2 * 8) x✝¹ ≥
                        BitVec.twoPow (2 * 8) (8 - 1)) then
                none
              else some (BitVec.ofBool (x✝ * x✝¹ == (x✝ + 1#8) * x✝¹))) ⊑
            some (BitVec.ofBool (x✝¹ == 0#8))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * BitVec.signExtend 16 x✝¹) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * BitVec.signExtend 16 x✝¹)) =
                  true then
              none
            else
              if
                  (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ
                            BitVec.signExtend 16 (x✝ + 1#8) * BitVec.signExtend 16 x✝¹) &&
                        BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 (x✝ + 1#8) * BitVec.signExtend 16 x✝¹)) =
                    true then
                none
              else some (if (x✝ * x✝¹ == (x✝ + 1#8) * x✝¹) = true then 1#1 else 0#1)) ⊑
            some (if (x✝¹ == 0#8) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:541:8: warning: declaration uses 'sorry'
[bv] [0.041849] Normalizing goal
  [Meta.synthInstance] [0.001291] ✅️ Decidable
        ((if
              True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) x✝¹ ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
            none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 8) (x✝ + 1#8) * BitVec.zeroExtend (2 * 8) x✝¹ ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else some (BitVec.ofBool (x✝ * x✝¹ == (x✝ + 1#8) * x✝¹))) ⊑
          some (BitVec.ofBool (x✝¹ == 0#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) x✝¹ ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 8) (x✝ + 1#8) * BitVec.zeroExtend (2 * 8) x✝¹ ≥
                      BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
                none
              else some (BitVec.ofBool (x✝ * x✝¹ == (x✝ + 1#8) * x✝¹))) ⊑
            some (BitVec.ofBool (x✝¹ == 0#8))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * BitVec.zeroExtend 16 x✝¹) = true then none
            else
              if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 (x✝ + 1#8) * BitVec.zeroExtend 16 x✝¹) = true then
                none
              else some (if (x✝ * x✝¹ == (x✝ + 1#8) * x✝¹) = true then 1#1 else 0#1)) ⊑
            some (if (x✝¹ == 0#8) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:553:8: warning: declaration uses 'sorry'
[bv] [0.044822] Normalizing goal
  [Meta.synthInstance] [0.001426] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) x✝¹ <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) x✝¹ ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else
            if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) (x✝ + 1#8) <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) (x✝ + 1#8) ≥
                      BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (x✝ * x✝¹ == x✝¹ * (x✝ + 1#8)))) ⊑
          some (BitVec.ofBool (x✝¹ == 0#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) x✝¹ <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) x✝¹ ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else
              if
                  True ∧
                    (BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) (x✝ + 1#8) <
                        BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                      BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) (x✝ + 1#8) ≥
                        BitVec.twoPow (2 * 8) (8 - 1)) then
                none
              else some (BitVec.ofBool (x✝ * x✝¹ == x✝¹ * (x✝ + 1#8)))) ⊑
            some (BitVec.ofBool (x✝¹ == 0#8))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * BitVec.signExtend 16 x✝¹) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * BitVec.signExtend 16 x✝¹)) =
                  true then
              none
            else
              if
                  (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ
                            BitVec.signExtend 16 x✝¹ * BitVec.signExtend 16 (x✝ + 1#8)) &&
                        BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝¹ * BitVec.signExtend 16 (x✝ + 1#8))) =
                    true then
                none
              else some (if (x✝ * x✝¹ == x✝¹ * (x✝ + 1#8)) = true then 1#1 else 0#1)) ⊑
            some (if (x✝¹ == 0#8) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:565:8: warning: declaration uses 'sorry'
[bv] [0.045306] Normalizing goal
  [Meta.synthInstance] [0.001393] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) x✝¹ <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) x✝¹ ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else
            if
                True ∧
                  (BitVec.signExtend (2 * 8) (x✝ + 1#8) * BitVec.signExtend (2 * 8) x✝¹ <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) (x✝ + 1#8) * BitVec.signExtend (2 * 8) x✝¹ ≥
                      BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (x✝ * x✝¹ != (x✝ + 1#8) * x✝¹))) ⊑
          some (BitVec.ofBool (x✝¹ != 0#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) x✝¹ <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) x✝¹ ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else
              if
                  True ∧
                    (BitVec.signExtend (2 * 8) (x✝ + 1#8) * BitVec.signExtend (2 * 8) x✝¹ <
                        BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                      BitVec.signExtend (2 * 8) (x✝ + 1#8) * BitVec.signExtend (2 * 8) x✝¹ ≥
                        BitVec.twoPow (2 * 8) (8 - 1)) then
                none
              else some (BitVec.ofBool (x✝ * x✝¹ != (x✝ + 1#8) * x✝¹))) ⊑
            some (BitVec.ofBool (x✝¹ != 0#8))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * BitVec.signExtend 16 x✝¹) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * BitVec.signExtend 16 x✝¹)) =
                  true then
              none
            else
              if
                  (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ
                            BitVec.signExtend 16 (x✝ + 1#8) * BitVec.signExtend 16 x✝¹) &&
                        BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 (x✝ + 1#8) * BitVec.signExtend 16 x✝¹)) =
                    true then
                none
              else some (if (!x✝ * x✝¹ == (x✝ + 1#8) * x✝¹) = true then 1#1 else 0#1)) ⊑
            some (if (!x✝¹ == 0#8) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:577:8: warning: declaration uses 'sorry'
[bv] [0.050840] Normalizing goal
  [Meta.synthInstance] [0.001252] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else
            if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 7#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (x✝¹ * 7#8 >ₛ x✝ * 7#8))) ⊑
          some (BitVec.ofBool (x✝¹ >ₛ x✝)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else
              if
                  True ∧
                    (BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 7#8 <
                        BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                      BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 7#8 ≥
                        BitVec.twoPow (2 * 8) (8 - 1)) then
                none
              else some (BitVec.ofBool (x✝¹ * 7#8 >ₛ x✝ * 7#8))) ⊑
            some (BitVec.ofBool (x✝¹ >ₛ x✝))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                  true then
              none
            else
              if
                  (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝¹ * 7#16) &&
                        BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝¹ * 7#16)) =
                    true then
                none
              else
                some
                  (if (!(!(x✝ * 7#8).getLsbD 7 == (x✝¹ * 7#8).getLsbD 7) == (x✝¹ * 7#8 >ᵤ x✝ * 7#8)) = true then 1#1
                  else 0#1)) ⊑
            some (if (!(!x✝.getLsbD 7 == x✝¹.getLsbD 7) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:589:8: warning: declaration uses 'sorry'
[bv] [0.052583] Normalizing goal
  [Meta.synthInstance] [0.001221] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else
            if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 7#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (x✝¹ * 7#8 ≥ₛ x✝ * 7#8))) ⊑
          some (BitVec.ofBool (x✝¹ ≥ₛ x✝)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else
              if
                  True ∧
                    (BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 7#8 <
                        BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                      BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 7#8 ≥
                        BitVec.twoPow (2 * 8) (8 - 1)) then
                none
              else some (BitVec.ofBool (x✝¹ * 7#8 ≥ₛ x✝ * 7#8))) ⊑
            some (BitVec.ofBool (x✝¹ ≥ₛ x✝))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                  true then
              none
            else
              if
                  (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝¹ * 7#16) &&
                        BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝¹ * 7#16)) =
                    true then
                none
              else
                some
                  (if ((!(x✝¹ * 7#8).getLsbD 7 == (x✝ * 7#8).getLsbD 7) == (x✝ * 7#8 >ᵤ x✝¹ * 7#8)) = true then 1#1
                  else 0#1)) ⊑
            some (if ((!x✝¹.getLsbD 7 == x✝.getLsbD 7) == (x✝ >ᵤ x✝¹)) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:601:8: warning: declaration uses 'sorry'
[bv] [0.050851] Normalizing goal
  [Meta.synthInstance] [0.001194] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else
            if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 7#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (x✝ * 7#8 >ₛ x✝¹ * 7#8))) ⊑
          some (BitVec.ofBool (x✝ >ₛ x✝¹)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else
              if
                  True ∧
                    (BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 7#8 <
                        BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                      BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 7#8 ≥
                        BitVec.twoPow (2 * 8) (8 - 1)) then
                none
              else some (BitVec.ofBool (x✝ * 7#8 >ₛ x✝¹ * 7#8))) ⊑
            some (BitVec.ofBool (x✝ >ₛ x✝¹))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                  true then
              none
            else
              if
                  (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝¹ * 7#16) &&
                        BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝¹ * 7#16)) =
                    true then
                none
              else
                some
                  (if (!(!(x✝¹ * 7#8).getLsbD 7 == (x✝ * 7#8).getLsbD 7) == (x✝ * 7#8 >ᵤ x✝¹ * 7#8)) = true then 1#1
                  else 0#1)) ⊑
            some (if (!(!x✝¹.getLsbD 7 == x✝.getLsbD 7) == (x✝ >ᵤ x✝¹)) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:613:8: warning: declaration uses 'sorry'
[bv] [0.052758] Normalizing goal
  [Meta.synthInstance] [0.001208] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else
            if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 7#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (x✝ * 7#8 ≥ₛ x✝¹ * 7#8))) ⊑
          some (BitVec.ofBool (x✝ ≥ₛ x✝¹)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else
              if
                  True ∧
                    (BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 7#8 <
                        BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                      BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 7#8 ≥
                        BitVec.twoPow (2 * 8) (8 - 1)) then
                none
              else some (BitVec.ofBool (x✝ * 7#8 ≥ₛ x✝¹ * 7#8))) ⊑
            some (BitVec.ofBool (x✝ ≥ₛ x✝¹))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                  true then
              none
            else
              if
                  (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝¹ * 7#16) &&
                        BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝¹ * 7#16)) =
                    true then
                none
              else
                some
                  (if ((!(x✝ * 7#8).getLsbD 7 == (x✝¹ * 7#8).getLsbD 7) == (x✝¹ * 7#8 >ᵤ x✝ * 7#8)) = true then 1#1
                  else 0#1)) ⊑
            some (if ((!x✝.getLsbD 7 == x✝¹.getLsbD 7) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:625:8: warning: declaration uses 'sorry'
[bv] [0.050635] Normalizing goal
  [Meta.synthInstance] [0.001201] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else
            if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 249#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 249#8 ≥
                      BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (x✝¹ * 249#8 >ₛ x✝ * 249#8))) ⊑
          some (BitVec.ofBool (x✝ >ₛ x✝¹)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else
              if
                  True ∧
                    (BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 249#8 <
                        BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                      BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 249#8 ≥
                        BitVec.twoPow (2 * 8) (8 - 1)) then
                none
              else some (BitVec.ofBool (x✝¹ * 249#8 >ₛ x✝ * 249#8))) ⊑
            some (BitVec.ofBool (x✝ >ₛ x✝¹))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)) =
                  true then
              none
            else
              if
                  (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝¹ * 65529#16) &&
                        BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝¹ * 65529#16)) =
                    true then
                none
              else
                some
                  (if (!(!(x✝ * 249#8).getLsbD 7 == (x✝¹ * 249#8).getLsbD 7) == (x✝¹ * 249#8 >ᵤ x✝ * 249#8)) = true then
                    1#1
                  else 0#1)) ⊑
            some (if (!(!x✝¹.getLsbD 7 == x✝.getLsbD 7) == (x✝ >ᵤ x✝¹)) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
