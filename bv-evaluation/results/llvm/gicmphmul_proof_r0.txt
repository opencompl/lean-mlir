⚠ [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
⚠ [878/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [881/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
⚠ [887/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
⚠ [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:18:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:11:8: error: (kernel) declaration has metavariables 'squared_nsw_eq0_thm'
[bv] [0.037681] Normalizing goal
  [Meta.synthInstance] [0.001715] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 5) x✝ * BitVec.signExtend (2 * 5) x✝ <
                    BitVec.signExtend (2 * 5) (BitVec.twoPow 5 (5 - 1)) ∨
                  BitVec.signExtend (2 * 5) x✝ * BitVec.signExtend (2 * 5) x✝ ≥ BitVec.twoPow (2 * 5) (5 - 1)) then
            none
          else some (BitVec.ofBool (x✝ * x✝ == 0#5))) ⊑
          some (BitVec.ofBool (x✝ == 0#5)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 5
      x✝ : BitVec 5
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 5) x✝ * BitVec.signExtend (2 * 5) x✝ <
                      BitVec.signExtend (2 * 5) (BitVec.twoPow 5 (5 - 1)) ∨
                    BitVec.signExtend (2 * 5) x✝ * BitVec.signExtend (2 * 5) x✝ ≥ BitVec.twoPow (2 * 5) (5 - 1)) then
              none
            else some (BitVec.ofBool (x✝ * x✝ == 0#5))) ⊑
            some (BitVec.ofBool (x✝ == 0#5))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 5
      x✝ : BitVec 5
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 10 (BitVec.twoPow 5 4) >ᵤ BitVec.signExtend 10 x✝ * BitVec.signExtend 10 x✝) &&
                      BitVec.twoPow 10 4 >ᵤ BitVec.signExtend 10 x✝ * BitVec.signExtend 10 x✝)) =
                  true then
              none
            else some (if (x✝ * x✝ == 0#5) = true then 1#1 else 0#1)) ⊑
            some (if (x✝ == 0#5) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:29:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:22:8: error: (kernel) declaration has metavariables 'squared_nsw_sgt0_thm'
[bv] [0.053020] Normalizing goal
  [Meta.synthInstance] [0.001758] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 5) x✝ * BitVec.signExtend (2 * 5) x✝ <
                    BitVec.signExtend (2 * 5) (BitVec.twoPow 5 (5 - 1)) ∨
                  BitVec.signExtend (2 * 5) x✝ * BitVec.signExtend (2 * 5) x✝ ≥ BitVec.twoPow (2 * 5) (5 - 1)) then
            none
          else some (BitVec.ofBool (x✝ * x✝ >ₛ 0#5))) ⊑
          some (BitVec.ofBool (x✝ != 0#5)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 5
      x✝ : BitVec 5
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 5) x✝ * BitVec.signExtend (2 * 5) x✝ <
                      BitVec.signExtend (2 * 5) (BitVec.twoPow 5 (5 - 1)) ∨
                    BitVec.signExtend (2 * 5) x✝ * BitVec.signExtend (2 * 5) x✝ ≥ BitVec.twoPow (2 * 5) (5 - 1)) then
              none
            else some (BitVec.ofBool (x✝ * x✝ >ₛ 0#5))) ⊑
            some (BitVec.ofBool (x✝ != 0#5))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 5
      x✝ : BitVec 5
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 10 (BitVec.twoPow 5 4) >ᵤ BitVec.signExtend 10 x✝ * BitVec.signExtend 10 x✝) &&
                      BitVec.twoPow 10 4 >ᵤ BitVec.signExtend 10 x✝ * BitVec.signExtend 10 x✝)) =
                  true then
              none
            else some (if (!(x✝ * x✝).getLsbD 4 == !x✝ * x✝ == 0#5) = true then 1#1 else 0#1)) ⊑
            some (if (!x✝ == 0#5) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:40:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:33:8: error: (kernel) declaration has metavariables 'slt_positive_multip_rem_zero_thm'
[bv] [0.052565] Normalizing goal
  [Meta.synthInstance] [0.001966] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else some (BitVec.ofBool (21#8 >ₛ x✝ * 7#8))) ⊑
          some (BitVec.ofBool (3#8 >ₛ x✝)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (21#8 >ₛ x✝ * 7#8))) ⊑
            some (BitVec.ofBool (3#8 >ₛ x✝))
      ⊢ False
  [Meta.isDefEq] [0.004311] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7) (BitVec.signExtend 16 x✝ * 7#16))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                            (BitVec.twoPow 16 7)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16) true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                (congrArg
                  (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) && x))
                  (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
        (true_and
          ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
            true))
    [Meta.isDefEq.assign] [0.004307] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                        (BitVec.signExtend 16 x✝ * 7#16))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                              (BitVec.twoPow 16 7)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16) true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                  (congrArg
                    (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) && x))
                    (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
          (true_and
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.004268] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                  BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                          (BitVec.signExtend 16 x✝ * 7#16))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                                (BitVec.twoPow 16 7)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16) true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                      !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                    (congrArg
                      (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) && x))
                      (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
            (true_and
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                true)) : (True ∧
              (BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7)) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
              true))
        [Meta.isDefEq] [0.004264] ✅️ (True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                true) =?= (True ∧
                (BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7)) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                true)
          [Meta.isDefEq] [0.004234] ✅️ True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1)) =?= True ∧
                (BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7)
            [Meta.isDefEq] [0.004211] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1) =?= BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7
              [Meta.isDefEq] [0.004050] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8)
                      (BitVec.twoPow 8
                        (8 - 1)) =?= BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7)
                [Meta.isDefEq] [0.004013] ✅️ instLTBitVec.1
                      (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8)
                      (BitVec.signExtend (2 * 8)
                        (BitVec.twoPow 8
                          (8 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 16 x✝ * 7#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                  [Meta.isDefEq] [0.003924] ✅️ (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8).toNat <
                        (BitVec.signExtend (2 * 8)
                            (BitVec.twoPow 8
                              (8 -
                                1))).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat <
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                    [Meta.isDefEq] [0.003899] ✅️ instLTNat.1
                          (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8).toNat
                          (BitVec.signExtend (2 * 8)
                              (BitVec.twoPow 8
                                (8 -
                                  1))).toNat =?= instLTNat.1 (BitVec.signExtend 16 x✝ * 7#16).toNat
                          (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                      [Meta.isDefEq] [0.003848] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 7#8).toNat.lt
                            (BitVec.signExtend (2 * 8)
                                (BitVec.twoPow 8
                                  (8 -
                                    1))).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat.lt
                            (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                        [Meta.isDefEq.delta] [0.003829] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 7#8).toNat.lt
                              (BitVec.signExtend (2 * 8)
                                  (BitVec.twoPow 8
                                    (8 -
                                      1))).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat.lt
                              (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                          [Meta.isDefEq] [0.003679] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 7#8).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat
                            [Meta.isDefEq.delta] [0.003653] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 7#8).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat
                              [Meta.isDefEq] [0.003619] ✅️ BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 7#8 =?= BitVec.signExtend 16 x✝ * 7#16
                                [Meta.isDefEq] [0.003575] ✅️ instHMul.1 (BitVec.signExtend (2 * 8) x✝)
                                      (BitVec.signExtend (2 * 8) 7#8) =?= instHMul.1 (BitVec.signExtend 16 x✝) 7#16
                                  [Meta.isDefEq] [0.003455] ✅️ Mul.mul (BitVec.signExtend (2 * 8) x✝)
                                        (BitVec.signExtend (2 * 8) 7#8) =?= Mul.mul (BitVec.signExtend 16 x✝) 7#16
                                    [Meta.isDefEq] [0.003413] ✅️ BitVec.instMul.1 (BitVec.signExtend (2 * 8) x✝)
                                          (BitVec.signExtend (2 * 8)
                                            7#8) =?= BitVec.instMul.1 (BitVec.signExtend 16 x✝) 7#16
                                      [Meta.isDefEq] [0.003337] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                            (BitVec.signExtend (2 * 8) 7#8) =?= (BitVec.signExtend 16 x✝).mul 7#16
                                        [Meta.isDefEq.delta] [0.003317] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                              (BitVec.signExtend (2 * 8) 7#8) =?= (BitVec.signExtend 16 x✝).mul 7#16
                                          [Meta.isDefEq] [0.003179] ✅️ BitVec.signExtend (2 * 8) 7#8 =?= 7#16
                                            [Meta.isDefEq] [0.003148] ✅️ BitVec.ofInt (2 * 8) (7#8).toInt =?= 7#16
                                              [Meta.isDefEq] [0.003120] ✅️ ((7#8).toInt %
                                                        Int.ofNat (2 ^ (2 * 8))).toNat#'⋯ =?= 7#16
                                                [Meta.isDefEq] [0.003081] ✅️ ((7#8).toInt %
                                                          Int.ofNat
                                                            (2 ^
                                                              (2 * 8))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 16) 7 }
                                                  [Meta.isDefEq] [0.003058] ✅️ {
                                                        toFin :=
                                                          ⟨((7#8).toInt % Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 16) 7 }
                                                    [Meta.isDefEq] [0.003002] ✅️ ⟨((7#8).toInt %
                                                              Int.ofNat (2 ^ (2 * 8))).toNat,
                                                          ⋯⟩ =?= Fin.ofNat' (2 ^ 16) 7
                                                      [Meta.isDefEq] [0.002976] ✅️ ⟨((7#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ =?= ⟨7 % 2 ^ 16, ⋯⟩
                                                        [Meta.isDefEq] [0.002822] ✅️ ((7#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat =?= 7 % 2 ^ 16
                                                          [Meta.isDefEq] [0.002680] ✅️ match
                                                                (7#8).toInt % Int.ofNat (2 ^ (2 * 8)) with
                                                              | Int.ofNat n => n
                                                              | Int.negSucc a => 0 =?= 7 % 2 ^ 16
                                                            [Meta.whnf] [0.002149] Non-easy whnf: (fun motive x h_1
                                                                      h_2 =>
                                                                    Int.casesOn x (fun a => h_1 a) fun a => h_2 a)
                                                                  (fun x => ℕ) ((7#8).toInt % Int.ofNat (2 ^ (2 * 8)))
                                                                  h_1 h_2
                                                              [Meta.whnf] [0.002111] Non-easy whnf: (7#8).toInt %
                                                                    Int.ofNat (2 ^ (2 * 8))
                                                                [Meta.whnf] [0.002100] Non-easy whnf: instHMod.1
                                                                      (7#8).toInt (Int.ofNat (2 ^ (2 * 8)))
                                                                  [Meta.whnf] [0.002071] Non-easy whnf: Int.instMod.1
                                                                        (7#8).toInt (Int.ofNat (2 ^ (2 * 8)))
                                                                    [Meta.whnf] [0.002043] Non-easy whnf: match
                                                                          (7#8).toInt, Int.ofNat (2 ^ (2 * 8)) with
                                                                        | Int.ofNat m, n => Int.ofNat (m % n.natAbs)
                                                                        | Int.negSucc m, n =>
                                                                          Int.subNatNat n.natAbs (m % n.natAbs).succ
                                                                      [Meta.whnf] [0.001970] Non-easy whnf: (fun motive
                                                                                x x_1 h_1 h_2 =>
                                                                              Int.casesOn x (fun a => h_1 a x_1)
                                                                                fun a => h_2 a x_1)
                                                                            (fun x x => ℤ) (7#8).toInt
                                                                            (Int.ofNat (2 ^ (2 * 8))) h_1 h_2
                                                                        [Meta.whnf] [0.001944] Non-easy whnf: (7#8).toInt
                                                                          [Meta.whnf] [0.001925] Non-easy whnf: if
                                                                                  2 * (7#8).toNat < 2 ^ 8 then
                                                                                ↑(7#8).toNat
                                                                              else ↑(7#8).toNat - ↑(2 ^ 8)
                                                                            [Meta.whnf] [0.001871] Non-easy whnf: Decidable.casesOn
                                                                                  ((2 * (7#8).toNat).decLt (2 ^ 8))
                                                                                  (fun x => ↑(7#8).toNat - ↑(2 ^ 8))
                                                                                  fun x => ↑(7#8).toNat
                                                                              [Meta.whnf] [0.001788] Non-easy whnf: (2 *
                                                                                        (7#8).toNat).decLt
                                                                                    (2 ^ 8)
                                                                                [Meta.whnf] [0.001771] Non-easy whnf: (2 *
                                                                                            (7#8).toNat).succ.decLe
                                                                                      (2 ^ 8)
                                                                                  [Meta.whnf] [0.001741] Non-easy whnf: if
                                                                                          h :
                                                                                          (2 * (7#8).toNat).succ.ble
                                                                                              (2 ^ 8) =
                                                                                            true then
                                                                                        isTrue ⋯
                                                                                      else isFalse ⋯
                                                                                    [Meta.whnf] [0.001712] Non-easy whnf: Decidable.casesOn
                                                                                          (instDecidableEqBool
                                                                                            ((2 * (7#8).toNat).succ.ble
                                                                                              (2 ^ 8))
                                                                                            true)
                                                                                          (fun h => isFalse ⋯) fun h =>
                                                                                          isTrue ⋯
                                                                                      [Meta.whnf] [0.001688] Non-easy whnf: instDecidableEqBool
                                                                                            ((2 * (7#8).toNat).succ.ble
                                                                                              (2 ^ 8))
                                                                                            true
                                                                                        [Meta.whnf] [0.001667] Non-easy whnf: ((2 *
                                                                                                        (7#8).toNat).succ.ble
                                                                                                  (2 ^ 8)).decEq
                                                                                              true
                                                                                          [Meta.whnf] [0.001648] Non-easy whnf: match
                                                                                                (2 *
                                                                                                        (7#8).toNat).succ.ble
                                                                                                  (2 ^ 8),
                                                                                                true with
                                                                                              | false, false => isTrue ⋯
                                                                                              | false, true => isFalse ⋯
                                                                                              | true, false => isFalse ⋯
                                                                                              | true, true => isTrue ⋯
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                  true then
              none
            else some (if (!(x✝ * 7#8).getLsbD 7 == (21#8 >ᵤ x✝ * 7#8)) = true then 1#1 else 0#1)) ⊑
            some (if (!x✝.getLsbD 7 == (3#8 >ᵤ x✝)) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:51:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:44:8: error: (kernel) declaration has metavariables 'slt_negative_multip_rem_zero_thm'
[bv] [0.067477] Normalizing goal
  [Meta.synthInstance] [0.002098] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else some (BitVec.ofBool (21#8 >ₛ x✝ * 249#8))) ⊑
          some (BitVec.ofBool (x✝ >ₛ 253#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (21#8 >ₛ x✝ * 249#8))) ⊑
            some (BitVec.ofBool (x✝ >ₛ 253#8))
      ⊢ False
  [Meta.isDefEq] [0.003092] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65529#16)
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                      (BitVec.signExtend 16 x✝ * 65529#16))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65529#16)
                            (BitVec.twoPow 16 7)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16) true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                (congrArg
                  (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) && x))
                  (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)))))))
        (true_and
          ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) &&
                BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)) =
            true))
    [Meta.isDefEq.assign] [0.003087] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65529#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                        (BitVec.signExtend 16 x✝ * 65529#16))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65529#16)
                              (BitVec.twoPow 16 7)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16) true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                  (congrArg
                    (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) && x))
                    (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)))))))
          (true_and
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.003043] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 <
                  BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65529#16)
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                          (BitVec.signExtend 16 x✝ * 65529#16))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65529#16)
                                (BitVec.twoPow 16 7)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16) true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                      !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                    (congrArg
                      (fun x =>
                        !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) && x))
                      (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)))))))
            (true_and
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)) =
                true)) : (True ∧
              (BitVec.signExtend 16 x✝ * 65529#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                BitVec.signExtend 16 x✝ * 65529#16 ≥ BitVec.twoPow 16 7)) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)) =
              true))
        [Meta.isDefEq] [0.003038] ✅️ (True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)) =
                true) =?= (True ∧
                (BitVec.signExtend 16 x✝ * 65529#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 65529#16 ≥ BitVec.twoPow 16 7)) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)) =
                true)
          [Meta.isDefEq] [0.003004] ✅️ True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1)) =?= True ∧
                (BitVec.signExtend 16 x✝ * 65529#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 65529#16 ≥ BitVec.twoPow 16 7)
            [Meta.isDefEq] [0.002986] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1) =?= BitVec.signExtend 16 x✝ * 65529#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 65529#16 ≥ BitVec.twoPow 16 7
              [Meta.isDefEq] [0.002810] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 <
                    BitVec.signExtend (2 * 8)
                      (BitVec.twoPow 8
                        (8 - 1)) =?= BitVec.signExtend 16 x✝ * 65529#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7)
                [Meta.isDefEq] [0.002778] ✅️ instLTBitVec.1
                      (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8)
                      (BitVec.signExtend (2 * 8)
                        (BitVec.twoPow 8
                          (8 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 16 x✝ * 65529#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                  [Meta.isDefEq] [0.002721] ✅️ (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8).toNat <
                        (BitVec.signExtend (2 * 8)
                            (BitVec.twoPow 8
                              (8 -
                                1))).toNat =?= (BitVec.signExtend 16 x✝ * 65529#16).toNat <
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                    [Meta.isDefEq] [0.002697] ✅️ instLTNat.1
                          (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8).toNat
                          (BitVec.signExtend (2 * 8)
                              (BitVec.twoPow 8
                                (8 -
                                  1))).toNat =?= instLTNat.1 (BitVec.signExtend 16 x✝ * 65529#16).toNat
                          (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                      [Meta.isDefEq] [0.002661] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 249#8).toNat.lt
                            (BitVec.signExtend (2 * 8)
                                (BitVec.twoPow 8
                                  (8 -
                                    1))).toNat =?= (BitVec.signExtend 16 x✝ * 65529#16).toNat.lt
                            (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                        [Meta.isDefEq.delta] [0.002641] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 249#8).toNat.lt
                              (BitVec.signExtend (2 * 8)
                                  (BitVec.twoPow 8
                                    (8 -
                                      1))).toNat =?= (BitVec.signExtend 16 x✝ * 65529#16).toNat.lt
                              (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                          [Meta.isDefEq] [0.002475] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 249#8).toNat =?= (BitVec.signExtend 16 x✝ * 65529#16).toNat
                            [Meta.isDefEq.delta] [0.002454] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8)
                                      249#8).toNat =?= (BitVec.signExtend 16 x✝ * 65529#16).toNat
                              [Meta.isDefEq] [0.002434] ✅️ BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 249#8 =?= BitVec.signExtend 16 x✝ * 65529#16
                                [Meta.isDefEq] [0.002402] ✅️ instHMul.1 (BitVec.signExtend (2 * 8) x✝)
                                      (BitVec.signExtend (2 * 8)
                                        249#8) =?= instHMul.1 (BitVec.signExtend 16 x✝) 65529#16
                                  [Meta.isDefEq] [0.002349] ✅️ Mul.mul (BitVec.signExtend (2 * 8) x✝)
                                        (BitVec.signExtend (2 * 8) 249#8) =?= Mul.mul (BitVec.signExtend 16 x✝) 65529#16
                                    [Meta.isDefEq] [0.002318] ✅️ BitVec.instMul.1 (BitVec.signExtend (2 * 8) x✝)
                                          (BitVec.signExtend (2 * 8)
                                            249#8) =?= BitVec.instMul.1 (BitVec.signExtend 16 x✝) 65529#16
                                      [Meta.isDefEq] [0.002236] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                            (BitVec.signExtend (2 * 8) 249#8) =?= (BitVec.signExtend 16 x✝).mul 65529#16
                                        [Meta.isDefEq.delta] [0.002218] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                              (BitVec.signExtend (2 * 8)
                                                249#8) =?= (BitVec.signExtend 16 x✝).mul 65529#16
                                          [Meta.isDefEq] [0.002131] ✅️ BitVec.signExtend (2 * 8) 249#8 =?= 65529#16
                                            [Meta.isDefEq] [0.002098] ✅️ BitVec.ofInt (2 * 8) (249#8).toInt =?= 65529#16
                                              [Meta.isDefEq] [0.002074] ✅️ ((249#8).toInt %
                                                        Int.ofNat (2 ^ (2 * 8))).toNat#'⋯ =?= 65529#16
                                                [Meta.isDefEq] [0.002047] ✅️ ((249#8).toInt %
                                                          Int.ofNat
                                                            (2 ^
                                                              (2 *
                                                                8))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 16) 65529 }
                                                  [Meta.isDefEq] [0.002026] ✅️ {
                                                        toFin :=
                                                          ⟨((249#8).toInt % Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 16) 65529 }
                                                    [Meta.isDefEq] [0.001995] ✅️ ⟨((249#8).toInt %
                                                              Int.ofNat (2 ^ (2 * 8))).toNat,
                                                          ⋯⟩ =?= Fin.ofNat' (2 ^ 16) 65529
                                                      [Meta.isDefEq] [0.001971] ✅️ ⟨((249#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ =?= ⟨65529 % 2 ^ 16, ⋯⟩
                                                        [Meta.isDefEq] [0.001899] ✅️ ((249#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat =?= 65529 % 2 ^ 16
                                                          [Meta.isDefEq] [0.001838] ✅️ match
                                                                (249#8).toInt % Int.ofNat (2 ^ (2 * 8)) with
                                                              | Int.ofNat n => n
                                                              | Int.negSucc a => 0 =?= 65529 % 2 ^ 16
                                                            [Meta.whnf] [0.001466] Non-easy whnf: (fun motive x h_1
                                                                      h_2 =>
                                                                    Int.casesOn x (fun a => h_1 a) fun a => h_2 a)
                                                                  (fun x => ℕ) ((249#8).toInt % Int.ofNat (2 ^ (2 * 8)))
                                                                  h_1 h_2
                                                              [Meta.whnf] [0.001425] Non-easy whnf: (249#8).toInt %
                                                                    Int.ofNat (2 ^ (2 * 8))
                                                                [Meta.whnf] [0.001415] Non-easy whnf: instHMod.1
                                                                      (249#8).toInt (Int.ofNat (2 ^ (2 * 8)))
                                                                  [Meta.whnf] [0.001403] Non-easy whnf: Int.instMod.1
                                                                        (249#8).toInt (Int.ofNat (2 ^ (2 * 8)))
                                                                    [Meta.whnf] [0.001388] Non-easy whnf: match
                                                                          (249#8).toInt, Int.ofNat (2 ^ (2 * 8)) with
                                                                        | Int.ofNat m, n => Int.ofNat (m % n.natAbs)
                                                                        | Int.negSucc m, n =>
                                                                          Int.subNatNat n.natAbs (m % n.natAbs).succ
                                                                      [Meta.whnf] [0.001124] Non-easy whnf: (fun motive
                                                                                x x_1 h_1 h_2 =>
                                                                              Int.casesOn x (fun a => h_1 a x_1)
                                                                                fun a => h_2 a x_1)
                                                                            (fun x x => ℤ) (249#8).toInt
                                                                            (Int.ofNat (2 ^ (2 * 8))) h_1 h_2
                                                                        [Meta.whnf] [0.001100] Non-easy whnf: (249#8).toInt
                                                                          [Meta.whnf] [0.001080] Non-easy whnf: if
                                                                                  2 * (249#8).toNat < 2 ^ 8 then
                                                                                ↑(249#8).toNat
                                                                              else ↑(249#8).toNat - ↑(2 ^ 8)
                                                                            [Meta.whnf] [0.001056] Non-easy whnf: Decidable.casesOn
                                                                                  ((2 * (249#8).toNat).decLt (2 ^ 8))
                                                                                  (fun x => ↑(249#8).toNat - ↑(2 ^ 8))
                                                                                  fun x => ↑(249#8).toNat
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)) =
                  true then
              none
            else some (if (!(x✝ * 249#8).getLsbD 7 == (21#8 >ᵤ x✝ * 249#8)) = true then 1#1 else 0#1)) ⊑
            some (if (!(!x✝.getLsbD 7) == (x✝ >ᵤ 253#8)) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:62:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:55:8: error: (kernel) declaration has metavariables 'slt_positive_multip_rem_nz_thm'
[bv] [0.043299] Normalizing goal
  [Meta.synthInstance] [0.001373] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else some (BitVec.ofBool (21#8 >ₛ x✝ * 5#8))) ⊑
          some (BitVec.ofBool (5#8 >ₛ x✝)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (21#8 >ₛ x✝ * 5#8))) ⊑
            some (BitVec.ofBool (5#8 >ₛ x✝))
      ⊢ False
  [Meta.isDefEq] [0.002403] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7) (BitVec.signExtend 16 x✝ * 5#16))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                            (BitVec.twoPow 16 7)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                (congrArg
                  (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                  (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
        (true_and
          ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
            true))
    [Meta.isDefEq.assign] [0.002400] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                        (BitVec.signExtend 16 x✝ * 5#16))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                              (BitVec.twoPow 16 7)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  (congrArg
                    (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                    (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
          (true_and
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.002364] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                  BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                          (BitVec.signExtend 16 x✝ * 5#16))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                                (BitVec.twoPow 16 7)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                      !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    (congrArg
                      (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                      (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
            (true_and
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true)) : (True ∧
              (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true))
        [Meta.isDefEq] [0.002360] ✅️ (True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true) =?= (True ∧
                (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true)
          [Meta.isDefEq] [0.002333] ✅️ True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1)) =?= True ∧
                (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)
            [Meta.isDefEq] [0.002313] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1) =?= BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7
              [Meta.isDefEq] [0.002165] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8)
                      (BitVec.twoPow 8
                        (8 - 1)) =?= BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7)
                [Meta.isDefEq] [0.002129] ✅️ instLTBitVec.1
                      (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8)
                      (BitVec.signExtend (2 * 8)
                        (BitVec.twoPow 8
                          (8 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 16 x✝ * 5#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                  [Meta.isDefEq] [0.002049] ✅️ (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8).toNat <
                        (BitVec.signExtend (2 * 8)
                            (BitVec.twoPow 8
                              (8 -
                                1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat <
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                    [Meta.isDefEq] [0.002026] ✅️ instLTNat.1
                          (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8).toNat
                          (BitVec.signExtend (2 * 8)
                              (BitVec.twoPow 8
                                (8 -
                                  1))).toNat =?= instLTNat.1 (BitVec.signExtend 16 x✝ * 5#16).toNat
                          (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                      [Meta.isDefEq] [0.001985] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 5#8).toNat.lt
                            (BitVec.signExtend (2 * 8)
                                (BitVec.twoPow 8
                                  (8 -
                                    1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat.lt
                            (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                        [Meta.isDefEq.delta] [0.001969] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8).toNat.lt
                              (BitVec.signExtend (2 * 8)
                                  (BitVec.twoPow 8
                                    (8 -
                                      1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat.lt
                              (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                          [Meta.isDefEq] [0.001840] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 5#8).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat
                            [Meta.isDefEq.delta] [0.001822] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat
                              [Meta.isDefEq] [0.001795] ✅️ BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8 =?= BitVec.signExtend 16 x✝ * 5#16
                                [Meta.isDefEq] [0.001757] ✅️ instHMul.1 (BitVec.signExtend (2 * 8) x✝)
                                      (BitVec.signExtend (2 * 8) 5#8) =?= instHMul.1 (BitVec.signExtend 16 x✝) 5#16
                                  [Meta.isDefEq] [0.001694] ✅️ Mul.mul (BitVec.signExtend (2 * 8) x✝)
                                        (BitVec.signExtend (2 * 8) 5#8) =?= Mul.mul (BitVec.signExtend 16 x✝) 5#16
                                    [Meta.isDefEq] [0.001666] ✅️ BitVec.instMul.1 (BitVec.signExtend (2 * 8) x✝)
                                          (BitVec.signExtend (2 * 8)
                                            5#8) =?= BitVec.instMul.1 (BitVec.signExtend 16 x✝) 5#16
                                      [Meta.isDefEq] [0.001614] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                            (BitVec.signExtend (2 * 8) 5#8) =?= (BitVec.signExtend 16 x✝).mul 5#16
                                        [Meta.isDefEq.delta] [0.001601] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                              (BitVec.signExtend (2 * 8) 5#8) =?= (BitVec.signExtend 16 x✝).mul 5#16
                                          [Meta.isDefEq] [0.001502] ✅️ BitVec.signExtend (2 * 8) 5#8 =?= 5#16
                                            [Meta.isDefEq] [0.001479] ✅️ BitVec.ofInt (2 * 8) (5#8).toInt =?= 5#16
                                              [Meta.isDefEq] [0.001455] ✅️ ((5#8).toInt %
                                                        Int.ofNat (2 ^ (2 * 8))).toNat#'⋯ =?= 5#16
                                                [Meta.isDefEq] [0.001429] ✅️ ((5#8).toInt %
                                                          Int.ofNat
                                                            (2 ^
                                                              (2 * 8))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 16) 5 }
                                                  [Meta.isDefEq] [0.001408] ✅️ {
                                                        toFin :=
                                                          ⟨((5#8).toInt % Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 16) 5 }
                                                    [Meta.isDefEq] [0.001366] ✅️ ⟨((5#8).toInt %
                                                              Int.ofNat (2 ^ (2 * 8))).toNat,
                                                          ⋯⟩ =?= Fin.ofNat' (2 ^ 16) 5
                                                      [Meta.isDefEq] [0.001346] ✅️ ⟨((5#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ =?= ⟨5 % 2 ^ 16, ⋯⟩
                                                        [Meta.isDefEq] [0.001241] ✅️ ((5#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat =?= 5 % 2 ^ 16
                                                          [Meta.isDefEq] [0.001149] ✅️ match
                                                                (5#8).toInt % Int.ofNat (2 ^ (2 * 8)) with
                                                              | Int.ofNat n => n
                                                              | Int.negSucc a => 0 =?= 5 % 2 ^ 16
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                  true then
              none
            else some (if (!(x✝ * 5#8).getLsbD 7 == (21#8 >ᵤ x✝ * 5#8)) = true then 1#1 else 0#1)) ⊑
            some (if (!x✝.getLsbD 7 == (5#8 >ᵤ x✝)) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:73:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:66:8: error: (kernel) declaration has metavariables 'ult_rem_zero_thm'
[bv] [0.031525] Normalizing goal
  [Meta.synthInstance] [0.001349] ✅️ Decidable
        ((if
              True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
            none
          else some (BitVec.ofBool (21#8 >ᵤ x✝ * 7#8))) ⊑
          some (BitVec.ofBool (3#8 >ᵤ x✝)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else some (BitVec.ofBool (21#8 >ᵤ x✝ * 7#8))) ⊑
            some (BitVec.ofBool (3#8 >ᵤ x✝))
      ⊢ False
  [Meta.isDefEq] [0.001644] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1) (BitVec.zeroExtend 16 x✝ * 7#16))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 7#16)
                      (BitVec.twoPow 16 7 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16)))))))
        (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true))
    [Meta.isDefEq.assign] [0.001642] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                  (BitVec.zeroExtend 16 x✝ * 7#16))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 7#16)
                        (BitVec.twoPow 16 7 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16)))))))
          (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001625] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                    (BitVec.zeroExtend 16 x✝ * 7#16))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 7#16)
                          (BitVec.twoPow 16 7 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16)))))))
            (true_and
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) =
                true)) : (True ∧ BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true))
        [Meta.isDefEq] [0.001621] ✅️ (True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) =
                true) =?= (True ∧ BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true)
          [Meta.isDefEq] [0.001600] ✅️ True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1
            [Meta.isDefEq] [0.001585] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1
              [Meta.isDefEq.delta] [0.001564] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1
                [Meta.isDefEq] [0.001069] ✅️ BitVec.zeroExtend (2 * 8) x✝ *
                      BitVec.zeroExtend (2 * 8) 7#8 =?= BitVec.zeroExtend 16 x✝ * 7#16
                  [Meta.isDefEq] [0.001035] ✅️ instHMul.1 (BitVec.zeroExtend (2 * 8) x✝)
                        (BitVec.zeroExtend (2 * 8) 7#8) =?= instHMul.1 (BitVec.zeroExtend 16 x✝) 7#16
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true then none
            else some (if (21#8 >ᵤ x✝ * 7#8) = true then 1#1 else 0#1)) ⊑
            some (if (3#8 >ᵤ x✝) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:84:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:77:8: error: (kernel) declaration has metavariables 'ult_rem_zero_nsw_thm'
[bv] [0.046687] Normalizing goal
  [Meta.synthInstance] [0.001501] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else some (BitVec.ofBool (21#8 >ᵤ x✝ * 7#8))) ⊑
          some (BitVec.ofBool (3#8 >ᵤ x✝)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                      BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
                none
              else some (BitVec.ofBool (21#8 >ᵤ x✝ * 7#8))) ⊑
            some (BitVec.ofBool (3#8 >ᵤ x✝))
      ⊢ False
  [Meta.isDefEq] [0.002031] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7) (BitVec.signExtend 16 x✝ * 7#16))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                            (BitVec.twoPow 16 7)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16) true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                (congrArg
                  (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) && x))
                  (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
        (true_and
          ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
            true))
    [Meta.isDefEq.assign] [0.002028] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                        (BitVec.signExtend 16 x✝ * 7#16))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                              (BitVec.twoPow 16 7)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16) true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                  (congrArg
                    (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) && x))
                    (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
          (true_and
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.002002] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                  BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                          (BitVec.signExtend 16 x✝ * 7#16))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                                (BitVec.twoPow 16 7)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16) true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                      !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                    (congrArg
                      (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) && x))
                      (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
            (true_and
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                true)) : (True ∧
              (BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7)) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
              true))
        [Meta.isDefEq] [0.001999] ✅️ (True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                true) =?= (True ∧
                (BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7)) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                true)
          [Meta.isDefEq] [0.001979] ✅️ True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1)) =?= True ∧
                (BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7)
            [Meta.isDefEq] [0.001963] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1) =?= BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7
              [Meta.isDefEq] [0.001849] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8)
                      (BitVec.twoPow 8
                        (8 - 1)) =?= BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7)
                [Meta.isDefEq] [0.001826] ✅️ instLTBitVec.1
                      (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8)
                      (BitVec.signExtend (2 * 8)
                        (BitVec.twoPow 8
                          (8 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 16 x✝ * 7#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                  [Meta.isDefEq] [0.001778] ✅️ (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8).toNat <
                        (BitVec.signExtend (2 * 8)
                            (BitVec.twoPow 8
                              (8 -
                                1))).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat <
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                    [Meta.isDefEq] [0.001765] ✅️ instLTNat.1
                          (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8).toNat
                          (BitVec.signExtend (2 * 8)
                              (BitVec.twoPow 8
                                (8 -
                                  1))).toNat =?= instLTNat.1 (BitVec.signExtend 16 x✝ * 7#16).toNat
                          (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                      [Meta.isDefEq] [0.001705] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 7#8).toNat.lt
                            (BitVec.signExtend (2 * 8)
                                (BitVec.twoPow 8
                                  (8 -
                                    1))).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat.lt
                            (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                        [Meta.isDefEq.delta] [0.001693] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 7#8).toNat.lt
                              (BitVec.signExtend (2 * 8)
                                  (BitVec.twoPow 8
                                    (8 -
                                      1))).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat.lt
                              (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                          [Meta.isDefEq] [0.001587] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 7#8).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat
                            [Meta.isDefEq.delta] [0.001572] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 7#8).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat
                              [Meta.isDefEq] [0.001550] ✅️ BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 7#8 =?= BitVec.signExtend 16 x✝ * 7#16
                                [Meta.isDefEq] [0.001522] ✅️ instHMul.1 (BitVec.signExtend (2 * 8) x✝)
                                      (BitVec.signExtend (2 * 8) 7#8) =?= instHMul.1 (BitVec.signExtend 16 x✝) 7#16
                                  [Meta.isDefEq] [0.001467] ✅️ Mul.mul (BitVec.signExtend (2 * 8) x✝)
                                        (BitVec.signExtend (2 * 8) 7#8) =?= Mul.mul (BitVec.signExtend 16 x✝) 7#16
                                    [Meta.isDefEq] [0.001444] ✅️ BitVec.instMul.1 (BitVec.signExtend (2 * 8) x✝)
                                          (BitVec.signExtend (2 * 8)
                                            7#8) =?= BitVec.instMul.1 (BitVec.signExtend 16 x✝) 7#16
                                      [Meta.isDefEq] [0.001396] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                            (BitVec.signExtend (2 * 8) 7#8) =?= (BitVec.signExtend 16 x✝).mul 7#16
                                        [Meta.isDefEq.delta] [0.001385] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                              (BitVec.signExtend (2 * 8) 7#8) =?= (BitVec.signExtend 16 x✝).mul 7#16
                                          [Meta.isDefEq] [0.001302] ✅️ BitVec.signExtend (2 * 8) 7#8 =?= 7#16
                                            [Meta.isDefEq] [0.001284] ✅️ BitVec.ofInt (2 * 8) (7#8).toInt =?= 7#16
                                              [Meta.isDefEq] [0.001267] ✅️ ((7#8).toInt %
                                                        Int.ofNat (2 ^ (2 * 8))).toNat#'⋯ =?= 7#16
                                                [Meta.isDefEq] [0.001248] ✅️ ((7#8).toInt %
                                                          Int.ofNat
                                                            (2 ^
                                                              (2 * 8))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 16) 7 }
                                                  [Meta.isDefEq] [0.001232] ✅️ {
                                                        toFin :=
                                                          ⟨((7#8).toInt % Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 16) 7 }
                                                    [Meta.isDefEq] [0.001177] ✅️ ⟨((7#8).toInt %
                                                              Int.ofNat (2 ^ (2 * 8))).toNat,
                                                          ⋯⟩ =?= Fin.ofNat' (2 ^ 16) 7
                                                      [Meta.isDefEq] [0.001159] ✅️ ⟨((7#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ =?= ⟨7 % 2 ^ 16, ⋯⟩
                                                        [Meta.isDefEq] [0.001057] ✅️ ((7#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat =?= 7 % 2 ^ 16
  [Meta.isDefEq] [0.001160] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1) (BitVec.zeroExtend 16 x✝ * 7#16))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 7#16)
                      (BitVec.twoPow 16 7 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16)))))))
        (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true))
    [Meta.isDefEq.assign] [0.001157] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                  (BitVec.zeroExtend 16 x✝ * 7#16))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 7#16)
                        (BitVec.twoPow 16 7 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16)))))))
          (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001140] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                    (BitVec.zeroExtend 16 x✝ * 7#16))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 7#16)
                          (BitVec.twoPow 16 7 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16)))))))
            (true_and
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) =
                true)) : (True ∧ BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true))
        [Meta.isDefEq] [0.001136] ✅️ (True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) =
                true) =?= (True ∧ BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true)
          [Meta.isDefEq] [0.001116] ✅️ True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1
            [Meta.isDefEq] [0.001105] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1
              [Meta.isDefEq.delta] [0.001082] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                  true then
              none
            else
              if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true then none
              else some (if (21#8 >ᵤ x✝ * 7#8) = true then 1#1 else 0#1)) ⊑
            some (if (3#8 >ᵤ x✝) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:95:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:88:8: error: (kernel) declaration has metavariables 'ult_rem_nz_thm'
[bv] [0.038758] Normalizing goal
  [Meta.synthInstance] [0.001652] ✅️ Decidable
        ((if
              True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
            none
          else some (BitVec.ofBool (21#8 >ᵤ x✝ * 5#8))) ⊑
          some (BitVec.ofBool (5#8 >ᵤ x✝)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else some (BitVec.ofBool (21#8 >ᵤ x✝ * 5#8))) ⊑
            some (BitVec.ofBool (5#8 >ᵤ x✝))
      ⊢ False
  [Meta.isDefEq] [0.001957] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1) (BitVec.zeroExtend 16 x✝ * 5#16))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                      (BitVec.twoPow 16 7 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
        (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
    [Meta.isDefEq.assign] [0.001953] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                  (BitVec.zeroExtend 16 x✝ * 5#16))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                        (BitVec.twoPow 16 7 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
          (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001934] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                    (BitVec.zeroExtend 16 x✝ * 5#16))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                          (BitVec.twoPow 16 7 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
            (true_and
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
                true)) : (True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
        [Meta.isDefEq] [0.001930] ✅️ (True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
                true) =?= (True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true)
          [Meta.isDefEq] [0.001905] ✅️ True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1
            [Meta.isDefEq] [0.001886] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1
              [Meta.isDefEq.delta] [0.001860] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1
                [Meta.isDefEq] [0.001308] ✅️ BitVec.zeroExtend (2 * 8) x✝ *
                      BitVec.zeroExtend (2 * 8) 5#8 =?= BitVec.zeroExtend 16 x✝ * 5#16
                  [Meta.isDefEq] [0.001273] ✅️ instHMul.1 (BitVec.zeroExtend (2 * 8) x✝)
                        (BitVec.zeroExtend (2 * 8) 5#8) =?= instHMul.1 (BitVec.zeroExtend 16 x✝) 5#16
                    [Meta.isDefEq] [0.001170] ✅️ Mul.mul (BitVec.zeroExtend (2 * 8) x✝)
                          (BitVec.zeroExtend (2 * 8) 5#8) =?= Mul.mul (BitVec.zeroExtend 16 x✝) 5#16
                      [Meta.isDefEq] [0.001138] ✅️ BitVec.instMul.1 (BitVec.zeroExtend (2 * 8) x✝)
                            (BitVec.zeroExtend (2 * 8) 5#8) =?= BitVec.instMul.1 (BitVec.zeroExtend 16 x✝) 5#16
                        [Meta.isDefEq] [0.001079] ✅️ (BitVec.zeroExtend (2 * 8) x✝).mul
                              (BitVec.zeroExtend (2 * 8) 5#8) =?= (BitVec.zeroExtend 16 x✝).mul 5#16
                          [Meta.isDefEq.delta] [0.001062] ✅️ (BitVec.zeroExtend (2 * 8) x✝).mul
                                (BitVec.zeroExtend (2 * 8) 5#8) =?= (BitVec.zeroExtend 16 x✝).mul 5#16
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true then none
            else some (if (21#8 >ᵤ x✝ * 5#8) = true then 1#1 else 0#1)) ⊑
            some (if (5#8 >ᵤ x✝) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:106:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:99:8: error: (kernel) declaration has metavariables 'ult_rem_nz_nsw_thm'
[bv] [0.066104] Normalizing goal
  [Meta.synthInstance] [0.001855] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else some (BitVec.ofBool (21#8 >ᵤ x✝ * 5#8))) ⊑
          some (BitVec.ofBool (5#8 >ᵤ x✝)))
    [Meta.check] [0.001050] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else some (BitVec.ofBool (21#8 >ᵤ x✝ * 5#8)))
          (some (BitVec.ofBool (5#8 >ᵤ x✝)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                      BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
                none
              else some (BitVec.ofBool (21#8 >ᵤ x✝ * 5#8))) ⊑
            some (BitVec.ofBool (5#8 >ᵤ x✝))
      ⊢ False
  [Meta.isDefEq] [0.002918] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7) (BitVec.signExtend 16 x✝ * 5#16))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                            (BitVec.twoPow 16 7)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                (congrArg
                  (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                  (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
        (true_and
          ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
            true))
    [Meta.isDefEq.assign] [0.002914] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                        (BitVec.signExtend 16 x✝ * 5#16))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                              (BitVec.twoPow 16 7)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  (congrArg
                    (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                    (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
          (true_and
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.002873] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                  BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                          (BitVec.signExtend 16 x✝ * 5#16))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                                (BitVec.twoPow 16 7)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                      !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    (congrArg
                      (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                      (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
            (true_and
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true)) : (True ∧
              (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true))
        [Meta.isDefEq] [0.002868] ✅️ (True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true) =?= (True ∧
                (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true)
          [Meta.isDefEq] [0.002833] ✅️ True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1)) =?= True ∧
                (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)
            [Meta.isDefEq] [0.002807] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1) =?= BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7
              [Meta.isDefEq] [0.002623] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8)
                      (BitVec.twoPow 8
                        (8 - 1)) =?= BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7)
                [Meta.isDefEq] [0.002589] ✅️ instLTBitVec.1
                      (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8)
                      (BitVec.signExtend (2 * 8)
                        (BitVec.twoPow 8
                          (8 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 16 x✝ * 5#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                  [Meta.isDefEq] [0.002515] ✅️ (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8).toNat <
                        (BitVec.signExtend (2 * 8)
                            (BitVec.twoPow 8
                              (8 -
                                1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat <
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                    [Meta.isDefEq] [0.002492] ✅️ instLTNat.1
                          (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8).toNat
                          (BitVec.signExtend (2 * 8)
                              (BitVec.twoPow 8
                                (8 -
                                  1))).toNat =?= instLTNat.1 (BitVec.signExtend 16 x✝ * 5#16).toNat
                          (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                      [Meta.isDefEq] [0.002447] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 5#8).toNat.lt
                            (BitVec.signExtend (2 * 8)
                                (BitVec.twoPow 8
                                  (8 -
                                    1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat.lt
                            (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                        [Meta.isDefEq.delta] [0.002428] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8).toNat.lt
                              (BitVec.signExtend (2 * 8)
                                  (BitVec.twoPow 8
                                    (8 -
                                      1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat.lt
                              (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                          [Meta.isDefEq] [0.002265] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 5#8).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat
                            [Meta.isDefEq.delta] [0.002245] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat
                              [Meta.isDefEq] [0.002212] ✅️ BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8 =?= BitVec.signExtend 16 x✝ * 5#16
                                [Meta.isDefEq] [0.002175] ✅️ instHMul.1 (BitVec.signExtend (2 * 8) x✝)
                                      (BitVec.signExtend (2 * 8) 5#8) =?= instHMul.1 (BitVec.signExtend 16 x✝) 5#16
                                  [Meta.isDefEq] [0.002099] ✅️ Mul.mul (BitVec.signExtend (2 * 8) x✝)
                                        (BitVec.signExtend (2 * 8) 5#8) =?= Mul.mul (BitVec.signExtend 16 x✝) 5#16
                                    [Meta.isDefEq] [0.002068] ✅️ BitVec.instMul.1 (BitVec.signExtend (2 * 8) x✝)
                                          (BitVec.signExtend (2 * 8)
                                            5#8) =?= BitVec.instMul.1 (BitVec.signExtend 16 x✝) 5#16
                                      [Meta.isDefEq] [0.001993] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                            (BitVec.signExtend (2 * 8) 5#8) =?= (BitVec.signExtend 16 x✝).mul 5#16
                                        [Meta.isDefEq.delta] [0.001975] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                              (BitVec.signExtend (2 * 8) 5#8) =?= (BitVec.signExtend 16 x✝).mul 5#16
                                          [Meta.isDefEq] [0.001848] ✅️ BitVec.signExtend (2 * 8) 5#8 =?= 5#16
                                            [Meta.isDefEq] [0.001824] ✅️ BitVec.ofInt (2 * 8) (5#8).toInt =?= 5#16
                                              [Meta.isDefEq] [0.001801] ✅️ ((5#8).toInt %
                                                        Int.ofNat (2 ^ (2 * 8))).toNat#'⋯ =?= 5#16
                                                [Meta.isDefEq] [0.001775] ✅️ ((5#8).toInt %
                                                          Int.ofNat
                                                            (2 ^
                                                              (2 * 8))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 16) 5 }
                                                  [Meta.isDefEq] [0.001754] ✅️ {
                                                        toFin :=
                                                          ⟨((5#8).toInt % Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 16) 5 }
                                                    [Meta.isDefEq] [0.001702] ✅️ ⟨((5#8).toInt %
                                                              Int.ofNat (2 ^ (2 * 8))).toNat,
                                                          ⋯⟩ =?= Fin.ofNat' (2 ^ 16) 5
                                                      [Meta.isDefEq] [0.001678] ✅️ ⟨((5#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ =?= ⟨5 % 2 ^ 16, ⋯⟩
                                                        [Meta.isDefEq] [0.001546] ✅️ ((5#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat =?= 5 % 2 ^ 16
                                                          [Meta.isDefEq] [0.001412] ✅️ match
                                                                (5#8).toInt % Int.ofNat (2 ^ (2 * 8)) with
                                                              | Int.ofNat n => n
                                                              | Int.negSucc a => 0 =?= 5 % 2 ^ 16
  [Meta.isDefEq] [0.002149] ✅️ ?x < ?y =?= BitVec.zeroExtend 16 x✝ * 5#16 < BitVec.twoPow 16 7 <<< 1
    [Meta.isDefEq] [0.002017] ✅️ ?y =?= BitVec.twoPow 16 7 <<< 1
  [Meta.isDefEq] [0.001640] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1) (BitVec.zeroExtend 16 x✝ * 5#16))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                      (BitVec.twoPow 16 7 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
        (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
    [Meta.isDefEq.assign] [0.001636] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                  (BitVec.zeroExtend 16 x✝ * 5#16))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                        (BitVec.twoPow 16 7 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
          (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001615] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                    (BitVec.zeroExtend 16 x✝ * 5#16))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                          (BitVec.twoPow 16 7 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
            (true_and
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
                true)) : (True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
        [Meta.isDefEq] [0.001610] ✅️ (True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
                true) =?= (True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true)
          [Meta.isDefEq] [0.001580] ✅️ True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1
            [Meta.isDefEq] [0.001562] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1
              [Meta.isDefEq.delta] [0.001532] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                  true then
              none
            else
              if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true then none
              else some (if (21#8 >ᵤ x✝ * 5#8) = true then 1#1 else 0#1)) ⊑
            some (if (5#8 >ᵤ x✝) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:117:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:110:8: error: (kernel) declaration has metavariables 'sgt_positive_multip_rem_zero_thm'
[bv] [0.041311] Normalizing goal
  [Meta.synthInstance] [0.001302] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else some (BitVec.ofBool (x✝ * 7#8 >ₛ 21#8))) ⊑
          some (BitVec.ofBool (x✝ >ₛ 3#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (x✝ * 7#8 >ₛ 21#8))) ⊑
            some (BitVec.ofBool (x✝ >ₛ 3#8))
      ⊢ False
  [Meta.isDefEq] [0.002270] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7) (BitVec.signExtend 16 x✝ * 7#16))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                            (BitVec.twoPow 16 7)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16) true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                (congrArg
                  (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) && x))
                  (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
        (true_and
          ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
            true))
    [Meta.isDefEq.assign] [0.002267] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                        (BitVec.signExtend 16 x✝ * 7#16))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                              (BitVec.twoPow 16 7)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16) true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                  (congrArg
                    (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) && x))
                    (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
          (true_and
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.002216] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                  BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                          (BitVec.signExtend 16 x✝ * 7#16))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                                (BitVec.twoPow 16 7)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16) true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                      !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                    (congrArg
                      (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) && x))
                      (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
            (true_and
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                true)) : (True ∧
              (BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7)) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
              true))
        [Meta.isDefEq] [0.002212] ✅️ (True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                true) =?= (True ∧
                (BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7)) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                true)
          [Meta.isDefEq] [0.002190] ✅️ True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1)) =?= True ∧
                (BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7)
            [Meta.isDefEq] [0.002174] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1) =?= BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7
              [Meta.isDefEq] [0.002057] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8)
                      (BitVec.twoPow 8
                        (8 - 1)) =?= BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7)
                [Meta.isDefEq] [0.002035] ✅️ instLTBitVec.1
                      (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8)
                      (BitVec.signExtend (2 * 8)
                        (BitVec.twoPow 8
                          (8 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 16 x✝ * 7#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                  [Meta.isDefEq] [0.001980] ✅️ (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8).toNat <
                        (BitVec.signExtend (2 * 8)
                            (BitVec.twoPow 8
                              (8 -
                                1))).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat <
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                    [Meta.isDefEq] [0.001966] ✅️ instLTNat.1
                          (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8).toNat
                          (BitVec.signExtend (2 * 8)
                              (BitVec.twoPow 8
                                (8 -
                                  1))).toNat =?= instLTNat.1 (BitVec.signExtend 16 x✝ * 7#16).toNat
                          (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                      [Meta.isDefEq] [0.001930] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 7#8).toNat.lt
                            (BitVec.signExtend (2 * 8)
                                (BitVec.twoPow 8
                                  (8 -
                                    1))).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat.lt
                            (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                        [Meta.isDefEq.delta] [0.001917] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 7#8).toNat.lt
                              (BitVec.signExtend (2 * 8)
                                  (BitVec.twoPow 8
                                    (8 -
                                      1))).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat.lt
                              (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                          [Meta.isDefEq] [0.001811] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 7#8).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat
                            [Meta.isDefEq.delta] [0.001798] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 7#8).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat
                              [Meta.isDefEq] [0.001753] ✅️ BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 7#8 =?= BitVec.signExtend 16 x✝ * 7#16
                                [Meta.isDefEq] [0.001728] ✅️ instHMul.1 (BitVec.signExtend (2 * 8) x✝)
                                      (BitVec.signExtend (2 * 8) 7#8) =?= instHMul.1 (BitVec.signExtend 16 x✝) 7#16
                                  [Meta.isDefEq] [0.001660] ✅️ Mul.mul (BitVec.signExtend (2 * 8) x✝)
                                        (BitVec.signExtend (2 * 8) 7#8) =?= Mul.mul (BitVec.signExtend 16 x✝) 7#16
                                    [Meta.isDefEq] [0.001636] ✅️ BitVec.instMul.1 (BitVec.signExtend (2 * 8) x✝)
                                          (BitVec.signExtend (2 * 8)
                                            7#8) =?= BitVec.instMul.1 (BitVec.signExtend 16 x✝) 7#16
                                      [Meta.isDefEq] [0.001584] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                            (BitVec.signExtend (2 * 8) 7#8) =?= (BitVec.signExtend 16 x✝).mul 7#16
                                        [Meta.isDefEq.delta] [0.001573] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                              (BitVec.signExtend (2 * 8) 7#8) =?= (BitVec.signExtend 16 x✝).mul 7#16
                                          [Meta.isDefEq] [0.001497] ✅️ BitVec.signExtend (2 * 8) 7#8 =?= 7#16
                                            [Meta.isDefEq] [0.001483] ✅️ BitVec.ofInt (2 * 8) (7#8).toInt =?= 7#16
                                              [Meta.isDefEq] [0.001464] ✅️ ((7#8).toInt %
                                                        Int.ofNat (2 ^ (2 * 8))).toNat#'⋯ =?= 7#16
                                                [Meta.isDefEq] [0.001444] ✅️ ((7#8).toInt %
                                                          Int.ofNat
                                                            (2 ^
                                                              (2 * 8))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 16) 7 }
                                                  [Meta.isDefEq] [0.001428] ✅️ {
                                                        toFin :=
                                                          ⟨((7#8).toInt % Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 16) 7 }
                                                    [Meta.isDefEq] [0.001394] ✅️ ⟨((7#8).toInt %
                                                              Int.ofNat (2 ^ (2 * 8))).toNat,
                                                          ⋯⟩ =?= Fin.ofNat' (2 ^ 16) 7
                                                      [Meta.isDefEq] [0.001366] ✅️ ⟨((7#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ =?= ⟨7 % 2 ^ 16, ⋯⟩
                                                        [Meta.isDefEq] [0.001273] ✅️ ((7#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat =?= 7 % 2 ^ 16
                                                          [Meta.isDefEq] [0.001153] ✅️ match
                                                                (7#8).toInt % Int.ofNat (2 ^ (2 * 8)) with
                                                              | Int.ofNat n => n
                                                              | Int.negSucc a => 0 =?= 7 % 2 ^ 16
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                  true then
              none
            else some (if (!(x✝ * 7#8).getLsbD 7 == (x✝ * 7#8 >ᵤ 21#8)) = true then 1#1 else 0#1)) ⊑
            some (if (!x✝.getLsbD 7 == (x✝ >ᵤ 3#8)) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:128:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:121:8: error: (kernel) declaration has metavariables 'sgt_negative_multip_rem_zero_thm'
[bv] [0.039765] Normalizing goal
  [Meta.synthInstance] [0.001227] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else some (BitVec.ofBool (x✝ * 249#8 >ₛ 21#8))) ⊑
          some (BitVec.ofBool (253#8 >ₛ x✝)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (x✝ * 249#8 >ₛ 21#8))) ⊑
            some (BitVec.ofBool (253#8 >ₛ x✝))
      ⊢ False
  [Meta.isDefEq] [0.001853] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65529#16)
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                      (BitVec.signExtend 16 x✝ * 65529#16))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65529#16)
                            (BitVec.twoPow 16 7)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16) true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                (congrArg
                  (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) && x))
                  (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)))))))
        (true_and
          ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) &&
                BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)) =
            true))
    [Meta.isDefEq.assign] [0.001850] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65529#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                        (BitVec.signExtend 16 x✝ * 65529#16))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65529#16)
                              (BitVec.twoPow 16 7)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16) true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                  (congrArg
                    (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) && x))
                    (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)))))))
          (true_and
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.001824] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 <
                  BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65529#16)
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                          (BitVec.signExtend 16 x✝ * 65529#16))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65529#16)
                                (BitVec.twoPow 16 7)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16) true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                      !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)
                    (congrArg
                      (fun x =>
                        !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) && x))
                      (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)))))))
            (true_and
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)) =
                true)) : (True ∧
              (BitVec.signExtend 16 x✝ * 65529#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                BitVec.signExtend 16 x✝ * 65529#16 ≥ BitVec.twoPow 16 7)) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)) =
              true))
        [Meta.isDefEq] [0.001820] ✅️ (True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)) =
                true) =?= (True ∧
                (BitVec.signExtend 16 x✝ * 65529#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 65529#16 ≥ BitVec.twoPow 16 7)) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)) =
                true)
          [Meta.isDefEq] [0.001795] ✅️ True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1)) =?= True ∧
                (BitVec.signExtend 16 x✝ * 65529#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 65529#16 ≥ BitVec.twoPow 16 7)
            [Meta.isDefEq] [0.001783] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1) =?= BitVec.signExtend 16 x✝ * 65529#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 65529#16 ≥ BitVec.twoPow 16 7
              [Meta.isDefEq] [0.001658] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 <
                    BitVec.signExtend (2 * 8)
                      (BitVec.twoPow 8
                        (8 - 1)) =?= BitVec.signExtend 16 x✝ * 65529#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7)
                [Meta.isDefEq] [0.001638] ✅️ instLTBitVec.1
                      (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8)
                      (BitVec.signExtend (2 * 8)
                        (BitVec.twoPow 8
                          (8 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 16 x✝ * 65529#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                  [Meta.isDefEq] [0.001603] ✅️ (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8).toNat <
                        (BitVec.signExtend (2 * 8)
                            (BitVec.twoPow 8
                              (8 -
                                1))).toNat =?= (BitVec.signExtend 16 x✝ * 65529#16).toNat <
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                    [Meta.isDefEq] [0.001590] ✅️ instLTNat.1
                          (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8).toNat
                          (BitVec.signExtend (2 * 8)
                              (BitVec.twoPow 8
                                (8 -
                                  1))).toNat =?= instLTNat.1 (BitVec.signExtend 16 x✝ * 65529#16).toNat
                          (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                      [Meta.isDefEq] [0.001570] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 249#8).toNat.lt
                            (BitVec.signExtend (2 * 8)
                                (BitVec.twoPow 8
                                  (8 -
                                    1))).toNat =?= (BitVec.signExtend 16 x✝ * 65529#16).toNat.lt
                            (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                        [Meta.isDefEq.delta] [0.001558] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 249#8).toNat.lt
                              (BitVec.signExtend (2 * 8)
                                  (BitVec.twoPow 8
                                    (8 -
                                      1))).toNat =?= (BitVec.signExtend 16 x✝ * 65529#16).toNat.lt
                              (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                          [Meta.isDefEq] [0.001467] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 249#8).toNat =?= (BitVec.signExtend 16 x✝ * 65529#16).toNat
                            [Meta.isDefEq.delta] [0.001456] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8)
                                      249#8).toNat =?= (BitVec.signExtend 16 x✝ * 65529#16).toNat
                              [Meta.isDefEq] [0.001444] ✅️ BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 249#8 =?= BitVec.signExtend 16 x✝ * 65529#16
                                [Meta.isDefEq] [0.001427] ✅️ instHMul.1 (BitVec.signExtend (2 * 8) x✝)
                                      (BitVec.signExtend (2 * 8)
                                        249#8) =?= instHMul.1 (BitVec.signExtend 16 x✝) 65529#16
                                  [Meta.isDefEq] [0.001399] ✅️ Mul.mul (BitVec.signExtend (2 * 8) x✝)
                                        (BitVec.signExtend (2 * 8) 249#8) =?= Mul.mul (BitVec.signExtend 16 x✝) 65529#16
                                    [Meta.isDefEq] [0.001383] ✅️ BitVec.instMul.1 (BitVec.signExtend (2 * 8) x✝)
                                          (BitVec.signExtend (2 * 8)
                                            249#8) =?= BitVec.instMul.1 (BitVec.signExtend 16 x✝) 65529#16
                                      [Meta.isDefEq] [0.001357] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                            (BitVec.signExtend (2 * 8) 249#8) =?= (BitVec.signExtend 16 x✝).mul 65529#16
                                        [Meta.isDefEq.delta] [0.001348] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                              (BitVec.signExtend (2 * 8)
                                                249#8) =?= (BitVec.signExtend 16 x✝).mul 65529#16
                                          [Meta.isDefEq] [0.001301] ✅️ BitVec.signExtend (2 * 8) 249#8 =?= 65529#16
                                            [Meta.isDefEq] [0.001284] ✅️ BitVec.ofInt (2 * 8) (249#8).toInt =?= 65529#16
                                              [Meta.isDefEq] [0.001271] ✅️ ((249#8).toInt %
                                                        Int.ofNat (2 ^ (2 * 8))).toNat#'⋯ =?= 65529#16
                                                [Meta.isDefEq] [0.001256] ✅️ ((249#8).toInt %
                                                          Int.ofNat
                                                            (2 ^
                                                              (2 *
                                                                8))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 16) 65529 }
                                                  [Meta.isDefEq] [0.001243] ✅️ {
                                                        toFin :=
                                                          ⟨((249#8).toInt % Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 16) 65529 }
                                                    [Meta.isDefEq] [0.001224] ✅️ ⟨((249#8).toInt %
                                                              Int.ofNat (2 ^ (2 * 8))).toNat,
                                                          ⋯⟩ =?= Fin.ofNat' (2 ^ 16) 65529
                                                      [Meta.isDefEq] [0.001205] ✅️ ⟨((249#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ =?= ⟨65529 % 2 ^ 16, ⋯⟩
                                                        [Meta.isDefEq] [0.001159] ✅️ ((249#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat =?= 65529 % 2 ^ 16
                                                          [Meta.isDefEq] [0.001104] ✅️ match
                                                                (249#8).toInt % Int.ofNat (2 ^ (2 * 8)) with
                                                              | Int.ofNat n => n
                                                              | Int.negSucc a => 0 =?= 65529 % 2 ^ 16
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)) =
                  true then
              none
            else some (if (!(x✝ * 249#8).getLsbD 7 == (x✝ * 249#8 >ᵤ 21#8)) = true then 1#1 else 0#1)) ⊑
            some (if (!(!x✝.getLsbD 7) == (253#8 >ᵤ x✝)) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:139:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:132:8: error: (kernel) declaration has metavariables 'sgt_positive_multip_rem_nz_thm'
[bv] [0.068365] Normalizing goal
  [Meta.synthInstance] [0.001977] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else some (BitVec.ofBool (x✝ * 5#8 >ₛ 21#8))) ⊑
          some (BitVec.ofBool (x✝ >ₛ 4#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (x✝ * 5#8 >ₛ 21#8))) ⊑
            some (BitVec.ofBool (x✝ >ₛ 4#8))
      ⊢ False
  [Meta.isDefEq] [0.003210] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7) (BitVec.signExtend 16 x✝ * 5#16))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                            (BitVec.twoPow 16 7)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                (congrArg
                  (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                  (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
        (true_and
          ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
            true))
    [Meta.isDefEq.assign] [0.003205] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                        (BitVec.signExtend 16 x✝ * 5#16))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                              (BitVec.twoPow 16 7)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  (congrArg
                    (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                    (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
          (true_and
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.003167] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                  BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                          (BitVec.signExtend 16 x✝ * 5#16))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                                (BitVec.twoPow 16 7)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                      !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    (congrArg
                      (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                      (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
            (true_and
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true)) : (True ∧
              (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true))
        [Meta.isDefEq] [0.003163] ✅️ (True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true) =?= (True ∧
                (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true)
          [Meta.isDefEq] [0.003128] ✅️ True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1)) =?= True ∧
                (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)
            [Meta.isDefEq] [0.003103] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1) =?= BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7
              [Meta.isDefEq] [0.002895] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8)
                      (BitVec.twoPow 8
                        (8 - 1)) =?= BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7)
                [Meta.isDefEq] [0.002862] ✅️ instLTBitVec.1
                      (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8)
                      (BitVec.signExtend (2 * 8)
                        (BitVec.twoPow 8
                          (8 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 16 x✝ * 5#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                  [Meta.isDefEq] [0.002790] ✅️ (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8).toNat <
                        (BitVec.signExtend (2 * 8)
                            (BitVec.twoPow 8
                              (8 -
                                1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat <
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                    [Meta.isDefEq] [0.002764] ✅️ instLTNat.1
                          (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8).toNat
                          (BitVec.signExtend (2 * 8)
                              (BitVec.twoPow 8
                                (8 -
                                  1))).toNat =?= instLTNat.1 (BitVec.signExtend 16 x✝ * 5#16).toNat
                          (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                      [Meta.isDefEq] [0.002712] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 5#8).toNat.lt
                            (BitVec.signExtend (2 * 8)
                                (BitVec.twoPow 8
                                  (8 -
                                    1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat.lt
                            (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                        [Meta.isDefEq.delta] [0.002690] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8).toNat.lt
                              (BitVec.signExtend (2 * 8)
                                  (BitVec.twoPow 8
                                    (8 -
                                      1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat.lt
                              (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                          [Meta.isDefEq] [0.002510] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 5#8).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat
                            [Meta.isDefEq.delta] [0.002488] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat
                              [Meta.isDefEq] [0.002431] ✅️ BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8 =?= BitVec.signExtend 16 x✝ * 5#16
                                [Meta.isDefEq] [0.002387] ✅️ instHMul.1 (BitVec.signExtend (2 * 8) x✝)
                                      (BitVec.signExtend (2 * 8) 5#8) =?= instHMul.1 (BitVec.signExtend 16 x✝) 5#16
                                  [Meta.isDefEq] [0.002304] ✅️ Mul.mul (BitVec.signExtend (2 * 8) x✝)
                                        (BitVec.signExtend (2 * 8) 5#8) =?= Mul.mul (BitVec.signExtend 16 x✝) 5#16
                                    [Meta.isDefEq] [0.002268] ✅️ BitVec.instMul.1 (BitVec.signExtend (2 * 8) x✝)
                                          (BitVec.signExtend (2 * 8)
                                            5#8) =?= BitVec.instMul.1 (BitVec.signExtend 16 x✝) 5#16
                                      [Meta.isDefEq] [0.002202] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                            (BitVec.signExtend (2 * 8) 5#8) =?= (BitVec.signExtend 16 x✝).mul 5#16
                                        [Meta.isDefEq.delta] [0.002186] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                              (BitVec.signExtend (2 * 8) 5#8) =?= (BitVec.signExtend 16 x✝).mul 5#16
                                          [Meta.isDefEq] [0.002056] ✅️ BitVec.signExtend (2 * 8) 5#8 =?= 5#16
                                            [Meta.isDefEq] [0.002030] ✅️ BitVec.ofInt (2 * 8) (5#8).toInt =?= 5#16
                                              [Meta.isDefEq] [0.002007] ✅️ ((5#8).toInt %
                                                        Int.ofNat (2 ^ (2 * 8))).toNat#'⋯ =?= 5#16
                                                [Meta.isDefEq] [0.001981] ✅️ ((5#8).toInt %
                                                          Int.ofNat
                                                            (2 ^
                                                              (2 * 8))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 16) 5 }
                                                  [Meta.isDefEq] [0.001960] ✅️ {
                                                        toFin :=
                                                          ⟨((5#8).toInt % Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 16) 5 }
                                                    [Meta.isDefEq] [0.001906] ✅️ ⟨((5#8).toInt %
                                                              Int.ofNat (2 ^ (2 * 8))).toNat,
                                                          ⋯⟩ =?= Fin.ofNat' (2 ^ 16) 5
                                                      [Meta.isDefEq] [0.001882] ✅️ ⟨((5#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ =?= ⟨5 % 2 ^ 16, ⋯⟩
                                                        [Meta.isDefEq] [0.001729] ✅️ ((5#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat =?= 5 % 2 ^ 16
                                                          [Meta.isDefEq] [0.001629] ✅️ match
                                                                (5#8).toInt % Int.ofNat (2 ^ (2 * 8)) with
                                                              | Int.ofNat n => n
                                                              | Int.negSucc a => 0 =?= 5 % 2 ^ 16
                                                            [Meta.whnf] [0.001066] Non-easy whnf: (fun motive x h_1
                                                                      h_2 =>
                                                                    Int.casesOn x (fun a => h_1 a) fun a => h_2 a)
                                                                  (fun x => ℕ) ((5#8).toInt % Int.ofNat (2 ^ (2 * 8)))
                                                                  h_1 h_2
                                                              [Meta.whnf] [0.001035] Non-easy whnf: (5#8).toInt %
                                                                    Int.ofNat (2 ^ (2 * 8))
                                                                [Meta.whnf] [0.001023] Non-easy whnf: instHMod.1
                                                                      (5#8).toInt (Int.ofNat (2 ^ (2 * 8)))
  [Meta.isDefEq] [0.002036] ❌️ ?a == ?a =?= false == (x✝ * 5#8).getLsbD 7
    [Meta.isDefEq.onFailure] [0.001642] ❌️ ?a == ?a =?= false == (x✝ * 5#8).getLsbD 7
      [Meta.synthInstance] [0.001613] 💥️ BEq ?α
        [Meta.synthInstance] [0.001502] new goal BEq ?α
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                  true then
              none
            else some (if (!(x✝ * 5#8).getLsbD 7 == (x✝ * 5#8 >ᵤ 21#8)) = true then 1#1 else 0#1)) ⊑
            some (if (!x✝.getLsbD 7 == (x✝ >ᵤ 4#8)) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:150:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:143:8: error: (kernel) declaration has metavariables 'ugt_rem_zero_thm'
[bv] [0.028423] Normalizing goal
  [Meta.synthInstance] [0.001161] ✅️ Decidable
        ((if
              True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
            none
          else some (BitVec.ofBool (x✝ * 7#8 >ᵤ 21#8))) ⊑
          some (BitVec.ofBool (x✝ >ᵤ 3#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else some (BitVec.ofBool (x✝ * 7#8 >ᵤ 21#8))) ⊑
            some (BitVec.ofBool (x✝ >ᵤ 3#8))
      ⊢ False
  [Meta.isDefEq] [0.001408] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1) (BitVec.zeroExtend 16 x✝ * 7#16))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 7#16)
                      (BitVec.twoPow 16 7 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16)))))))
        (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true))
    [Meta.isDefEq.assign] [0.001406] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                  (BitVec.zeroExtend 16 x✝ * 7#16))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 7#16)
                        (BitVec.twoPow 16 7 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16)))))))
          (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001386] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                    (BitVec.zeroExtend 16 x✝ * 7#16))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 7#16)
                          (BitVec.twoPow 16 7 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16)))))))
            (true_and
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) =
                true)) : (True ∧ BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true))
        [Meta.isDefEq] [0.001383] ✅️ (True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) =
                true) =?= (True ∧ BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true)
          [Meta.isDefEq] [0.001364] ✅️ True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1
            [Meta.isDefEq] [0.001349] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1
              [Meta.isDefEq.delta] [0.001329] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true then none
            else some (if (x✝ * 7#8 >ᵤ 21#8) = true then 1#1 else 0#1)) ⊑
            some (if (x✝ >ᵤ 3#8) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:161:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:154:8: error: (kernel) declaration has metavariables 'ugt_rem_zero_nsw_thm'
[bv] [0.045699] Normalizing goal
  [Meta.synthInstance] [0.001383] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else some (BitVec.ofBool (x✝ * 7#8 >ᵤ 21#8))) ⊑
          some (BitVec.ofBool (x✝ >ᵤ 3#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                      BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
                none
              else some (BitVec.ofBool (x✝ * 7#8 >ᵤ 21#8))) ⊑
            some (BitVec.ofBool (x✝ >ᵤ 3#8))
      ⊢ False
  [Meta.isDefEq] [0.002150] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7) (BitVec.signExtend 16 x✝ * 7#16))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                            (BitVec.twoPow 16 7)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16) true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                (congrArg
                  (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) && x))
                  (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
        (true_and
          ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
            true))
    [Meta.isDefEq.assign] [0.002148] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                        (BitVec.signExtend 16 x✝ * 7#16))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                              (BitVec.twoPow 16 7)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16) true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                  (congrArg
                    (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) && x))
                    (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
          (true_and
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.002123] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                  BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                          (BitVec.signExtend 16 x✝ * 7#16))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                                (BitVec.twoPow 16 7)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16) true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                      !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                    (congrArg
                      (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) && x))
                      (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
            (true_and
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                true)) : (True ∧
              (BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7)) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
              true))
        [Meta.isDefEq] [0.002120] ✅️ (True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                true) =?= (True ∧
                (BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7)) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                true)
          [Meta.isDefEq] [0.002101] ✅️ True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1)) =?= True ∧
                (BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7)
            [Meta.isDefEq] [0.002087] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1) =?= BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7
              [Meta.isDefEq] [0.001971] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8)
                      (BitVec.twoPow 8
                        (8 - 1)) =?= BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7)
                [Meta.isDefEq] [0.001950] ✅️ instLTBitVec.1
                      (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8)
                      (BitVec.signExtend (2 * 8)
                        (BitVec.twoPow 8
                          (8 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 16 x✝ * 7#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                  [Meta.isDefEq] [0.001895] ✅️ (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8).toNat <
                        (BitVec.signExtend (2 * 8)
                            (BitVec.twoPow 8
                              (8 -
                                1))).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat <
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                    [Meta.isDefEq] [0.001882] ✅️ instLTNat.1
                          (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8).toNat
                          (BitVec.signExtend (2 * 8)
                              (BitVec.twoPow 8
                                (8 -
                                  1))).toNat =?= instLTNat.1 (BitVec.signExtend 16 x✝ * 7#16).toNat
                          (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                      [Meta.isDefEq] [0.001823] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 7#8).toNat.lt
                            (BitVec.signExtend (2 * 8)
                                (BitVec.twoPow 8
                                  (8 -
                                    1))).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat.lt
                            (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                        [Meta.isDefEq.delta] [0.001811] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 7#8).toNat.lt
                              (BitVec.signExtend (2 * 8)
                                  (BitVec.twoPow 8
                                    (8 -
                                      1))).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat.lt
                              (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                          [Meta.isDefEq] [0.001716] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 7#8).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat
                            [Meta.isDefEq.delta] [0.001697] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 7#8).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat
                              [Meta.isDefEq] [0.001672] ✅️ BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 7#8 =?= BitVec.signExtend 16 x✝ * 7#16
                                [Meta.isDefEq] [0.001638] ✅️ instHMul.1 (BitVec.signExtend (2 * 8) x✝)
                                      (BitVec.signExtend (2 * 8) 7#8) =?= instHMul.1 (BitVec.signExtend 16 x✝) 7#16
                                  [Meta.isDefEq] [0.001569] ✅️ Mul.mul (BitVec.signExtend (2 * 8) x✝)
                                        (BitVec.signExtend (2 * 8) 7#8) =?= Mul.mul (BitVec.signExtend 16 x✝) 7#16
                                    [Meta.isDefEq] [0.001548] ✅️ BitVec.instMul.1 (BitVec.signExtend (2 * 8) x✝)
                                          (BitVec.signExtend (2 * 8)
                                            7#8) =?= BitVec.instMul.1 (BitVec.signExtend 16 x✝) 7#16
                                      [Meta.isDefEq] [0.001499] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                            (BitVec.signExtend (2 * 8) 7#8) =?= (BitVec.signExtend 16 x✝).mul 7#16
                                        [Meta.isDefEq.delta] [0.001490] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                              (BitVec.signExtend (2 * 8) 7#8) =?= (BitVec.signExtend 16 x✝).mul 7#16
                                          [Meta.isDefEq] [0.001411] ✅️ BitVec.signExtend (2 * 8) 7#8 =?= 7#16
                                            [Meta.isDefEq] [0.001393] ✅️ BitVec.ofInt (2 * 8) (7#8).toInt =?= 7#16
                                              [Meta.isDefEq] [0.001374] ✅️ ((7#8).toInt %
                                                        Int.ofNat (2 ^ (2 * 8))).toNat#'⋯ =?= 7#16
                                                [Meta.isDefEq] [0.001355] ✅️ ((7#8).toInt %
                                                          Int.ofNat
                                                            (2 ^
                                                              (2 * 8))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 16) 7 }
                                                  [Meta.isDefEq] [0.001338] ✅️ {
                                                        toFin :=
                                                          ⟨((7#8).toInt % Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 16) 7 }
                                                    [Meta.isDefEq] [0.001305] ✅️ ⟨((7#8).toInt %
                                                              Int.ofNat (2 ^ (2 * 8))).toNat,
                                                          ⋯⟩ =?= Fin.ofNat' (2 ^ 16) 7
                                                      [Meta.isDefEq] [0.001276] ✅️ ⟨((7#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ =?= ⟨7 % 2 ^ 16, ⋯⟩
                                                        [Meta.isDefEq] [0.001188] ✅️ ((7#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat =?= 7 % 2 ^ 16
                                                          [Meta.isDefEq] [0.001071] ✅️ match
                                                                (7#8).toInt % Int.ofNat (2 ^ (2 * 8)) with
                                                              | Int.ofNat n => n
                                                              | Int.negSucc a => 0 =?= 7 % 2 ^ 16
  [Meta.isDefEq] [0.002608] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1) (BitVec.zeroExtend 16 x✝ * 7#16))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 7#16)
                      (BitVec.twoPow 16 7 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16)))))))
        (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true))
    [Meta.isDefEq.assign] [0.002606] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                  (BitVec.zeroExtend 16 x✝ * 7#16))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 7#16)
                        (BitVec.twoPow 16 7 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16)))))))
          (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true))
      [Meta.isDefEq.assign.checkTypes] [0.002592] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                    (BitVec.zeroExtend 16 x✝ * 7#16))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 7#16)
                          (BitVec.twoPow 16 7 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16)))))))
            (true_and
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) =
                true)) : (True ∧ BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true))
        [Meta.isDefEq] [0.002589] ✅️ (True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) =
                true) =?= (True ∧ BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true)
          [Meta.isDefEq] [0.002570] ✅️ True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1
            [Meta.isDefEq] [0.002561] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1
              [Meta.isDefEq.delta] [0.002543] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7 <<< 1
                [Meta.isDefEq] [0.002102] ✅️ BitVec.zeroExtend (2 * 8) x✝ *
                      BitVec.zeroExtend (2 * 8) 7#8 =?= BitVec.zeroExtend 16 x✝ * 7#16
                  [Meta.isDefEq] [0.002081] ✅️ instHMul.1 (BitVec.zeroExtend (2 * 8) x✝)
                        (BitVec.zeroExtend (2 * 8) 7#8) =?= instHMul.1 (BitVec.zeroExtend 16 x✝) 7#16
                    [Meta.isDefEq] [0.002053] ✅️ Mul.mul (BitVec.zeroExtend (2 * 8) x✝)
                          (BitVec.zeroExtend (2 * 8) 7#8) =?= Mul.mul (BitVec.zeroExtend 16 x✝) 7#16
                      [Meta.isDefEq] [0.002038] ✅️ BitVec.instMul.1 (BitVec.zeroExtend (2 * 8) x✝)
                            (BitVec.zeroExtend (2 * 8) 7#8) =?= BitVec.instMul.1 (BitVec.zeroExtend 16 x✝) 7#16
                        [Meta.isDefEq] [0.002015] ✅️ (BitVec.zeroExtend (2 * 8) x✝).mul
                              (BitVec.zeroExtend (2 * 8) 7#8) =?= (BitVec.zeroExtend 16 x✝).mul 7#16
                          [Meta.isDefEq.delta] [0.002007] ✅️ (BitVec.zeroExtend (2 * 8) x✝).mul
                                (BitVec.zeroExtend (2 * 8) 7#8) =?= (BitVec.zeroExtend 16 x✝).mul 7#16
                            [Meta.isDefEq] [0.001937] ✅️ BitVec.zeroExtend (2 * 8) 7#8 =?= 7#16
                              [Meta.isDefEq] [0.001925] ✅️ BitVec.setWidth (2 * 8) 7#8 =?= 7#16
                                [Meta.isDefEq] [0.001906] ✅️ if h : 8 ≤ 2 * 8 then BitVec.setWidth' h 7#8
                                    else BitVec.ofNat (2 * 8) (7#8).toNat =?= 7#16
                                  [Meta.isDefEq] [0.001855] ✅️ if h : 8 ≤ 2 * 8 then BitVec.setWidth' h 7#8
                                      else BitVec.ofNat (2 * 8) (7#8).toNat =?= { toFin := Fin.ofNat' (2 ^ 16) 7 }
                                    [Meta.isDefEq] [0.001842] ✅️ Decidable.casesOn (Nat.decLe 8 (2 * 8))
                                          (fun h => BitVec.ofNat (2 * 8) (7#8).toNat) fun h =>
                                          BitVec.setWidth' h 7#8 =?= { toFin := Fin.ofNat' (2 ^ 16) 7 }
                                      [Meta.isDefEq] [0.001715] ✅️ BitVec.setWidth' ⋯
                                            7#8 =?= { toFin := Fin.ofNat' (2 ^ 16) 7 }
                                        [Meta.isDefEq] [0.001698] ✅️ (7#8).toNat#'⋯ =?= {
                                              toFin := Fin.ofNat' (2 ^ 16) 7 }
                                          [Meta.isDefEq] [0.001685] ✅️ {
                                                toFin := ⟨(7#8).toNat, ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 16) 7 }
                                            [Meta.isDefEq] [0.001666] ✅️ ⟨(7#8).toNat, ⋯⟩ =?= Fin.ofNat' (2 ^ 16) 7
                                              [Meta.isDefEq] [0.001653] ✅️ ⟨(7#8).toNat, ⋯⟩ =?= ⟨7 % 2 ^ 16, ⋯⟩
                                                [Meta.isDefEq] [0.001622] ✅️ (7#8).toNat =?= 7 % 2 ^ 16
                                                  [Meta.isDefEq] [0.001594] ✅️ ↑(7#8).toFin =?= 7 % 2 ^ 16
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                  true then
              none
            else
              if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 7#16) = true then none
              else some (if (x✝ * 7#8 >ᵤ 21#8) = true then 1#1 else 0#1)) ⊑
            some (if (x✝ >ᵤ 3#8) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:172:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:165:8: error: (kernel) declaration has metavariables 'ugt_rem_nz_thm'
[bv] [0.037474] Normalizing goal
  [Meta.synthInstance] [0.001209] ✅️ Decidable
        ((if
              True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
            none
          else some (BitVec.ofBool (x✝ * 5#8 >ᵤ 21#8))) ⊑
          some (BitVec.ofBool (x✝ >ᵤ 4#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else some (BitVec.ofBool (x✝ * 5#8 >ᵤ 21#8))) ⊑
            some (BitVec.ofBool (x✝ >ᵤ 4#8))
      ⊢ False
  [Meta.isDefEq] [0.002422] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1) (BitVec.zeroExtend 16 x✝ * 5#16))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                      (BitVec.twoPow 16 7 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
        (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
    [Meta.isDefEq.assign] [0.002417] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                  (BitVec.zeroExtend 16 x✝ * 5#16))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                        (BitVec.twoPow 16 7 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
          (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
      [Meta.isDefEq.assign.checkTypes] [0.002396] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                    (BitVec.zeroExtend 16 x✝ * 5#16))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                          (BitVec.twoPow 16 7 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
            (true_and
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
                true)) : (True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
        [Meta.isDefEq] [0.002391] ✅️ (True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
                true) =?= (True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true)
          [Meta.isDefEq] [0.002355] ✅️ True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1
            [Meta.isDefEq] [0.002329] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1
              [Meta.isDefEq.delta] [0.002299] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1
                [Meta.isDefEq] [0.001548] ✅️ BitVec.zeroExtend (2 * 8) x✝ *
                      BitVec.zeroExtend (2 * 8) 5#8 =?= BitVec.zeroExtend 16 x✝ * 5#16
                  [Meta.isDefEq] [0.001482] ✅️ instHMul.1 (BitVec.zeroExtend (2 * 8) x✝)
                        (BitVec.zeroExtend (2 * 8) 5#8) =?= instHMul.1 (BitVec.zeroExtend 16 x✝) 5#16
                    [Meta.isDefEq] [0.001395] ✅️ Mul.mul (BitVec.zeroExtend (2 * 8) x✝)
                          (BitVec.zeroExtend (2 * 8) 5#8) =?= Mul.mul (BitVec.zeroExtend 16 x✝) 5#16
                      [Meta.isDefEq] [0.001353] ✅️ BitVec.instMul.1 (BitVec.zeroExtend (2 * 8) x✝)
                            (BitVec.zeroExtend (2 * 8) 5#8) =?= BitVec.instMul.1 (BitVec.zeroExtend 16 x✝) 5#16
                        [Meta.isDefEq] [0.001286] ✅️ (BitVec.zeroExtend (2 * 8) x✝).mul
                              (BitVec.zeroExtend (2 * 8) 5#8) =?= (BitVec.zeroExtend 16 x✝).mul 5#16
                          [Meta.isDefEq.delta] [0.001266] ✅️ (BitVec.zeroExtend (2 * 8) x✝).mul
                                (BitVec.zeroExtend (2 * 8) 5#8) =?= (BitVec.zeroExtend 16 x✝).mul 5#16
                            [Meta.isDefEq] [0.001108] ✅️ BitVec.zeroExtend (2 * 8) 5#8 =?= 5#16
                              [Meta.isDefEq] [0.001084] ✅️ BitVec.setWidth (2 * 8) 5#8 =?= 5#16
                                [Meta.isDefEq] [0.001054] ✅️ if h : 8 ≤ 2 * 8 then BitVec.setWidth' h 5#8
                                    else BitVec.ofNat (2 * 8) (5#8).toNat =?= 5#16
                                  [Meta.isDefEq] [0.001014] ✅️ if h : 8 ≤ 2 * 8 then BitVec.setWidth' h 5#8
                                      else BitVec.ofNat (2 * 8) (5#8).toNat =?= { toFin := Fin.ofNat' (2 ^ 16) 5 }
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true then none
            else some (if (x✝ * 5#8 >ᵤ 21#8) = true then 1#1 else 0#1)) ⊑
            some (if (x✝ >ᵤ 4#8) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:183:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:176:8: error: (kernel) declaration has metavariables 'ugt_rem_nz_nsw_thm'
[bv] [0.046000] Normalizing goal
  [Meta.synthInstance] [0.001409] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else some (BitVec.ofBool (x✝ * 5#8 >ᵤ 21#8))) ⊑
          some (BitVec.ofBool (x✝ >ᵤ 4#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                      BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
                none
              else some (BitVec.ofBool (x✝ * 5#8 >ᵤ 21#8))) ⊑
            some (BitVec.ofBool (x✝ >ᵤ 4#8))
      ⊢ False
  [Meta.isDefEq] [0.001913] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7) (BitVec.signExtend 16 x✝ * 5#16))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                            (BitVec.twoPow 16 7)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                (congrArg
                  (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                  (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
        (true_and
          ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
            true))
    [Meta.isDefEq.assign] [0.001910] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                        (BitVec.signExtend 16 x✝ * 5#16))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                              (BitVec.twoPow 16 7)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  (congrArg
                    (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                    (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
          (true_and
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.001882] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                  BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                          (BitVec.signExtend 16 x✝ * 5#16))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                                (BitVec.twoPow 16 7)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                      !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    (congrArg
                      (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                      (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
            (true_and
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true)) : (True ∧
              (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true))
        [Meta.isDefEq] [0.001879] ✅️ (True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true) =?= (True ∧
                (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true)
          [Meta.isDefEq] [0.001860] ✅️ True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1)) =?= True ∧
                (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)
            [Meta.isDefEq] [0.001846] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1) =?= BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7
              [Meta.isDefEq] [0.001728] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8)
                      (BitVec.twoPow 8
                        (8 - 1)) =?= BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7)
                [Meta.isDefEq] [0.001701] ✅️ instLTBitVec.1
                      (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8)
                      (BitVec.signExtend (2 * 8)
                        (BitVec.twoPow 8
                          (8 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 16 x✝ * 5#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                  [Meta.isDefEq] [0.001653] ✅️ (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8).toNat <
                        (BitVec.signExtend (2 * 8)
                            (BitVec.twoPow 8
                              (8 -
                                1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat <
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                    [Meta.isDefEq] [0.001639] ✅️ instLTNat.1
                          (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8).toNat
                          (BitVec.signExtend (2 * 8)
                              (BitVec.twoPow 8
                                (8 -
                                  1))).toNat =?= instLTNat.1 (BitVec.signExtend 16 x✝ * 5#16).toNat
                          (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                      [Meta.isDefEq] [0.001609] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 5#8).toNat.lt
                            (BitVec.signExtend (2 * 8)
                                (BitVec.twoPow 8
                                  (8 -
                                    1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat.lt
                            (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                        [Meta.isDefEq.delta] [0.001597] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8).toNat.lt
                              (BitVec.signExtend (2 * 8)
                                  (BitVec.twoPow 8
                                    (8 -
                                      1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat.lt
                              (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                          [Meta.isDefEq] [0.001478] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 5#8).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat
                            [Meta.isDefEq.delta] [0.001466] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat
                              [Meta.isDefEq] [0.001446] ✅️ BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8 =?= BitVec.signExtend 16 x✝ * 5#16
                                [Meta.isDefEq] [0.001422] ✅️ instHMul.1 (BitVec.signExtend (2 * 8) x✝)
                                      (BitVec.signExtend (2 * 8) 5#8) =?= instHMul.1 (BitVec.signExtend 16 x✝) 5#16
                                  [Meta.isDefEq] [0.001372] ✅️ Mul.mul (BitVec.signExtend (2 * 8) x✝)
                                        (BitVec.signExtend (2 * 8) 5#8) =?= Mul.mul (BitVec.signExtend 16 x✝) 5#16
                                    [Meta.isDefEq] [0.001353] ✅️ BitVec.instMul.1 (BitVec.signExtend (2 * 8) x✝)
                                          (BitVec.signExtend (2 * 8)
                                            5#8) =?= BitVec.instMul.1 (BitVec.signExtend 16 x✝) 5#16
                                      [Meta.isDefEq] [0.001311] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                            (BitVec.signExtend (2 * 8) 5#8) =?= (BitVec.signExtend 16 x✝).mul 5#16
                                        [Meta.isDefEq.delta] [0.001302] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                              (BitVec.signExtend (2 * 8) 5#8) =?= (BitVec.signExtend 16 x✝).mul 5#16
                                          [Meta.isDefEq] [0.001208] ✅️ BitVec.signExtend (2 * 8) 5#8 =?= 5#16
                                            [Meta.isDefEq] [0.001187] ✅️ BitVec.ofInt (2 * 8) (5#8).toInt =?= 5#16
                                              [Meta.isDefEq] [0.001163] ✅️ ((5#8).toInt %
                                                        Int.ofNat (2 ^ (2 * 8))).toNat#'⋯ =?= 5#16
                                                [Meta.isDefEq] [0.001141] ✅️ ((5#8).toInt %
                                                          Int.ofNat
                                                            (2 ^
                                                              (2 * 8))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 16) 5 }
                                                  [Meta.isDefEq] [0.001125] ✅️ {
                                                        toFin :=
                                                          ⟨((5#8).toInt % Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 16) 5 }
                                                    [Meta.isDefEq] [0.001077] ✅️ ⟨((5#8).toInt %
                                                              Int.ofNat (2 ^ (2 * 8))).toNat,
                                                          ⋯⟩ =?= Fin.ofNat' (2 ^ 16) 5
                                                      [Meta.isDefEq] [0.001055] ✅️ ⟨((5#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ =?= ⟨5 % 2 ^ 16, ⋯⟩
  [Meta.isDefEq] [0.001165] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1) (BitVec.zeroExtend 16 x✝ * 5#16))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                      (BitVec.twoPow 16 7 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
        (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
    [Meta.isDefEq.assign] [0.001162] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                  (BitVec.zeroExtend 16 x✝ * 5#16))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                        (BitVec.twoPow 16 7 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
          (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001147] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                    (BitVec.zeroExtend 16 x✝ * 5#16))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                          (BitVec.twoPow 16 7 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
            (true_and
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
                true)) : (True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
        [Meta.isDefEq] [0.001144] ✅️ (True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
                true) =?= (True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true)
          [Meta.isDefEq] [0.001122] ✅️ True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1
            [Meta.isDefEq] [0.001111] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1
              [Meta.isDefEq.delta] [0.001091] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                  true then
              none
            else
              if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true then none
              else some (if (x✝ * 5#8 >ᵤ 21#8) = true then 1#1 else 0#1)) ⊑
            some (if (x✝ >ᵤ 4#8) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:194:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:187:8: error: (kernel) declaration has metavariables 'eq_nsw_rem_zero_thm'
[bv] [0.050034] Normalizing goal
  [Meta.synthInstance] [0.001973] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 251#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 251#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else some (BitVec.ofBool (x✝ * 251#8 == 20#8))) ⊑
          some (BitVec.ofBool (x✝ == 252#8)))
    [Meta.check] [0.001013] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 251#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 251#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else some (BitVec.ofBool (x✝ * 251#8 == 20#8)))
          (some (BitVec.ofBool (x✝ == 252#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 251#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 251#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (x✝ * 251#8 == 20#8))) ⊑
            some (BitVec.ofBool (x✝ == 252#8))
      ⊢ False
  [Meta.isDefEq] [0.003015] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65531#16)
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                      (BitVec.signExtend 16 x✝ * 65531#16))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65531#16)
                            (BitVec.twoPow 16 7)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16) true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65531#16)
                !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65531#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16)
                (congrArg
                  (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65531#16) && x))
                  (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16)))))))
        (true_and
          ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65531#16) &&
                BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16)) =
            true))
    [Meta.isDefEq.assign] [0.003009] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65531#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                        (BitVec.signExtend 16 x✝ * 65531#16))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65531#16)
                              (BitVec.twoPow 16 7)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16) true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65531#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65531#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16)
                  (congrArg
                    (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65531#16) && x))
                    (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16)))))))
          (true_and
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65531#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.002974] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 251#8 <
                  BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 251#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65531#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65531#16)
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                          (BitVec.signExtend 16 x✝ * 65531#16))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 65531#16)
                                (BitVec.twoPow 16 7)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16) true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65531#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65531#16)
                      !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16)
                    (congrArg
                      (fun x =>
                        !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65531#16) && x))
                      (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16)))))))
            (true_and
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65531#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16)) =
                true)) : (True ∧
              (BitVec.signExtend 16 x✝ * 65531#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                BitVec.signExtend 16 x✝ * 65531#16 ≥ BitVec.twoPow 16 7)) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65531#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16)) =
              true))
        [Meta.isDefEq] [0.002969] ✅️ (True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 251#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 251#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65531#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16)) =
                true) =?= (True ∧
                (BitVec.signExtend 16 x✝ * 65531#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 65531#16 ≥ BitVec.twoPow 16 7)) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65531#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16)) =
                true)
          [Meta.isDefEq] [0.002934] ✅️ True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 251#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 251#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1)) =?= True ∧
                (BitVec.signExtend 16 x✝ * 65531#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 65531#16 ≥ BitVec.twoPow 16 7)
            [Meta.isDefEq] [0.002917] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 251#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 251#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1) =?= BitVec.signExtend 16 x✝ * 65531#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 65531#16 ≥ BitVec.twoPow 16 7
              [Meta.isDefEq] [0.002761] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 251#8 <
                    BitVec.signExtend (2 * 8)
                      (BitVec.twoPow 8
                        (8 - 1)) =?= BitVec.signExtend 16 x✝ * 65531#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7)
                [Meta.isDefEq] [0.002733] ✅️ instLTBitVec.1
                      (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 251#8)
                      (BitVec.signExtend (2 * 8)
                        (BitVec.twoPow 8
                          (8 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 16 x✝ * 65531#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                  [Meta.isDefEq] [0.002681] ✅️ (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 251#8).toNat <
                        (BitVec.signExtend (2 * 8)
                            (BitVec.twoPow 8
                              (8 -
                                1))).toNat =?= (BitVec.signExtend 16 x✝ * 65531#16).toNat <
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                    [Meta.isDefEq] [0.002657] ✅️ instLTNat.1
                          (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 251#8).toNat
                          (BitVec.signExtend (2 * 8)
                              (BitVec.twoPow 8
                                (8 -
                                  1))).toNat =?= instLTNat.1 (BitVec.signExtend 16 x✝ * 65531#16).toNat
                          (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                      [Meta.isDefEq] [0.002623] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 251#8).toNat.lt
                            (BitVec.signExtend (2 * 8)
                                (BitVec.twoPow 8
                                  (8 -
                                    1))).toNat =?= (BitVec.signExtend 16 x✝ * 65531#16).toNat.lt
                            (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                        [Meta.isDefEq.delta] [0.002598] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 251#8).toNat.lt
                              (BitVec.signExtend (2 * 8)
                                  (BitVec.twoPow 8
                                    (8 -
                                      1))).toNat =?= (BitVec.signExtend 16 x✝ * 65531#16).toNat.lt
                              (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                          [Meta.isDefEq] [0.002452] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 251#8).toNat =?= (BitVec.signExtend 16 x✝ * 65531#16).toNat
                            [Meta.isDefEq.delta] [0.002433] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8)
                                      251#8).toNat =?= (BitVec.signExtend 16 x✝ * 65531#16).toNat
                              [Meta.isDefEq] [0.002396] ✅️ BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 251#8 =?= BitVec.signExtend 16 x✝ * 65531#16
                                [Meta.isDefEq] [0.002370] ✅️ instHMul.1 (BitVec.signExtend (2 * 8) x✝)
                                      (BitVec.signExtend (2 * 8)
                                        251#8) =?= instHMul.1 (BitVec.signExtend 16 x✝) 65531#16
                                  [Meta.isDefEq] [0.002328] ✅️ Mul.mul (BitVec.signExtend (2 * 8) x✝)
                                        (BitVec.signExtend (2 * 8) 251#8) =?= Mul.mul (BitVec.signExtend 16 x✝) 65531#16
                                    [Meta.isDefEq] [0.002303] ✅️ BitVec.instMul.1 (BitVec.signExtend (2 * 8) x✝)
                                          (BitVec.signExtend (2 * 8)
                                            251#8) =?= BitVec.instMul.1 (BitVec.signExtend 16 x✝) 65531#16
                                      [Meta.isDefEq] [0.002260] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                            (BitVec.signExtend (2 * 8) 251#8) =?= (BitVec.signExtend 16 x✝).mul 65531#16
                                        [Meta.isDefEq.delta] [0.002245] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                              (BitVec.signExtend (2 * 8)
                                                251#8) =?= (BitVec.signExtend 16 x✝).mul 65531#16
                                          [Meta.isDefEq] [0.002171] ✅️ BitVec.signExtend (2 * 8) 251#8 =?= 65531#16
                                            [Meta.isDefEq] [0.002146] ✅️ BitVec.ofInt (2 * 8) (251#8).toInt =?= 65531#16
                                              [Meta.isDefEq] [0.002127] ✅️ ((251#8).toInt %
                                                        Int.ofNat (2 ^ (2 * 8))).toNat#'⋯ =?= 65531#16
                                                [Meta.isDefEq] [0.002104] ✅️ ((251#8).toInt %
                                                          Int.ofNat
                                                            (2 ^
                                                              (2 *
                                                                8))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 16) 65531 }
                                                  [Meta.isDefEq] [0.002085] ✅️ {
                                                        toFin :=
                                                          ⟨((251#8).toInt % Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 16) 65531 }
                                                    [Meta.isDefEq] [0.002053] ✅️ ⟨((251#8).toInt %
                                                              Int.ofNat (2 ^ (2 * 8))).toNat,
                                                          ⋯⟩ =?= Fin.ofNat' (2 ^ 16) 65531
                                                      [Meta.isDefEq] [0.002033] ✅️ ⟨((251#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ =?= ⟨65531 % 2 ^ 16, ⋯⟩
                                                        [Meta.isDefEq] [0.001958] ✅️ ((251#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat =?= 65531 % 2 ^ 16
                                                          [Meta.isDefEq] [0.001911] ✅️ match
                                                                (251#8).toInt % Int.ofNat (2 ^ (2 * 8)) with
                                                              | Int.ofNat n => n
                                                              | Int.negSucc a => 0 =?= 65531 % 2 ^ 16
                                                            [Meta.whnf] [0.001571] Non-easy whnf: (fun motive x h_1
                                                                      h_2 =>
                                                                    Int.casesOn x (fun a => h_1 a) fun a => h_2 a)
                                                                  (fun x => ℕ) ((251#8).toInt % Int.ofNat (2 ^ (2 * 8)))
                                                                  h_1 h_2
                                                              [Meta.whnf] [0.001547] Non-easy whnf: (251#8).toInt %
                                                                    Int.ofNat (2 ^ (2 * 8))
                                                                [Meta.whnf] [0.001515] Non-easy whnf: instHMod.1
                                                                      (251#8).toInt (Int.ofNat (2 ^ (2 * 8)))
                                                                  [Meta.whnf] [0.001504] Non-easy whnf: Int.instMod.1
                                                                        (251#8).toInt (Int.ofNat (2 ^ (2 * 8)))
                                                                    [Meta.whnf] [0.001492] Non-easy whnf: match
                                                                          (251#8).toInt, Int.ofNat (2 ^ (2 * 8)) with
                                                                        | Int.ofNat m, n => Int.ofNat (m % n.natAbs)
                                                                        | Int.negSucc m, n =>
                                                                          Int.subNatNat n.natAbs (m % n.natAbs).succ
                                                                      [Meta.whnf] [0.001241] Non-easy whnf: (fun motive
                                                                                x x_1 h_1 h_2 =>
                                                                              Int.casesOn x (fun a => h_1 a x_1)
                                                                                fun a => h_2 a x_1)
                                                                            (fun x x => ℤ) (251#8).toInt
                                                                            (Int.ofNat (2 ^ (2 * 8))) h_1 h_2
                                                                        [Meta.whnf] [0.001220] Non-easy whnf: (251#8).toInt
                                                                          [Meta.whnf] [0.001199] Non-easy whnf: if
                                                                                  2 * (251#8).toNat < 2 ^ 8 then
                                                                                ↑(251#8).toNat
                                                                              else ↑(251#8).toNat - ↑(2 ^ 8)
                                                                            [Meta.whnf] [0.001177] Non-easy whnf: Decidable.casesOn
                                                                                  ((2 * (251#8).toNat).decLt (2 ^ 8))
                                                                                  (fun x => ↑(251#8).toNat - ↑(2 ^ 8))
                                                                                  fun x => ↑(251#8).toNat
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65531#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65531#16)) =
                  true then
              none
            else some (if (x✝ * 251#8 == 20#8) = true then 1#1 else 0#1)) ⊑
            some (if (x✝ == 252#8) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:204:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:198:8: error: (kernel) declaration has metavariables 'eq_nsw_rem_nz_thm'
[bv] [0.032394] Normalizing goal
  [Meta.synthInstance] [0.001313] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else some (BitVec.ofBool (x✝ * 5#8 == 245#8))) ⊑
          some 0#1)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (x✝ * 5#8 == 245#8))) ⊑
            some 0#1
      ⊢ False
  [Meta.isDefEq] [0.001549] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7) (BitVec.signExtend 16 x✝ * 5#16))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                            (BitVec.twoPow 16 7)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                (congrArg
                  (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                  (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
        (true_and
          ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
            true))
    [Meta.isDefEq.assign] [0.001547] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                        (BitVec.signExtend 16 x✝ * 5#16))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                              (BitVec.twoPow 16 7)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  (congrArg
                    (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                    (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
          (true_and
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.001520] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                  BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                          (BitVec.signExtend 16 x✝ * 5#16))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                                (BitVec.twoPow 16 7)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                      !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    (congrArg
                      (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                      (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
            (true_and
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true)) : (True ∧
              (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true))
        [Meta.isDefEq] [0.001517] ✅️ (True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true) =?= (True ∧
                (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true)
          [Meta.isDefEq] [0.001498] ✅️ True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1)) =?= True ∧
                (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)
            [Meta.isDefEq] [0.001483] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1) =?= BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7
              [Meta.isDefEq] [0.001346] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8)
                      (BitVec.twoPow 8
                        (8 - 1)) =?= BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7)
                [Meta.isDefEq] [0.001328] ✅️ instLTBitVec.1
                      (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8)
                      (BitVec.signExtend (2 * 8)
                        (BitVec.twoPow 8
                          (8 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 16 x✝ * 5#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                  [Meta.isDefEq] [0.001279] ✅️ (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8).toNat <
                        (BitVec.signExtend (2 * 8)
                            (BitVec.twoPow 8
                              (8 -
                                1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat <
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                    [Meta.isDefEq] [0.001266] ✅️ instLTNat.1
                          (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8).toNat
                          (BitVec.signExtend (2 * 8)
                              (BitVec.twoPow 8
                                (8 -
                                  1))).toNat =?= instLTNat.1 (BitVec.signExtend 16 x✝ * 5#16).toNat
                          (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                      [Meta.isDefEq] [0.001236] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 5#8).toNat.lt
                            (BitVec.signExtend (2 * 8)
                                (BitVec.twoPow 8
                                  (8 -
                                    1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat.lt
                            (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                        [Meta.isDefEq.delta] [0.001225] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8).toNat.lt
                              (BitVec.signExtend (2 * 8)
                                  (BitVec.twoPow 8
                                    (8 -
                                      1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat.lt
                              (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                          [Meta.isDefEq] [0.001133] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 5#8).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat
                            [Meta.isDefEq.delta] [0.001121] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat
                              [Meta.isDefEq] [0.001102] ✅️ BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8 =?= BitVec.signExtend 16 x✝ * 5#16
                                [Meta.isDefEq] [0.001079] ✅️ instHMul.1 (BitVec.signExtend (2 * 8) x✝)
                                      (BitVec.signExtend (2 * 8) 5#8) =?= instHMul.1 (BitVec.signExtend 16 x✝) 5#16
                                  [Meta.isDefEq] [0.001031] ✅️ Mul.mul (BitVec.signExtend (2 * 8) x✝)
                                        (BitVec.signExtend (2 * 8) 5#8) =?= Mul.mul (BitVec.signExtend 16 x✝) 5#16
                                    [Meta.isDefEq] [0.001008] ✅️ BitVec.instMul.1 (BitVec.signExtend (2 * 8) x✝)
                                          (BitVec.signExtend (2 * 8)
                                            5#8) =?= BitVec.instMul.1 (BitVec.signExtend 16 x✝) 5#16
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                  true then
              none
            else some (if (x✝ * 5#8 == 245#8) = true then 1#1 else 0#1)) ⊑
            some 0#1
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:214:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:208:8: error: (kernel) declaration has metavariables 'ne_nsw_rem_nz_thm'
[bv] [0.039675] Normalizing goal
  [Meta.synthInstance] [0.001177] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else some (BitVec.ofBool (x✝ * 5#8 != 130#8))) ⊑
          some 1#1)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (x✝ * 5#8 != 130#8))) ⊑
            some 1#1
      ⊢ False
  [Meta.isDefEq] [0.002485] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7) (BitVec.signExtend 16 x✝ * 5#16))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                            (BitVec.twoPow 16 7)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                (congrArg
                  (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                  (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
        (true_and
          ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
            true))
    [Meta.isDefEq.assign] [0.002480] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                        (BitVec.signExtend 16 x✝ * 5#16))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                              (BitVec.twoPow 16 7)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                  (congrArg
                    (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                    (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
          (true_and
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.002447] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                  BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                          (BitVec.signExtend 16 x✝ * 5#16))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 5#16)
                                (BitVec.twoPow 16 7)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16) true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                      !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)
                    (congrArg
                      (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) && x))
                      (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)))))))
            (true_and
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true)) : (True ∧
              (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
              true))
        [Meta.isDefEq] [0.002442] ✅️ (True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true) =?= (True ∧
                (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                true)
          [Meta.isDefEq] [0.002409] ✅️ True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1)) =?= True ∧
                (BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7)
            [Meta.isDefEq] [0.002384] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1) =?= BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7
              [Meta.isDefEq] [0.002181] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8 <
                    BitVec.signExtend (2 * 8)
                      (BitVec.twoPow 8
                        (8 - 1)) =?= BitVec.signExtend 16 x✝ * 5#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7)
                [Meta.isDefEq] [0.002152] ✅️ instLTBitVec.1
                      (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8)
                      (BitVec.signExtend (2 * 8)
                        (BitVec.twoPow 8
                          (8 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 16 x✝ * 5#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                  [Meta.isDefEq] [0.002079] ✅️ (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8).toNat <
                        (BitVec.signExtend (2 * 8)
                            (BitVec.twoPow 8
                              (8 -
                                1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat <
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                    [Meta.isDefEq] [0.002054] ✅️ instLTNat.1
                          (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 5#8).toNat
                          (BitVec.signExtend (2 * 8)
                              (BitVec.twoPow 8
                                (8 -
                                  1))).toNat =?= instLTNat.1 (BitVec.signExtend 16 x✝ * 5#16).toNat
                          (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                      [Meta.isDefEq] [0.001983] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 5#8).toNat.lt
                            (BitVec.signExtend (2 * 8)
                                (BitVec.twoPow 8
                                  (8 -
                                    1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat.lt
                            (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                        [Meta.isDefEq.delta] [0.001962] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8).toNat.lt
                              (BitVec.signExtend (2 * 8)
                                  (BitVec.twoPow 8
                                    (8 -
                                      1))).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat.lt
                              (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                          [Meta.isDefEq] [0.001779] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 5#8).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat
                            [Meta.isDefEq.delta] [0.001758] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8).toNat =?= (BitVec.signExtend 16 x✝ * 5#16).toNat
                              [Meta.isDefEq] [0.001725] ✅️ BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 5#8 =?= BitVec.signExtend 16 x✝ * 5#16
                                [Meta.isDefEq] [0.001687] ✅️ instHMul.1 (BitVec.signExtend (2 * 8) x✝)
                                      (BitVec.signExtend (2 * 8) 5#8) =?= instHMul.1 (BitVec.signExtend 16 x✝) 5#16
                                  [Meta.isDefEq] [0.001613] ✅️ Mul.mul (BitVec.signExtend (2 * 8) x✝)
                                        (BitVec.signExtend (2 * 8) 5#8) =?= Mul.mul (BitVec.signExtend 16 x✝) 5#16
                                    [Meta.isDefEq] [0.001576] ✅️ BitVec.instMul.1 (BitVec.signExtend (2 * 8) x✝)
                                          (BitVec.signExtend (2 * 8)
                                            5#8) =?= BitVec.instMul.1 (BitVec.signExtend 16 x✝) 5#16
                                      [Meta.isDefEq] [0.001511] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                            (BitVec.signExtend (2 * 8) 5#8) =?= (BitVec.signExtend 16 x✝).mul 5#16
                                        [Meta.isDefEq.delta] [0.001493] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                              (BitVec.signExtend (2 * 8) 5#8) =?= (BitVec.signExtend 16 x✝).mul 5#16
                                          [Meta.isDefEq] [0.001365] ✅️ BitVec.signExtend (2 * 8) 5#8 =?= 5#16
                                            [Meta.isDefEq] [0.001338] ✅️ BitVec.ofInt (2 * 8) (5#8).toInt =?= 5#16
                                              [Meta.isDefEq] [0.001317] ✅️ ((5#8).toInt %
                                                        Int.ofNat (2 ^ (2 * 8))).toNat#'⋯ =?= 5#16
                                                [Meta.isDefEq] [0.001293] ✅️ ((5#8).toInt %
                                                          Int.ofNat
                                                            (2 ^
                                                              (2 * 8))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 16) 5 }
                                                  [Meta.isDefEq] [0.001275] ✅️ {
                                                        toFin :=
                                                          ⟨((5#8).toInt % Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 16) 5 }
                                                    [Meta.isDefEq] [0.001243] ✅️ ⟨((5#8).toInt %
                                                              Int.ofNat (2 ^ (2 * 8))).toNat,
                                                          ⋯⟩ =?= Fin.ofNat' (2 ^ 16) 5
                                                      [Meta.isDefEq] [0.001221] ✅️ ⟨((5#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ =?= ⟨5 % 2 ^ 16, ⋯⟩
                                                        [Meta.isDefEq] [0.001147] ✅️ ((5#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat =?= 5 % 2 ^ 16
                                                          [Meta.isDefEq] [0.001098] ✅️ match
                                                                (5#8).toInt % Int.ofNat (2 ^ (2 * 8)) with
                                                              | Int.ofNat n => n
                                                              | Int.negSucc a => 0 =?= 5 % 2 ^ 16
  [Meta.isDefEq] [0.002145] ✅️ if ?b then ?x else ?y =?= if (!x✝ * 5#8 == 130#8) = true then 1#1 else 0#1
    [Meta.isDefEq] [0.001921] ✅️ ?b =?= (!x✝ * 5#8 == 130#8) = true
      [Meta.isDefEq.assign] [0.001916] ✅️ ?b := (!x✝ * 5#8 == 130#8) = true
        [Meta.isDefEq.assign.checkTypes] [0.001903] ✅️ (?b : Prop) := ((!x✝ * 5#8 == 130#8) = true : Prop)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 5#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 5#16)) =
                  true then
              none
            else some (if (!x✝ * 5#8 == 130#8) = true then 1#1 else 0#1)) ⊑
            some 1#1
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:225:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:218:8: error: (kernel) declaration has metavariables 'ne_nuw_rem_zero_thm'
[bv] [0.032662] Normalizing goal
  [Meta.synthInstance] [0.001184] ✅️ Decidable
        ((if
              True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
            none
          else some (BitVec.ofBool (x✝ * 5#8 != 130#8))) ⊑
          some (BitVec.ofBool (x✝ != 26#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else some (BitVec.ofBool (x✝ * 5#8 != 130#8))) ⊑
            some (BitVec.ofBool (x✝ != 26#8))
      ⊢ False
  [Meta.isDefEq] [0.001289] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1) (BitVec.zeroExtend 16 x✝ * 5#16))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                      (BitVec.twoPow 16 7 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
        (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
    [Meta.isDefEq.assign] [0.001287] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                  (BitVec.zeroExtend 16 x✝ * 5#16))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                        (BitVec.twoPow 16 7 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
          (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001273] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                    (BitVec.zeroExtend 16 x✝ * 5#16))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                          (BitVec.twoPow 16 7 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
            (true_and
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
                true)) : (True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
        [Meta.isDefEq] [0.001270] ✅️ (True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
                true) =?= (True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true)
          [Meta.isDefEq] [0.001251] ✅️ True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1
            [Meta.isDefEq] [0.001236] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1
              [Meta.isDefEq.delta] [0.001217] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true then none
            else some (if (!x✝ * 5#8 == 130#8) = true then 1#1 else 0#1)) ⊑
            some (if (!x✝ == 26#8) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:235:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:229:8: error: (kernel) declaration has metavariables 'eq_nuw_rem_nz_thm'
[bv] [0.033136] Normalizing goal
  [Meta.synthInstance] [0.001806] ✅️ Decidable
        ((if
              True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 251#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
            none
          else some (BitVec.ofBool (x✝ * 251#8 == 20#8))) ⊑
          some 0#1)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 251#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else some (BitVec.ofBool (x✝ * 251#8 == 20#8))) ⊑
            some 0#1
      ⊢ False
  [Meta.isDefEq] [0.001240] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                (BitVec.zeroExtend 16 x✝ * 251#16))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 251#16)
                      (BitVec.twoPow 16 7 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 251#16) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 251#16)))))))
        (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 251#16) = true))
    [Meta.isDefEq.assign] [0.001237] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                  (BitVec.zeroExtend 16 x✝ * 251#16))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 251#16)
                        (BitVec.twoPow 16 7 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 251#16) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 251#16)))))))
          (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 251#16) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001224] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 251#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 251#16) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                    (BitVec.zeroExtend 16 x✝ * 251#16))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 251#16)
                          (BitVec.twoPow 16 7 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 251#16) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 251#16)))))))
            (true_and
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 251#16) =
                true)) : (True ∧ BitVec.zeroExtend 16 x✝ * 251#16 ≥ BitVec.twoPow 16 7 <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 251#16) = true))
        [Meta.isDefEq] [0.001221] ✅️ (True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 251#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 251#16) =
                true) =?= (True ∧ BitVec.zeroExtend 16 x✝ * 251#16 ≥ BitVec.twoPow 16 7 <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 251#16) = true)
          [Meta.isDefEq] [0.001201] ✅️ True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 251#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 16 x✝ * 251#16 ≥ BitVec.twoPow 16 7 <<< 1
            [Meta.isDefEq] [0.001192] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 251#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 251#16 ≥ BitVec.twoPow 16 7 <<< 1
              [Meta.isDefEq.delta] [0.001173] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 251#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 251#16 ≥ BitVec.twoPow 16 7 <<< 1
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 251#16) = true then none
            else some (if (x✝ * 251#8 == 20#8) = true then 1#1 else 0#1)) ⊑
            some 0#1
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:245:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:239:8: error: (kernel) declaration has metavariables 'ne_nuw_rem_nz_thm'
[bv] [0.027448] Normalizing goal
  [Meta.synthInstance] [0.001180] ✅️ Decidable
        ((if
              True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
            none
          else some (BitVec.ofBool (x✝ * 5#8 != 226#8))) ⊑
          some 1#1)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else some (BitVec.ofBool (x✝ * 5#8 != 226#8))) ⊑
            some 1#1
      ⊢ False
  [Meta.isDefEq] [0.001261] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1) (BitVec.zeroExtend 16 x✝ * 5#16))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                      (BitVec.twoPow 16 7 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
        (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
    [Meta.isDefEq.assign] [0.001258] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                  (BitVec.zeroExtend 16 x✝ * 5#16))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                        (BitVec.twoPow 16 7 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
          (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001240] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                    (BitVec.zeroExtend 16 x✝ * 5#16))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 x✝ * 5#16)
                          (BitVec.twoPow 16 7 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16)))))))
            (true_and
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
                true)) : (True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true))
        [Meta.isDefEq] [0.001236] ✅️ (True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) =
                true) =?= (True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true)
          [Meta.isDefEq] [0.001212] ✅️ True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1
            [Meta.isDefEq] [0.001196] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1
              [Meta.isDefEq.delta] [0.001175] ✅️ BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) 5#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 =?= BitVec.zeroExtend 16 x✝ * 5#16 ≥ BitVec.twoPow 16 7 <<< 1
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * 5#16) = true then none
            else some (if (!x✝ * 5#8 == 226#8) = true then 1#1 else 0#1)) ⊑
            some 1#1
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:255:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:249:8: error: (kernel) declaration has metavariables 'sgt_minnum_thm'
[bv] [0.030538] Normalizing goal
  [Meta.synthInstance] [0.001143] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else some (BitVec.ofBool (x✝ * 7#8 >ₛ 128#8))) ⊑
          some 1#1)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (x✝ * 7#8 >ₛ 128#8))) ⊑
            some 1#1
      ⊢ False
  [Meta.isDefEq] [0.001466] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7) (BitVec.signExtend 16 x✝ * 7#16))
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                            (BitVec.twoPow 16 7)))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                          (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16) true))
                      (congrArg (fun x => (!x) = true)
                        (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                (congrArg
                  (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) && x))
                  (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
        (true_and
          ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
            true))
    [Meta.isDefEq.assign] [0.001464] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                  (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                    (Eq.trans
                      (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                        (BitVec.signExtend 16 x✝ * 7#16))
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                              (BitVec.twoPow 16 7)))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                            (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16) true))
                        (congrArg (fun x => (!x) = true)
                          (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                  (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                  !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                  (congrArg
                    (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) && x))
                    (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
          (true_and
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.001439] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                  BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                    (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7)
                          (BitVec.signExtend 16 x✝ * 7#16))
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.signExtend 16 x✝ * 7#16)
                                (BitVec.twoPow 16 7)))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                              (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16) true))
                          (congrArg (fun x => (!x) = true)
                            (beq_true (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or
                    (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                    !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                      !BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)
                    (congrArg
                      (fun x => !((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) && x))
                      (Bool.not_not (BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)))))))
            (true_and
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                true)) : (True ∧
              (BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7)) =
            ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                  BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
              true))
        [Meta.isDefEq] [0.001436] ✅️ (True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                true) =?= (True ∧
                (BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7)) =
              ((!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                    BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                true)
          [Meta.isDefEq] [0.001417] ✅️ True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1)) =?= True ∧
                (BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7)
            [Meta.isDefEq] [0.001402] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1) =?= BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 7#16 ≥ BitVec.twoPow 16 7
              [Meta.isDefEq] [0.001293] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8)
                      (BitVec.twoPow 8
                        (8 - 1)) =?= BitVec.signExtend 16 x✝ * 7#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7)
                [Meta.isDefEq] [0.001274] ✅️ instLTBitVec.1
                      (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8)
                      (BitVec.signExtend (2 * 8)
                        (BitVec.twoPow 8
                          (8 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 16 x✝ * 7#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                  [Meta.isDefEq] [0.001222] ✅️ (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8).toNat <
                        (BitVec.signExtend (2 * 8)
                            (BitVec.twoPow 8
                              (8 -
                                1))).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat <
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                    [Meta.isDefEq] [0.001209] ✅️ instLTNat.1
                          (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8).toNat
                          (BitVec.signExtend (2 * 8)
                              (BitVec.twoPow 8
                                (8 -
                                  1))).toNat =?= instLTNat.1 (BitVec.signExtend 16 x✝ * 7#16).toNat
                          (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                      [Meta.isDefEq] [0.001182] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 7#8).toNat.lt
                            (BitVec.signExtend (2 * 8)
                                (BitVec.twoPow 8
                                  (8 -
                                    1))).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat.lt
                            (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                        [Meta.isDefEq.delta] [0.001172] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 7#8).toNat.lt
                              (BitVec.signExtend (2 * 8)
                                  (BitVec.twoPow 8
                                    (8 -
                                      1))).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat.lt
                              (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                          [Meta.isDefEq] [0.001081] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 7#8).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat
                            [Meta.isDefEq.delta] [0.001068] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 7#8).toNat =?= (BitVec.signExtend 16 x✝ * 7#16).toNat
                              [Meta.isDefEq] [0.001050] ✅️ BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 7#8 =?= BitVec.signExtend 16 x✝ * 7#16
                                [Meta.isDefEq] [0.001025] ✅️ instHMul.1 (BitVec.signExtend (2 * 8) x✝)
                                      (BitVec.signExtend (2 * 8) 7#8) =?= instHMul.1 (BitVec.signExtend 16 x✝) 7#16
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                  true then
              none
            else some (if (!(!(x✝ * 7#8).getLsbD 7) == (x✝ * 7#8 >ᵤ 128#8)) = true then 1#1 else 0#1)) ⊑
            some 1#1
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 95.936770ms, solving context: 0.000000ms
LeanSAT proved the goal after 185.078979ms: rewriting 38.076529ms, bitblasting 0.000000ms, SAT solving 110.709009ms, LRAT trimming 5.553840ms, LRAT checking 12.929900ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:275:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:269:8: error: (kernel) declaration has metavariables 'sgt_mulzero_thm'
[bv] [0.048726] Normalizing goal
  [Meta.synthInstance] [0.001957] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 0#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 0#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else some (BitVec.ofBool (x✝ * 0#8 >ₛ 21#8))) ⊑
          some 0#1)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 0#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 0#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (x✝ * 0#8 >ₛ 21#8))) ⊑
            some 0#1
      ⊢ False
  [Meta.isDefEq] [0.003084] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (Eq.trans
              (congr
                (congrArg Or
                  (Eq.trans
                    (Eq.trans (congrArg (fun x => x < BitVec.signExtend 16 (BitVec.twoPow 8 7)) BitVec.mul_zero)
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (0#16) (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                    (congrArg (fun x => x = true)
                      (Eq.trans
                        (Std.Tactic.BVDecide.Normalize.BitVec.zero_ult' (BitVec.signExtend 16 (BitVec.twoPow 8 7)))
                        (Std.Tactic.BVDecide.Normalize.BitVec.bne_to_beq (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                          0#16)))))
                (Eq.trans
                  (Eq.trans (congrArg (fun x => x ≥ BitVec.twoPow 16 7) BitVec.mul_zero)
                    Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2)
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7) 0#16)
                    (Eq.trans
                      (Eq.trans
                        (congrArg Not
                          (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (0#16) (BitVec.twoPow 16 7))
                            (congrArg (fun x => x = true)
                              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.zero_ult' (BitVec.twoPow 16 7))
                                (Std.Tactic.BVDecide.Normalize.BitVec.bne_to_beq (BitVec.twoPow 16 7) 0#16)))))
                        (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq (!BitVec.twoPow 16 7 == 0#16) true))
                      (congrArg (fun x => x = true)
                        (Eq.trans (congrArg not (beq_true !BitVec.twoPow 16 7 == 0#16))
                          (Bool.not_not (BitVec.twoPow 16 7 == 0#16))))))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_to_or (!BitVec.signExtend 16 (BitVec.twoPow 8 7) == 0#16)
                (BitVec.twoPow 16 7 == 0#16)))
            (congrArg (fun x => x = true)
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim (!BitVec.signExtend 16 (BitVec.twoPow 8 7) == 0#16)
                  (BitVec.twoPow 16 7 == 0#16))
                (congrArg (fun x => !(x && !BitVec.twoPow 16 7 == 0#16))
                  (Bool.not_not (BitVec.signExtend 16 (BitVec.twoPow 8 7) == 0#16)))))))
        (true_and ((!(BitVec.signExtend 16 (BitVec.twoPow 8 7) == 0#16 && !BitVec.twoPow 16 7 == 0#16)) = true))
    [Meta.isDefEq.assign] [0.003080] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Or
                    (Eq.trans
                      (Eq.trans (congrArg (fun x => x < BitVec.signExtend 16 (BitVec.twoPow 8 7)) BitVec.mul_zero)
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (0#16) (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                      (congrArg (fun x => x = true)
                        (Eq.trans
                          (Std.Tactic.BVDecide.Normalize.BitVec.zero_ult' (BitVec.signExtend 16 (BitVec.twoPow 8 7)))
                          (Std.Tactic.BVDecide.Normalize.BitVec.bne_to_beq (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                            0#16)))))
                  (Eq.trans
                    (Eq.trans (congrArg (fun x => x ≥ BitVec.twoPow 16 7) BitVec.mul_zero)
                      Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2)
                    (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7) 0#16)
                      (Eq.trans
                        (Eq.trans
                          (congrArg Not
                            (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (0#16) (BitVec.twoPow 16 7))
                              (congrArg (fun x => x = true)
                                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.zero_ult' (BitVec.twoPow 16 7))
                                  (Std.Tactic.BVDecide.Normalize.BitVec.bne_to_beq (BitVec.twoPow 16 7) 0#16)))))
                          (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq (!BitVec.twoPow 16 7 == 0#16) true))
                        (congrArg (fun x => x = true)
                          (Eq.trans (congrArg not (beq_true !BitVec.twoPow 16 7 == 0#16))
                            (Bool.not_not (BitVec.twoPow 16 7 == 0#16))))))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_to_or (!BitVec.signExtend 16 (BitVec.twoPow 8 7) == 0#16)
                  (BitVec.twoPow 16 7 == 0#16)))
              (congrArg (fun x => x = true)
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.Bool.or_elim (!BitVec.signExtend 16 (BitVec.twoPow 8 7) == 0#16)
                    (BitVec.twoPow 16 7 == 0#16))
                  (congrArg (fun x => !(x && !BitVec.twoPow 16 7 == 0#16))
                    (Bool.not_not (BitVec.signExtend 16 (BitVec.twoPow 8 7) == 0#16)))))))
          (true_and ((!(BitVec.signExtend 16 (BitVec.twoPow 8 7) == 0#16 && !BitVec.twoPow 16 7 == 0#16)) = true))
      [Meta.isDefEq.assign.checkTypes] [0.003060] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 0#8 <
                  BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 0#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
            ((!(BitVec.signExtend 16 (BitVec.twoPow 8 7) == 0#16 && !BitVec.twoPow 16 7 == 0#16)) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (Eq.trans
                  (congr
                    (congrArg Or
                      (Eq.trans
                        (Eq.trans (congrArg (fun x => x < BitVec.signExtend 16 (BitVec.twoPow 8 7)) BitVec.mul_zero)
                          (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (0#16)
                            (BitVec.signExtend 16 (BitVec.twoPow 8 7))))
                        (congrArg (fun x => x = true)
                          (Eq.trans
                            (Std.Tactic.BVDecide.Normalize.BitVec.zero_ult' (BitVec.signExtend 16 (BitVec.twoPow 8 7)))
                            (Std.Tactic.BVDecide.Normalize.BitVec.bne_to_beq (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                              0#16)))))
                    (Eq.trans
                      (Eq.trans (congrArg (fun x => x ≥ BitVec.twoPow 16 7) BitVec.mul_zero)
                        Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2)
                      (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7) 0#16)
                        (Eq.trans
                          (Eq.trans
                            (congrArg Not
                              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (0#16) (BitVec.twoPow 16 7))
                                (congrArg (fun x => x = true)
                                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.zero_ult' (BitVec.twoPow 16 7))
                                    (Std.Tactic.BVDecide.Normalize.BitVec.bne_to_beq (BitVec.twoPow 16 7) 0#16)))))
                            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq (!BitVec.twoPow 16 7 == 0#16) true))
                          (congrArg (fun x => x = true)
                            (Eq.trans (congrArg not (beq_true !BitVec.twoPow 16 7 == 0#16))
                              (Bool.not_not (BitVec.twoPow 16 7 == 0#16))))))))
                  (Std.Tactic.BVDecide.Normalize.Bool.or_to_or (!BitVec.signExtend 16 (BitVec.twoPow 8 7) == 0#16)
                    (BitVec.twoPow 16 7 == 0#16)))
                (congrArg (fun x => x = true)
                  (Eq.trans
                    (Std.Tactic.BVDecide.Normalize.Bool.or_elim (!BitVec.signExtend 16 (BitVec.twoPow 8 7) == 0#16)
                      (BitVec.twoPow 16 7 == 0#16))
                    (congrArg (fun x => !(x && !BitVec.twoPow 16 7 == 0#16))
                      (Bool.not_not (BitVec.signExtend 16 (BitVec.twoPow 8 7) == 0#16)))))))
            (true_and
              ((!(BitVec.signExtend 16 (BitVec.twoPow 8 7) == 0#16 && !BitVec.twoPow 16 7 == 0#16)) =
                true)) : (True ∧
              (BitVec.signExtend 16 x✝ * 0#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                BitVec.signExtend 16 x✝ * 0#16 ≥ BitVec.twoPow 16 7)) =
            ((!(BitVec.signExtend 16 (BitVec.twoPow 8 7) == 0#16 && !BitVec.twoPow 16 7 == 0#16)) = true))
        [Meta.isDefEq] [0.003056] ✅️ (True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 0#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 0#8 ≥ BitVec.twoPow (2 * 8) (8 - 1))) =
              ((!(BitVec.signExtend 16 (BitVec.twoPow 8 7) == 0#16 && !BitVec.twoPow 16 7 == 0#16)) =
                true) =?= (True ∧
                (BitVec.signExtend 16 x✝ * 0#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 0#16 ≥ BitVec.twoPow 16 7)) =
              ((!(BitVec.signExtend 16 (BitVec.twoPow 8 7) == 0#16 && !BitVec.twoPow 16 7 == 0#16)) = true)
          [Meta.isDefEq] [0.003021] ✅️ True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 0#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 0#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1)) =?= True ∧
                (BitVec.signExtend 16 x✝ * 0#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 0#16 ≥ BitVec.twoPow 16 7)
            [Meta.isDefEq] [0.002993] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 0#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 0#8 ≥
                    BitVec.twoPow (2 * 8)
                      (8 -
                        1) =?= BitVec.signExtend 16 x✝ * 0#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7) ∨
                  BitVec.signExtend 16 x✝ * 0#16 ≥ BitVec.twoPow 16 7
              [Meta.isDefEq] [0.002772] ✅️ BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 0#8 <
                    BitVec.signExtend (2 * 8)
                      (BitVec.twoPow 8
                        (8 - 1)) =?= BitVec.signExtend 16 x✝ * 0#16 < BitVec.signExtend 16 (BitVec.twoPow 8 7)
                [Meta.isDefEq] [0.002738] ✅️ instLTBitVec.1
                      (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 0#8)
                      (BitVec.signExtend (2 * 8)
                        (BitVec.twoPow 8
                          (8 -
                            1))) =?= instLTBitVec.1 (BitVec.signExtend 16 x✝ * 0#16)
                      (BitVec.signExtend 16 (BitVec.twoPow 8 7))
                  [Meta.isDefEq] [0.002664] ✅️ (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 0#8).toNat <
                        (BitVec.signExtend (2 * 8)
                            (BitVec.twoPow 8
                              (8 -
                                1))).toNat =?= (BitVec.signExtend 16 x✝ * 0#16).toNat <
                        (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                    [Meta.isDefEq] [0.002637] ✅️ instLTNat.1
                          (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 0#8).toNat
                          (BitVec.signExtend (2 * 8)
                              (BitVec.twoPow 8
                                (8 -
                                  1))).toNat =?= instLTNat.1 (BitVec.signExtend 16 x✝ * 0#16).toNat
                          (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                      [Meta.isDefEq] [0.002583] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 0#8).toNat.lt
                            (BitVec.signExtend (2 * 8)
                                (BitVec.twoPow 8
                                  (8 -
                                    1))).toNat =?= (BitVec.signExtend 16 x✝ * 0#16).toNat.lt
                            (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                        [Meta.isDefEq.delta] [0.002562] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 0#8).toNat.lt
                              (BitVec.signExtend (2 * 8)
                                  (BitVec.twoPow 8
                                    (8 -
                                      1))).toNat =?= (BitVec.signExtend 16 x✝ * 0#16).toNat.lt
                              (BitVec.signExtend 16 (BitVec.twoPow 8 7)).toNat
                          [Meta.isDefEq] [0.002386] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                  BitVec.signExtend (2 * 8) 0#8).toNat =?= (BitVec.signExtend 16 x✝ * 0#16).toNat
                            [Meta.isDefEq.delta] [0.002363] ✅️ (BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 0#8).toNat =?= (BitVec.signExtend 16 x✝ * 0#16).toNat
                              [Meta.isDefEq] [0.002325] ✅️ BitVec.signExtend (2 * 8) x✝ *
                                    BitVec.signExtend (2 * 8) 0#8 =?= BitVec.signExtend 16 x✝ * 0#16
                                [Meta.isDefEq] [0.002282] ✅️ instHMul.1 (BitVec.signExtend (2 * 8) x✝)
                                      (BitVec.signExtend (2 * 8) 0#8) =?= instHMul.1 (BitVec.signExtend 16 x✝) 0#16
                                  [Meta.isDefEq] [0.002186] ✅️ Mul.mul (BitVec.signExtend (2 * 8) x✝)
                                        (BitVec.signExtend (2 * 8) 0#8) =?= Mul.mul (BitVec.signExtend 16 x✝) 0#16
                                    [Meta.isDefEq] [0.002149] ✅️ BitVec.instMul.1 (BitVec.signExtend (2 * 8) x✝)
                                          (BitVec.signExtend (2 * 8)
                                            0#8) =?= BitVec.instMul.1 (BitVec.signExtend 16 x✝) 0#16
                                      [Meta.isDefEq] [0.002080] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                            (BitVec.signExtend (2 * 8) 0#8) =?= (BitVec.signExtend 16 x✝).mul 0#16
                                        [Meta.isDefEq.delta] [0.002061] ✅️ (BitVec.signExtend (2 * 8) x✝).mul
                                              (BitVec.signExtend (2 * 8) 0#8) =?= (BitVec.signExtend 16 x✝).mul 0#16
                                          [Meta.isDefEq] [0.001927] ✅️ BitVec.signExtend (2 * 8) 0#8 =?= 0#16
                                            [Meta.isDefEq] [0.001897] ✅️ BitVec.ofInt (2 * 8) (0#8).toInt =?= 0#16
                                              [Meta.isDefEq] [0.001868] ✅️ ((0#8).toInt %
                                                        Int.ofNat (2 ^ (2 * 8))).toNat#'⋯ =?= 0#16
                                                [Meta.isDefEq] [0.001838] ✅️ ((0#8).toInt %
                                                          Int.ofNat
                                                            (2 ^
                                                              (2 * 8))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 16) 0 }
                                                  [Meta.isDefEq] [0.001816] ✅️ {
                                                        toFin :=
                                                          ⟨((0#8).toInt % Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 16) 0 }
                                                    [Meta.isDefEq] [0.001760] ✅️ ⟨((0#8).toInt %
                                                              Int.ofNat (2 ^ (2 * 8))).toNat,
                                                          ⋯⟩ =?= Fin.ofNat' (2 ^ 16) 0
                                                      [Meta.isDefEq] [0.001732] ✅️ ⟨((0#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat,
                                                            ⋯⟩ =?= ⟨0 % 2 ^ 16, ⋯⟩
                                                        [Meta.isDefEq] [0.001546] ✅️ ((0#8).toInt %
                                                                Int.ofNat (2 ^ (2 * 8))).toNat =?= 0 % 2 ^ 16
                                                          [Meta.isDefEq] [0.001430] ✅️ match
                                                                (0#8).toInt % Int.ofNat (2 ^ (2 * 8)) with
                                                              | Int.ofNat n => n
                                                              | Int.negSucc a => 0 =?= 0 % 2 ^ 16
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if (!(BitVec.signExtend 16 (BitVec.twoPow 8 7) == 0#16 && !BitVec.twoPow 16 7 == 0#16)) = true then none
            else some 0#1) ⊑
            some 0#1
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 88.977159ms, solving context: 0.000000ms
LeanSAT proved the goal after 95.404530ms: rewriting 24.541630ms, bitblasting 0.000000ms, SAT solving 56.341300ms, LRAT trimming 0.000000ms, LRAT checking 5.382230ms
Bitwuzla proved the goal after 90.286260ms, solving context: 0.000000ms
LeanSAT proved the goal after 94.518949ms: rewriting 21.159920ms, bitblasting 0.000000ms, SAT solving 54.665309ms, LRAT trimming 2.545920ms, LRAT checking 7.199270ms
Bitwuzla proved the goal after 235.700839ms, solving context: 131.000000ms
LeanSAT proved the goal after 1114.222896ms: rewriting 21.026270ms, bitblasting 32.770950ms, SAT solving 662.846837ms, LRAT trimming 204.494299ms, LRAT checking 145.082690ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:317:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:317:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:309:8: error: (kernel) declaration has metavariables 'mul_constant_eq_nsw_thm'
[bv] [0.046476] Normalizing goal
  [Meta.synthInstance] [0.001319] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 32) x✝ * BitVec.signExtend (2 * 32) 6#32 <
                    BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                  BitVec.signExtend (2 * 32) x✝ * BitVec.signExtend (2 * 32) 6#32 ≥
                    BitVec.twoPow (2 * 32) (32 - 1)) then
            none
          else
            if
                True ∧
                  (BitVec.signExtend (2 * 32) x✝¹ * BitVec.signExtend (2 * 32) 6#32 <
                      BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                    BitVec.signExtend (2 * 32) x✝¹ * BitVec.signExtend (2 * 32) 6#32 ≥
                      BitVec.twoPow (2 * 32) (32 - 1)) then
              none
            else some (BitVec.ofBool (x✝ * 6#32 == x✝¹ * 6#32))) ⊑
          some (BitVec.ofBool (x✝ == x✝¹)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 32) x✝ * BitVec.signExtend (2 * 32) 6#32 <
                      BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                    BitVec.signExtend (2 * 32) x✝ * BitVec.signExtend (2 * 32) 6#32 ≥
                      BitVec.twoPow (2 * 32) (32 - 1)) then
              none
            else
              if
                  True ∧
                    (BitVec.signExtend (2 * 32) x✝¹ * BitVec.signExtend (2 * 32) 6#32 <
                        BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                      BitVec.signExtend (2 * 32) x✝¹ * BitVec.signExtend (2 * 32) 6#32 ≥
                        BitVec.twoPow (2 * 32) (32 - 1)) then
                none
              else some (BitVec.ofBool (x✝ * 6#32 == x✝¹ * 6#32))) ⊑
            some (BitVec.ofBool (x✝ == x✝¹))
      ⊢ False
  [Meta.isDefEq] [0.001793] ❌️ ?a == ?a =?= x✝ * 6#32 == x✝¹ * 6#32
    [Meta.isDefEq] [0.001631] ✅️ ?a =?= x✝ * 6#32
      [Meta.isDefEq.assign] [0.001628] ✅️ ?a := x✝ * 6#32
        [Meta.isDefEq.assign.checkTypes] [0.001618] ✅️ (?a : BitVec 32) := (x✝ * 6#32 : BitVec 32)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ BitVec.signExtend 64 x✝ * 6#64) &&
                      BitVec.twoPow 64 31 >ᵤ BitVec.signExtend 64 x✝ * 6#64)) =
                  true then
              none
            else
              if
                  (!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ BitVec.signExtend 64 x✝¹ * 6#64) &&
                        BitVec.twoPow 64 31 >ᵤ BitVec.signExtend 64 x✝¹ * 6#64)) =
                    true then
                none
              else some (if (x✝ * 6#32 == x✝¹ * 6#32) = true then 1#1 else 0#1)) ⊑
            some (if (x✝ == x✝¹) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:329:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:329:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:321:8: error: (kernel) declaration has metavariables 'mul_constant_nuw_eq_thm'
[bv] [0.041091] Normalizing goal
  [Meta.synthInstance] [0.001210] ✅️ Decidable
        ((if
              True ∧
                BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 22#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
            none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 32) x✝¹ * BitVec.zeroExtend (2 * 32) 22#32 ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else some (BitVec.ofBool (x✝ * 22#32 == x✝¹ * 22#32))) ⊑
          some (BitVec.ofBool (x✝ == x✝¹)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if
                True ∧
                  BitVec.zeroExtend (2 * 32) x✝ * BitVec.zeroExtend (2 * 32) 22#32 ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 32) x✝¹ * BitVec.zeroExtend (2 * 32) 22#32 ≥
                      BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                none
              else some (BitVec.ofBool (x✝ * 22#32 == x✝¹ * 22#32))) ⊑
            some (BitVec.ofBool (x✝ == x✝¹))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝ * 22#64) = true then none
            else
              if (!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 22#64) = true then none
              else some (if (x✝ * 22#32 == x✝¹ * 22#32) = true then 1#1 else 0#1)) ⊑
            some (if (x✝ == x✝¹) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:340:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:333:8: error: (kernel) declaration has metavariables 'mul_constant_partial_nuw_eq_thm'
[bv] [0.034792] Normalizing goal
  [Meta.synthInstance] [0.001471] ✅️ Decidable
        ((if
              True ∧
                BitVec.zeroExtend (2 * 32) x✝¹ * BitVec.zeroExtend (2 * 32) 44#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
            none
          else some (BitVec.ofBool (x✝ * 44#32 == x✝¹ * 44#32))) ⊑
          some (BitVec.ofBool ((x✝ ^^^ x✝¹) &&& 1073741823#32 == 0#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if
                True ∧
                  BitVec.zeroExtend (2 * 32) x✝¹ * BitVec.zeroExtend (2 * 32) 44#32 ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else some (BitVec.ofBool (x✝ * 44#32 == x✝¹ * 44#32))) ⊑
            some (BitVec.ofBool ((x✝ ^^^ x✝¹) &&& 1073741823#32 == 0#32))
      ⊢ False
  [Meta.isDefEq] [0.001423] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                (BitVec.zeroExtend 64 x✝¹ * 44#64))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 x✝¹ * 44#64)
                      (BitVec.twoPow 64 31 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 44#64) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 44#64)))))))
        (true_and ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 44#64) = true))
    [Meta.isDefEq.assign] [0.001421] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                  (BitVec.zeroExtend 64 x✝¹ * 44#64))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 x✝¹ * 44#64)
                        (BitVec.twoPow 64 31 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 44#64) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 44#64)))))))
          (true_and ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 44#64) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001408] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 32) x✝¹ * BitVec.zeroExtend (2 * 32) 44#32 ≥
                BitVec.twoPow (2 * 32) (32 - 1) <<< 1) =
            ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 44#64) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                    (BitVec.zeroExtend 64 x✝¹ * 44#64))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 x✝¹ * 44#64)
                          (BitVec.twoPow 64 31 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 44#64) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 44#64)))))))
            (true_and
              ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 44#64) =
                true)) : (True ∧ BitVec.zeroExtend 64 x✝¹ * 44#64 ≥ BitVec.twoPow 64 31 <<< 1) =
            ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 44#64) = true))
        [Meta.isDefEq] [0.001404] ✅️ (True ∧
                BitVec.zeroExtend (2 * 32) x✝¹ * BitVec.zeroExtend (2 * 32) 44#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1) =
              ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 44#64) =
                true) =?= (True ∧ BitVec.zeroExtend 64 x✝¹ * 44#64 ≥ BitVec.twoPow 64 31 <<< 1) =
              ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 44#64) = true)
          [Meta.isDefEq] [0.001385] ✅️ True ∧
                BitVec.zeroExtend (2 * 32) x✝¹ * BitVec.zeroExtend (2 * 32) 44#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 64 x✝¹ * 44#64 ≥ BitVec.twoPow 64 31 <<< 1
            [Meta.isDefEq] [0.001370] ✅️ BitVec.zeroExtend (2 * 32) x✝¹ * BitVec.zeroExtend (2 * 32) 44#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1 =?= BitVec.zeroExtend 64 x✝¹ * 44#64 ≥ BitVec.twoPow 64 31 <<< 1
              [Meta.isDefEq.delta] [0.001350] ✅️ BitVec.zeroExtend (2 * 32) x✝¹ * BitVec.zeroExtend (2 * 32) 44#32 ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<<
                      1 =?= BitVec.zeroExtend 64 x✝¹ * 44#64 ≥ BitVec.twoPow 64 31 <<< 1
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 44#64) = true then none
            else some (if (x✝ * 44#32 == x✝¹ * 44#32) = true then 1#1 else 0#1)) ⊑
            some (if ((x✝ ^^^ x✝¹) &&& 1073741823#32 == 0#32) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:352:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:352:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:344:8: error: (kernel) declaration has metavariables 'mul_constant_mismatch_wrap_eq_thm'
[bv] [0.048257] Normalizing goal
  [Meta.synthInstance] [0.001429] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 32) x✝ * BitVec.signExtend (2 * 32) 54#32 <
                    BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                  BitVec.signExtend (2 * 32) x✝ * BitVec.signExtend (2 * 32) 54#32 ≥
                    BitVec.twoPow (2 * 32) (32 - 1)) then
            none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 32) x✝¹ * BitVec.zeroExtend (2 * 32) 54#32 ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else some (BitVec.ofBool (x✝ * 54#32 == x✝¹ * 54#32))) ⊑
          some (BitVec.ofBool ((x✝ ^^^ x✝¹) &&& 2147483647#32 == 0#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 32) x✝ * BitVec.signExtend (2 * 32) 54#32 <
                      BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                    BitVec.signExtend (2 * 32) x✝ * BitVec.signExtend (2 * 32) 54#32 ≥
                      BitVec.twoPow (2 * 32) (32 - 1)) then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 32) x✝¹ * BitVec.zeroExtend (2 * 32) 54#32 ≥
                      BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                none
              else some (BitVec.ofBool (x✝ * 54#32 == x✝¹ * 54#32))) ⊑
            some (BitVec.ofBool ((x✝ ^^^ x✝¹) &&& 2147483647#32 == 0#32))
      ⊢ False
  [Meta.isDefEq] [0.002312] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                (BitVec.zeroExtend 64 x✝¹ * 54#64))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 x✝¹ * 54#64)
                      (BitVec.twoPow 64 31 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 54#64) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 54#64)))))))
        (true_and ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 54#64) = true))
    [Meta.isDefEq.assign] [0.002309] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                  (BitVec.zeroExtend 64 x✝¹ * 54#64))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 x✝¹ * 54#64)
                        (BitVec.twoPow 64 31 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 54#64) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 54#64)))))))
          (true_and ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 54#64) = true))
      [Meta.isDefEq.assign.checkTypes] [0.002296] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 32) x✝¹ * BitVec.zeroExtend (2 * 32) 54#32 ≥
                BitVec.twoPow (2 * 32) (32 - 1) <<< 1) =
            ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 54#64) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 64 31 <<< 1)
                    (BitVec.zeroExtend 64 x✝¹ * 54#64))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 64 x✝¹ * 54#64)
                          (BitVec.twoPow 64 31 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 54#64) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 54#64)))))))
            (true_and
              ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 54#64) =
                true)) : (True ∧ BitVec.zeroExtend 64 x✝¹ * 54#64 ≥ BitVec.twoPow 64 31 <<< 1) =
            ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 54#64) = true))
        [Meta.isDefEq] [0.002293] ✅️ (True ∧
                BitVec.zeroExtend (2 * 32) x✝¹ * BitVec.zeroExtend (2 * 32) 54#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1) =
              ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 54#64) =
                true) =?= (True ∧ BitVec.zeroExtend 64 x✝¹ * 54#64 ≥ BitVec.twoPow 64 31 <<< 1) =
              ((!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 54#64) = true)
          [Meta.isDefEq] [0.002274] ✅️ True ∧
                BitVec.zeroExtend (2 * 32) x✝¹ * BitVec.zeroExtend (2 * 32) 54#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 64 x✝¹ * 54#64 ≥ BitVec.twoPow 64 31 <<< 1
            [Meta.isDefEq] [0.002264] ✅️ BitVec.zeroExtend (2 * 32) x✝¹ * BitVec.zeroExtend (2 * 32) 54#32 ≥
                  BitVec.twoPow (2 * 32) (32 - 1) <<< 1 =?= BitVec.zeroExtend 64 x✝¹ * 54#64 ≥ BitVec.twoPow 64 31 <<< 1
              [Meta.isDefEq.delta] [0.002245] ✅️ BitVec.zeroExtend (2 * 32) x✝¹ * BitVec.zeroExtend (2 * 32) 54#32 ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<<
                      1 =?= BitVec.zeroExtend 64 x✝¹ * 54#64 ≥ BitVec.twoPow 64 31 <<< 1
                [Meta.isDefEq] [0.001841] ✅️ BitVec.zeroExtend (2 * 32) x✝¹ *
                      BitVec.zeroExtend (2 * 32) 54#32 =?= BitVec.zeroExtend 64 x✝¹ * 54#64
                  [Meta.isDefEq] [0.001822] ✅️ instHMul.1 (BitVec.zeroExtend (2 * 32) x✝¹)
                        (BitVec.zeroExtend (2 * 32) 54#32) =?= instHMul.1 (BitVec.zeroExtend 64 x✝¹) 54#64
                    [Meta.isDefEq] [0.001790] ✅️ Mul.mul (BitVec.zeroExtend (2 * 32) x✝¹)
                          (BitVec.zeroExtend (2 * 32) 54#32) =?= Mul.mul (BitVec.zeroExtend 64 x✝¹) 54#64
                      [Meta.isDefEq] [0.001775] ✅️ BitVec.instMul.1 (BitVec.zeroExtend (2 * 32) x✝¹)
                            (BitVec.zeroExtend (2 * 32) 54#32) =?= BitVec.instMul.1 (BitVec.zeroExtend 64 x✝¹) 54#64
                        [Meta.isDefEq] [0.001751] ✅️ (BitVec.zeroExtend (2 * 32) x✝¹).mul
                              (BitVec.zeroExtend (2 * 32) 54#32) =?= (BitVec.zeroExtend 64 x✝¹).mul 54#64
                          [Meta.isDefEq.delta] [0.001742] ✅️ (BitVec.zeroExtend (2 * 32) x✝¹).mul
                                (BitVec.zeroExtend (2 * 32) 54#32) =?= (BitVec.zeroExtend 64 x✝¹).mul 54#64
                            [Meta.isDefEq] [0.001670] ✅️ BitVec.zeroExtend (2 * 32) 54#32 =?= 54#64
                              [Meta.isDefEq] [0.001658] ✅️ BitVec.setWidth (2 * 32) 54#32 =?= 54#64
                                [Meta.isDefEq] [0.001640] ✅️ if h : 32 ≤ 2 * 32 then BitVec.setWidth' h 54#32
                                    else BitVec.ofNat (2 * 32) (54#32).toNat =?= 54#64
                                  [Meta.isDefEq] [0.001618] ✅️ if h : 32 ≤ 2 * 32 then BitVec.setWidth' h 54#32
                                      else BitVec.ofNat (2 * 32) (54#32).toNat =?= { toFin := Fin.ofNat' (2 ^ 64) 54 }
                                    [Meta.isDefEq] [0.001602] ✅️ Decidable.casesOn (Nat.decLe 32 (2 * 32))
                                          (fun h => BitVec.ofNat (2 * 32) (54#32).toNat) fun h =>
                                          BitVec.setWidth' h 54#32 =?= { toFin := Fin.ofNat' (2 ^ 64) 54 }
                                      [Meta.whnf] [0.001292] Non-easy whnf: Nat.decLe 32 (2 * 32)
                                        [Meta.whnf] [0.001278] Non-easy whnf: if h : Nat.ble 32 (2 * 32) = true then
                                              isTrue ⋯
                                            else isFalse ⋯
                                          [Meta.whnf] [0.001272] Non-easy whnf: Decidable.casesOn
                                                (instDecidableEqBool (Nat.ble 32 (2 * 32)) true) (fun h => isFalse ⋯)
                                                fun h => isTrue ⋯
                                            [Meta.whnf] [0.001256] Non-easy whnf: instDecidableEqBool
                                                  (Nat.ble 32 (2 * 32)) true
                                              [Meta.whnf] [0.001250] Non-easy whnf: (Nat.ble 32 (2 * 32)).decEq true
                                                [Meta.whnf] [0.001242] Non-easy whnf: match Nat.ble 32 (2 * 32),
                                                      true with
                                                    | false, false => isTrue ⋯
                                                    | false, true => isFalse ⋯
                                                    | true, false => isFalse ⋯
                                                    | true, true => isTrue ⋯
                                                  [Meta.whnf] [0.001212] Non-easy whnf: (fun motive a b h_1 h_2 h_3
                                                            h_4 =>
                                                          Bool.casesOn a (Bool.casesOn b (h_1 ()) (h_2 ()))
                                                            (Bool.casesOn b (h_3 ()) (h_4 ())))
                                                        (fun a b => Decidable (a = b)) (Nat.ble 32 (2 * 32)) true h_1
                                                        h_2 h_3 h_4
                                                    [Meta.whnf] [0.001159] Non-easy whnf: Nat.ble 32 (2 * 32)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ BitVec.signExtend 64 x✝ * 54#64) &&
                      BitVec.twoPow 64 31 >ᵤ BitVec.signExtend 64 x✝ * 54#64)) =
                  true then
              none
            else
              if (!BitVec.twoPow 64 31 <<< 1 >ᵤ BitVec.zeroExtend 64 x✝¹ * 54#64) = true then none
              else some (if (x✝ * 54#32 == x✝¹ * 54#32) = true then 1#1 else 0#1)) ⊑
            some (if ((x✝ ^^^ x✝¹) &&& 2147483647#32 == 0#32) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 191.714479ms, solving context: 94.000000ms
LeanSAT proved the goal after 614.578187ms: rewriting 24.864850ms, bitblasting 16.240670ms, SAT solving 355.692398ms, LRAT trimming 98.449000ms, LRAT checking 99.522999ms
Bitwuzla proved the goal after 80.052310ms, solving context: 0.000000ms
LeanSAT proved the goal after 93.510800ms: rewriting 16.114150ms, bitblasting 4.927330ms, SAT solving 55.764790ms, LRAT trimming 0.000000ms, LRAT checking 10.656230ms
Bitwuzla proved the goal after 78.609120ms, solving context: 0.000000ms
LeanSAT proved the goal after 92.799700ms: rewriting 16.278680ms, bitblasting 4.774460ms, SAT solving 55.505550ms, LRAT trimming 0.000000ms, LRAT checking 10.052820ms
Bitwuzla proved the goal after 77.505360ms, solving context: 0.000000ms
LeanSAT proved the goal after 89.458939ms: rewriting 16.391670ms, bitblasting 4.305290ms, SAT solving 55.462739ms, LRAT trimming 0.000000ms, LRAT checking 8.362330ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:407:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:399:8: error: (kernel) declaration has metavariables 'not_mul_of_bool_thm'
[bv] [0.040904] Normalizing goal
  [Meta.synthInstance] [0.001647] ✅️ Decidable
        (some (BitVec.ofBool ((x✝ &&& 3#32) * BitVec.zeroExtend 32 x✝¹ >ᵤ 255#32)) ⊑
          if
              True ∧
                (BitVec.signExtend (2 * 32) (x✝ &&& 3#32) * BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝¹) <
                    BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                  BitVec.signExtend (2 * 32) (x✝ &&& 3#32) * BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝¹) ≥
                    BitVec.twoPow (2 * 32) (32 - 1)) then
            none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 32) (x✝ &&& 3#32) * BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝¹) ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else some (BitVec.ofBool ((x✝ &&& 3#32) * BitVec.zeroExtend 32 x✝¹ >ᵤ 255#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 32
      x✝¹ : BitVec 8
      x✝ : BitVec 32
      a✝ :
        ¬some (BitVec.ofBool ((x✝ &&& 3#32) * BitVec.zeroExtend 32 x✝¹ >ᵤ 255#32)) ⊑
            if
                True ∧
                  (BitVec.signExtend (2 * 32) (x✝ &&& 3#32) * BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝¹) <
                      BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                    BitVec.signExtend (2 * 32) (x✝ &&& 3#32) * BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝¹) ≥
                      BitVec.twoPow (2 * 32) (32 - 1)) then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 32) (x✝ &&& 3#32) * BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝¹) ≥
                      BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                none
              else some (BitVec.ofBool ((x✝ &&& 3#32) * BitVec.zeroExtend 32 x✝¹ >ᵤ 255#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 32
      x✝¹ : BitVec 8
      x✝ : BitVec 32
      a✝ :
        ¬some (if ((x✝ &&& 3#32) * BitVec.zeroExtend 32 x✝¹ >ᵤ 255#32) = true then 1#1 else 0#1) ⊑
            if
                (!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                          BitVec.signExtend 64 (x✝ &&& 3#32) * BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝¹)) &&
                      BitVec.twoPow 64 31 >ᵤ
                        BitVec.signExtend 64 (x✝ &&& 3#32) * BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝¹))) =
                  true then
              none
            else
              if
                  (!BitVec.twoPow 64 31 <<< 1 >ᵤ
                        BitVec.zeroExtend 64 (x✝ &&& 3#32) * BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝¹)) =
                    true then
                none
              else some (if ((x✝ &&& 3#32) * BitVec.zeroExtend 32 x✝¹ >ᵤ 255#32) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:419:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:411:8: error: (kernel) declaration has metavariables 'not_mul_of_bool_commute_thm'
[bv] [0.043203] Normalizing goal
  [Meta.synthInstance] [0.001685] ✅️ Decidable
        ((if 30#32 ≥ ↑32 then none else some (BitVec.ofBool ((x✝ &&& 255#32) * x✝¹ >>> 30#32 >ᵤ 255#32))) ⊑
          if 30#32 ≥ ↑32 then none
          else
            if
                True ∧
                  (BitVec.signExtend (2 * 32) (x✝ &&& 255#32) * BitVec.signExtend (2 * 32) (x✝¹ >>> 30#32) <
                      BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                    BitVec.signExtend (2 * 32) (x✝ &&& 255#32) * BitVec.signExtend (2 * 32) (x✝¹ >>> 30#32) ≥
                      BitVec.twoPow (2 * 32) (32 - 1)) then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 32) (x✝ &&& 255#32) * BitVec.zeroExtend (2 * 32) (x✝¹ >>> 30#32) ≥
                      BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                none
              else some (BitVec.ofBool ((x✝ &&& 255#32) * x✝¹ >>> 30#32 >ᵤ 255#32)))
    [Meta.check] [0.001061] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if 30#32 ≥ ↑32 then none else some (BitVec.ofBool ((x✝ &&& 255#32) * x✝¹ >>> 30#32 >ᵤ 255#32)))
          (if 30#32 ≥ ↑32 then none
          else
            if
                True ∧
                  (BitVec.signExtend (2 * 32) (x✝ &&& 255#32) * BitVec.signExtend (2 * 32) (x✝¹ >>> 30#32) <
                      BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                    BitVec.signExtend (2 * 32) (x✝ &&& 255#32) * BitVec.signExtend (2 * 32) (x✝¹ >>> 30#32) ≥
                      BitVec.twoPow (2 * 32) (32 - 1)) then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 32) (x✝ &&& 255#32) * BitVec.zeroExtend (2 * 32) (x✝¹ >>> 30#32) ≥
                      BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                none
              else some (BitVec.ofBool ((x✝ &&& 255#32) * x✝¹ >>> 30#32 >ᵤ 255#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if 30#32 ≥ ↑32 then none else some (BitVec.ofBool ((x✝ &&& 255#32) * x✝¹ >>> 30#32 >ᵤ 255#32))) ⊑
            if 30#32 ≥ ↑32 then none
            else
              if
                  True ∧
                    (BitVec.signExtend (2 * 32) (x✝ &&& 255#32) * BitVec.signExtend (2 * 32) (x✝¹ >>> 30#32) <
                        BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                      BitVec.signExtend (2 * 32) (x✝ &&& 255#32) * BitVec.signExtend (2 * 32) (x✝¹ >>> 30#32) ≥
                        BitVec.twoPow (2 * 32) (32 - 1)) then
                none
              else
                if
                    True ∧
                      BitVec.zeroExtend (2 * 32) (x✝ &&& 255#32) * BitVec.zeroExtend (2 * 32) (x✝¹ >>> 30#32) ≥
                        BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                  none
                else some (BitVec.ofBool ((x✝ &&& 255#32) * x✝¹ >>> 30#32 >ᵤ 255#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬some (if ((x✝ &&& 255#32) * x✝¹ >>> 30 >ᵤ 255#32) = true then 1#1 else 0#1) ⊑
            if
                (!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                          BitVec.signExtend 64 (x✝ &&& 255#32) * BitVec.signExtend 64 (x✝¹ >>> 30)) &&
                      BitVec.twoPow 64 31 >ᵤ
                        BitVec.signExtend 64 (x✝ &&& 255#32) * BitVec.signExtend 64 (x✝¹ >>> 30))) =
                  true then
              none
            else
              if
                  (!BitVec.twoPow 64 31 <<< 1 >ᵤ
                        BitVec.zeroExtend 64 (x✝ &&& 255#32) * BitVec.zeroExtend 64 (x✝¹ >>> 30)) =
                    true then
                none
              else some (if ((x✝ &&& 255#32) * x✝¹ >>> 30 >ᵤ 255#32) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:431:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:423:8: error: (kernel) declaration has metavariables 'mul_of_bool_no_lz_other_op_thm'
[bv] [0.048910] Normalizing goal
  [Meta.synthInstance] [0.001590] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 32) (x✝ &&& 1#32) * BitVec.signExtend (2 * 32) (BitVec.signExtend 32 x✝¹) <
                    BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                  BitVec.signExtend (2 * 32) (x✝ &&& 1#32) * BitVec.signExtend (2 * 32) (BitVec.signExtend 32 x✝¹) ≥
                    BitVec.twoPow (2 * 32) (32 - 1)) then
            none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 32) (x✝ &&& 1#32) * BitVec.zeroExtend (2 * 32) (BitVec.signExtend 32 x✝¹) ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else some (BitVec.ofBool ((x✝ &&& 1#32) * BitVec.signExtend 32 x✝¹ >ₛ 127#32))) ⊑
          some 0#1)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 32
      x✝¹ : BitVec 8
      x✝ : BitVec 32
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 32) (x✝ &&& 1#32) * BitVec.signExtend (2 * 32) (BitVec.signExtend 32 x✝¹) <
                      BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                    BitVec.signExtend (2 * 32) (x✝ &&& 1#32) * BitVec.signExtend (2 * 32) (BitVec.signExtend 32 x✝¹) ≥
                      BitVec.twoPow (2 * 32) (32 - 1)) then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 32) (x✝ &&& 1#32) * BitVec.zeroExtend (2 * 32) (BitVec.signExtend 32 x✝¹) ≥
                      BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                none
              else some (BitVec.ofBool ((x✝ &&& 1#32) * BitVec.signExtend 32 x✝¹ >ₛ 127#32))) ⊑
            some 0#1
      ⊢ False
  [Meta.isDefEq] [0.002072] ❌️ ?a =
        ?a =?= (BitVec.twoPow 64 31 >ᵤ
          BitVec.signExtend 64 (x✝ &&& 1#32) * BitVec.signExtend 64 (BitVec.signExtend 32 x✝¹)) =
        true
    [Meta.isDefEq] [0.001827] ✅️ ?α =?= Bool
      [Meta.isDefEq.assign] [0.001824] ✅️ ?α := Bool
        [Meta.isDefEq.assign.checkTypes] [0.001817] ✅️ (?α : Sort ?u.232564) := (Bool : Type)
          [Meta.isDefEq] [0.001773] ✅️ Sort ?u.232564 =?= Type
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 32
      x✝¹ : BitVec 8
      x✝ : BitVec 32
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                          BitVec.signExtend 64 (x✝ &&& 1#32) * BitVec.signExtend 64 (BitVec.signExtend 32 x✝¹)) &&
                      BitVec.twoPow 64 31 >ᵤ
                        BitVec.signExtend 64 (x✝ &&& 1#32) * BitVec.signExtend 64 (BitVec.signExtend 32 x✝¹))) =
                  true then
              none
            else
              if
                  (!BitVec.twoPow 64 31 <<< 1 >ᵤ
                        BitVec.zeroExtend 64 (x✝ &&& 1#32) * BitVec.zeroExtend 64 (BitVec.signExtend 32 x✝¹)) =
                    true then
                none
              else
                some
                  (if
                      (!((x✝ &&& 1#32) * BitVec.signExtend 32 x✝¹).getLsbD 31 ==
                            ((x✝ &&& 1#32) * BitVec.signExtend 32 x✝¹ >ᵤ 127#32)) =
                        true then
                    1#1
                  else 0#1)) ⊑
            some 0#1
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 77.516720ms, solving context: 0.000000ms
LeanSAT proved the goal after 102.224250ms: rewriting 16.099700ms, bitblasting 4.910120ms, SAT solving 55.427370ms, LRAT trimming 2.863910ms, LRAT checking 14.981950ms
Bitwuzla proved the goal after 77.163010ms, solving context: 0.000000ms
LeanSAT proved the goal after 101.806199ms: rewriting 16.317660ms, bitblasting 5.152160ms, SAT solving 55.037559ms, LRAT trimming 2.822560ms, LRAT checking 14.821780ms
Bitwuzla proved the goal after 68.134979ms, solving context: 0.000000ms
LeanSAT proved the goal after 88.918929ms: rewriting 11.246479ms, bitblasting 3.155140ms, SAT solving 55.263030ms, LRAT trimming 3.117230ms, LRAT checking 11.804610ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:474:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:466:8: error: (kernel) declaration has metavariables 'not_mul_of_pow2_thm'
[bv] [0.040274] Normalizing goal
  [Meta.synthInstance] [0.001610] ✅️ Decidable
        (some (BitVec.ofBool ((x✝ &&& 6#32) * BitVec.zeroExtend 32 x✝¹ >ᵤ 1530#32)) ⊑
          if
              True ∧
                (BitVec.signExtend (2 * 32) (x✝ &&& 6#32) * BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝¹) <
                    BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                  BitVec.signExtend (2 * 32) (x✝ &&& 6#32) * BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝¹) ≥
                    BitVec.twoPow (2 * 32) (32 - 1)) then
            none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 32) (x✝ &&& 6#32) * BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝¹) ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else some (BitVec.ofBool ((x✝ &&& 6#32) * BitVec.zeroExtend 32 x✝¹ >ᵤ 1530#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 32
      x✝¹ : BitVec 8
      x✝ : BitVec 32
      a✝ :
        ¬some (BitVec.ofBool ((x✝ &&& 6#32) * BitVec.zeroExtend 32 x✝¹ >ᵤ 1530#32)) ⊑
            if
                True ∧
                  (BitVec.signExtend (2 * 32) (x✝ &&& 6#32) * BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝¹) <
                      BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                    BitVec.signExtend (2 * 32) (x✝ &&& 6#32) * BitVec.signExtend (2 * 32) (BitVec.zeroExtend 32 x✝¹) ≥
                      BitVec.twoPow (2 * 32) (32 - 1)) then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 32) (x✝ &&& 6#32) * BitVec.zeroExtend (2 * 32) (BitVec.zeroExtend 32 x✝¹) ≥
                      BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                none
              else some (BitVec.ofBool ((x✝ &&& 6#32) * BitVec.zeroExtend 32 x✝¹ >ᵤ 1530#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      e_1 : LLVM.IntW 32
      x✝¹ : BitVec 8
      x✝ : BitVec 32
      a✝ :
        ¬some (if ((x✝ &&& 6#32) * BitVec.zeroExtend 32 x✝¹ >ᵤ 1530#32) = true then 1#1 else 0#1) ⊑
            if
                (!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                          BitVec.signExtend 64 (x✝ &&& 6#32) * BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝¹)) &&
                      BitVec.twoPow 64 31 >ᵤ
                        BitVec.signExtend 64 (x✝ &&& 6#32) * BitVec.signExtend 64 (BitVec.zeroExtend 32 x✝¹))) =
                  true then
              none
            else
              if
                  (!BitVec.twoPow 64 31 <<< 1 >ᵤ
                        BitVec.zeroExtend 64 (x✝ &&& 6#32) * BitVec.zeroExtend 64 (BitVec.zeroExtend 32 x✝¹)) =
                    true then
                none
              else some (if ((x✝ &&& 6#32) * BitVec.zeroExtend 32 x✝¹ >ᵤ 1530#32) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:487:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:478:8: error: (kernel) declaration has metavariables 'not_mul_of_pow2_commute_thm'
[bv] [0.040342] Normalizing goal
  [Meta.synthInstance] [0.001557] ✅️ Decidable
        (some (BitVec.ofBool ((x✝ &&& 255#32) * (x✝¹ &&& 12#32) >ᵤ 3060#32)) ⊑
          if
              True ∧
                (BitVec.signExtend (2 * 32) (x✝ &&& 255#32) * BitVec.signExtend (2 * 32) (x✝¹ &&& 12#32) <
                    BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                  BitVec.signExtend (2 * 32) (x✝ &&& 255#32) * BitVec.signExtend (2 * 32) (x✝¹ &&& 12#32) ≥
                    BitVec.twoPow (2 * 32) (32 - 1)) then
            none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 32) (x✝ &&& 255#32) * BitVec.zeroExtend (2 * 32) (x✝¹ &&& 12#32) ≥
                    BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
              none
            else some (BitVec.ofBool ((x✝ &&& 255#32) * (x✝¹ &&& 12#32) >ᵤ 3060#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬some (BitVec.ofBool ((x✝ &&& 255#32) * (x✝¹ &&& 12#32) >ᵤ 3060#32)) ⊑
            if
                True ∧
                  (BitVec.signExtend (2 * 32) (x✝ &&& 255#32) * BitVec.signExtend (2 * 32) (x✝¹ &&& 12#32) <
                      BitVec.signExtend (2 * 32) (BitVec.twoPow 32 (32 - 1)) ∨
                    BitVec.signExtend (2 * 32) (x✝ &&& 255#32) * BitVec.signExtend (2 * 32) (x✝¹ &&& 12#32) ≥
                      BitVec.twoPow (2 * 32) (32 - 1)) then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 32) (x✝ &&& 255#32) * BitVec.zeroExtend (2 * 32) (x✝¹ &&& 12#32) ≥
                      BitVec.twoPow (2 * 32) (32 - 1) <<< 1 then
                none
              else some (BitVec.ofBool ((x✝ &&& 255#32) * (x✝¹ &&& 12#32) >ᵤ 3060#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬some (if ((x✝ &&& 255#32) * (x✝¹ &&& 12#32) >ᵤ 3060#32) = true then 1#1 else 0#1) ⊑
            if
                (!((!BitVec.signExtend 64 (BitVec.twoPow 32 31) >ᵤ
                          BitVec.signExtend 64 (x✝ &&& 255#32) * BitVec.signExtend 64 (x✝¹ &&& 12#32)) &&
                      BitVec.twoPow 64 31 >ᵤ
                        BitVec.signExtend 64 (x✝ &&& 255#32) * BitVec.signExtend 64 (x✝¹ &&& 12#32))) =
                  true then
              none
            else
              if
                  (!BitVec.twoPow 64 31 <<< 1 >ᵤ
                        BitVec.zeroExtend 64 (x✝ &&& 255#32) * BitVec.zeroExtend 64 (x✝¹ &&& 12#32)) =
                    true then
                none
              else some (if ((x✝ &&& 255#32) * (x✝¹ &&& 12#32) >ᵤ 3060#32) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:498:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:491:8: error: (kernel) declaration has metavariables 'splat_mul_known_lz_thm'
[bv] [0.016917] Normalizing goal
  [Meta.synthInstance] [0.001141] ✅️ Decidable
        ((if 96#128 ≥ ↑128 then none
          else some (BitVec.ofBool ((BitVec.zeroExtend 128 x✝ * 18446744078004518913#128) >>> 96#128 == 0#128))) ⊑
          some 1#1)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if 96#128 ≥ ↑128 then none
            else some (BitVec.ofBool ((BitVec.zeroExtend 128 x✝ * 18446744078004518913#128) >>> 96#128 == 0#128))) ⊑
            some 1#1
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬some (if ((BitVec.zeroExtend 128 x✝ * 18446744078004518913#128) >>> 96 == 0#128) = true then 1#1 else 0#1) ⊑
            some 1#1
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:509:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:502:8: error: (kernel) declaration has metavariables 'splat_mul_unknown_lz_thm'
[bv] [0.025711] Normalizing goal
  [Meta.synthInstance] [0.001173] ✅️ Decidable
        ((if 95#128 ≥ ↑128 then none
          else some (BitVec.ofBool ((BitVec.zeroExtend 128 x✝ * 18446744078004518913#128) >>> 95#128 == 0#128))) ⊑
          some (BitVec.ofBool (x✝ >ₛ -1#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if 95#128 ≥ ↑128 then none
            else some (BitVec.ofBool ((BitVec.zeroExtend 128 x✝ * 18446744078004518913#128) >>> 95#128 == 0#128))) ⊑
            some (BitVec.ofBool (x✝ >ₛ -1#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬some (if ((BitVec.zeroExtend 128 x✝ * 18446744078004518913#128) >>> 95 == 0#128) = true then 1#1 else 0#1) ⊑
            some (if (!x✝.getLsbD 31) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:525:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:525:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:525:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:525:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:513:8: error: (kernel) declaration has metavariables 'reused_mul_nuw_xy_z_selectnonzero_ugt_thm'
[bv] [0.075846] Normalizing goal
  [Meta.synthInstance] [0.002069] ✅️ Decidable
        ((match some (BitVec.ofBool (x✝ != 0#8)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } =>
            if
                True ∧
                  BitVec.zeroExtend (2 * 8) x✝¹ * BitVec.zeroExtend (2 * 8) x✝ ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 8) x✝² * BitVec.zeroExtend (2 * 8) x✝ ≥
                      BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
                none
              else some (BitVec.ofBool (x✝¹ * x✝ >ᵤ x✝² * x✝))
          | some { toFin := ⟨0, ⋯⟩ } => some 1#1) ⊑
          match some (BitVec.ofBool (x✝ == 0#8)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some 1#1
          | some { toFin := ⟨0, ⋯⟩ } =>
            if
                True ∧
                  BitVec.zeroExtend (2 * 8) x✝¹ * BitVec.zeroExtend (2 * 8) x✝ ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 8) x✝² * BitVec.zeroExtend (2 * 8) x✝ ≥
                      BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
                none
              else some (BitVec.ofBool (x✝¹ * x✝ >ᵤ x✝² * x✝)))
    [Meta.check] [0.001030] ✅️ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (match some (BitVec.ofBool (x✝ != 0#8)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } =>
            if
                True ∧
                  BitVec.zeroExtend (2 * 8) x✝¹ * BitVec.zeroExtend (2 * 8) x✝ ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 8) x✝² * BitVec.zeroExtend (2 * 8) x✝ ≥
                      BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
                none
              else some (BitVec.ofBool (x✝¹ * x✝ >ᵤ x✝² * x✝))
          | some { toFin := ⟨0, ⋯⟩ } => some 1#1)
          (match some (BitVec.ofBool (x✝ == 0#8)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some 1#1
          | some { toFin := ⟨0, ⋯⟩ } =>
            if
                True ∧
                  BitVec.zeroExtend (2 * 8) x✝¹ * BitVec.zeroExtend (2 * 8) x✝ ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 8) x✝² * BitVec.zeroExtend (2 * 8) x✝ ≥
                      BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
                none
              else some (BitVec.ofBool (x✝¹ * x✝ >ᵤ x✝² * x✝)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x✝² x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(match some (BitVec.ofBool (x✝ != 0#8)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } =>
              if
                  True ∧
                    BitVec.zeroExtend (2 * 8) x✝¹ * BitVec.zeroExtend (2 * 8) x✝ ≥
                      BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
                none
              else
                if
                    True ∧
                      BitVec.zeroExtend (2 * 8) x✝² * BitVec.zeroExtend (2 * 8) x✝ ≥
                        BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
                  none
                else some (BitVec.ofBool (x✝¹ * x✝ >ᵤ x✝² * x✝))
            | some { toFin := ⟨0, ⋯⟩ } => some 1#1) ⊑
            match some (BitVec.ofBool (x✝ == 0#8)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 1#1
            | some { toFin := ⟨0, ⋯⟩ } =>
              if
                  True ∧
                    BitVec.zeroExtend (2 * 8) x✝¹ * BitVec.zeroExtend (2 * 8) x✝ ≥
                      BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
                none
              else
                if
                    True ∧
                      BitVec.zeroExtend (2 * 8) x✝² * BitVec.zeroExtend (2 * 8) x✝ ≥
                        BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
                  none
                else some (BitVec.ofBool (x✝¹ * x✝ >ᵤ x✝² * x✝))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 8
      x✝² x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(match some (if (!x✝ == 0#8) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } =>
              if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝¹ * BitVec.zeroExtend 16 x✝) = true then none
              else
                if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝² * BitVec.zeroExtend 16 x✝) = true then none
                else some (if (x✝¹ * x✝ >ᵤ x✝² * x✝) = true then 1#1 else 0#1)
            | some { toFin := ⟨0, ⋯⟩ } => some 1#1) ⊑
            match some (if (x✝ == 0#8) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 1#1
            | some { toFin := ⟨0, ⋯⟩ } =>
              if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝¹ * BitVec.zeroExtend 16 x✝) = true then none
              else
                if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝² * BitVec.zeroExtend 16 x✝) = true then none
                else some (if (x✝¹ * x✝ >ᵤ x✝² * x✝) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:537:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:529:8: error: (kernel) declaration has metavariables 'icmp_eq_mul_nsw_nonequal_thm'
[bv] [0.044628] Normalizing goal
  [Meta.synthInstance] [0.001423] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) x✝¹ <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) x✝¹ ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else
            if
                True ∧
                  (BitVec.signExtend (2 * 8) (x✝ + 1#8) * BitVec.signExtend (2 * 8) x✝¹ <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) (x✝ + 1#8) * BitVec.signExtend (2 * 8) x✝¹ ≥
                      BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (x✝ * x✝¹ == (x✝ + 1#8) * x✝¹))) ⊑
          some (BitVec.ofBool (x✝¹ == 0#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) x✝¹ <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) x✝¹ ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else
              if
                  True ∧
                    (BitVec.signExtend (2 * 8) (x✝ + 1#8) * BitVec.signExtend (2 * 8) x✝¹ <
                        BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                      BitVec.signExtend (2 * 8) (x✝ + 1#8) * BitVec.signExtend (2 * 8) x✝¹ ≥
                        BitVec.twoPow (2 * 8) (8 - 1)) then
                none
              else some (BitVec.ofBool (x✝ * x✝¹ == (x✝ + 1#8) * x✝¹))) ⊑
            some (BitVec.ofBool (x✝¹ == 0#8))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * BitVec.signExtend 16 x✝¹) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * BitVec.signExtend 16 x✝¹)) =
                  true then
              none
            else
              if
                  (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ
                            BitVec.signExtend 16 (x✝ + 1#8) * BitVec.signExtend 16 x✝¹) &&
                        BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 (x✝ + 1#8) * BitVec.signExtend 16 x✝¹)) =
                    true then
                none
              else some (if (x✝ * x✝¹ == (x✝ + 1#8) * x✝¹) = true then 1#1 else 0#1)) ⊑
            some (if (x✝¹ == 0#8) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:549:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:541:8: error: (kernel) declaration has metavariables 'icmp_eq_mul_nuw_nonequal_thm'
[bv] [0.042380] Normalizing goal
  [Meta.synthInstance] [0.001333] ✅️ Decidable
        ((if
              True ∧
                BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) x✝¹ ≥ BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
            none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 8) (x✝ + 1#8) * BitVec.zeroExtend (2 * 8) x✝¹ ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else some (BitVec.ofBool (x✝ * x✝¹ == (x✝ + 1#8) * x✝¹))) ⊑
          some (BitVec.ofBool (x✝¹ == 0#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  BitVec.zeroExtend (2 * 8) x✝ * BitVec.zeroExtend (2 * 8) x✝¹ ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 8) (x✝ + 1#8) * BitVec.zeroExtend (2 * 8) x✝¹ ≥
                      BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
                none
              else some (BitVec.ofBool (x✝ * x✝¹ == (x✝ + 1#8) * x✝¹))) ⊑
            some (BitVec.ofBool (x✝¹ == 0#8))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 x✝ * BitVec.zeroExtend 16 x✝¹) = true then none
            else
              if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 (x✝ + 1#8) * BitVec.zeroExtend 16 x✝¹) = true then
                none
              else some (if (x✝ * x✝¹ == (x✝ + 1#8) * x✝¹) = true then 1#1 else 0#1)) ⊑
            some (if (x✝¹ == 0#8) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:561:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:553:8: error: (kernel) declaration has metavariables 'icmp_eq_mul_nsw_nonequal_commuted_thm'
[bv] [0.044252] Normalizing goal
  [Meta.synthInstance] [0.001402] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) x✝¹ <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) x✝¹ ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else
            if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) (x✝ + 1#8) <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) (x✝ + 1#8) ≥
                      BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (x✝ * x✝¹ == x✝¹ * (x✝ + 1#8)))) ⊑
          some (BitVec.ofBool (x✝¹ == 0#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) x✝¹ <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) x✝¹ ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else
              if
                  True ∧
                    (BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) (x✝ + 1#8) <
                        BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                      BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) (x✝ + 1#8) ≥
                        BitVec.twoPow (2 * 8) (8 - 1)) then
                none
              else some (BitVec.ofBool (x✝ * x✝¹ == x✝¹ * (x✝ + 1#8)))) ⊑
            some (BitVec.ofBool (x✝¹ == 0#8))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * BitVec.signExtend 16 x✝¹) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * BitVec.signExtend 16 x✝¹)) =
                  true then
              none
            else
              if
                  (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ
                            BitVec.signExtend 16 x✝¹ * BitVec.signExtend 16 (x✝ + 1#8)) &&
                        BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝¹ * BitVec.signExtend 16 (x✝ + 1#8))) =
                    true then
                none
              else some (if (x✝ * x✝¹ == x✝¹ * (x✝ + 1#8)) = true then 1#1 else 0#1)) ⊑
            some (if (x✝¹ == 0#8) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:573:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:565:8: error: (kernel) declaration has metavariables 'icmp_ne_mul_nsw_nonequal_thm'
[bv] [0.045962] Normalizing goal
  [Meta.synthInstance] [0.001440] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) x✝¹ <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) x✝¹ ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else
            if
                True ∧
                  (BitVec.signExtend (2 * 8) (x✝ + 1#8) * BitVec.signExtend (2 * 8) x✝¹ <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) (x✝ + 1#8) * BitVec.signExtend (2 * 8) x✝¹ ≥
                      BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (x✝ * x✝¹ != (x✝ + 1#8) * x✝¹))) ⊑
          some (BitVec.ofBool (x✝¹ != 0#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) x✝¹ <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) x✝¹ ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else
              if
                  True ∧
                    (BitVec.signExtend (2 * 8) (x✝ + 1#8) * BitVec.signExtend (2 * 8) x✝¹ <
                        BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                      BitVec.signExtend (2 * 8) (x✝ + 1#8) * BitVec.signExtend (2 * 8) x✝¹ ≥
                        BitVec.twoPow (2 * 8) (8 - 1)) then
                none
              else some (BitVec.ofBool (x✝ * x✝¹ != (x✝ + 1#8) * x✝¹))) ⊑
            some (BitVec.ofBool (x✝¹ != 0#8))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * BitVec.signExtend 16 x✝¹) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * BitVec.signExtend 16 x✝¹)) =
                  true then
              none
            else
              if
                  (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ
                            BitVec.signExtend 16 (x✝ + 1#8) * BitVec.signExtend 16 x✝¹) &&
                        BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 (x✝ + 1#8) * BitVec.signExtend 16 x✝¹)) =
                    true then
                none
              else some (if (!x✝ * x✝¹ == (x✝ + 1#8) * x✝¹) = true then 1#1 else 0#1)) ⊑
            some (if (!x✝¹ == 0#8) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:585:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:585:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:577:8: error: (kernel) declaration has metavariables 'icmp_mul_nsw_slt_thm'
[bv] [0.051036] Normalizing goal
  [Meta.synthInstance] [0.001227] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else
            if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 7#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (x✝¹ * 7#8 >ₛ x✝ * 7#8))) ⊑
          some (BitVec.ofBool (x✝¹ >ₛ x✝)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else
              if
                  True ∧
                    (BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 7#8 <
                        BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                      BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 7#8 ≥
                        BitVec.twoPow (2 * 8) (8 - 1)) then
                none
              else some (BitVec.ofBool (x✝¹ * 7#8 >ₛ x✝ * 7#8))) ⊑
            some (BitVec.ofBool (x✝¹ >ₛ x✝))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                  true then
              none
            else
              if
                  (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝¹ * 7#16) &&
                        BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝¹ * 7#16)) =
                    true then
                none
              else
                some
                  (if (!(!(x✝ * 7#8).getLsbD 7 == (x✝¹ * 7#8).getLsbD 7) == (x✝¹ * 7#8 >ᵤ x✝ * 7#8)) = true then 1#1
                  else 0#1)) ⊑
            some (if (!(!x✝.getLsbD 7 == x✝¹.getLsbD 7) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:597:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:597:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:589:8: error: (kernel) declaration has metavariables 'icmp_mul_nsw_sle_thm'
[bv] [0.052644] Normalizing goal
  [Meta.synthInstance] [0.001224] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else
            if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 7#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (x✝¹ * 7#8 ≥ₛ x✝ * 7#8))) ⊑
          some (BitVec.ofBool (x✝¹ ≥ₛ x✝)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else
              if
                  True ∧
                    (BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 7#8 <
                        BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                      BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 7#8 ≥
                        BitVec.twoPow (2 * 8) (8 - 1)) then
                none
              else some (BitVec.ofBool (x✝¹ * 7#8 ≥ₛ x✝ * 7#8))) ⊑
            some (BitVec.ofBool (x✝¹ ≥ₛ x✝))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                  true then
              none
            else
              if
                  (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝¹ * 7#16) &&
                        BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝¹ * 7#16)) =
                    true then
                none
              else
                some
                  (if ((!(x✝¹ * 7#8).getLsbD 7 == (x✝ * 7#8).getLsbD 7) == (x✝ * 7#8 >ᵤ x✝¹ * 7#8)) = true then 1#1
                  else 0#1)) ⊑
            some (if ((!x✝¹.getLsbD 7 == x✝.getLsbD 7) == (x✝ >ᵤ x✝¹)) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:609:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:609:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:601:8: error: (kernel) declaration has metavariables 'icmp_mul_nsw_sgt_thm'
[bv] [0.050553] Normalizing goal
  [Meta.synthInstance] [0.001213] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else
            if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 7#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (x✝ * 7#8 >ₛ x✝¹ * 7#8))) ⊑
          some (BitVec.ofBool (x✝ >ₛ x✝¹)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else
              if
                  True ∧
                    (BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 7#8 <
                        BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                      BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 7#8 ≥
                        BitVec.twoPow (2 * 8) (8 - 1)) then
                none
              else some (BitVec.ofBool (x✝ * 7#8 >ₛ x✝¹ * 7#8))) ⊑
            some (BitVec.ofBool (x✝ >ₛ x✝¹))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                  true then
              none
            else
              if
                  (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝¹ * 7#16) &&
                        BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝¹ * 7#16)) =
                    true then
                none
              else
                some
                  (if (!(!(x✝¹ * 7#8).getLsbD 7 == (x✝ * 7#8).getLsbD 7) == (x✝ * 7#8 >ᵤ x✝¹ * 7#8)) = true then 1#1
                  else 0#1)) ⊑
            some (if (!(!x✝¹.getLsbD 7 == x✝.getLsbD 7) == (x✝ >ᵤ x✝¹)) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:621:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:621:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:613:8: error: (kernel) declaration has metavariables 'icmp_mul_nsw_sge_thm'
[bv] [0.052773] Normalizing goal
  [Meta.synthInstance] [0.001223] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else
            if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 7#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (x✝ * 7#8 ≥ₛ x✝¹ * 7#8))) ⊑
          some (BitVec.ofBool (x✝ ≥ₛ x✝¹)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 7#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else
              if
                  True ∧
                    (BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 7#8 <
                        BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                      BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 7#8 ≥
                        BitVec.twoPow (2 * 8) (8 - 1)) then
                none
              else some (BitVec.ofBool (x✝ * 7#8 ≥ₛ x✝¹ * 7#8))) ⊑
            some (BitVec.ofBool (x✝ ≥ₛ x✝¹))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 7#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 7#16)) =
                  true then
              none
            else
              if
                  (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝¹ * 7#16) &&
                        BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝¹ * 7#16)) =
                    true then
                none
              else
                some
                  (if ((!(x✝ * 7#8).getLsbD 7 == (x✝¹ * 7#8).getLsbD 7) == (x✝¹ * 7#8 >ᵤ x✝ * 7#8)) = true then 1#1
                  else 0#1)) ⊑
            some (if ((!x✝.getLsbD 7 == x✝¹.getLsbD 7) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:633:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:633:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gicmphmul_proof.lean:625:8: error: (kernel) declaration has metavariables 'icmp_mul_nsw_slt_neg_thm'
[bv] [0.051056] Normalizing goal
  [Meta.synthInstance] [0.001227] ✅️ Decidable
        ((if
              True ∧
                (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 <
                    BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                  BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
            none
          else
            if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 249#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 249#8 ≥
                      BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else some (BitVec.ofBool (x✝¹ * 249#8 >ₛ x✝ * 249#8))) ⊑
          some (BitVec.ofBool (x✝ >ₛ x✝¹)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                True ∧
                  (BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 <
                      BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                    BitVec.signExtend (2 * 8) x✝ * BitVec.signExtend (2 * 8) 249#8 ≥ BitVec.twoPow (2 * 8) (8 - 1)) then
              none
            else
              if
                  True ∧
                    (BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 249#8 <
                        BitVec.signExtend (2 * 8) (BitVec.twoPow 8 (8 - 1)) ∨
                      BitVec.signExtend (2 * 8) x✝¹ * BitVec.signExtend (2 * 8) 249#8 ≥
                        BitVec.twoPow (2 * 8) (8 - 1)) then
                none
              else some (BitVec.ofBool (x✝¹ * 249#8 >ₛ x✝ * 249#8))) ⊑
            some (BitVec.ofBool (x✝ >ₛ x✝¹))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 8
      x✝¹ x✝ : BitVec 8
      a✝ :
        ¬(if
                (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝ * 65529#16) &&
                      BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝ * 65529#16)) =
                  true then
              none
            else
              if
                  (!((!BitVec.signExtend 16 (BitVec.twoPow 8 7) >ᵤ BitVec.signExtend 16 x✝¹ * 65529#16) &&
                        BitVec.twoPow 16 7 >ᵤ BitVec.signExtend 16 x✝¹ * 65529#16)) =
                    true then
                none
              else
                some
                  (if (!(!(x✝ * 249#8).getLsbD 7 == (x✝¹ * 249#8).getLsbD 7) == (x✝¹ * 249#8 >ᵤ x✝ * 249#8)) = true then
                    1#1
                  else 0#1)) ⊑
            some (if (!(!x✝¹.getLsbD 7 == x✝.getLsbD 7) == (x✝ >ᵤ x✝¹)) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
