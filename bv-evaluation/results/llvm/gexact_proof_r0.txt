‚ö† [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
‚ö† [878/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
‚ö† [881/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
‚ö† [887/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
‚ö† [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:16:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:11:8: error: (kernel) declaration has metavariables 'sdiv2_thm'
[bv] [0.034329] Normalizing goal
  [Meta.synthInstance] [0.001425] ‚úÖÔ∏è Decidable
        ((if (8#32 == 0 || 32 != 1 && x‚úù == BitVec.intMin 32 && 8#32 == -1) = true then none else some (x‚úù.sdiv 8#32)) ‚äë
          if 3#32 ‚â• ‚Üë32 then none else some (x‚úù.sshiftRight (3#32).toNat))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if (8#32 == 0 || 32 != 1 && x‚úù == BitVec.intMin 32 && 8#32 == -1) = true then none else some (x‚úù.sdiv 8#32)) ‚äë
            if 3#32 ‚â• ‚Üë32 then none else some (x‚úù.sshiftRight (3#32).toNat)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨some (if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 8#32) + 1#32 else x‚úù / 8#32) ‚äë some (x‚úù.sshiftRight 3)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:25:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:20:8: error: (kernel) declaration has metavariables 'sdiv4_thm'
[bv] [0.034357] Normalizing goal
  [Meta.synthInstance] [0.001277] ‚úÖÔ∏è Decidable
        ((if (3#32 == 0 || 32 != 1 && x‚úù == BitVec.intMin 32 && 3#32 == -1) = true then none
          else some (x‚úù.sdiv 3#32 * 3#32)) ‚äë
          some x‚úù)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if (3#32 == 0 || 32 != 1 && x‚úù == BitVec.intMin 32 && 3#32 == -1) = true then none
            else some (x‚úù.sdiv 3#32 * 3#32)) ‚äë
            some x‚úù
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù : ¬¨some ((if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 3#32) + 1#32 else x‚úù / 3#32) * 3#32) ‚äë some x‚úù
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:34:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:29:8: error: (kernel) declaration has metavariables 'sdiv6_thm'
[bv] [0.033175] Normalizing goal
  [Meta.synthInstance] [0.001576] ‚úÖÔ∏è Decidable
        ((if (3#32 == 0 || 32 != 1 && x‚úù == BitVec.intMin 32 && 3#32 == -1) = true then none
          else some (x‚úù.sdiv 3#32 * 4294967293#32)) ‚äë
          some (0#32 - x‚úù))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if (3#32 == 0 || 32 != 1 && x‚úù == BitVec.intMin 32 && 3#32 == -1) = true then none
            else some (x‚úù.sdiv 3#32 * 4294967293#32)) ‚äë
            some (0#32 - x‚úù)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨some ((if x‚úù.getLsbD 31 = true then ~~~((~~~x‚úù + 1#32) / 3#32) + 1#32 else x‚úù / 3#32) * 4294967293#32) ‚äë
            some (~~~x‚úù + 1#32)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:43:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:38:8: error: (kernel) declaration has metavariables 'udiv1_thm'
[bv] [0.021399] Normalizing goal
  [Meta.synthInstance] [0.001477] ‚úÖÔ∏è Decidable ((if x‚úù¬π = 0 then none else some (x‚úù / x‚úù¬π * x‚úù¬π)) ‚äë some x‚úù)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x‚úù¬π x‚úù : BitVec 32
      a‚úù : ¬¨(if x‚úù¬π = 0 then none else some (x‚úù / x‚úù¬π * x‚úù¬π)) ‚äë some x‚úù
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x‚úù¬π x‚úù : BitVec 32
      a‚úù : ¬¨(if (x‚úù¬π == 0#32) = true then none else some (x‚úù / x‚úù¬π * x‚úù¬π)) ‚äë some x‚úù
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:52:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:47:8: error: (kernel) declaration has metavariables 'udiv2_thm'
[bv] [0.042604] Normalizing goal
  [Meta.synthInstance] [0.001857] ‚úÖÔ∏è Decidable
        ((if x‚úù¬π ‚â• ‚Üë32 then none else if 1#32 <<< x‚úù¬π = 0 then none else some (x‚úù / 1#32 <<< x‚úù¬π)) ‚äë
          if x‚úù¬π ‚â• ‚Üë32 then none else some (x‚úù >>> x‚úù¬π))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x‚úù¬π x‚úù : BitVec 32
      a‚úù :
        ¬¨(if x‚úù¬π ‚â• ‚Üë32 then none else if 1#32 <<< x‚úù¬π = 0 then none else some (x‚úù / 1#32 <<< x‚úù¬π)) ‚äë
            if x‚úù¬π ‚â• ‚Üë32 then none else some (x‚úù >>> x‚úù¬π)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x‚úù¬π x‚úù : BitVec 32
      a‚úù :
        ¬¨(if (!32#32 >·µ§ x‚úù¬π) = true then none
            else if (1#32 <<< x‚úù¬π == 0#32) = true then none else some (x‚úù / 1#32 <<< x‚úù¬π)) ‚äë
            if (!32#32 >·µ§ x‚úù¬π) = true then none else some (x‚úù >>> x‚úù¬π)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:62:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:56:8: error: (kernel) declaration has metavariables 'ashr_icmp1_thm'
[bv] [0.021155] Normalizing goal
  [Meta.synthInstance] [0.001028] ‚úÖÔ∏è Decidable
        ((if 2#64 ‚â• ‚Üë64 then none else some (BitVec.ofBool (x‚úù.sshiftRight (2#64).toNat == 0#64))) ‚äë
          some (BitVec.ofBool (x‚úù == 0#64)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      x‚úù : BitVec 64
      a‚úù :
        ¬¨(if 2#64 ‚â• ‚Üë64 then none else some (BitVec.ofBool (x‚úù.sshiftRight (2#64).toNat == 0#64))) ‚äë
            some (BitVec.ofBool (x‚úù == 0#64))
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      x‚úù : BitVec 64
      a‚úù :
        ¬¨some (if (x‚úù.sshiftRight 2 == 0#64) = true then 1#1 else 0#1) ‚äë some (if (x‚úù == 0#64) = true then 1#1 else 0#1)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:72:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:66:8: error: (kernel) declaration has metavariables 'ashr_icmp2_thm'
[bv] [0.031867] Normalizing goal
  [Meta.synthInstance] [0.001345] ‚úÖÔ∏è Decidable
        ((if 2#64 ‚â• ‚Üë64 then none else some (BitVec.ofBool (4#64 >‚Çõ x‚úù.sshiftRight (2#64).toNat))) ‚äë
          some (BitVec.ofBool (16#64 >‚Çõ x‚úù)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      x‚úù : BitVec 64
      a‚úù :
        ¬¨(if 2#64 ‚â• ‚Üë64 then none else some (BitVec.ofBool (4#64 >‚Çõ x‚úù.sshiftRight (2#64).toNat))) ‚äë
            some (BitVec.ofBool (16#64 >‚Çõ x‚úù))
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      x‚úù : BitVec 64
      a‚úù :
        ¬¨some (if (!(x‚úù.sshiftRight 2).getLsbD 63 == (4#64 >·µ§ x‚úù.sshiftRight 2)) = true then 1#1 else 0#1) ‚äë
            some (if (!x‚úù.getLsbD 63 == (16#64 >·µ§ x‚úù)) = true then 1#1 else 0#1)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:83:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:76:8: error: (kernel) declaration has metavariables 'pr9998_thm'
[bv] [0.029641] Normalizing goal
  [Meta.synthInstance] [0.001565] ‚úÖÔ∏è Decidable
        ((if 31#32 ‚â• ‚Üë32 then none
          else
            if 31#32 ‚â• ‚Üë32 then none
            else
              some
                (BitVec.ofBool
                  (BitVec.signExtend 64 ((x‚úù <<< 31#32).sshiftRight (31#32).toNat) >·µ§ 7297771788697658747#64))) ‚äë
          some (BitVec.ofBool (x‚úù &&& 1#32 != 0#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨(if 31#32 ‚â• ‚Üë32 then none
            else
              if 31#32 ‚â• ‚Üë32 then none
              else
                some
                  (BitVec.ofBool
                    (BitVec.signExtend 64 ((x‚úù <<< 31#32).sshiftRight (31#32).toNat) >·µ§ 7297771788697658747#64))) ‚äë
            some (BitVec.ofBool (x‚úù &&& 1#32 != 0#32))
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x‚úù : BitVec 32
      a‚úù :
        ¬¨some
              (if (BitVec.signExtend 64 ((x‚úù <<< 31).sshiftRight 31) >·µ§ 7297771788697658747#64) = true then 1#1
              else 0#1) ‚äë
            some (if (!x‚úù &&& 1#32 == 0#32) = true then 1#1 else 0#1)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:93:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:87:8: error: (kernel) declaration has metavariables 'udiv_icmp1_thm'
[bv] [0.025610] Normalizing goal
  [Meta.synthInstance] [0.001370] ‚úÖÔ∏è Decidable
        ((if 5#64 = 0 then none else some (BitVec.ofBool (x‚úù / 5#64 != 0#64))) ‚äë some (BitVec.ofBool (x‚úù != 0#64)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      x‚úù : BitVec 64
      a‚úù : ¬¨(if 5#64 = 0 then none else some (BitVec.ofBool (x‚úù / 5#64 != 0#64))) ‚äë some (BitVec.ofBool (x‚úù != 0#64))
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      x‚úù : BitVec 64
      a‚úù : ¬¨some (if (!x‚úù / 5#64 == 0#64) = true then 1#1 else 0#1) ‚äë some (if (!x‚úù == 0#64) = true then 1#1 else 0#1)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:103:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:97:8: error: (kernel) declaration has metavariables 'udiv_icmp2_thm'
[bv] [0.018473] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      x‚úù : BitVec 64
      a‚úù : ¬¨(if 5#64 = 0 then none else some (BitVec.ofBool (x‚úù / 5#64 == 0#64))) ‚äë some (BitVec.ofBool (x‚úù == 0#64))
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      x‚úù : BitVec 64
      a‚úù : ¬¨some (if (x‚úù / 5#64 == 0#64) = true then 1#1 else 0#1) ‚äë some (if (x‚úù == 0#64) = true then 1#1 else 0#1)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:113:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:107:8: error: (kernel) declaration has metavariables 'sdiv_icmp1_thm'
[bv] [0.058020] Normalizing goal
  [Meta.synthInstance] [0.001648] ‚úÖÔ∏è Decidable
        ((if (5#64 == 0 || 64 != 1 && x‚úù == BitVec.intMin 64 && 5#64 == -1) = true then none
          else some (BitVec.ofBool (x‚úù.sdiv 5#64 == 0#64))) ‚äë
          some (BitVec.ofBool (x‚úù == 0#64)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      x‚úù : BitVec 64
      a‚úù :
        ¬¨(if (5#64 == 0 || 64 != 1 && x‚úù == BitVec.intMin 64 && 5#64 == -1) = true then none
            else some (BitVec.ofBool (x‚úù.sdiv 5#64 == 0#64))) ‚äë
            some (BitVec.ofBool (x‚úù == 0#64))
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      x‚úù : BitVec 64
      a‚úù :
        ¬¨some
              (if ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 5#64) + 1#64 else x‚úù / 5#64) == 0#64) = true then
                1#1
              else 0#1) ‚äë
            some (if (x‚úù == 0#64) = true then 1#1 else 0#1)
      ‚ä¢ False
  [Meta.isDefEq] [0.001648] ‚ùåÔ∏è ?a ==
        ?a =?= (if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 5#64) + 1#64 else x‚úù / 5#64) == 0#64
    [Meta.isDefEq.onFailure] [0.001055] ‚ùåÔ∏è ?a ==
          ?a =?= (if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 5#64) + 1#64 else x‚úù / 5#64) == 0#64
      [Meta.synthInstance] [0.001003] üí•Ô∏è BEq ?Œ±
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:123:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:117:8: error: (kernel) declaration has metavariables 'sdiv_icmp2_thm'
[bv] [0.036238] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      x‚úù : BitVec 64
      a‚úù :
        ¬¨(if (5#64 == 0 || 64 != 1 && x‚úù == BitVec.intMin 64 && 5#64 == -1) = true then none
            else some (BitVec.ofBool (x‚úù.sdiv 5#64 == 1#64))) ‚äë
            some (BitVec.ofBool (x‚úù == 5#64))
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      x‚úù : BitVec 64
      a‚úù :
        ¬¨some
              (if ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 5#64) + 1#64 else x‚úù / 5#64) == 1#64) = true then
                1#1
              else 0#1) ‚äë
            some (if (x‚úù == 5#64) = true then 1#1 else 0#1)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:133:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:127:8: error: (kernel) declaration has metavariables 'sdiv_icmp3_thm'
[bv] [0.054988] Normalizing goal
  [Meta.synthInstance] [0.001446] ‚úÖÔ∏è Decidable
        ((if (5#64 == 0 || 64 != 1 && x‚úù == BitVec.intMin 64 && 5#64 == -1) = true then none
          else some (BitVec.ofBool (x‚úù.sdiv 5#64 == -1#64))) ‚äë
          some (BitVec.ofBool (x‚úù == 18446744073709551611#64)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      x‚úù : BitVec 64
      a‚úù :
        ¬¨(if (5#64 == 0 || 64 != 1 && x‚úù == BitVec.intMin 64 && 5#64 == -1) = true then none
            else some (BitVec.ofBool (x‚úù.sdiv 5#64 == -1#64))) ‚äë
            some (BitVec.ofBool (x‚úù == 18446744073709551611#64))
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      x‚úù : BitVec 64
      a‚úù :
        ¬¨some
              (if
                  ((if x‚úù.getLsbD 63 = true then ~~~((~~~x‚úù + 1#64) / 5#64) + 1#64 else x‚úù / 5#64) ==
                      18446744073709551615#64) =
                    true then
                1#1
              else 0#1) ‚äë
            some (if (x‚úù == 18446744073709551611#64) = true then 1#1 else 0#1)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:143:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:137:8: error: (kernel) declaration has metavariables 'sdiv_icmp4_thm'
[bv] [0.042195] Normalizing goal
  [Meta.synthInstance] [0.001268] ‚úÖÔ∏è Decidable
        ((if
              (18446744073709551611#64 == 0 || 64 != 1 && x‚úù == BitVec.intMin 64 && 18446744073709551611#64 == -1) =
                true then
            none
          else some (BitVec.ofBool (x‚úù.sdiv 18446744073709551611#64 == 0#64))) ‚äë
          some (BitVec.ofBool (x‚úù == 0#64)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      x‚úù : BitVec 64
      a‚úù :
        ¬¨(if
                (18446744073709551611#64 == 0 || 64 != 1 && x‚úù == BitVec.intMin 64 && 18446744073709551611#64 == -1) =
                  true then
              none
            else some (BitVec.ofBool (x‚úù.sdiv 18446744073709551611#64 == 0#64))) ‚äë
            some (BitVec.ofBool (x‚úù == 0#64))
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      x‚úù : BitVec 64
      a‚úù :
        ¬¨some
              (if ((if x‚úù.getLsbD 63 = true then (~~~x‚úù + 1#64) / 5#64 else ~~~(x‚úù / 5#64) + 1#64) == 0#64) = true then
                1#1
              else 0#1) ‚äë
            some (if (x‚úù == 0#64) = true then 1#1 else 0#1)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:153:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:147:8: error: (kernel) declaration has metavariables 'sdiv_icmp5_thm'
[bv] [0.037935] Normalizing goal
  [Meta.synthInstance] [0.001029] ‚úÖÔ∏è Decidable
        ((if
              (18446744073709551611#64 == 0 || 64 != 1 && x‚úù == BitVec.intMin 64 && 18446744073709551611#64 == -1) =
                true then
            none
          else some (BitVec.ofBool (x‚úù.sdiv 18446744073709551611#64 == 1#64))) ‚äë
          some (BitVec.ofBool (x‚úù == 18446744073709551611#64)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      x‚úù : BitVec 64
      a‚úù :
        ¬¨(if
                (18446744073709551611#64 == 0 || 64 != 1 && x‚úù == BitVec.intMin 64 && 18446744073709551611#64 == -1) =
                  true then
              none
            else some (BitVec.ofBool (x‚úù.sdiv 18446744073709551611#64 == 1#64))) ‚äë
            some (BitVec.ofBool (x‚úù == 18446744073709551611#64))
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      x‚úù : BitVec 64
      a‚úù :
        ¬¨some
              (if ((if x‚úù.getLsbD 63 = true then (~~~x‚úù + 1#64) / 5#64 else ~~~(x‚úù / 5#64) + 1#64) == 1#64) = true then
                1#1
              else 0#1) ‚äë
            some (if (x‚úù == 18446744073709551611#64) = true then 1#1 else 0#1)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:163:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:157:8: error: (kernel) declaration has metavariables 'sdiv_icmp6_thm'
[bv] [0.038604] Normalizing goal
  [Meta.synthInstance] [0.001058] ‚úÖÔ∏è Decidable
        ((if
              (18446744073709551611#64 == 0 || 64 != 1 && x‚úù == BitVec.intMin 64 && 18446744073709551611#64 == -1) =
                true then
            none
          else some (BitVec.ofBool (x‚úù.sdiv 18446744073709551611#64 == -1#64))) ‚äë
          some (BitVec.ofBool (x‚úù == 5#64)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      x‚úù : BitVec 64
      a‚úù :
        ¬¨(if
                (18446744073709551611#64 == 0 || 64 != 1 && x‚úù == BitVec.intMin 64 && 18446744073709551611#64 == -1) =
                  true then
              none
            else some (BitVec.ofBool (x‚úù.sdiv 18446744073709551611#64 == -1#64))) ‚äë
            some (BitVec.ofBool (x‚úù == 5#64))
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      x‚úù : BitVec 64
      a‚úù :
        ¬¨some
              (if
                  ((if x‚úù.getLsbD 63 = true then (~~~x‚úù + 1#64) / 5#64 else ~~~(x‚úù / 5#64) + 1#64) ==
                      18446744073709551615#64) =
                    true then
                1#1
              else 0#1) ‚äë
            some (if (x‚úù == 5#64) = true then 1#1 else 0#1)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:172:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:167:8: error: (kernel) declaration has metavariables 'mul_of_udiv_thm'
[bv] [0.011525] Normalizing goal
  [Meta.synthInstance] [0.001253] ‚úÖÔ∏è Decidable
        ((if 12#8 = 0 then none else some (x‚úù / 12#8 * 6#8)) ‚äë if 1#8 ‚â• ‚Üë8 then none else some (x‚úù >>> 1#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x‚úù : BitVec 8
      a‚úù : ¬¨(if 12#8 = 0 then none else some (x‚úù / 12#8 * 6#8)) ‚äë if 1#8 ‚â• ‚Üë8 then none else some (x‚úù >>> 1#8)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x‚úù : BitVec 8
      a‚úù : ¬¨some (x‚úù / 12#8 * 6#8) ‚äë some (x‚úù >>> 1)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:183:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:176:8: error: (kernel) declaration has metavariables 'mul_of_sdiv_thm'
[bv] [0.053675] Normalizing goal
  [Meta.synthInstance] [0.001647] ‚úÖÔ∏è Decidable
        ((if (12#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 12#8 == -1) = true then none
          else some (x‚úù.sdiv 12#8 * 250#8)) ‚äë
          if 1#8 ‚â• ‚Üë8 then none
          else
            if
                True ‚àß
                  (BitVec.signExtend (8 + 1) 0#8 - BitVec.signExtend (8 + 1) (x‚úù.sshiftRight (1#8).toNat)).msb ‚â†
                    (BitVec.signExtend (8 + 1) 0#8 - BitVec.signExtend (8 + 1) (x‚úù.sshiftRight (1#8).toNat)).getMsbD
                      1 then
              none
            else some (0#8 - x‚úù.sshiftRight (1#8).toNat))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x‚úù : BitVec 8
      a‚úù :
        ¬¨(if (12#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 12#8 == -1) = true then none
            else some (x‚úù.sdiv 12#8 * 250#8)) ‚äë
            if 1#8 ‚â• ‚Üë8 then none
            else
              if
                  True ‚àß
                    (BitVec.signExtend (8 + 1) 0#8 - BitVec.signExtend (8 + 1) (x‚úù.sshiftRight (1#8).toNat)).msb ‚â†
                      (BitVec.signExtend (8 + 1) 0#8 - BitVec.signExtend (8 + 1) (x‚úù.sshiftRight (1#8).toNat)).getMsbD
                        1 then
                none
              else some (0#8 - x‚úù.sshiftRight (1#8).toNat)
      ‚ä¢ False
  [Meta.isDefEq] [0.001820] ‚úÖÔ∏è ?h‚ÇÅ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (congr
              (congrArg Ne
                (Eq.trans
                  (congrArg BitVec.msb
                    (Eq.trans (BitVec.sub_toAdd (0#9) (BitVec.signExtend 9 (x‚úù.sshiftRight 1)))
                      (Eq.trans
                        (congrArg (HAdd.hAdd 0#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x‚úù.sshiftRight 1))))
                        (BitVec.zero_add (~~~BitVec.signExtend 9 (x‚úù.sshiftRight 1) + 1#9)))))
                  (BitVec.msb_eq_getLsbD_last (~~~BitVec.signExtend 9 (x‚úù.sshiftRight 1) + 1#9))))
              (congrArg (fun x => x.getMsbD 1)
                (Eq.trans (BitVec.sub_toAdd (0#9) (BitVec.signExtend 9 (x‚úù.sshiftRight 1)))
                  (Eq.trans (congrArg (HAdd.hAdd 0#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x‚úù.sshiftRight 1))))
                    (BitVec.zero_add (~~~BitVec.signExtend 9 (x‚úù.sshiftRight 1) + 1#9))))))
            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq ((~~~BitVec.signExtend 9 (x‚úù.sshiftRight 1) + 1#9).getLsbD 8)
              ((~~~BitVec.signExtend 9 (x‚úù.sshiftRight 1) + 1#9).getMsbD 1))))
        (true_and
          ((!(~~~BitVec.signExtend 9 (x‚úù.sshiftRight 1) + 1#9).getLsbD 8 ==
                (~~~BitVec.signExtend 9 (x‚úù.sshiftRight 1) + 1#9).getMsbD 1) =
            true))
    [Meta.isDefEq.assign] [0.001816] ‚úÖÔ∏è ?h‚ÇÅ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (congr
                (congrArg Ne
                  (Eq.trans
                    (congrArg BitVec.msb
                      (Eq.trans (BitVec.sub_toAdd (0#9) (BitVec.signExtend 9 (x‚úù.sshiftRight 1)))
                        (Eq.trans
                          (congrArg (HAdd.hAdd 0#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x‚úù.sshiftRight 1))))
                          (BitVec.zero_add (~~~BitVec.signExtend 9 (x‚úù.sshiftRight 1) + 1#9)))))
                    (BitVec.msb_eq_getLsbD_last (~~~BitVec.signExtend 9 (x‚úù.sshiftRight 1) + 1#9))))
                (congrArg (fun x => x.getMsbD 1)
                  (Eq.trans (BitVec.sub_toAdd (0#9) (BitVec.signExtend 9 (x‚úù.sshiftRight 1)))
                    (Eq.trans
                      (congrArg (HAdd.hAdd 0#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x‚úù.sshiftRight 1))))
                      (BitVec.zero_add (~~~BitVec.signExtend 9 (x‚úù.sshiftRight 1) + 1#9))))))
              (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                ((~~~BitVec.signExtend 9 (x‚úù.sshiftRight 1) + 1#9).getLsbD 8)
                ((~~~BitVec.signExtend 9 (x‚úù.sshiftRight 1) + 1#9).getMsbD 1))))
          (true_and
            ((!(~~~BitVec.signExtend 9 (x‚úù.sshiftRight 1) + 1#9).getLsbD 8 ==
                  (~~~BitVec.signExtend 9 (x‚úù.sshiftRight 1) + 1#9).getMsbD 1) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.001789] ‚úÖÔ∏è (?h‚ÇÅ : (True ‚àß
              (BitVec.signExtend (8 + 1) 0#8 - BitVec.signExtend (8 + 1) (x‚úù.sshiftRight (1#8).toNat)).msb ‚â†
                (BitVec.signExtend (8 + 1) 0#8 - BitVec.signExtend (8 + 1) (x‚úù.sshiftRight (1#8).toNat)).getMsbD 1) =
            ((!(~~~BitVec.signExtend 9 (x‚úù.sshiftRight 1) + 1#9).getLsbD 8 ==
                  (~~~BitVec.signExtend 9 (x‚úù.sshiftRight 1) + 1#9).getMsbD 1) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (congr
                  (congrArg Ne
                    (Eq.trans
                      (congrArg BitVec.msb
                        (Eq.trans (BitVec.sub_toAdd (0#9) (BitVec.signExtend 9 (x‚úù.sshiftRight 1)))
                          (Eq.trans
                            (congrArg (HAdd.hAdd 0#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x‚úù.sshiftRight 1))))
                            (BitVec.zero_add (~~~BitVec.signExtend 9 (x‚úù.sshiftRight 1) + 1#9)))))
                      (BitVec.msb_eq_getLsbD_last (~~~BitVec.signExtend 9 (x‚úù.sshiftRight 1) + 1#9))))
                  (congrArg (fun x => x.getMsbD 1)
                    (Eq.trans (BitVec.sub_toAdd (0#9) (BitVec.signExtend 9 (x‚úù.sshiftRight 1)))
                      (Eq.trans
                        (congrArg (HAdd.hAdd 0#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x‚úù.sshiftRight 1))))
                        (BitVec.zero_add (~~~BitVec.signExtend 9 (x‚úù.sshiftRight 1) + 1#9))))))
                (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                  ((~~~BitVec.signExtend 9 (x‚úù.sshiftRight 1) + 1#9).getLsbD 8)
                  ((~~~BitVec.signExtend 9 (x‚úù.sshiftRight 1) + 1#9).getMsbD 1))))
            (true_and
              ((!(~~~BitVec.signExtend 9 (x‚úù.sshiftRight 1) + 1#9).getLsbD 8 ==
                    (~~~BitVec.signExtend 9 (x‚úù.sshiftRight 1) + 1#9).getMsbD 1) =
                true)) : (True ‚àß
              (0#9 - BitVec.signExtend 9 (x‚úù.sshiftRight 1)).msb ‚â†
                (0#9 - BitVec.signExtend 9 (x‚úù.sshiftRight 1)).getMsbD 1) =
            ((!(~~~BitVec.signExtend 9 (x‚úù.sshiftRight 1) + 1#9).getLsbD 8 ==
                  (~~~BitVec.signExtend 9 (x‚úù.sshiftRight 1) + 1#9).getMsbD 1) =
              true))
        [Meta.isDefEq] [0.001785] ‚úÖÔ∏è (True ‚àß
                (BitVec.signExtend (8 + 1) 0#8 - BitVec.signExtend (8 + 1) (x‚úù.sshiftRight (1#8).toNat)).msb ‚â†
                  (BitVec.signExtend (8 + 1) 0#8 - BitVec.signExtend (8 + 1) (x‚úù.sshiftRight (1#8).toNat)).getMsbD 1) =
              ((!(~~~BitVec.signExtend 9 (x‚úù.sshiftRight 1) + 1#9).getLsbD 8 ==
                    (~~~BitVec.signExtend 9 (x‚úù.sshiftRight 1) + 1#9).getMsbD 1) =
                true) =?= (True ‚àß
                (0#9 - BitVec.signExtend 9 (x‚úù.sshiftRight 1)).msb ‚â†
                  (0#9 - BitVec.signExtend 9 (x‚úù.sshiftRight 1)).getMsbD 1) =
              ((!(~~~BitVec.signExtend 9 (x‚úù.sshiftRight 1) + 1#9).getLsbD 8 ==
                    (~~~BitVec.signExtend 9 (x‚úù.sshiftRight 1) + 1#9).getMsbD 1) =
                true)
          [Meta.isDefEq] [0.001759] ‚úÖÔ∏è True ‚àß
                (BitVec.signExtend (8 + 1) 0#8 - BitVec.signExtend (8 + 1) (x‚úù.sshiftRight (1#8).toNat)).msb ‚â†
                  (BitVec.signExtend (8 + 1) 0#8 - BitVec.signExtend (8 + 1) (x‚úù.sshiftRight (1#8).toNat)).getMsbD
                    1 =?= True ‚àß
                (0#9 - BitVec.signExtend 9 (x‚úù.sshiftRight 1)).msb ‚â†
                  (0#9 - BitVec.signExtend 9 (x‚úù.sshiftRight 1)).getMsbD 1
            [Meta.isDefEq] [0.001743] ‚úÖÔ∏è (BitVec.signExtend (8 + 1) 0#8 -
                      BitVec.signExtend (8 + 1) (x‚úù.sshiftRight (1#8).toNat)).msb ‚â†
                  (BitVec.signExtend (8 + 1) 0#8 - BitVec.signExtend (8 + 1) (x‚úù.sshiftRight (1#8).toNat)).getMsbD
                    1 =?= (0#9 - BitVec.signExtend 9 (x‚úù.sshiftRight 1)).msb ‚â†
                  (0#9 - BitVec.signExtend 9 (x‚úù.sshiftRight 1)).getMsbD 1
              [Meta.isDefEq.delta] [0.001728] ‚úÖÔ∏è (BitVec.signExtend (8 + 1) 0#8 -
                        BitVec.signExtend (8 + 1) (x‚úù.sshiftRight (1#8).toNat)).msb ‚â†
                    (BitVec.signExtend (8 + 1) 0#8 - BitVec.signExtend (8 + 1) (x‚úù.sshiftRight (1#8).toNat)).getMsbD
                      1 =?= (0#9 - BitVec.signExtend 9 (x‚úù.sshiftRight 1)).msb ‚â†
                    (0#9 - BitVec.signExtend 9 (x‚úù.sshiftRight 1)).getMsbD 1
                [Meta.isDefEq] [0.001665] ‚úÖÔ∏è (BitVec.signExtend (8 + 1) 0#8 -
                        BitVec.signExtend (8 + 1)
                          (x‚úù.sshiftRight (1#8).toNat)).msb =?= (0#9 - BitVec.signExtend 9 (x‚úù.sshiftRight 1)).msb
                  [Meta.isDefEq.delta] [0.001655] ‚úÖÔ∏è (BitVec.signExtend (8 + 1) 0#8 -
                          BitVec.signExtend (8 + 1)
                            (x‚úù.sshiftRight (1#8).toNat)).msb =?= (0#9 - BitVec.signExtend 9 (x‚úù.sshiftRight 1)).msb
                    [Meta.isDefEq] [0.001634] ‚úÖÔ∏è BitVec.signExtend (8 + 1) 0#8 -
                          BitVec.signExtend (8 + 1)
                            (x‚úù.sshiftRight (1#8).toNat) =?= 0#9 - BitVec.signExtend 9 (x‚úù.sshiftRight 1)
                      [Meta.isDefEq] [0.001608] ‚úÖÔ∏è instHSub.1 (BitVec.signExtend (8 + 1) 0#8)
                            (BitVec.signExtend (8 + 1)
                              (x‚úù.sshiftRight
                                (1#8).toNat)) =?= instHSub.1 (0#9) (BitVec.signExtend 9 (x‚úù.sshiftRight 1))
                        [Meta.isDefEq] [0.001555] ‚úÖÔ∏è Sub.sub (BitVec.signExtend (8 + 1) 0#8)
                              (BitVec.signExtend (8 + 1)
                                (x‚úù.sshiftRight (1#8).toNat)) =?= Sub.sub (0#9) (BitVec.signExtend 9 (x‚úù.sshiftRight 1))
                          [Meta.isDefEq] [0.001535] ‚úÖÔ∏è BitVec.instSub.1 (BitVec.signExtend (8 + 1) 0#8)
                                (BitVec.signExtend (8 + 1)
                                  (x‚úù.sshiftRight
                                    (1#8).toNat)) =?= BitVec.instSub.1 (0#9) (BitVec.signExtend 9 (x‚úù.sshiftRight 1))
                            [Meta.isDefEq] [0.001498] ‚úÖÔ∏è (BitVec.signExtend (8 + 1) 0#8).sub
                                  (BitVec.signExtend (8 + 1)
                                    (x‚úù.sshiftRight (1#8).toNat)) =?= (0#9).sub (BitVec.signExtend 9 (x‚úù.sshiftRight 1))
                              [Meta.isDefEq.delta] [0.001487] ‚úÖÔ∏è (BitVec.signExtend (8 + 1) 0#8).sub
                                    (BitVec.signExtend (8 + 1)
                                      (x‚úù.sshiftRight
                                        (1#8).toNat)) =?= (0#9).sub (BitVec.signExtend 9 (x‚úù.sshiftRight 1))
                                [Meta.isDefEq] [0.001218] ‚úÖÔ∏è BitVec.signExtend (8 + 1) 0#8 =?= 0#9
                                  [Meta.isDefEq] [0.001202] ‚úÖÔ∏è BitVec.ofInt (8 + 1) (0#8).toInt =?= 0#9
                                    [Meta.isDefEq] [0.001187] ‚úÖÔ∏è ((0#8).toInt %
                                              Int.ofNat (2 ^ (8 + 1))).toNat#'‚ãØ =?= 0#9
                                      [Meta.isDefEq] [0.001170] ‚úÖÔ∏è ((0#8).toInt %
                                                Int.ofNat (2 ^ (8 + 1))).toNat#'‚ãØ =?= { toFin := Fin.ofNat' (2 ^ 9) 0 }
                                        [Meta.isDefEq] [0.001158] ‚úÖÔ∏è {
                                              toFin :=
                                                ‚ü®((0#8).toInt % Int.ofNat (2 ^ (8 + 1))).toNat,
                                                  ‚ãØ‚ü© } =?= { toFin := Fin.ofNat' (2 ^ 9) 0 }
                                          [Meta.isDefEq] [0.001109] ‚úÖÔ∏è ‚ü®((0#8).toInt % Int.ofNat (2 ^ (8 + 1))).toNat,
                                                ‚ãØ‚ü© =?= Fin.ofNat' (2 ^ 9) 0
                                            [Meta.isDefEq] [0.001093] ‚úÖÔ∏è ‚ü®((0#8).toInt % Int.ofNat (2 ^ (8 + 1))).toNat,
                                                  ‚ãØ‚ü© =?= ‚ü®0 % 2 ^ 9, ‚ãØ‚ü©
                                              [Meta.isDefEq] [0.001001] ‚úÖÔ∏è ((0#8).toInt %
                                                      Int.ofNat (2 ^ (8 + 1))).toNat =?= 0 % 2 ^ 9
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x‚úù : BitVec 8
      a‚úù :
        ¬¨some ((if x‚úù.getLsbD 7 = true then ~~~((~~~x‚úù + 1#8) / 12#8) + 1#8 else x‚úù / 12#8) * 250#8) ‚äë
            if
                (!(~~~BitVec.signExtend 9 (x‚úù.sshiftRight 1) + 1#9).getLsbD 8 ==
                      (~~~BitVec.signExtend 9 (x‚úù.sshiftRight 1) + 1#9).getMsbD 1) =
                  true then
              none
            else some (~~~x‚úù.sshiftRight 1 + 1#8)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:194:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:187:8: error: (kernel) declaration has metavariables 'mul_of_udiv_fail_bad_remainder_thm'
[bv] [0.025266] Normalizing goal
  [Meta.synthInstance] [0.001426] ‚úÖÔ∏è Decidable
        ((if 11#8 = 0 then none else some (x‚úù / 11#8 * 6#8)) ‚äë
          if 11#8 = 0 then none
          else
            if
                True ‚àß
                  BitVec.zeroExtend (2 * 8) (x‚úù / 11#8) * BitVec.zeroExtend (2 * 8) 6#8 ‚â•
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else some (x‚úù / 11#8 * 6#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x‚úù : BitVec 8
      a‚úù :
        ¬¨(if 11#8 = 0 then none else some (x‚úù / 11#8 * 6#8)) ‚äë
            if 11#8 = 0 then none
            else
              if
                  True ‚àß
                    BitVec.zeroExtend (2 * 8) (x‚úù / 11#8) * BitVec.zeroExtend (2 * 8) 6#8 ‚â•
                      BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
                none
              else some (x‚úù / 11#8 * 6#8)
      ‚ä¢ False
  [Meta.isDefEq] [0.001383] ‚úÖÔ∏è ?h‚ÇÅ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                (BitVec.zeroExtend 16 (x‚úù / 11#8) * 6#16))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 (x‚úù / 11#8) * 6#16)
                      (BitVec.twoPow 16 7 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 16 7 <<< 1 >·µ§ BitVec.zeroExtend 16 (x‚úù / 11#8) * 6#16) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 16 7 <<< 1 >·µ§ BitVec.zeroExtend 16 (x‚úù / 11#8) * 6#16)))))))
        (true_and ((!BitVec.twoPow 16 7 <<< 1 >·µ§ BitVec.zeroExtend 16 (x‚úù / 11#8) * 6#16) = true))
    [Meta.isDefEq.assign] [0.001380] ‚úÖÔ∏è ?h‚ÇÅ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                  (BitVec.zeroExtend 16 (x‚úù / 11#8) * 6#16))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 (x‚úù / 11#8) * 6#16)
                        (BitVec.twoPow 16 7 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 16 7 <<< 1 >·µ§ BitVec.zeroExtend 16 (x‚úù / 11#8) * 6#16) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 16 7 <<< 1 >·µ§ BitVec.zeroExtend 16 (x‚úù / 11#8) * 6#16)))))))
          (true_and ((!BitVec.twoPow 16 7 <<< 1 >·µ§ BitVec.zeroExtend 16 (x‚úù / 11#8) * 6#16) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001366] ‚úÖÔ∏è (?h‚ÇÅ : (True ‚àß
              BitVec.zeroExtend (2 * 8) (x‚úù / 11#8) * BitVec.zeroExtend (2 * 8) 6#8 ‚â•
                BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >·µ§ BitVec.zeroExtend 16 (x‚úù / 11#8) * 6#16) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                    (BitVec.zeroExtend 16 (x‚úù / 11#8) * 6#16))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 (x‚úù / 11#8) * 6#16)
                          (BitVec.twoPow 16 7 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 16 7 <<< 1 >·µ§ BitVec.zeroExtend 16 (x‚úù / 11#8) * 6#16) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 16 7 <<< 1 >·µ§ BitVec.zeroExtend 16 (x‚úù / 11#8) * 6#16)))))))
            (true_and
              ((!BitVec.twoPow 16 7 <<< 1 >·µ§ BitVec.zeroExtend 16 (x‚úù / 11#8) * 6#16) =
                true)) : (True ‚àß BitVec.zeroExtend 16 (x‚úù / 11#8) * 6#16 ‚â• BitVec.twoPow 16 7 <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >·µ§ BitVec.zeroExtend 16 (x‚úù / 11#8) * 6#16) = true))
        [Meta.isDefEq] [0.001363] ‚úÖÔ∏è (True ‚àß
                BitVec.zeroExtend (2 * 8) (x‚úù / 11#8) * BitVec.zeroExtend (2 * 8) 6#8 ‚â•
                  BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >·µ§ BitVec.zeroExtend 16 (x‚úù / 11#8) * 6#16) =
                true) =?= (True ‚àß BitVec.zeroExtend 16 (x‚úù / 11#8) * 6#16 ‚â• BitVec.twoPow 16 7 <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >·µ§ BitVec.zeroExtend 16 (x‚úù / 11#8) * 6#16) = true)
          [Meta.isDefEq] [0.001344] ‚úÖÔ∏è True ‚àß
                BitVec.zeroExtend (2 * 8) (x‚úù / 11#8) * BitVec.zeroExtend (2 * 8) 6#8 ‚â•
                  BitVec.twoPow (2 * 8) (8 - 1) <<<
                    1 =?= True ‚àß BitVec.zeroExtend 16 (x‚úù / 11#8) * 6#16 ‚â• BitVec.twoPow 16 7 <<< 1
            [Meta.isDefEq] [0.001329] ‚úÖÔ∏è BitVec.zeroExtend (2 * 8) (x‚úù / 11#8) * BitVec.zeroExtend (2 * 8) 6#8 ‚â•
                  BitVec.twoPow (2 * 8) (8 - 1) <<<
                    1 =?= BitVec.zeroExtend 16 (x‚úù / 11#8) * 6#16 ‚â• BitVec.twoPow 16 7 <<< 1
              [Meta.isDefEq.delta] [0.001309] ‚úÖÔ∏è BitVec.zeroExtend (2 * 8) (x‚úù / 11#8) * BitVec.zeroExtend (2 * 8) 6#8 ‚â•
                    BitVec.twoPow (2 * 8) (8 - 1) <<<
                      1 =?= BitVec.zeroExtend 16 (x‚úù / 11#8) * 6#16 ‚â• BitVec.twoPow 16 7 <<< 1
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x‚úù : BitVec 8
      a‚úù :
        ¬¨some (x‚úù / 11#8 * 6#8) ‚äë
            if (!BitVec.twoPow 16 7 <<< 1 >·µ§ BitVec.zeroExtend 16 (x‚úù / 11#8) * 6#16) = true then none
            else some (x‚úù / 11#8 * 6#8)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:203:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:198:8: error: (kernel) declaration has metavariables 'mul_of_sdiv_fail_ub_thm'
[bv] [0.030197] Normalizing goal
  [Meta.synthInstance] [0.001053] ‚úÖÔ∏è Decidable
        ((if (6#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 6#8 == -1) = true then none
          else some (x‚úù.sdiv 6#8 * 250#8)) ‚äë
          some (0#8 - x‚úù))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x‚úù : BitVec 8
      a‚úù :
        ¬¨(if (6#8 == 0 || 8 != 1 && x‚úù == BitVec.intMin 8 && 6#8 == -1) = true then none
            else some (x‚úù.sdiv 6#8 * 250#8)) ‚äë
            some (0#8 - x‚úù)
      ‚ä¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x‚úù : BitVec 8
      a‚úù :
        ¬¨some ((if x‚úù.getLsbD 7 = true then ~~~((~~~x‚úù + 1#8) / 6#8) + 1#8 else x‚úù / 6#8) * 250#8) ‚äë some (~~~x‚úù + 1#8)
      ‚ä¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
