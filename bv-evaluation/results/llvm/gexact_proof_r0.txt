⚠ [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
⚠ [878/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [881/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
⚠ [887/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
⚠ [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:16:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:11:8: error: (kernel) declaration has metavariables 'sdiv2_thm'
[bv] [0.034329] Normalizing goal
  [Meta.synthInstance] [0.001425] ✅️ Decidable
        ((if (8#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 8#32 == -1) = true then none else some (x✝.sdiv 8#32)) ⊑
          if 3#32 ≥ ↑32 then none else some (x✝.sshiftRight (3#32).toNat))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if (8#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 8#32 == -1) = true then none else some (x✝.sdiv 8#32)) ⊑
            if 3#32 ≥ ↑32 then none else some (x✝.sshiftRight (3#32).toNat)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬some (if x✝.getLsbD 31 = true then ~~~((~~~x✝ + 1#32) / 8#32) + 1#32 else x✝ / 8#32) ⊑ some (x✝.sshiftRight 3)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:25:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:20:8: error: (kernel) declaration has metavariables 'sdiv4_thm'
[bv] [0.034357] Normalizing goal
  [Meta.synthInstance] [0.001277] ✅️ Decidable
        ((if (3#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 3#32 == -1) = true then none
          else some (x✝.sdiv 3#32 * 3#32)) ⊑
          some x✝)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if (3#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 3#32 == -1) = true then none
            else some (x✝.sdiv 3#32 * 3#32)) ⊑
            some x✝
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ : ¬some ((if x✝.getLsbD 31 = true then ~~~((~~~x✝ + 1#32) / 3#32) + 1#32 else x✝ / 3#32) * 3#32) ⊑ some x✝
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:34:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:29:8: error: (kernel) declaration has metavariables 'sdiv6_thm'
[bv] [0.033175] Normalizing goal
  [Meta.synthInstance] [0.001576] ✅️ Decidable
        ((if (3#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 3#32 == -1) = true then none
          else some (x✝.sdiv 3#32 * 4294967293#32)) ⊑
          some (0#32 - x✝))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if (3#32 == 0 || 32 != 1 && x✝ == BitVec.intMin 32 && 3#32 == -1) = true then none
            else some (x✝.sdiv 3#32 * 4294967293#32)) ⊑
            some (0#32 - x✝)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬some ((if x✝.getLsbD 31 = true then ~~~((~~~x✝ + 1#32) / 3#32) + 1#32 else x✝ / 3#32) * 4294967293#32) ⊑
            some (~~~x✝ + 1#32)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:43:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:38:8: error: (kernel) declaration has metavariables 'udiv1_thm'
[bv] [0.021399] Normalizing goal
  [Meta.synthInstance] [0.001477] ✅️ Decidable ((if x✝¹ = 0 then none else some (x✝ / x✝¹ * x✝¹)) ⊑ some x✝)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ : ¬(if x✝¹ = 0 then none else some (x✝ / x✝¹ * x✝¹)) ⊑ some x✝
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ : ¬(if (x✝¹ == 0#32) = true then none else some (x✝ / x✝¹ * x✝¹)) ⊑ some x✝
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:52:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:47:8: error: (kernel) declaration has metavariables 'udiv2_thm'
[bv] [0.042604] Normalizing goal
  [Meta.synthInstance] [0.001857] ✅️ Decidable
        ((if x✝¹ ≥ ↑32 then none else if 1#32 <<< x✝¹ = 0 then none else some (x✝ / 1#32 <<< x✝¹)) ⊑
          if x✝¹ ≥ ↑32 then none else some (x✝ >>> x✝¹))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if x✝¹ ≥ ↑32 then none else if 1#32 <<< x✝¹ = 0 then none else some (x✝ / 1#32 <<< x✝¹)) ⊑
            if x✝¹ ≥ ↑32 then none else some (x✝ >>> x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 : LLVM.IntW 32
      x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if (!32#32 >ᵤ x✝¹) = true then none
            else if (1#32 <<< x✝¹ == 0#32) = true then none else some (x✝ / 1#32 <<< x✝¹)) ⊑
            if (!32#32 >ᵤ x✝¹) = true then none else some (x✝ >>> x✝¹)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:62:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:56:8: error: (kernel) declaration has metavariables 'ashr_icmp1_thm'
[bv] [0.021155] Normalizing goal
  [Meta.synthInstance] [0.001028] ✅️ Decidable
        ((if 2#64 ≥ ↑64 then none else some (BitVec.ofBool (x✝.sshiftRight (2#64).toNat == 0#64))) ⊑
          some (BitVec.ofBool (x✝ == 0#64)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      x✝ : BitVec 64
      a✝ :
        ¬(if 2#64 ≥ ↑64 then none else some (BitVec.ofBool (x✝.sshiftRight (2#64).toNat == 0#64))) ⊑
            some (BitVec.ofBool (x✝ == 0#64))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      x✝ : BitVec 64
      a✝ :
        ¬some (if (x✝.sshiftRight 2 == 0#64) = true then 1#1 else 0#1) ⊑ some (if (x✝ == 0#64) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:72:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:66:8: error: (kernel) declaration has metavariables 'ashr_icmp2_thm'
[bv] [0.031867] Normalizing goal
  [Meta.synthInstance] [0.001345] ✅️ Decidable
        ((if 2#64 ≥ ↑64 then none else some (BitVec.ofBool (4#64 >ₛ x✝.sshiftRight (2#64).toNat))) ⊑
          some (BitVec.ofBool (16#64 >ₛ x✝)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      x✝ : BitVec 64
      a✝ :
        ¬(if 2#64 ≥ ↑64 then none else some (BitVec.ofBool (4#64 >ₛ x✝.sshiftRight (2#64).toNat))) ⊑
            some (BitVec.ofBool (16#64 >ₛ x✝))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      x✝ : BitVec 64
      a✝ :
        ¬some (if (!(x✝.sshiftRight 2).getLsbD 63 == (4#64 >ᵤ x✝.sshiftRight 2)) = true then 1#1 else 0#1) ⊑
            some (if (!x✝.getLsbD 63 == (16#64 >ᵤ x✝)) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:83:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:76:8: error: (kernel) declaration has metavariables 'pr9998_thm'
[bv] [0.029641] Normalizing goal
  [Meta.synthInstance] [0.001565] ✅️ Decidable
        ((if 31#32 ≥ ↑32 then none
          else
            if 31#32 ≥ ↑32 then none
            else
              some
                (BitVec.ofBool
                  (BitVec.signExtend 64 ((x✝ <<< 31#32).sshiftRight (31#32).toNat) >ᵤ 7297771788697658747#64))) ⊑
          some (BitVec.ofBool (x✝ &&& 1#32 != 0#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬(if 31#32 ≥ ↑32 then none
            else
              if 31#32 ≥ ↑32 then none
              else
                some
                  (BitVec.ofBool
                    (BitVec.signExtend 64 ((x✝ <<< 31#32).sshiftRight (31#32).toNat) >ᵤ 7297771788697658747#64))) ⊑
            some (BitVec.ofBool (x✝ &&& 1#32 != 0#32))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬some
              (if (BitVec.signExtend 64 ((x✝ <<< 31).sshiftRight 31) >ᵤ 7297771788697658747#64) = true then 1#1
              else 0#1) ⊑
            some (if (!x✝ &&& 1#32 == 0#32) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:93:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:87:8: error: (kernel) declaration has metavariables 'udiv_icmp1_thm'
[bv] [0.025610] Normalizing goal
  [Meta.synthInstance] [0.001370] ✅️ Decidable
        ((if 5#64 = 0 then none else some (BitVec.ofBool (x✝ / 5#64 != 0#64))) ⊑ some (BitVec.ofBool (x✝ != 0#64)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      x✝ : BitVec 64
      a✝ : ¬(if 5#64 = 0 then none else some (BitVec.ofBool (x✝ / 5#64 != 0#64))) ⊑ some (BitVec.ofBool (x✝ != 0#64))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      x✝ : BitVec 64
      a✝ : ¬some (if (!x✝ / 5#64 == 0#64) = true then 1#1 else 0#1) ⊑ some (if (!x✝ == 0#64) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:103:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:97:8: error: (kernel) declaration has metavariables 'udiv_icmp2_thm'
[bv] [0.018473] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      x✝ : BitVec 64
      a✝ : ¬(if 5#64 = 0 then none else some (BitVec.ofBool (x✝ / 5#64 == 0#64))) ⊑ some (BitVec.ofBool (x✝ == 0#64))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      x✝ : BitVec 64
      a✝ : ¬some (if (x✝ / 5#64 == 0#64) = true then 1#1 else 0#1) ⊑ some (if (x✝ == 0#64) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:113:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:107:8: error: (kernel) declaration has metavariables 'sdiv_icmp1_thm'
[bv] [0.058020] Normalizing goal
  [Meta.synthInstance] [0.001648] ✅️ Decidable
        ((if (5#64 == 0 || 64 != 1 && x✝ == BitVec.intMin 64 && 5#64 == -1) = true then none
          else some (BitVec.ofBool (x✝.sdiv 5#64 == 0#64))) ⊑
          some (BitVec.ofBool (x✝ == 0#64)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      x✝ : BitVec 64
      a✝ :
        ¬(if (5#64 == 0 || 64 != 1 && x✝ == BitVec.intMin 64 && 5#64 == -1) = true then none
            else some (BitVec.ofBool (x✝.sdiv 5#64 == 0#64))) ⊑
            some (BitVec.ofBool (x✝ == 0#64))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      x✝ : BitVec 64
      a✝ :
        ¬some
              (if ((if x✝.getLsbD 63 = true then ~~~((~~~x✝ + 1#64) / 5#64) + 1#64 else x✝ / 5#64) == 0#64) = true then
                1#1
              else 0#1) ⊑
            some (if (x✝ == 0#64) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.isDefEq] [0.001648] ❌️ ?a ==
        ?a =?= (if x✝.getLsbD 63 = true then ~~~((~~~x✝ + 1#64) / 5#64) + 1#64 else x✝ / 5#64) == 0#64
    [Meta.isDefEq.onFailure] [0.001055] ❌️ ?a ==
          ?a =?= (if x✝.getLsbD 63 = true then ~~~((~~~x✝ + 1#64) / 5#64) + 1#64 else x✝ / 5#64) == 0#64
      [Meta.synthInstance] [0.001003] 💥️ BEq ?α
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:123:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:117:8: error: (kernel) declaration has metavariables 'sdiv_icmp2_thm'
[bv] [0.036238] Normalizing goal
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      x✝ : BitVec 64
      a✝ :
        ¬(if (5#64 == 0 || 64 != 1 && x✝ == BitVec.intMin 64 && 5#64 == -1) = true then none
            else some (BitVec.ofBool (x✝.sdiv 5#64 == 1#64))) ⊑
            some (BitVec.ofBool (x✝ == 5#64))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      x✝ : BitVec 64
      a✝ :
        ¬some
              (if ((if x✝.getLsbD 63 = true then ~~~((~~~x✝ + 1#64) / 5#64) + 1#64 else x✝ / 5#64) == 1#64) = true then
                1#1
              else 0#1) ⊑
            some (if (x✝ == 5#64) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:133:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:127:8: error: (kernel) declaration has metavariables 'sdiv_icmp3_thm'
[bv] [0.054988] Normalizing goal
  [Meta.synthInstance] [0.001446] ✅️ Decidable
        ((if (5#64 == 0 || 64 != 1 && x✝ == BitVec.intMin 64 && 5#64 == -1) = true then none
          else some (BitVec.ofBool (x✝.sdiv 5#64 == -1#64))) ⊑
          some (BitVec.ofBool (x✝ == 18446744073709551611#64)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      x✝ : BitVec 64
      a✝ :
        ¬(if (5#64 == 0 || 64 != 1 && x✝ == BitVec.intMin 64 && 5#64 == -1) = true then none
            else some (BitVec.ofBool (x✝.sdiv 5#64 == -1#64))) ⊑
            some (BitVec.ofBool (x✝ == 18446744073709551611#64))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      x✝ : BitVec 64
      a✝ :
        ¬some
              (if
                  ((if x✝.getLsbD 63 = true then ~~~((~~~x✝ + 1#64) / 5#64) + 1#64 else x✝ / 5#64) ==
                      18446744073709551615#64) =
                    true then
                1#1
              else 0#1) ⊑
            some (if (x✝ == 18446744073709551611#64) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:143:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:137:8: error: (kernel) declaration has metavariables 'sdiv_icmp4_thm'
[bv] [0.042195] Normalizing goal
  [Meta.synthInstance] [0.001268] ✅️ Decidable
        ((if
              (18446744073709551611#64 == 0 || 64 != 1 && x✝ == BitVec.intMin 64 && 18446744073709551611#64 == -1) =
                true then
            none
          else some (BitVec.ofBool (x✝.sdiv 18446744073709551611#64 == 0#64))) ⊑
          some (BitVec.ofBool (x✝ == 0#64)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      x✝ : BitVec 64
      a✝ :
        ¬(if
                (18446744073709551611#64 == 0 || 64 != 1 && x✝ == BitVec.intMin 64 && 18446744073709551611#64 == -1) =
                  true then
              none
            else some (BitVec.ofBool (x✝.sdiv 18446744073709551611#64 == 0#64))) ⊑
            some (BitVec.ofBool (x✝ == 0#64))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      x✝ : BitVec 64
      a✝ :
        ¬some
              (if ((if x✝.getLsbD 63 = true then (~~~x✝ + 1#64) / 5#64 else ~~~(x✝ / 5#64) + 1#64) == 0#64) = true then
                1#1
              else 0#1) ⊑
            some (if (x✝ == 0#64) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:153:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:147:8: error: (kernel) declaration has metavariables 'sdiv_icmp5_thm'
[bv] [0.037935] Normalizing goal
  [Meta.synthInstance] [0.001029] ✅️ Decidable
        ((if
              (18446744073709551611#64 == 0 || 64 != 1 && x✝ == BitVec.intMin 64 && 18446744073709551611#64 == -1) =
                true then
            none
          else some (BitVec.ofBool (x✝.sdiv 18446744073709551611#64 == 1#64))) ⊑
          some (BitVec.ofBool (x✝ == 18446744073709551611#64)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      x✝ : BitVec 64
      a✝ :
        ¬(if
                (18446744073709551611#64 == 0 || 64 != 1 && x✝ == BitVec.intMin 64 && 18446744073709551611#64 == -1) =
                  true then
              none
            else some (BitVec.ofBool (x✝.sdiv 18446744073709551611#64 == 1#64))) ⊑
            some (BitVec.ofBool (x✝ == 18446744073709551611#64))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      x✝ : BitVec 64
      a✝ :
        ¬some
              (if ((if x✝.getLsbD 63 = true then (~~~x✝ + 1#64) / 5#64 else ~~~(x✝ / 5#64) + 1#64) == 1#64) = true then
                1#1
              else 0#1) ⊑
            some (if (x✝ == 18446744073709551611#64) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:163:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:157:8: error: (kernel) declaration has metavariables 'sdiv_icmp6_thm'
[bv] [0.038604] Normalizing goal
  [Meta.synthInstance] [0.001058] ✅️ Decidable
        ((if
              (18446744073709551611#64 == 0 || 64 != 1 && x✝ == BitVec.intMin 64 && 18446744073709551611#64 == -1) =
                true then
            none
          else some (BitVec.ofBool (x✝.sdiv 18446744073709551611#64 == -1#64))) ⊑
          some (BitVec.ofBool (x✝ == 5#64)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 64
      x✝ : BitVec 64
      a✝ :
        ¬(if
                (18446744073709551611#64 == 0 || 64 != 1 && x✝ == BitVec.intMin 64 && 18446744073709551611#64 == -1) =
                  true then
              none
            else some (BitVec.ofBool (x✝.sdiv 18446744073709551611#64 == -1#64))) ⊑
            some (BitVec.ofBool (x✝ == 5#64))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 64
      x✝ : BitVec 64
      a✝ :
        ¬some
              (if
                  ((if x✝.getLsbD 63 = true then (~~~x✝ + 1#64) / 5#64 else ~~~(x✝ / 5#64) + 1#64) ==
                      18446744073709551615#64) =
                    true then
                1#1
              else 0#1) ⊑
            some (if (x✝ == 5#64) = true then 1#1 else 0#1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:172:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:167:8: error: (kernel) declaration has metavariables 'mul_of_udiv_thm'
[bv] [0.011525] Normalizing goal
  [Meta.synthInstance] [0.001253] ✅️ Decidable
        ((if 12#8 = 0 then none else some (x✝ / 12#8 * 6#8)) ⊑ if 1#8 ≥ ↑8 then none else some (x✝ >>> 1#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ : ¬(if 12#8 = 0 then none else some (x✝ / 12#8 * 6#8)) ⊑ if 1#8 ≥ ↑8 then none else some (x✝ >>> 1#8)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ : ¬some (x✝ / 12#8 * 6#8) ⊑ some (x✝ >>> 1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:183:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:176:8: error: (kernel) declaration has metavariables 'mul_of_sdiv_thm'
[bv] [0.053675] Normalizing goal
  [Meta.synthInstance] [0.001647] ✅️ Decidable
        ((if (12#8 == 0 || 8 != 1 && x✝ == BitVec.intMin 8 && 12#8 == -1) = true then none
          else some (x✝.sdiv 12#8 * 250#8)) ⊑
          if 1#8 ≥ ↑8 then none
          else
            if
                True ∧
                  (BitVec.signExtend (8 + 1) 0#8 - BitVec.signExtend (8 + 1) (x✝.sshiftRight (1#8).toNat)).msb ≠
                    (BitVec.signExtend (8 + 1) 0#8 - BitVec.signExtend (8 + 1) (x✝.sshiftRight (1#8).toNat)).getMsbD
                      1 then
              none
            else some (0#8 - x✝.sshiftRight (1#8).toNat))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if (12#8 == 0 || 8 != 1 && x✝ == BitVec.intMin 8 && 12#8 == -1) = true then none
            else some (x✝.sdiv 12#8 * 250#8)) ⊑
            if 1#8 ≥ ↑8 then none
            else
              if
                  True ∧
                    (BitVec.signExtend (8 + 1) 0#8 - BitVec.signExtend (8 + 1) (x✝.sshiftRight (1#8).toNat)).msb ≠
                      (BitVec.signExtend (8 + 1) 0#8 - BitVec.signExtend (8 + 1) (x✝.sshiftRight (1#8).toNat)).getMsbD
                        1 then
                none
              else some (0#8 - x✝.sshiftRight (1#8).toNat)
      ⊢ False
  [Meta.isDefEq] [0.001820] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans
            (congr
              (congrArg Ne
                (Eq.trans
                  (congrArg BitVec.msb
                    (Eq.trans (BitVec.sub_toAdd (0#9) (BitVec.signExtend 9 (x✝.sshiftRight 1)))
                      (Eq.trans
                        (congrArg (HAdd.hAdd 0#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝.sshiftRight 1))))
                        (BitVec.zero_add (~~~BitVec.signExtend 9 (x✝.sshiftRight 1) + 1#9)))))
                  (BitVec.msb_eq_getLsbD_last (~~~BitVec.signExtend 9 (x✝.sshiftRight 1) + 1#9))))
              (congrArg (fun x => x.getMsbD 1)
                (Eq.trans (BitVec.sub_toAdd (0#9) (BitVec.signExtend 9 (x✝.sshiftRight 1)))
                  (Eq.trans (congrArg (HAdd.hAdd 0#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝.sshiftRight 1))))
                    (BitVec.zero_add (~~~BitVec.signExtend 9 (x✝.sshiftRight 1) + 1#9))))))
            (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq ((~~~BitVec.signExtend 9 (x✝.sshiftRight 1) + 1#9).getLsbD 8)
              ((~~~BitVec.signExtend 9 (x✝.sshiftRight 1) + 1#9).getMsbD 1))))
        (true_and
          ((!(~~~BitVec.signExtend 9 (x✝.sshiftRight 1) + 1#9).getLsbD 8 ==
                (~~~BitVec.signExtend 9 (x✝.sshiftRight 1) + 1#9).getMsbD 1) =
            true))
    [Meta.isDefEq.assign] [0.001816] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans
              (congr
                (congrArg Ne
                  (Eq.trans
                    (congrArg BitVec.msb
                      (Eq.trans (BitVec.sub_toAdd (0#9) (BitVec.signExtend 9 (x✝.sshiftRight 1)))
                        (Eq.trans
                          (congrArg (HAdd.hAdd 0#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝.sshiftRight 1))))
                          (BitVec.zero_add (~~~BitVec.signExtend 9 (x✝.sshiftRight 1) + 1#9)))))
                    (BitVec.msb_eq_getLsbD_last (~~~BitVec.signExtend 9 (x✝.sshiftRight 1) + 1#9))))
                (congrArg (fun x => x.getMsbD 1)
                  (Eq.trans (BitVec.sub_toAdd (0#9) (BitVec.signExtend 9 (x✝.sshiftRight 1)))
                    (Eq.trans
                      (congrArg (HAdd.hAdd 0#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝.sshiftRight 1))))
                      (BitVec.zero_add (~~~BitVec.signExtend 9 (x✝.sshiftRight 1) + 1#9))))))
              (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                ((~~~BitVec.signExtend 9 (x✝.sshiftRight 1) + 1#9).getLsbD 8)
                ((~~~BitVec.signExtend 9 (x✝.sshiftRight 1) + 1#9).getMsbD 1))))
          (true_and
            ((!(~~~BitVec.signExtend 9 (x✝.sshiftRight 1) + 1#9).getLsbD 8 ==
                  (~~~BitVec.signExtend 9 (x✝.sshiftRight 1) + 1#9).getMsbD 1) =
              true))
      [Meta.isDefEq.assign.checkTypes] [0.001789] ✅️ (?h₁ : (True ∧
              (BitVec.signExtend (8 + 1) 0#8 - BitVec.signExtend (8 + 1) (x✝.sshiftRight (1#8).toNat)).msb ≠
                (BitVec.signExtend (8 + 1) 0#8 - BitVec.signExtend (8 + 1) (x✝.sshiftRight (1#8).toNat)).getMsbD 1) =
            ((!(~~~BitVec.signExtend 9 (x✝.sshiftRight 1) + 1#9).getLsbD 8 ==
                  (~~~BitVec.signExtend 9 (x✝.sshiftRight 1) + 1#9).getMsbD 1) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans
                (congr
                  (congrArg Ne
                    (Eq.trans
                      (congrArg BitVec.msb
                        (Eq.trans (BitVec.sub_toAdd (0#9) (BitVec.signExtend 9 (x✝.sshiftRight 1)))
                          (Eq.trans
                            (congrArg (HAdd.hAdd 0#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝.sshiftRight 1))))
                            (BitVec.zero_add (~~~BitVec.signExtend 9 (x✝.sshiftRight 1) + 1#9)))))
                      (BitVec.msb_eq_getLsbD_last (~~~BitVec.signExtend 9 (x✝.sshiftRight 1) + 1#9))))
                  (congrArg (fun x => x.getMsbD 1)
                    (Eq.trans (BitVec.sub_toAdd (0#9) (BitVec.signExtend 9 (x✝.sshiftRight 1)))
                      (Eq.trans
                        (congrArg (HAdd.hAdd 0#9) (BitVec.neg_eq_not_add (BitVec.signExtend 9 (x✝.sshiftRight 1))))
                        (BitVec.zero_add (~~~BitVec.signExtend 9 (x✝.sshiftRight 1) + 1#9))))))
                (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                  ((~~~BitVec.signExtend 9 (x✝.sshiftRight 1) + 1#9).getLsbD 8)
                  ((~~~BitVec.signExtend 9 (x✝.sshiftRight 1) + 1#9).getMsbD 1))))
            (true_and
              ((!(~~~BitVec.signExtend 9 (x✝.sshiftRight 1) + 1#9).getLsbD 8 ==
                    (~~~BitVec.signExtend 9 (x✝.sshiftRight 1) + 1#9).getMsbD 1) =
                true)) : (True ∧
              (0#9 - BitVec.signExtend 9 (x✝.sshiftRight 1)).msb ≠
                (0#9 - BitVec.signExtend 9 (x✝.sshiftRight 1)).getMsbD 1) =
            ((!(~~~BitVec.signExtend 9 (x✝.sshiftRight 1) + 1#9).getLsbD 8 ==
                  (~~~BitVec.signExtend 9 (x✝.sshiftRight 1) + 1#9).getMsbD 1) =
              true))
        [Meta.isDefEq] [0.001785] ✅️ (True ∧
                (BitVec.signExtend (8 + 1) 0#8 - BitVec.signExtend (8 + 1) (x✝.sshiftRight (1#8).toNat)).msb ≠
                  (BitVec.signExtend (8 + 1) 0#8 - BitVec.signExtend (8 + 1) (x✝.sshiftRight (1#8).toNat)).getMsbD 1) =
              ((!(~~~BitVec.signExtend 9 (x✝.sshiftRight 1) + 1#9).getLsbD 8 ==
                    (~~~BitVec.signExtend 9 (x✝.sshiftRight 1) + 1#9).getMsbD 1) =
                true) =?= (True ∧
                (0#9 - BitVec.signExtend 9 (x✝.sshiftRight 1)).msb ≠
                  (0#9 - BitVec.signExtend 9 (x✝.sshiftRight 1)).getMsbD 1) =
              ((!(~~~BitVec.signExtend 9 (x✝.sshiftRight 1) + 1#9).getLsbD 8 ==
                    (~~~BitVec.signExtend 9 (x✝.sshiftRight 1) + 1#9).getMsbD 1) =
                true)
          [Meta.isDefEq] [0.001759] ✅️ True ∧
                (BitVec.signExtend (8 + 1) 0#8 - BitVec.signExtend (8 + 1) (x✝.sshiftRight (1#8).toNat)).msb ≠
                  (BitVec.signExtend (8 + 1) 0#8 - BitVec.signExtend (8 + 1) (x✝.sshiftRight (1#8).toNat)).getMsbD
                    1 =?= True ∧
                (0#9 - BitVec.signExtend 9 (x✝.sshiftRight 1)).msb ≠
                  (0#9 - BitVec.signExtend 9 (x✝.sshiftRight 1)).getMsbD 1
            [Meta.isDefEq] [0.001743] ✅️ (BitVec.signExtend (8 + 1) 0#8 -
                      BitVec.signExtend (8 + 1) (x✝.sshiftRight (1#8).toNat)).msb ≠
                  (BitVec.signExtend (8 + 1) 0#8 - BitVec.signExtend (8 + 1) (x✝.sshiftRight (1#8).toNat)).getMsbD
                    1 =?= (0#9 - BitVec.signExtend 9 (x✝.sshiftRight 1)).msb ≠
                  (0#9 - BitVec.signExtend 9 (x✝.sshiftRight 1)).getMsbD 1
              [Meta.isDefEq.delta] [0.001728] ✅️ (BitVec.signExtend (8 + 1) 0#8 -
                        BitVec.signExtend (8 + 1) (x✝.sshiftRight (1#8).toNat)).msb ≠
                    (BitVec.signExtend (8 + 1) 0#8 - BitVec.signExtend (8 + 1) (x✝.sshiftRight (1#8).toNat)).getMsbD
                      1 =?= (0#9 - BitVec.signExtend 9 (x✝.sshiftRight 1)).msb ≠
                    (0#9 - BitVec.signExtend 9 (x✝.sshiftRight 1)).getMsbD 1
                [Meta.isDefEq] [0.001665] ✅️ (BitVec.signExtend (8 + 1) 0#8 -
                        BitVec.signExtend (8 + 1)
                          (x✝.sshiftRight (1#8).toNat)).msb =?= (0#9 - BitVec.signExtend 9 (x✝.sshiftRight 1)).msb
                  [Meta.isDefEq.delta] [0.001655] ✅️ (BitVec.signExtend (8 + 1) 0#8 -
                          BitVec.signExtend (8 + 1)
                            (x✝.sshiftRight (1#8).toNat)).msb =?= (0#9 - BitVec.signExtend 9 (x✝.sshiftRight 1)).msb
                    [Meta.isDefEq] [0.001634] ✅️ BitVec.signExtend (8 + 1) 0#8 -
                          BitVec.signExtend (8 + 1)
                            (x✝.sshiftRight (1#8).toNat) =?= 0#9 - BitVec.signExtend 9 (x✝.sshiftRight 1)
                      [Meta.isDefEq] [0.001608] ✅️ instHSub.1 (BitVec.signExtend (8 + 1) 0#8)
                            (BitVec.signExtend (8 + 1)
                              (x✝.sshiftRight
                                (1#8).toNat)) =?= instHSub.1 (0#9) (BitVec.signExtend 9 (x✝.sshiftRight 1))
                        [Meta.isDefEq] [0.001555] ✅️ Sub.sub (BitVec.signExtend (8 + 1) 0#8)
                              (BitVec.signExtend (8 + 1)
                                (x✝.sshiftRight (1#8).toNat)) =?= Sub.sub (0#9) (BitVec.signExtend 9 (x✝.sshiftRight 1))
                          [Meta.isDefEq] [0.001535] ✅️ BitVec.instSub.1 (BitVec.signExtend (8 + 1) 0#8)
                                (BitVec.signExtend (8 + 1)
                                  (x✝.sshiftRight
                                    (1#8).toNat)) =?= BitVec.instSub.1 (0#9) (BitVec.signExtend 9 (x✝.sshiftRight 1))
                            [Meta.isDefEq] [0.001498] ✅️ (BitVec.signExtend (8 + 1) 0#8).sub
                                  (BitVec.signExtend (8 + 1)
                                    (x✝.sshiftRight (1#8).toNat)) =?= (0#9).sub (BitVec.signExtend 9 (x✝.sshiftRight 1))
                              [Meta.isDefEq.delta] [0.001487] ✅️ (BitVec.signExtend (8 + 1) 0#8).sub
                                    (BitVec.signExtend (8 + 1)
                                      (x✝.sshiftRight
                                        (1#8).toNat)) =?= (0#9).sub (BitVec.signExtend 9 (x✝.sshiftRight 1))
                                [Meta.isDefEq] [0.001218] ✅️ BitVec.signExtend (8 + 1) 0#8 =?= 0#9
                                  [Meta.isDefEq] [0.001202] ✅️ BitVec.ofInt (8 + 1) (0#8).toInt =?= 0#9
                                    [Meta.isDefEq] [0.001187] ✅️ ((0#8).toInt %
                                              Int.ofNat (2 ^ (8 + 1))).toNat#'⋯ =?= 0#9
                                      [Meta.isDefEq] [0.001170] ✅️ ((0#8).toInt %
                                                Int.ofNat (2 ^ (8 + 1))).toNat#'⋯ =?= { toFin := Fin.ofNat' (2 ^ 9) 0 }
                                        [Meta.isDefEq] [0.001158] ✅️ {
                                              toFin :=
                                                ⟨((0#8).toInt % Int.ofNat (2 ^ (8 + 1))).toNat,
                                                  ⋯⟩ } =?= { toFin := Fin.ofNat' (2 ^ 9) 0 }
                                          [Meta.isDefEq] [0.001109] ✅️ ⟨((0#8).toInt % Int.ofNat (2 ^ (8 + 1))).toNat,
                                                ⋯⟩ =?= Fin.ofNat' (2 ^ 9) 0
                                            [Meta.isDefEq] [0.001093] ✅️ ⟨((0#8).toInt % Int.ofNat (2 ^ (8 + 1))).toNat,
                                                  ⋯⟩ =?= ⟨0 % 2 ^ 9, ⋯⟩
                                              [Meta.isDefEq] [0.001001] ✅️ ((0#8).toInt %
                                                      Int.ofNat (2 ^ (8 + 1))).toNat =?= 0 % 2 ^ 9
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬some ((if x✝.getLsbD 7 = true then ~~~((~~~x✝ + 1#8) / 12#8) + 1#8 else x✝ / 12#8) * 250#8) ⊑
            if
                (!(~~~BitVec.signExtend 9 (x✝.sshiftRight 1) + 1#9).getLsbD 8 ==
                      (~~~BitVec.signExtend 9 (x✝.sshiftRight 1) + 1#9).getMsbD 1) =
                  true then
              none
            else some (~~~x✝.sshiftRight 1 + 1#8)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:194:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:187:8: error: (kernel) declaration has metavariables 'mul_of_udiv_fail_bad_remainder_thm'
[bv] [0.025266] Normalizing goal
  [Meta.synthInstance] [0.001426] ✅️ Decidable
        ((if 11#8 = 0 then none else some (x✝ / 11#8 * 6#8)) ⊑
          if 11#8 = 0 then none
          else
            if
                True ∧
                  BitVec.zeroExtend (2 * 8) (x✝ / 11#8) * BitVec.zeroExtend (2 * 8) 6#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
              none
            else some (x✝ / 11#8 * 6#8))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if 11#8 = 0 then none else some (x✝ / 11#8 * 6#8)) ⊑
            if 11#8 = 0 then none
            else
              if
                  True ∧
                    BitVec.zeroExtend (2 * 8) (x✝ / 11#8) * BitVec.zeroExtend (2 * 8) 6#8 ≥
                      BitVec.twoPow (2 * 8) (8 - 1) <<< 1 then
                none
              else some (x✝ / 11#8 * 6#8)
      ⊢ False
  [Meta.isDefEq] [0.001383] ✅️ ?h₁ =?= Eq.trans
        (congrArg (And True)
          (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
            (Eq.trans
              (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                (BitVec.zeroExtend 16 (x✝ / 11#8) * 6#16))
              (Eq.trans
                (Eq.trans
                  (congrArg Not
                    (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 (x✝ / 11#8) * 6#16)
                      (BitVec.twoPow 16 7 <<< 1)))
                  (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                    (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 (x✝ / 11#8) * 6#16) true))
                (congrArg (fun x => (!x) = true)
                  (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 (x✝ / 11#8) * 6#16)))))))
        (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 (x✝ / 11#8) * 6#16) = true))
    [Meta.isDefEq.assign] [0.001380] ✅️ ?h₁ := Eq.trans
          (congrArg (And True)
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans
                (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                  (BitVec.zeroExtend 16 (x✝ / 11#8) * 6#16))
                (Eq.trans
                  (Eq.trans
                    (congrArg Not
                      (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 (x✝ / 11#8) * 6#16)
                        (BitVec.twoPow 16 7 <<< 1)))
                    (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                      (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 (x✝ / 11#8) * 6#16) true))
                  (congrArg (fun x => (!x) = true)
                    (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 (x✝ / 11#8) * 6#16)))))))
          (true_and ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 (x✝ / 11#8) * 6#16) = true))
      [Meta.isDefEq.assign.checkTypes] [0.001366] ✅️ (?h₁ : (True ∧
              BitVec.zeroExtend (2 * 8) (x✝ / 11#8) * BitVec.zeroExtend (2 * 8) 6#8 ≥
                BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 (x✝ / 11#8) * 6#16) =
              true)) := (Eq.trans
            (congrArg (And True)
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans
                  (Std.Tactic.BVDecide.Normalize.BitVec.le_ult (BitVec.twoPow 16 7 <<< 1)
                    (BitVec.zeroExtend 16 (x✝ / 11#8) * 6#16))
                  (Eq.trans
                    (Eq.trans
                      (congrArg Not
                        (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult (BitVec.zeroExtend 16 (x✝ / 11#8) * 6#16)
                          (BitVec.twoPow 16 7 <<< 1)))
                      (Std.Tactic.BVDecide.Normalize.Bool.ne_to_beq
                        (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 (x✝ / 11#8) * 6#16) true))
                    (congrArg (fun x => (!x) = true)
                      (beq_true (BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 (x✝ / 11#8) * 6#16)))))))
            (true_and
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 (x✝ / 11#8) * 6#16) =
                true)) : (True ∧ BitVec.zeroExtend 16 (x✝ / 11#8) * 6#16 ≥ BitVec.twoPow 16 7 <<< 1) =
            ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 (x✝ / 11#8) * 6#16) = true))
        [Meta.isDefEq] [0.001363] ✅️ (True ∧
                BitVec.zeroExtend (2 * 8) (x✝ / 11#8) * BitVec.zeroExtend (2 * 8) 6#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 (x✝ / 11#8) * 6#16) =
                true) =?= (True ∧ BitVec.zeroExtend 16 (x✝ / 11#8) * 6#16 ≥ BitVec.twoPow 16 7 <<< 1) =
              ((!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 (x✝ / 11#8) * 6#16) = true)
          [Meta.isDefEq] [0.001344] ✅️ True ∧
                BitVec.zeroExtend (2 * 8) (x✝ / 11#8) * BitVec.zeroExtend (2 * 8) 6#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<<
                    1 =?= True ∧ BitVec.zeroExtend 16 (x✝ / 11#8) * 6#16 ≥ BitVec.twoPow 16 7 <<< 1
            [Meta.isDefEq] [0.001329] ✅️ BitVec.zeroExtend (2 * 8) (x✝ / 11#8) * BitVec.zeroExtend (2 * 8) 6#8 ≥
                  BitVec.twoPow (2 * 8) (8 - 1) <<<
                    1 =?= BitVec.zeroExtend 16 (x✝ / 11#8) * 6#16 ≥ BitVec.twoPow 16 7 <<< 1
              [Meta.isDefEq.delta] [0.001309] ✅️ BitVec.zeroExtend (2 * 8) (x✝ / 11#8) * BitVec.zeroExtend (2 * 8) 6#8 ≥
                    BitVec.twoPow (2 * 8) (8 - 1) <<<
                      1 =?= BitVec.zeroExtend 16 (x✝ / 11#8) * 6#16 ≥ BitVec.twoPow 16 7 <<< 1
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬some (x✝ / 11#8 * 6#8) ⊑
            if (!BitVec.twoPow 16 7 <<< 1 >ᵤ BitVec.zeroExtend 16 (x✝ / 11#8) * 6#16) = true then none
            else some (x✝ / 11#8 * 6#8)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:203:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gexact_proof.lean:198:8: error: (kernel) declaration has metavariables 'mul_of_sdiv_fail_ub_thm'
[bv] [0.030197] Normalizing goal
  [Meta.synthInstance] [0.001053] ✅️ Decidable
        ((if (6#8 == 0 || 8 != 1 && x✝ == BitVec.intMin 8 && 6#8 == -1) = true then none
          else some (x✝.sdiv 6#8 * 250#8)) ⊑
          some (0#8 - x✝))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬(if (6#8 == 0 || 8 != 1 && x✝ == BitVec.intMin 8 && 6#8 == -1) = true then none
            else some (x✝.sdiv 6#8 * 250#8)) ⊑
            some (0#8 - x✝)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      x✝ : BitVec 8
      a✝ :
        ¬some ((if x✝.getLsbD 7 = true then ~~~((~~~x✝ + 1#8) / 6#8) + 1#8 else x✝ / 6#8) * 250#8) ⊑ some (~~~x✝ + 1#8)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
