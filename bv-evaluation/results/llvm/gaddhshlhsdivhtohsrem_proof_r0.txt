âš  [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
âš  [878/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
âš  [881/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
âš  [887/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
âš  [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddhshlhsdivhtohsrem_proof.lean:17:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddhshlhsdivhtohsrem_proof.lean:11:8: error: (kernel) declaration has metavariables 'addhshlhsdivhscalar0_thm'
[bv] [0.068981] Normalizing goal
  [Meta.synthInstance] [0.001940] âœ…ï¸ Decidable
        ((if (252#8 == 0 || 8 != 1 && xâœ == BitVec.intMin 8 && 252#8 == -1) = true then none
          else if 2#8 â‰¥ â†‘8 then none else some (xâœ.sdiv 252#8 <<< 2#8 + xâœ)) âŠ‘
          Option.map (fun div => xâœ - div * 4#8)
            (if (4#8 == 0 || 8 != 1 && xâœ == BitVec.intMin 8 && 4#8 == -1) = true then none else some (xâœ.sdiv 4#8)))
    [Meta.check] [0.001286] âœ…ï¸ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if (252#8 == 0 || 8 != 1 && xâœ == BitVec.intMin 8 && 252#8 == -1) = true then none
          else if 2#8 â‰¥ â†‘8 then none else some (xâœ.sdiv 252#8 <<< 2#8 + xâœ))
          (Option.map (fun div => xâœ - div * 4#8)
            (if (4#8 == 0 || 8 != 1 && xâœ == BitVec.intMin 8 && 4#8 == -1) = true then none else some (xâœ.sdiv 4#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      xâœ : BitVec 8
      aâœ :
        Â¬(if (252#8 == 0 || 8 != 1 && xâœ == BitVec.intMin 8 && 252#8 == -1) = true then none
            else if 2#8 â‰¥ â†‘8 then none else some (xâœ.sdiv 252#8 <<< 2#8 + xâœ)) âŠ‘
            Option.map (fun div => xâœ - div * 4#8)
              (if (4#8 == 0 || 8 != 1 && xâœ == BitVec.intMin 8 && 4#8 == -1) = true then none else some (xâœ.sdiv 4#8))
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      xâœ : BitVec 8
      aâœ :
        Â¬some ((if xâœ.getLsbD 7 = true then (~~~xâœ + 1#8) / 4#8 else ~~~(xâœ / 4#8) + 1#8) <<< 2 + xâœ) âŠ‘
            Option.map (fun div => xâœ + (~~~(div * 4#8) + 1#8))
              (some (if xâœ.getLsbD 7 = true then ~~~((~~~xâœ + 1#8) / 4#8) + 1#8 else xâœ / 4#8))
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddhshlhsdivhtohsrem_proof.lean:27:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddhshlhsdivhtohsrem_proof.lean:21:8: error: (kernel) declaration has metavariables 'addhshlhsdivhscalar1_thm'
[bv] [0.076062] Normalizing goal
  [Meta.synthInstance] [0.002496] âœ…ï¸ Decidable
        ((if (192#8 == 0 || 8 != 1 && xâœ == BitVec.intMin 8 && 192#8 == -1) = true then none
          else if 6#8 â‰¥ â†‘8 then none else some (xâœ.sdiv 192#8 <<< 6#8 + xâœ)) âŠ‘
          Option.map (fun div => xâœ - div * 64#8)
            (if (64#8 == 0 || 8 != 1 && xâœ == BitVec.intMin 8 && 64#8 == -1) = true then none else some (xâœ.sdiv 64#8)))
    [Meta.check] [0.001534] âœ…ï¸ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if (192#8 == 0 || 8 != 1 && xâœ == BitVec.intMin 8 && 192#8 == -1) = true then none
          else if 6#8 â‰¥ â†‘8 then none else some (xâœ.sdiv 192#8 <<< 6#8 + xâœ))
          (Option.map (fun div => xâœ - div * 64#8)
            (if (64#8 == 0 || 8 != 1 && xâœ == BitVec.intMin 8 && 64#8 == -1) = true then none else some (xâœ.sdiv 64#8)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      xâœ : BitVec 8
      aâœ :
        Â¬(if (192#8 == 0 || 8 != 1 && xâœ == BitVec.intMin 8 && 192#8 == -1) = true then none
            else if 6#8 â‰¥ â†‘8 then none else some (xâœ.sdiv 192#8 <<< 6#8 + xâœ)) âŠ‘
            Option.map (fun div => xâœ - div * 64#8)
              (if (64#8 == 0 || 8 != 1 && xâœ == BitVec.intMin 8 && 64#8 == -1) = true then none
              else some (xâœ.sdiv 64#8))
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      xâœ : BitVec 8
      aâœ :
        Â¬some ((if xâœ.getLsbD 7 = true then (~~~xâœ + 1#8) / 64#8 else ~~~(xâœ / 64#8) + 1#8) <<< 6 + xâœ) âŠ‘
            Option.map (fun div => xâœ + (~~~(div * 64#8) + 1#8))
              (some (if xâœ.getLsbD 7 = true then ~~~((~~~xâœ + 1#8) / 64#8) + 1#8 else xâœ / 64#8))
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddhshlhsdivhtohsrem_proof.lean:37:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddhshlhsdivhtohsrem_proof.lean:31:8: error: (kernel) declaration has metavariables 'addhshlhsdivhscalar2_thm'
[bv] [0.078208] Normalizing goal
  [Meta.synthInstance] [0.001661] âœ…ï¸ Decidable
        ((if (3221225472#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 3221225472#32 == -1) = true then none
          else if 30#32 â‰¥ â†‘32 then none else some (xâœ.sdiv 3221225472#32 <<< 30#32 + xâœ)) âŠ‘
          Option.map (fun div => xâœ - div * 1073741824#32)
            (if (1073741824#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 1073741824#32 == -1) = true then none
            else some (xâœ.sdiv 1073741824#32)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(if (3221225472#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 3221225472#32 == -1) = true then none
            else if 30#32 â‰¥ â†‘32 then none else some (xâœ.sdiv 3221225472#32 <<< 30#32 + xâœ)) âŠ‘
            Option.map (fun div => xâœ - div * 1073741824#32)
              (if (1073741824#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 1073741824#32 == -1) = true then none
              else some (xâœ.sdiv 1073741824#32))
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬some
              ((if xâœ.getLsbD 31 = true then (~~~xâœ + 1#32) / 1073741824#32 else ~~~(xâœ / 1073741824#32) + 1#32) <<<
                  30 +
                xâœ) âŠ‘
            Option.map (fun div => xâœ + (~~~(div * 1073741824#32) + 1#32))
              (some (if xâœ.getLsbD 31 = true then ~~~((~~~xâœ + 1#32) / 1073741824#32) + 1#32 else xâœ / 1073741824#32))
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddhshlhsdivhtohsrem_proof.lean:48:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddhshlhsdivhtohsrem_proof.lean:41:8: error: (kernel) declaration has metavariables 'addhshlhsdivhnegative0_thm'
[bv] [0.053977] Normalizing goal
  [Meta.synthInstance] [0.001356] âœ…ï¸ Decidable
        ((if (4#8 == 0 || 8 != 1 && xâœ == BitVec.intMin 8 && 4#8 == -1) = true then none
          else if 2#8 â‰¥ â†‘8 then none else some (xâœ.sdiv 4#8 <<< 2#8 + xâœ)) âŠ‘
          if (4#8 == 0 || 8 != 1 && xâœ == BitVec.intMin 8 && 4#8 == -1) = true then none
          else
            if True âˆ§ (xâœ.sdiv 4#8 <<< 2#8).sshiftRight (2#8).toNat = xâœ.sdiv 4#8 then none
            else if 2#8 â‰¥ â†‘8 then none else some (xâœ.sdiv 4#8 <<< 2#8 + xâœ))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 8
      xâœ : BitVec 8
      aâœ :
        Â¬(if (4#8 == 0 || 8 != 1 && xâœ == BitVec.intMin 8 && 4#8 == -1) = true then none
            else if 2#8 â‰¥ â†‘8 then none else some (xâœ.sdiv 4#8 <<< 2#8 + xâœ)) âŠ‘
            if (4#8 == 0 || 8 != 1 && xâœ == BitVec.intMin 8 && 4#8 == -1) = true then none
            else
              if True âˆ§ (xâœ.sdiv 4#8 <<< 2#8).sshiftRight (2#8).toNat = xâœ.sdiv 4#8 then none
              else if 2#8 â‰¥ â†‘8 then none else some (xâœ.sdiv 4#8 <<< 2#8 + xâœ)
      âŠ¢ False
  [Meta.isDefEq] [0.005875] âœ…ï¸ ?hâ‚ƒ =?= fun a =>
        Eq.trans
          (ite_cond_eq_false none (some (xâœ.sdiv 4#8 <<< 2#8 + xâœ))
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
                (Eq.trans (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                  Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
          (congrArg (fun x => some (x <<< 2#8 + xâœ))
            (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv xâœ 4#8)
              (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last xâœ))
                (fun a =>
                  Eq.trans
                    (ite_cond_eq_false (-xâœ / -4#8) (-(-xâœ / 4#8))
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 4#8))
                        (eq_false' fun h => Bool.noConfusion h)))
                    (Eq.trans (congrArg (fun x => -(x / 4#8)) (BitVec.neg_eq_not_add xâœ))
                      (BitVec.neg_eq_not_add ((~~~xâœ + 1#8) / 4#8))))
                fun a =>
                ite_cond_eq_false (-(xâœ / -4#8)) (xâœ / 4#8)
                  (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 4#8))
                    (eq_false' fun h => Bool.noConfusion h)))))
    [Meta.isDefEq.assign] [0.005872] âœ…ï¸ ?hâ‚ƒ := fun a =>
          Eq.trans
            (ite_cond_eq_false none (some (xâœ.sdiv 4#8 <<< 2#8 + xâœ))
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
                  (Eq.trans
                    (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                    Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
            (congrArg (fun x => some (x <<< 2#8 + xâœ))
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv xâœ 4#8)
                (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last xâœ))
                  (fun a =>
                    Eq.trans
                      (ite_cond_eq_false (-xâœ / -4#8) (-(-xâœ / 4#8))
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 4#8))
                          (eq_false' fun h => Bool.noConfusion h)))
                      (Eq.trans (congrArg (fun x => -(x / 4#8)) (BitVec.neg_eq_not_add xâœ))
                        (BitVec.neg_eq_not_add ((~~~xâœ + 1#8) / 4#8))))
                  fun a =>
                  ite_cond_eq_false (-(xâœ / -4#8)) (xâœ / 4#8)
                    (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 4#8))
                      (eq_false' fun h => Bool.noConfusion h)))))
      [Meta.isDefEq.assign.checkTypes] [0.005830] âœ…ï¸ (?hâ‚ƒ : Â¬(((if xâœ.getLsbD 7 = true then
                          ~~~((~~~xâœ + 1#8) / 4#8) + 1#8
                        else xâœ / 4#8) <<<
                        2).sshiftRight
                    2 ==
                  if xâœ.getLsbD 7 = true then ~~~((~~~xâœ + 1#8) / 4#8) + 1#8 else xâœ / 4#8) =
                true â†’
            (if 2#8 â‰¥ â†‘8 then none else some (xâœ.sdiv 4#8 <<< 2#8 + xâœ)) =
              some
                ((if xâœ.getLsbD 7 = true then ~~~((~~~xâœ + 1#8) / 4#8) + 1#8 else xâœ / 4#8) <<< 2 +
                  xâœ)) := (fun a =>
            Eq.trans
              (ite_cond_eq_false none (some (xâœ.sdiv 4#8 <<< 2#8 + xâœ))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 8#8 2#8)
                    (Eq.trans
                      (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 2#8 8#8) (eq_self true)))
                      Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
              (congrArg (fun x => some (x <<< 2#8 + xâœ))
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv xâœ 4#8)
                  (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last xâœ))
                    (fun a =>
                      Eq.trans
                        (ite_cond_eq_false (-xâœ / -4#8) (-(-xâœ / 4#8))
                          (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 4#8))
                            (eq_false' fun h => Bool.noConfusion h)))
                        (Eq.trans (congrArg (fun x => -(x / 4#8)) (BitVec.neg_eq_not_add xâœ))
                          (BitVec.neg_eq_not_add ((~~~xâœ + 1#8) / 4#8))))
                    fun a =>
                    ite_cond_eq_false (-(xâœ / -4#8)) (xâœ / 4#8)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 4#8))
                        (eq_false' fun h =>
                          Bool.noConfusion
                            h))))) : Â¬(((if xâœ.getLsbD 7 = true then ~~~((~~~xâœ + 1#8) / 4#8) + 1#8 else xâœ / 4#8) <<<
                        2).sshiftRight
                    2 ==
                  if xâœ.getLsbD 7 = true then ~~~((~~~xâœ + 1#8) / 4#8) + 1#8 else xâœ / 4#8) =
                true â†’
            (if 2#8 â‰¥ â†‘8 then none else some (xâœ.sdiv 4#8 <<< 2#8 + xâœ)) =
              some ((if xâœ.getLsbD 7 = true then ~~~((~~~xâœ + 1#8) / 4#8) + 1#8 else xâœ / 4#8) <<< 2#8 + xâœ))
        [Meta.isDefEq] [0.005825] âœ…ï¸ Â¬(((if xâœ.getLsbD 7 = true then ~~~((~~~xâœ + 1#8) / 4#8) + 1#8 else xâœ / 4#8) <<<
                          2).sshiftRight
                      2 ==
                    if xâœ.getLsbD 7 = true then ~~~((~~~xâœ + 1#8) / 4#8) + 1#8 else xâœ / 4#8) =
                  true â†’
              (if 2#8 â‰¥ â†‘8 then none else some (xâœ.sdiv 4#8 <<< 2#8 + xâœ)) =
                some
                  ((if xâœ.getLsbD 7 = true then ~~~((~~~xâœ + 1#8) / 4#8) + 1#8 else xâœ / 4#8) <<< 2 +
                    xâœ) =?= Â¬(((if xâœ.getLsbD 7 = true then ~~~((~~~xâœ + 1#8) / 4#8) + 1#8 else xâœ / 4#8) <<<
                          2).sshiftRight
                      2 ==
                    if xâœ.getLsbD 7 = true then ~~~((~~~xâœ + 1#8) / 4#8) + 1#8 else xâœ / 4#8) =
                  true â†’
              (if 2#8 â‰¥ â†‘8 then none else some (xâœ.sdiv 4#8 <<< 2#8 + xâœ)) =
                some ((if xâœ.getLsbD 7 = true then ~~~((~~~xâœ + 1#8) / 4#8) + 1#8 else xâœ / 4#8) <<< 2#8 + xâœ)
          [Meta.isDefEq] [0.005795] âœ…ï¸ (if 2#8 â‰¥ â†‘8 then none else some (xâœ.sdiv 4#8 <<< 2#8 + xâœ)) =
                some
                  ((if xâœ.getLsbD 7 = true then ~~~((~~~xâœ + 1#8) / 4#8) + 1#8 else xâœ / 4#8) <<< 2 +
                    xâœ) =?= (if 2#8 â‰¥ â†‘8 then none else some (xâœ.sdiv 4#8 <<< 2#8 + xâœ)) =
                some ((if xâœ.getLsbD 7 = true then ~~~((~~~xâœ + 1#8) / 4#8) + 1#8 else xâœ / 4#8) <<< 2#8 + xâœ)
            [Meta.isDefEq] [0.005773] âœ…ï¸ some
                  ((if xâœ.getLsbD 7 = true then ~~~((~~~xâœ + 1#8) / 4#8) + 1#8 else xâœ / 4#8) <<< 2 +
                    xâœ) =?= some
                  ((if xâœ.getLsbD 7 = true then ~~~((~~~xâœ + 1#8) / 4#8) + 1#8 else xâœ / 4#8) <<< 2#8 + xâœ)
              [Meta.isDefEq] [0.005750] âœ…ï¸ (if xâœ.getLsbD 7 = true then ~~~((~~~xâœ + 1#8) / 4#8) + 1#8
                      else xâœ / 4#8) <<<
                      2 +
                    xâœ =?= (if xâœ.getLsbD 7 = true then ~~~((~~~xâœ + 1#8) / 4#8) + 1#8 else xâœ / 4#8) <<< 2#8 + xâœ
                [Meta.isDefEq] [0.005635] âœ…ï¸ instHAdd.1
                      ((if xâœ.getLsbD 7 = true then ~~~((~~~xâœ + 1#8) / 4#8) + 1#8 else xâœ / 4#8) <<< 2)
                      xâœ =?= instHAdd.1
                      ((if xâœ.getLsbD 7 = true then ~~~((~~~xâœ + 1#8) / 4#8) + 1#8 else xâœ / 4#8) <<< 2#8) xâœ
                  [Meta.isDefEq] [0.005579] âœ…ï¸ Add.add
                        ((if xâœ.getLsbD 7 = true then ~~~((~~~xâœ + 1#8) / 4#8) + 1#8 else xâœ / 4#8) <<< 2)
                        xâœ =?= Add.add
                        ((if xâœ.getLsbD 7 = true then ~~~((~~~xâœ + 1#8) / 4#8) + 1#8 else xâœ / 4#8) <<< 2#8) xâœ
                    [Meta.isDefEq] [0.005095] âŒï¸ BitVec.instAdd =?= instAddNat
                      [Meta.isDefEq] [0.005041] âŒï¸ { add := BitVec.add } =?= instAddNat
                        [Meta.isDefEq] [0.001769] âŒï¸ { add := BitVec.add } =?= { add := Nat.add }
                          [Meta.isDefEq] [0.001690] âŒï¸ BitVec.add =?= Nat.add
                            [Meta.isDefEq.onFailure] [0.001649] âŒï¸ BitVec.add =?= Nat.add
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 8
      xâœ : BitVec 8
      aâœ :
        Â¬some ((if xâœ.getLsbD 7 = true then ~~~((~~~xâœ + 1#8) / 4#8) + 1#8 else xâœ / 4#8) <<< 2 + xâœ) âŠ‘
            if
                (((if xâœ.getLsbD 7 = true then ~~~((~~~xâœ + 1#8) / 4#8) + 1#8 else xâœ / 4#8) <<< 2).sshiftRight 2 ==
                    if xâœ.getLsbD 7 = true then ~~~((~~~xâœ + 1#8) / 4#8) + 1#8 else xâœ / 4#8) =
                  true then
              none
            else some ((if xâœ.getLsbD 7 = true then ~~~((~~~xâœ + 1#8) / 4#8) + 1#8 else xâœ / 4#8) <<< 2 + xâœ)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddhshlhsdivhtohsrem_proof.lean:58:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddhshlhsdivhtohsrem_proof.lean:52:8: error: (kernel) declaration has metavariables 'addhshlhsdivhnegative1_thm'
[bv] [0.143729] Normalizing goal
  [Meta.synthInstance] [0.002121] âœ…ï¸ Decidable
        ((if (-1#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && -1#32 == -1) = true then none
          else if 1#32 â‰¥ â†‘32 then none else some (xâœ.sdiv (-1#32) <<< 1#32 + xâœ)) âŠ‘
          some (0#32 - xâœ))
    [Meta.check] [0.001141] âœ…ï¸ BitVec.Refinement.instDecidableRelOptionOfDecidableEq
          (if (-1#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && -1#32 == -1) = true then none
          else if 1#32 â‰¥ â†‘32 then none else some (xâœ.sdiv (-1#32) <<< 1#32 + xâœ))
          (some (0#32 - xâœ))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(if (-1#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && -1#32 == -1) = true then none
            else if 1#32 â‰¥ â†‘32 then none else some (xâœ.sdiv (-1#32) <<< 1#32 + xâœ)) âŠ‘
            some (0#32 - xâœ)
      âŠ¢ False
  [Meta.isDefEq] [0.003103] âœ…ï¸ ?hâ‚ =?= congrArg (fun x => x = true)
        (Eq.trans
          (Eq.trans
            (congrArg false.or
              (Eq.trans
                (congr (congrArg Bool.and (Bool.true_and (xâœ == BitVec.intMin 32))) (beq_self_eq_true' 4294967295#32))
                (Bool.and_true (xâœ == BitVec.intMin 32))))
            (Std.Tactic.BVDecide.Normalize.Bool.or_elim false (xâœ == BitVec.intMin 32)))
          (Eq.trans
            (congrArg not
              (Eq.trans (congrArg (fun x => x && !xâœ == BitVec.intMin 32) Bool.not_false)
                (Bool.true_and !xâœ == BitVec.intMin 32)))
            (Bool.not_not (xâœ == BitVec.intMin 32))))
    [Meta.isDefEq.assign] [0.003099] âœ…ï¸ ?hâ‚ := congrArg (fun x => x = true)
          (Eq.trans
            (Eq.trans
              (congrArg false.or
                (Eq.trans
                  (congr (congrArg Bool.and (Bool.true_and (xâœ == BitVec.intMin 32))) (beq_self_eq_true' 4294967295#32))
                  (Bool.and_true (xâœ == BitVec.intMin 32))))
              (Std.Tactic.BVDecide.Normalize.Bool.or_elim false (xâœ == BitVec.intMin 32)))
            (Eq.trans
              (congrArg not
                (Eq.trans (congrArg (fun x => x && !xâœ == BitVec.intMin 32) Bool.not_false)
                  (Bool.true_and !xâœ == BitVec.intMin 32)))
              (Bool.not_not (xâœ == BitVec.intMin 32))))
      [Meta.isDefEq.assign.checkTypes] [0.003075] âœ…ï¸ (?hâ‚ : ((-1#32 == 0 ||
                32 != 1 && xâœ == BitVec.intMin 32 && -1#32 == -1) =
              true) =
            ((xâœ == BitVec.intMin 32) =
              true)) := (congrArg (fun x => x = true)
            (Eq.trans
              (Eq.trans
                (congrArg false.or
                  (Eq.trans
                    (congr (congrArg Bool.and (Bool.true_and (xâœ == BitVec.intMin 32)))
                      (beq_self_eq_true' 4294967295#32))
                    (Bool.and_true (xâœ == BitVec.intMin 32))))
                (Std.Tactic.BVDecide.Normalize.Bool.or_elim false (xâœ == BitVec.intMin 32)))
              (Eq.trans
                (congrArg not
                  (Eq.trans (congrArg (fun x => x && !xâœ == BitVec.intMin 32) Bool.not_false)
                    (Bool.true_and !xâœ == BitVec.intMin 32)))
                (Bool.not_not
                  (xâœ ==
                    BitVec.intMin
                      32)))) : ((false || true && xâœ == BitVec.intMin 32 && 4294967295#32 == 4294967295#32) = true) =
            ((xâœ == BitVec.intMin 32) = true))
        [Meta.isDefEq] [0.003069] âœ…ï¸ ((-1#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && -1#32 == -1) = true) =
              ((xâœ == BitVec.intMin 32) =
                true) =?= ((false || true && xâœ == BitVec.intMin 32 && 4294967295#32 == 4294967295#32) = true) =
              ((xâœ == BitVec.intMin 32) = true)
          [Meta.isDefEq] [0.003039] âœ…ï¸ (-1#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && -1#32 == -1) =
                true =?= (false || true && xâœ == BitVec.intMin 32 && 4294967295#32 == 4294967295#32) = true
            [Meta.isDefEq] [0.003015] âœ…ï¸ -1#32 == 0 ||
                  32 != 1 && xâœ == BitVec.intMin 32 &&
                    -1#32 == -1 =?= false || true && xâœ == BitVec.intMin 32 && 4294967295#32 == 4294967295#32
              [Meta.isDefEq.delta] [0.002993] âœ…ï¸ -1#32 == 0 ||
                    32 != 1 && xâœ == BitVec.intMin 32 &&
                      -1#32 == -1 =?= false || true && xâœ == BitVec.intMin 32 && 4294967295#32 == 4294967295#32
                [Meta.isDefEq] [0.001313] âœ…ï¸ -1#32 == 0 =?= false
                  [Meta.isDefEq] [0.001292] âœ…ï¸ instBEqOfDecidableEq.1 (-1#32) 0 =?= false
                    [Meta.isDefEq] [0.001240] âœ…ï¸ Decidable.decide (-1#32 = 0) =?= false
                      [Meta.isDefEq] [0.001214] âœ…ï¸ Decidable.casesOn (instDecidableEqBitVec (-1#32) 0) (fun x => false)
                            fun x => true =?= false
                        [Meta.whnf] [0.001169] Non-easy whnf: instDecidableEqBitVec (-1#32) 0
                          [Meta.whnf] [0.001160] Non-easy whnf: (-1#32).decEq 0
                            [Meta.whnf] [0.001129] Non-easy whnf: match -1#32, 0 with
                                | { toFin := n }, { toFin := m } => if h : n = m then isTrue â‹¯ else isFalse â‹¯
                [Meta.isDefEq] [0.001659] âœ…ï¸ 32 != 1 && xâœ == BitVec.intMin 32 &&
                      -1#32 == -1 =?= true && xâœ == BitVec.intMin 32 && 4294967295#32 == 4294967295#32
                  [Meta.isDefEq.delta] [0.001634] âœ…ï¸ 32 != 1 && xâœ == BitVec.intMin 32 &&
                        -1#32 == -1 =?= true && xâœ == BitVec.intMin 32 && 4294967295#32 == 4294967295#32
                    [Meta.isDefEq] [0.001277] âœ…ï¸ -1#32 == -1 =?= 4294967295#32 == 4294967295#32
                      [Meta.isDefEq] [0.001245] âœ…ï¸ instBEqOfDecidableEq.1 (-1#32)
                            (-1) =?= instBEqOfDecidableEq.1 4294967295#32 4294967295#32
                        [Meta.isDefEq] [0.001197] âœ…ï¸ Decidable.decide
                              (-1#32 = -1) =?= Decidable.decide (4294967295#32 = 4294967295#32)
                          [Meta.isDefEq.delta] [0.001175] âœ…ï¸ Decidable.decide
                                (-1#32 = -1) =?= Decidable.decide (4294967295#32 = 4294967295#32)
                            [Meta.isDefEq] [0.001013] âœ…ï¸ -1#32 = -1 =?= 4294967295#32 = 4294967295#32
  [Meta.isDefEq] [0.004996] âŒï¸ ?a + ?a =?= ~~~xâœ + 1#32
    [Meta.isDefEq] [0.002626] âŒï¸ instHAdd =?= instHAdd
      [Meta.isDefEq] [0.002376] âŒï¸ { hAdd := fun a b => Add.add a b } =?= { hAdd := fun a b => Add.add a b }
        [Meta.isDefEq] [0.002161] âŒï¸ fun a b => Add.add a b =?= fun a b => Add.add a b
    [Meta.isDefEq] [0.002120] âœ…ï¸ ?a =?= ~~~xâœ
      [Meta.isDefEq.assign] [0.002110] âœ…ï¸ ?a := ~~~xâœ
        [Meta.isDefEq.assign.checkTypes] [0.002092] âœ…ï¸ (?a : BitVec ?w) := (~~~xâœ : BitVec 32)
          [Meta.isDefEq] [0.002085] âœ…ï¸ BitVec ?w =?= BitVec 32
  [Meta.isDefEq] [0.002178] âœ…ï¸ ?hâ‚‚ =?= fun a =>
        Eq.trans
          (ite_cond_eq_true (-xâœ / -4294967295#32) (-(-xâœ / 4294967295#32))
            (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 4294967295#32)) (eq_self true)))
          (Eq.trans (congrArg (fun x => x / 1#32) (BitVec.neg_eq_not_add xâœ)) BitVec.udiv_one)
    [Meta.isDefEq.assign] [0.002172] âœ…ï¸ ?hâ‚‚ := fun a =>
          Eq.trans
            (ite_cond_eq_true (-xâœ / -4294967295#32) (-(-xâœ / 4294967295#32))
              (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 4294967295#32)) (eq_self true)))
            (Eq.trans (congrArg (fun x => x / 1#32) (BitVec.neg_eq_not_add xâœ)) BitVec.udiv_one)
      [Meta.isDefEq.assign.checkTypes] [0.002140] âœ…ï¸ (?hâ‚‚ : xâœ.getLsbD 31 = true â†’
            (if (4294967295#32).msb = true then -xâœ / -4294967295#32 else -(-xâœ / 4294967295#32)) =
              ~~~xâœ +
                1#32) := (fun a =>
            Eq.trans
              (ite_cond_eq_true (-xâœ / -4294967295#32) (-(-xâœ / 4294967295#32))
                (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 4294967295#32)) (eq_self true)))
              (Eq.trans (congrArg (fun x => x / 1#32) (BitVec.neg_eq_not_add xâœ))
                BitVec.udiv_one) : xâœ.getLsbD 31 = true â†’
            (if (4294967295#32).msb = true then -xâœ / -4294967295#32 else -(-xâœ / 4294967295#32)) = ~~~xâœ + 1#32)
  [Meta.appBuilder] [0.005149] âœ…ï¸ f: HAdd.hAdd, xs: [~~~xâœ, 1#32]
    [Meta.synthInstance] [0.005061] âœ…ï¸ HAdd (BitVec 32) (BitVec 32) (BitVec 32)
      [Meta.synthInstance] [0.002483] âœ…ï¸ apply @instHAdd to HAdd (BitVec 32) (BitVec 32) (BitVec 32)
  [Meta.synthInstance] [0.002602] âœ…ï¸ Decidable (xâœ.getLsbD 31 = true)
    [Meta.check] [0.002264] âœ…ï¸ instDecidableEqBool (xâœ.getLsbD 31) true
  [Meta.isDefEq] [0.009627] âœ…ï¸ ?hâ‚ƒ =?= fun a =>
        Eq.trans
          (ite_cond_eq_false none (some (xâœ.sdiv (-1#32) <<< 1#32 + xâœ))
            (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 32#32 1#32)
                (Eq.trans
                  (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 1#32 32#32) (eq_self true)))
                  Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
          (congrArg (fun x => some (x <<< 1#32 + xâœ))
            (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv xâœ 4294967295#32)
              (Eq.trans
                (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last xâœ))
                  (fun a =>
                    Eq.trans
                      (ite_cond_eq_true (-xâœ / -4294967295#32) (-(-xâœ / 4294967295#32))
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 4294967295#32))
                          (eq_self true)))
                      (Eq.trans (congrArg (fun x => x / 1#32) (BitVec.neg_eq_not_add xâœ)) BitVec.udiv_one))
                  fun a =>
                  Eq.trans
                    (ite_cond_eq_true (-(xâœ / -4294967295#32)) (xâœ / 4294967295#32)
                      (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 4294967295#32))
                        (eq_self true)))
                    (Eq.trans (congrArg Neg.neg BitVec.udiv_one) (BitVec.neg_eq_not_add xâœ)))
                (ite_self (~~~xâœ + 1#32)))))
    [Meta.isDefEq.assign] [0.009621] âœ…ï¸ ?hâ‚ƒ := fun a =>
          Eq.trans
            (ite_cond_eq_false none (some (xâœ.sdiv (-1#32) <<< 1#32 + xâœ))
              (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 32#32 1#32)
                  (Eq.trans
                    (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 1#32 32#32) (eq_self true)))
                    Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
            (congrArg (fun x => some (x <<< 1#32 + xâœ))
              (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv xâœ 4294967295#32)
                (Eq.trans
                  (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last xâœ))
                    (fun a =>
                      Eq.trans
                        (ite_cond_eq_true (-xâœ / -4294967295#32) (-(-xâœ / 4294967295#32))
                          (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 4294967295#32))
                            (eq_self true)))
                        (Eq.trans (congrArg (fun x => x / 1#32) (BitVec.neg_eq_not_add xâœ)) BitVec.udiv_one))
                    fun a =>
                    Eq.trans
                      (ite_cond_eq_true (-(xâœ / -4294967295#32)) (xâœ / 4294967295#32)
                        (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 4294967295#32))
                          (eq_self true)))
                      (Eq.trans (congrArg Neg.neg BitVec.udiv_one) (BitVec.neg_eq_not_add xâœ)))
                  (ite_self (~~~xâœ + 1#32)))))
      [Meta.isDefEq.assign.checkTypes] [0.009530] âœ…ï¸ (?hâ‚ƒ : Â¬(xâœ == BitVec.intMin 32) = true â†’
            (if 1#32 â‰¥ â†‘32 then none else some (xâœ.sdiv (-1#32) <<< 1#32 + xâœ)) =
              some
                ((~~~xâœ + 1#32) <<< 1 +
                  xâœ)) := (fun a =>
            Eq.trans
              (ite_cond_eq_false none (some (xâœ.sdiv (-1#32) <<< 1#32 + xâœ))
                (Eq.trans Std.Tactic.BVDecide.Normalize.BitVec._auxLemma.2
                  (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.le_ult 32#32 1#32)
                    (Eq.trans
                      (congrArg Not (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.lt_ult 1#32 32#32) (eq_self true)))
                      Std.Tactic.BVDecide.Normalize.Prop._auxLemma.2))))
              (congrArg (fun x => some (x <<< 1#32 + xâœ))
                (Eq.trans (Std.Tactic.BVDecide.Normalize.BitVec.sdiv_udiv xâœ 4294967295#32)
                  (Eq.trans
                    (ite_congr (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last xâœ))
                      (fun a =>
                        Eq.trans
                          (ite_cond_eq_true (-xâœ / -4294967295#32) (-(-xâœ / 4294967295#32))
                            (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 4294967295#32))
                              (eq_self true)))
                          (Eq.trans (congrArg (fun x => x / 1#32) (BitVec.neg_eq_not_add xâœ)) BitVec.udiv_one))
                      fun a =>
                      Eq.trans
                        (ite_cond_eq_true (-(xâœ / -4294967295#32)) (xâœ / 4294967295#32)
                          (Eq.trans (congrArg (fun x => x = true) (BitVec.msb_eq_getLsbD_last 4294967295#32))
                            (eq_self true)))
                        (Eq.trans (congrArg Neg.neg BitVec.udiv_one) (BitVec.neg_eq_not_add xâœ)))
                    (ite_self
                      (~~~xâœ +
                        1#32))))) : Â¬(xâœ == BitVec.intMin 32) = true â†’
            (if 1#32 â‰¥ â†‘32 then none else some (xâœ.sdiv (-1#32) <<< 1#32 + xâœ)) = some ((~~~xâœ + 1#32) <<< 1#32 + xâœ))
        [Meta.isDefEq] [0.009525] âœ…ï¸ Â¬(xâœ == BitVec.intMin 32) = true â†’
              (if 1#32 â‰¥ â†‘32 then none else some (xâœ.sdiv (-1#32) <<< 1#32 + xâœ)) =
                some
                  ((~~~xâœ + 1#32) <<< 1 +
                    xâœ) =?= Â¬(xâœ == BitVec.intMin 32) = true â†’
              (if 1#32 â‰¥ â†‘32 then none else some (xâœ.sdiv (-1#32) <<< 1#32 + xâœ)) = some ((~~~xâœ + 1#32) <<< 1#32 + xâœ)
          [Meta.isDefEq] [0.009487] âœ…ï¸ (if 1#32 â‰¥ â†‘32 then none else some (xâœ.sdiv (-1#32) <<< 1#32 + xâœ)) =
                some
                  ((~~~xâœ + 1#32) <<< 1 +
                    xâœ) =?= (if 1#32 â‰¥ â†‘32 then none else some (xâœ.sdiv (-1#32) <<< 1#32 + xâœ)) =
                some ((~~~xâœ + 1#32) <<< 1#32 + xâœ)
            [Meta.isDefEq] [0.009460] âœ…ï¸ some ((~~~xâœ + 1#32) <<< 1 + xâœ) =?= some ((~~~xâœ + 1#32) <<< 1#32 + xâœ)
              [Meta.isDefEq] [0.009433] âœ…ï¸ (~~~xâœ + 1#32) <<< 1 + xâœ =?= (~~~xâœ + 1#32) <<< 1#32 + xâœ
                [Meta.isDefEq] [0.009310] âœ…ï¸ instHAdd.1 ((~~~xâœ + 1#32) <<< 1)
                      xâœ =?= instHAdd.1 ((~~~xâœ + 1#32) <<< 1#32) xâœ
                  [Meta.isDefEq] [0.009245] âœ…ï¸ Add.add ((~~~xâœ + 1#32) <<< 1)
                        xâœ =?= Add.add ((~~~xâœ + 1#32) <<< 1#32) xâœ
                    [Meta.isDefEq] [0.006520] âŒï¸ BitVec.instAdd =?= instAddNat
                      [Meta.isDefEq] [0.004344] âŒï¸ { add := BitVec.add } =?= instAddNat
                        [Meta.isDefEq] [0.002327] âŒï¸ { add := BitVec.add } =?= { add := Nat.add }
                          [Meta.isDefEq] [0.002230] âŒï¸ BitVec.add =?= Nat.add
                            [Meta.isDefEq.onFailure] [0.002174] âŒï¸ BitVec.add =?= Nat.add
                    [Meta.isDefEq] [0.002673] âœ…ï¸ BitVec.instAdd.1 ((~~~xâœ + 1#32) <<< 1)
                          xâœ =?= BitVec.instAdd.1 ((~~~xâœ + 1#32) <<< 1#32) xâœ
                      [Meta.isDefEq] [0.002617] âœ…ï¸ ((~~~xâœ + 1#32) <<< 1).add xâœ =?= ((~~~xâœ + 1#32) <<< 1#32).add xâœ
                        [Meta.isDefEq.delta] [0.002600] âœ…ï¸ ((~~~xâœ + 1#32) <<< 1).add
                              xâœ =?= ((~~~xâœ + 1#32) <<< 1#32).add xâœ
                          [Meta.isDefEq] [0.002552] âœ…ï¸ (~~~xâœ + 1#32) <<< 1 =?= (~~~xâœ + 1#32) <<< 1#32
                            [Meta.isDefEq] [0.002480] âœ…ï¸ BitVec.instHShiftLeftNat.1 (~~~xâœ + 1#32)
                                  1 =?= BitVec.instHShiftLeft.1 (~~~xâœ + 1#32) 1#32
                              [Meta.whnf] [0.002008] Non-easy whnf: HShiftLeft (BitVec 32) â„• (BitVec 32)
  [Meta.synthInstance] [0.002318] âœ…ï¸ Decidable ((xâœ == BitVec.intMin 32) = true)
  [Meta.appBuilder] [0.002339] âœ…ï¸ f: Subsingleton.elim, xs: [hâœ, h]
    [Meta.isDefEq] [0.002047] âœ…ï¸ ?Î± =?= Decidable câœ
      [Meta.isDefEq.assign] [0.002040] âœ…ï¸ ?Î± := Decidable câœ
        [Meta.isDefEq.assign.checkTypes] [0.002027] âœ…ï¸ (?Î± : Sort ?u.65128) := (Decidable câœ : Type)
  [Meta.isDefEq] [0.004444] âŒï¸ ?a + (~~~?a + 1#?w) =?= 0#32 + (~~~xâœ + 1#32)
    [Meta.isDefEq] [0.002217] âŒï¸ instHAdd =?= instHAdd
      [Meta.isDefEq] [0.002146] âŒï¸ { hAdd := fun a b => Add.add a b } =?= { hAdd := fun a b => Add.add a b }
    [Meta.isDefEq] [0.002080] âŒï¸ ~~~0#32 + 1#32 =?= ~~~xâœ + 1#32
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ : Â¬(if (xâœ == BitVec.intMin 32) = true then none else some ((~~~xâœ + 1#32) <<< 1 + xâœ)) âŠ‘ some (~~~xâœ + 1#32)
      âŠ¢ False
  [Meta.isDefEq] [0.006558] âŒï¸ ?a == ?a =?= xâœ == BitVec.intMin 32
    [Meta.isDefEq.onFailure] [0.006131] âŒï¸ ?a == ?a =?= xâœ == BitVec.intMin 32
      [Meta.synthInstance] [0.006089] ğŸ’¥ï¸ BEq ?Î±
        [Meta.synthInstance] [0.002070] ğŸ’¥ï¸ apply Nat.Linear.instBEqPolyCnstr to BEq ?Î±
          [Meta.synthInstance.tryResolve] [0.002035] ğŸ’¥ï¸ BEq ?Î± â‰Ÿ BEq Nat.Linear.PolyCnstr
            [Meta.isDefEq] [0.002026] ğŸ’¥ï¸ BEq ?Î± =?= BEq Nat.Linear.PolyCnstr
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddhshlhsdivhtohsrem_proof.lean:69:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gaddhshlhsdivhtohsrem_proof.lean:62:8: error: (kernel) declaration has metavariables 'addhshlhsdivhnegative2_thm'
[bv] [0.057614] Normalizing goal
  [Meta.synthInstance] [0.001542] âœ…ï¸ Decidable
        ((if (2147483648#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 2147483648#32 == -1) = true then none
          else if 31#32 â‰¥ â†‘32 then none else some (xâœ.sdiv 2147483648#32 <<< 31#32 + xâœ)) âŠ‘
          Option.bind
            (match some (BitVec.ofBool (xâœ == 2147483648#32)) with
            | none => none
            | some { toFin := âŸ¨1, â‹¯âŸ© } => some 2147483648#32
            | some { toFin := âŸ¨0, â‹¯âŸ© } => some 0#32)
            fun x' => some (x' + xâœ))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬(if (2147483648#32 == 0 || 32 != 1 && xâœ == BitVec.intMin 32 && 2147483648#32 == -1) = true then none
            else if 31#32 â‰¥ â†‘32 then none else some (xâœ.sdiv 2147483648#32 <<< 31#32 + xâœ)) âŠ‘
            Option.bind
              (match some (BitVec.ofBool (xâœ == 2147483648#32)) with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some 2147483648#32
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some 0#32)
              fun x' => some (x' + xâœ)
      âŠ¢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      xâœ : BitVec 32
      aâœ :
        Â¬some
              ((if xâœ.getLsbD 31 = true then (~~~xâœ + 1#32) / 2147483648#32 else ~~~(xâœ / 2147483648#32) + 1#32) <<<
                  31 +
                xâœ) âŠ‘
            Option.bind
              (match some (if (xâœ == 2147483648#32) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := âŸ¨1, â‹¯âŸ© } => some 2147483648#32
              | some { toFin := âŸ¨0, â‹¯âŸ© } => some 0#32)
              fun a => some (a + xâœ)
      âŠ¢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
