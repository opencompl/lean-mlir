⚠ [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
⚠ [878/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [881/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
⚠ [887/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
⚠ [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:19:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:11:8: error: (kernel) declaration has metavariables 'foo_thm'
[bv] [0.048059] Normalizing goal
  [Meta.synthInstance] [0.002431] ✅️ Decidable
        (some
            (x✝ &&& BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) |||
              x✝³ &&& (BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) ^^^ -1#32)) ⊑
          match some (BitVec.ofBool (x✝² >ₛ x✝¹)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝
          | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬some
              (x✝ &&& BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) |||
                x✝³ &&& (BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) ^^^ -1#32)) ⊑
            match some (BitVec.ofBool (x✝² >ₛ x✝¹)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝
            | some { toFin := ⟨0, ⋯⟩ } => some x✝³
      ⊢ False
  [Meta.appBuilder] [0.001266] ✅️ f: Eq.mp, xs: [congrArg Not
         (congr
           (congrArg (fun x => BitVec.Refinement (some x))
             (congr
               (congrArg (fun x => HOr.hOr (x✝ &&& BitVec.signExtend 32 x))
                 (Eq.trans
                   (congrArg BitVec.ofBool
                     (Eq.trans (BitVec.slt_eq_ult x✝¹ x✝²)
                       (Eq.trans
                         (congrArg (fun x => x ^^ x✝² >ᵤ x✝¹)
                           (Eq.trans
                             (congr (congrArg bne (BitVec.msb_eq_getLsbD_last x✝¹)) (BitVec.msb_eq_getLsbD_last x✝²))
                             (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (x✝¹.getLsbD 31) (x✝².getLsbD 31))))
                         (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (!x✝¹.getLsbD 31 == x✝².getLsbD 31)
                           (x✝² >ᵤ x✝¹)))))
                   (Std.Tactic.BVDecide.Normalize.BitVec.ofBool_eq_if
                     !(!x✝¹.getLsbD 31 == x✝².getLsbD 31) == (x✝² >ᵤ x✝¹))))
               (congrArg (fun x => x✝³ &&& (BitVec.signExtend 32 x ^^^ 4294967295#32))
                 (Eq.trans
                   (congrArg BitVec.ofBool
                     (Eq.trans (BitVec.slt_eq_ult x✝¹ x✝²)
                       (Eq.trans
                         (congrArg (fun x => x ^^ x✝² >ᵤ x✝¹)
                           (Eq.trans
                             (congr (congrArg bne (BitVec.msb_eq_getLsbD_last x✝¹)) (BitVec.msb_eq_getLsbD_last x✝²))
                             (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (x✝¹.getLsbD 31) (x✝².getLsbD 31))))
                         (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (!x✝¹.getLsbD 31 == x✝².getLsbD 31)
                           (x✝² >ᵤ x✝¹)))))
                   (Std.Tactic.BVDecide.Normalize.BitVec.ofBool_eq_if
                     !(!x✝¹.getLsbD 31 == x✝².getLsbD 31) == (x✝² >ᵤ x✝¹))))))
           (congrArg
             (fun x =>
               match some x with
               | none => none
               | some { toFin := ⟨1, .(Fin.ofNat'.proof_1 (2 ^ 1) 1)⟩ } => some x✝
               | some { toFin := ⟨0, .(Fin.ofNat'.proof_1 (2 ^ 1) 0)⟩ } => some x✝³)
             (Eq.trans
               (congrArg BitVec.ofBool
                 (Eq.trans (BitVec.slt_eq_ult x✝¹ x✝²)
                   (Eq.trans
                     (congrArg (fun x => x ^^ x✝² >ᵤ x✝¹)
                       (Eq.trans
                         (congr (congrArg bne (BitVec.msb_eq_getLsbD_last x✝¹)) (BitVec.msb_eq_getLsbD_last x✝²))
                         (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (x✝¹.getLsbD 31) (x✝².getLsbD 31))))
                     (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (!x✝¹.getLsbD 31 == x✝².getLsbD 31) (x✝² >ᵤ x✝¹)))))
               (Std.Tactic.BVDecide.Normalize.BitVec.ofBool_eq_if
                 !(!x✝¹.getLsbD 31 == x✝².getLsbD 31) == (x✝² >ᵤ x✝¹))))),
       a✝]
    [Meta.isDefEq] [0.001139] ✅️ ¬some
              (x✝ &&& BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) |||
                x✝³ &&& (BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) ^^^ 4294967295#32)) ⊑
            match some (BitVec.ofBool (x✝² >ₛ x✝¹)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝
            | some { toFin := ⟨0, ⋯⟩ } =>
              some
                x✝³ =?= ¬some
              (x✝ &&& BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) |||
                x✝³ &&& (BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) ^^^ -1#32)) ⊑
            match some (BitVec.ofBool (x✝² >ₛ x✝¹)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝
            | some { toFin := ⟨0, ⋯⟩ } => some x✝³
      [Meta.isDefEq] [0.001131] ✅️ ¬some
                (x✝ &&& BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) |||
                  x✝³ &&& (BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) ^^^ 4294967295#32)) ⊑
              match some (BitVec.ofBool (x✝² >ₛ x✝¹)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝
              | some { toFin := ⟨0, ⋯⟩ } =>
                some
                  x✝³ =?= ¬some
                (x✝ &&& BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) |||
                  x✝³ &&& (BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) ^^^ -1#32)) ⊑
              match some (BitVec.ofBool (x✝² >ₛ x✝¹)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝
              | some { toFin := ⟨0, ⋯⟩ } => some x✝³
        [Meta.isDefEq.delta] [0.001118] ✅️ ¬some
                  (x✝ &&& BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) |||
                    x✝³ &&& (BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) ^^^ 4294967295#32)) ⊑
                match some (BitVec.ofBool (x✝² >ₛ x✝¹)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝
                | some { toFin := ⟨0, ⋯⟩ } =>
                  some
                    x✝³ =?= ¬some
                  (x✝ &&& BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) |||
                    x✝³ &&& (BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) ^^^ -1#32)) ⊑
                match some (BitVec.ofBool (x✝² >ₛ x✝¹)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³
          [Meta.isDefEq] [0.001115] ✅️ some
                  (x✝ &&& BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) |||
                    x✝³ &&& (BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) ^^^ 4294967295#32)) ⊑
                match some (BitVec.ofBool (x✝² >ₛ x✝¹)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝
                | some { toFin := ⟨0, ⋯⟩ } =>
                  some
                    x✝³ =?= some
                  (x✝ &&& BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) |||
                    x✝³ &&& (BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) ^^^ -1#32)) ⊑
                match some (BitVec.ofBool (x✝² >ₛ x✝¹)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³
            [Meta.isDefEq] [0.001085] ✅️ some
                  (x✝ &&& BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) |||
                    x✝³ &&&
                      (BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) ^^^
                        4294967295#32)) =?= some
                  (x✝ &&& BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) |||
                    x✝³ &&& (BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) ^^^ -1#32))
              [Meta.isDefEq] [0.001068] ✅️ x✝ &&& BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) |||
                    x✝³ &&&
                      (BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) ^^^
                        4294967295#32) =?= x✝ &&& BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) |||
                    x✝³ &&& (BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) ^^^ -1#32)
                [Meta.isDefEq] [0.001037] ✅️ instHOrOfOrOp.1 (x✝ &&& BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)))
                      (x✝³ &&&
                        (BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) ^^^
                          4294967295#32)) =?= instHOrOfOrOp.1 (x✝ &&& BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)))
                      (x✝³ &&& (BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) ^^^ -1#32))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬some
              (x✝ &&&
                  BitVec.signExtend 32
                    (if (!(!x✝¹.getLsbD 31 == x✝².getLsbD 31) == (x✝² >ᵤ x✝¹)) = true then 1#1 else 0#1) |||
                x✝³ &&&
                  (BitVec.signExtend 32
                      (if (!(!x✝¹.getLsbD 31 == x✝².getLsbD 31) == (x✝² >ᵤ x✝¹)) = true then 1#1 else 0#1) ^^^
                    4294967295#32)) ⊑
            match some (if (!(!x✝¹.getLsbD 31 == x✝².getLsbD 31) == (x✝² >ᵤ x✝¹)) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝
            | some { toFin := ⟨0, ⋯⟩ } => some x✝³
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:31:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:23:8: error: (kernel) declaration has metavariables 'bar_thm'
[bv] [0.038331] Normalizing goal
  [Meta.synthInstance] [0.001457] ✅️ Decidable
        (some
            (x✝ &&& (BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) ^^^ -1#32) |||
              x✝³ &&& BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹))) ⊑
          match some (BitVec.ofBool (x✝² >ₛ x✝¹)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝³
          | some { toFin := ⟨0, ⋯⟩ } => some x✝)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬some
              (x✝ &&& (BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) ^^^ -1#32) |||
                x✝³ &&& BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹))) ⊑
            match some (BitVec.ofBool (x✝² >ₛ x✝¹)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝³
            | some { toFin := ⟨0, ⋯⟩ } => some x✝
      ⊢ False
  [Meta.appBuilder] [0.001191] ✅️ f: Eq.mp, xs: [congrArg Not
         (congr
           (congrArg (fun x => BitVec.Refinement (some x))
             (congr
               (congrArg (fun x => HOr.hOr (x✝ &&& (BitVec.signExtend 32 x ^^^ 4294967295#32)))
                 (Eq.trans
                   (congrArg BitVec.ofBool
                     (Eq.trans (BitVec.slt_eq_ult x✝¹ x✝²)
                       (Eq.trans
                         (congrArg (fun x => x ^^ x✝² >ᵤ x✝¹)
                           (Eq.trans
                             (congr (congrArg bne (BitVec.msb_eq_getLsbD_last x✝¹)) (BitVec.msb_eq_getLsbD_last x✝²))
                             (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (x✝¹.getLsbD 31) (x✝².getLsbD 31))))
                         (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (!x✝¹.getLsbD 31 == x✝².getLsbD 31)
                           (x✝² >ᵤ x✝¹)))))
                   (Std.Tactic.BVDecide.Normalize.BitVec.ofBool_eq_if
                     !(!x✝¹.getLsbD 31 == x✝².getLsbD 31) == (x✝² >ᵤ x✝¹))))
               (congrArg (fun x => x✝³ &&& BitVec.signExtend 32 x)
                 (Eq.trans
                   (congrArg BitVec.ofBool
                     (Eq.trans (BitVec.slt_eq_ult x✝¹ x✝²)
                       (Eq.trans
                         (congrArg (fun x => x ^^ x✝² >ᵤ x✝¹)
                           (Eq.trans
                             (congr (congrArg bne (BitVec.msb_eq_getLsbD_last x✝¹)) (BitVec.msb_eq_getLsbD_last x✝²))
                             (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (x✝¹.getLsbD 31) (x✝².getLsbD 31))))
                         (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (!x✝¹.getLsbD 31 == x✝².getLsbD 31)
                           (x✝² >ᵤ x✝¹)))))
                   (Std.Tactic.BVDecide.Normalize.BitVec.ofBool_eq_if
                     !(!x✝¹.getLsbD 31 == x✝².getLsbD 31) == (x✝² >ᵤ x✝¹))))))
           (congrArg
             (fun x =>
               match some x with
               | none => none
               | some { toFin := ⟨1, .(Fin.ofNat'.proof_1 (2 ^ 1) 1)⟩ } => some x✝³
               | some { toFin := ⟨0, .(Fin.ofNat'.proof_1 (2 ^ 1) 0)⟩ } => some x✝)
             (Eq.trans
               (congrArg BitVec.ofBool
                 (Eq.trans (BitVec.slt_eq_ult x✝¹ x✝²)
                   (Eq.trans
                     (congrArg (fun x => x ^^ x✝² >ᵤ x✝¹)
                       (Eq.trans
                         (congr (congrArg bne (BitVec.msb_eq_getLsbD_last x✝¹)) (BitVec.msb_eq_getLsbD_last x✝²))
                         (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (x✝¹.getLsbD 31) (x✝².getLsbD 31))))
                     (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (!x✝¹.getLsbD 31 == x✝².getLsbD 31) (x✝² >ᵤ x✝¹)))))
               (Std.Tactic.BVDecide.Normalize.BitVec.ofBool_eq_if
                 !(!x✝¹.getLsbD 31 == x✝².getLsbD 31) == (x✝² >ᵤ x✝¹))))),
       a✝]
    [Meta.isDefEq] [0.001073] ✅️ ¬some
              (x✝ &&& (BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) ^^^ 4294967295#32) |||
                x✝³ &&& BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹))) ⊑
            match some (BitVec.ofBool (x✝² >ₛ x✝¹)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝³
            | some { toFin := ⟨0, ⋯⟩ } =>
              some
                x✝ =?= ¬some
              (x✝ &&& (BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) ^^^ -1#32) |||
                x✝³ &&& BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹))) ⊑
            match some (BitVec.ofBool (x✝² >ₛ x✝¹)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝³
            | some { toFin := ⟨0, ⋯⟩ } => some x✝
      [Meta.isDefEq] [0.001064] ✅️ ¬some
                (x✝ &&& (BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) ^^^ 4294967295#32) |||
                  x✝³ &&& BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹))) ⊑
              match some (BitVec.ofBool (x✝² >ₛ x✝¹)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝³
              | some { toFin := ⟨0, ⋯⟩ } =>
                some
                  x✝ =?= ¬some
                (x✝ &&& (BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) ^^^ -1#32) |||
                  x✝³ &&& BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹))) ⊑
              match some (BitVec.ofBool (x✝² >ₛ x✝¹)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝³
              | some { toFin := ⟨0, ⋯⟩ } => some x✝
        [Meta.isDefEq.delta] [0.001052] ✅️ ¬some
                  (x✝ &&& (BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) ^^^ 4294967295#32) |||
                    x✝³ &&& BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹))) ⊑
                match some (BitVec.ofBool (x✝² >ₛ x✝¹)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝³
                | some { toFin := ⟨0, ⋯⟩ } =>
                  some
                    x✝ =?= ¬some
                  (x✝ &&& (BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) ^^^ -1#32) |||
                    x✝³ &&& BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹))) ⊑
                match some (BitVec.ofBool (x✝² >ₛ x✝¹)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝³
                | some { toFin := ⟨0, ⋯⟩ } => some x✝
          [Meta.isDefEq] [0.001047] ✅️ some
                  (x✝ &&& (BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) ^^^ 4294967295#32) |||
                    x✝³ &&& BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹))) ⊑
                match some (BitVec.ofBool (x✝² >ₛ x✝¹)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝³
                | some { toFin := ⟨0, ⋯⟩ } =>
                  some
                    x✝ =?= some
                  (x✝ &&& (BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) ^^^ -1#32) |||
                    x✝³ &&& BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹))) ⊑
                match some (BitVec.ofBool (x✝² >ₛ x✝¹)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝³
                | some { toFin := ⟨0, ⋯⟩ } => some x✝
            [Meta.isDefEq] [0.001016] ✅️ some
                  (x✝ &&& (BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) ^^^ 4294967295#32) |||
                    x✝³ &&&
                      BitVec.signExtend 32
                        (BitVec.ofBool
                          (x✝² >ₛ
                            x✝¹))) =?= some
                  (x✝ &&& (BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)) ^^^ -1#32) |||
                    x✝³ &&& BitVec.signExtend 32 (BitVec.ofBool (x✝² >ₛ x✝¹)))
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬some
              (x✝ &&&
                  (BitVec.signExtend 32
                      (if (!(!x✝¹.getLsbD 31 == x✝².getLsbD 31) == (x✝² >ᵤ x✝¹)) = true then 1#1 else 0#1) ^^^
                    4294967295#32) |||
                x✝³ &&&
                  BitVec.signExtend 32
                    (if (!(!x✝¹.getLsbD 31 == x✝².getLsbD 31) == (x✝² >ᵤ x✝¹)) = true then 1#1 else 0#1)) ⊑
            match some (if (!(!x✝¹.getLsbD 31 == x✝².getLsbD 31) == (x✝² >ᵤ x✝¹)) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝³
            | some { toFin := ⟨0, ⋯⟩ } => some x✝
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:43:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:35:8: error: (kernel) declaration has metavariables 'goo_thm'
[bv] [0.080641] Normalizing goal
  [Meta.synthInstance] [0.001683] ✅️ Decidable
        ((Option.bind
            (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
              fun a_1 => some (a &&& x✝² ||| (a_1 ^^^ -1#32) &&& x✝³)) ⊑
          match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝²
          | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
                | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
                fun a_1 => some (a &&& x✝² ||| (a_1 ^^^ -1#32) &&& x✝³)) ⊑
            match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some x✝³
      ⊢ False
  [Meta.isDefEq] [0.004466] ✅️ ?hx =?= congrArg
        (fun x =>
          match some x with
          | none => none
          | some { toFin := ⟨1, .(Fin.ofNat'.proof_1 (2 ^ 1) 1)⟩ } => some (-1#32)
          | some { toFin := ⟨0, .(Fin.ofNat'.proof_1 (2 ^ 1) 0)⟩ } => some 0#32)
        (Eq.trans
          (congrArg BitVec.ofBool
            (Eq.trans (BitVec.slt_eq_ult x✝ x✝¹)
              (Eq.trans
                (congrArg (fun x => x ^^ x✝¹ >ᵤ x✝)
                  (Eq.trans (congr (congrArg bne (BitVec.msb_eq_getLsbD_last x✝)) (BitVec.msb_eq_getLsbD_last x✝¹))
                    (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (x✝.getLsbD 31) (x✝¹.getLsbD 31))))
                (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (!x✝.getLsbD 31 == x✝¹.getLsbD 31) (x✝¹ >ᵤ x✝)))))
          (Std.Tactic.BVDecide.Normalize.BitVec.ofBool_eq_if !(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)))
    [Meta.isDefEq.assign] [0.004463] ✅️ ?hx := congrArg
          (fun x =>
            match some x with
            | none => none
            | some { toFin := ⟨1, .(Fin.ofNat'.proof_1 (2 ^ 1) 1)⟩ } => some (-1#32)
            | some { toFin := ⟨0, .(Fin.ofNat'.proof_1 (2 ^ 1) 0)⟩ } => some 0#32)
          (Eq.trans
            (congrArg BitVec.ofBool
              (Eq.trans (BitVec.slt_eq_ult x✝ x✝¹)
                (Eq.trans
                  (congrArg (fun x => x ^^ x✝¹ >ᵤ x✝)
                    (Eq.trans (congr (congrArg bne (BitVec.msb_eq_getLsbD_last x✝)) (BitVec.msb_eq_getLsbD_last x✝¹))
                      (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (x✝.getLsbD 31) (x✝¹.getLsbD 31))))
                  (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (!x✝.getLsbD 31 == x✝¹.getLsbD 31) (x✝¹ >ᵤ x✝)))))
            (Std.Tactic.BVDecide.Normalize.BitVec.ofBool_eq_if !(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)))
      [Meta.isDefEq.assign.checkTypes] [0.004439] ✅️ (?hx : (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32) =
            match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 4294967295#32
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32) := (congrArg
            (fun x =>
              match some x with
              | none => none
              | some { toFin := ⟨1, .(Fin.ofNat'.proof_1 (2 ^ 1) 1)⟩ } => some (-1#32)
              | some { toFin := ⟨0, .(Fin.ofNat'.proof_1 (2 ^ 1) 0)⟩ } => some 0#32)
            (Eq.trans
              (congrArg BitVec.ofBool
                (Eq.trans (BitVec.slt_eq_ult x✝ x✝¹)
                  (Eq.trans
                    (congrArg (fun x => x ^^ x✝¹ >ᵤ x✝)
                      (Eq.trans (congr (congrArg bne (BitVec.msb_eq_getLsbD_last x✝)) (BitVec.msb_eq_getLsbD_last x✝¹))
                        (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (x✝.getLsbD 31) (x✝¹.getLsbD 31))))
                    (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (!x✝.getLsbD 31 == x✝¹.getLsbD 31) (x✝¹ >ᵤ x✝)))))
              (Std.Tactic.BVDecide.Normalize.BitVec.ofBool_eq_if
                !(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝))) : (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32) =
            match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
        [Meta.isDefEq] [0.004435] ✅️ (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32) =
              match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 4294967295#32
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32 =?= (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32) =
              match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32
          [Meta.isDefEq] [0.004399] ✅️ match
                some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 4294967295#32
              | some { toFin := ⟨0, ⋯⟩ } =>
                some
                  0#32 =?= match
                some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32
            [Meta.whnf] [0.001180] Non-easy whnf: (fun motive c? h_1 h_2 h_3 =>
                    Option.casesOn c? (h_1 ()) fun val =>
                      BitVec.casesOn val fun toFin =>
                        Fin.casesOn toFin fun val isLt =>
                          Nat.casesOn (motive := fun x => (isLt : x < 2 ^ 1) → motive (some { toFin := ⟨x, isLt⟩ })) val
                            (fun isLt => h_3 ())
                            (fun n isLt =>
                              Nat.casesOn (motive := fun x =>
                                (isLt : x.succ < 2 ^ 1) → motive (some { toFin := ⟨x.succ, isLt⟩ })) n
                                (fun isLt => h_2 ()) (fun n isLt => ⋯.elim) isLt)
                            isLt)
                  (fun c? => LLVM.IntW 32)
                  (some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1)) h_1 h_2 h_3
  [Meta.isDefEq] [0.003810] ✅️ ?hx =?= congrArg
        (fun x =>
          match some x with
          | none => none
          | some { toFin := ⟨1, .(Fin.ofNat'.proof_1 (2 ^ 1) 1)⟩ } => some (-1#32)
          | some { toFin := ⟨0, .(Fin.ofNat'.proof_1 (2 ^ 1) 0)⟩ } => some 0#32)
        (Eq.trans
          (congrArg BitVec.ofBool
            (Eq.trans (BitVec.slt_eq_ult x✝ x✝¹)
              (Eq.trans
                (congrArg (fun x => x ^^ x✝¹ >ᵤ x✝)
                  (Eq.trans (congr (congrArg bne (BitVec.msb_eq_getLsbD_last x✝)) (BitVec.msb_eq_getLsbD_last x✝¹))
                    (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (x✝.getLsbD 31) (x✝¹.getLsbD 31))))
                (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (!x✝.getLsbD 31 == x✝¹.getLsbD 31) (x✝¹ >ᵤ x✝)))))
          (Std.Tactic.BVDecide.Normalize.BitVec.ofBool_eq_if !(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)))
    [Meta.isDefEq.assign] [0.003788] ✅️ ?hx := congrArg
          (fun x =>
            match some x with
            | none => none
            | some { toFin := ⟨1, .(Fin.ofNat'.proof_1 (2 ^ 1) 1)⟩ } => some (-1#32)
            | some { toFin := ⟨0, .(Fin.ofNat'.proof_1 (2 ^ 1) 0)⟩ } => some 0#32)
          (Eq.trans
            (congrArg BitVec.ofBool
              (Eq.trans (BitVec.slt_eq_ult x✝ x✝¹)
                (Eq.trans
                  (congrArg (fun x => x ^^ x✝¹ >ᵤ x✝)
                    (Eq.trans (congr (congrArg bne (BitVec.msb_eq_getLsbD_last x✝)) (BitVec.msb_eq_getLsbD_last x✝¹))
                      (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (x✝.getLsbD 31) (x✝¹.getLsbD 31))))
                  (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (!x✝.getLsbD 31 == x✝¹.getLsbD 31) (x✝¹ >ᵤ x✝)))))
            (Std.Tactic.BVDecide.Normalize.BitVec.ofBool_eq_if !(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)))
      [Meta.isDefEq.assign.checkTypes] [0.003771] ✅️ (?hx : (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32) =
            match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 4294967295#32
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32) := (congrArg
            (fun x =>
              match some x with
              | none => none
              | some { toFin := ⟨1, .(Fin.ofNat'.proof_1 (2 ^ 1) 1)⟩ } => some (-1#32)
              | some { toFin := ⟨0, .(Fin.ofNat'.proof_1 (2 ^ 1) 0)⟩ } => some 0#32)
            (Eq.trans
              (congrArg BitVec.ofBool
                (Eq.trans (BitVec.slt_eq_ult x✝ x✝¹)
                  (Eq.trans
                    (congrArg (fun x => x ^^ x✝¹ >ᵤ x✝)
                      (Eq.trans (congr (congrArg bne (BitVec.msb_eq_getLsbD_last x✝)) (BitVec.msb_eq_getLsbD_last x✝¹))
                        (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (x✝.getLsbD 31) (x✝¹.getLsbD 31))))
                    (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (!x✝.getLsbD 31 == x✝¹.getLsbD 31) (x✝¹ >ᵤ x✝)))))
              (Std.Tactic.BVDecide.Normalize.BitVec.ofBool_eq_if
                !(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝))) : (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32) =
            match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
        [Meta.isDefEq] [0.003768] ✅️ (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32) =
              match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 4294967295#32
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32 =?= (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32) =
              match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32
          [Meta.isDefEq] [0.003736] ✅️ match
                some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 4294967295#32
              | some { toFin := ⟨0, ⋯⟩ } =>
                some
                  0#32 =?= match
                some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 4294967295#32
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
              fun a =>
              Option.bind
                (match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some 4294967295#32
                | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
                fun a_1 => some (a &&& x✝² ||| (a_1 ^^^ 4294967295#32) &&& x✝³)) ⊑
            match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some x✝³
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:55:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:47:8: error: (kernel) declaration has metavariables 'poo_thm'
[bv] [0.089709] Normalizing goal
  [Meta.synthInstance] [0.001754] ✅️ Decidable
        ((Option.bind
            (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 0#32
              | some { toFin := ⟨0, ⋯⟩ } => some (-1#32))
              fun a_1 => some (a &&& x✝² ||| a_1 &&& x✝³)) ⊑
          match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝²
          | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some 0#32
                | some { toFin := ⟨0, ⋯⟩ } => some (-1#32))
                fun a_1 => some (a &&& x✝² ||| a_1 &&& x✝³)) ⊑
            match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some x✝³
      ⊢ False
  [Meta.isDefEq] [0.004389] ✅️ ?hx =?= congrArg
        (fun x =>
          match some x with
          | none => none
          | some { toFin := ⟨1, .(Fin.ofNat'.proof_1 (2 ^ 1) 1)⟩ } => some (-1#32)
          | some { toFin := ⟨0, .(Fin.ofNat'.proof_1 (2 ^ 1) 0)⟩ } => some 0#32)
        (Eq.trans
          (congrArg BitVec.ofBool
            (Eq.trans (BitVec.slt_eq_ult x✝ x✝¹)
              (Eq.trans
                (congrArg (fun x => x ^^ x✝¹ >ᵤ x✝)
                  (Eq.trans (congr (congrArg bne (BitVec.msb_eq_getLsbD_last x✝)) (BitVec.msb_eq_getLsbD_last x✝¹))
                    (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (x✝.getLsbD 31) (x✝¹.getLsbD 31))))
                (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (!x✝.getLsbD 31 == x✝¹.getLsbD 31) (x✝¹ >ᵤ x✝)))))
          (Std.Tactic.BVDecide.Normalize.BitVec.ofBool_eq_if !(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)))
    [Meta.isDefEq.assign] [0.004386] ✅️ ?hx := congrArg
          (fun x =>
            match some x with
            | none => none
            | some { toFin := ⟨1, .(Fin.ofNat'.proof_1 (2 ^ 1) 1)⟩ } => some (-1#32)
            | some { toFin := ⟨0, .(Fin.ofNat'.proof_1 (2 ^ 1) 0)⟩ } => some 0#32)
          (Eq.trans
            (congrArg BitVec.ofBool
              (Eq.trans (BitVec.slt_eq_ult x✝ x✝¹)
                (Eq.trans
                  (congrArg (fun x => x ^^ x✝¹ >ᵤ x✝)
                    (Eq.trans (congr (congrArg bne (BitVec.msb_eq_getLsbD_last x✝)) (BitVec.msb_eq_getLsbD_last x✝¹))
                      (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (x✝.getLsbD 31) (x✝¹.getLsbD 31))))
                  (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (!x✝.getLsbD 31 == x✝¹.getLsbD 31) (x✝¹ >ᵤ x✝)))))
            (Std.Tactic.BVDecide.Normalize.BitVec.ofBool_eq_if !(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)))
      [Meta.isDefEq.assign.checkTypes] [0.004361] ✅️ (?hx : (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32) =
            match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 4294967295#32
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32) := (congrArg
            (fun x =>
              match some x with
              | none => none
              | some { toFin := ⟨1, .(Fin.ofNat'.proof_1 (2 ^ 1) 1)⟩ } => some (-1#32)
              | some { toFin := ⟨0, .(Fin.ofNat'.proof_1 (2 ^ 1) 0)⟩ } => some 0#32)
            (Eq.trans
              (congrArg BitVec.ofBool
                (Eq.trans (BitVec.slt_eq_ult x✝ x✝¹)
                  (Eq.trans
                    (congrArg (fun x => x ^^ x✝¹ >ᵤ x✝)
                      (Eq.trans (congr (congrArg bne (BitVec.msb_eq_getLsbD_last x✝)) (BitVec.msb_eq_getLsbD_last x✝¹))
                        (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (x✝.getLsbD 31) (x✝¹.getLsbD 31))))
                    (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (!x✝.getLsbD 31 == x✝¹.getLsbD 31) (x✝¹ >ᵤ x✝)))))
              (Std.Tactic.BVDecide.Normalize.BitVec.ofBool_eq_if
                !(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝))) : (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32) =
            match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
        [Meta.isDefEq] [0.004357] ✅️ (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32) =
              match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 4294967295#32
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32 =?= (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32) =
              match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32
          [Meta.isDefEq] [0.004321] ✅️ match
                some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 4294967295#32
              | some { toFin := ⟨0, ⋯⟩ } =>
                some
                  0#32 =?= match
                some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32
            [Meta.whnf] [0.001183] Non-easy whnf: (fun motive c? h_1 h_2 h_3 =>
                    Option.casesOn c? (h_1 ()) fun val =>
                      BitVec.casesOn val fun toFin =>
                        Fin.casesOn toFin fun val isLt =>
                          Nat.casesOn (motive := fun x => (isLt : x < 2 ^ 1) → motive (some { toFin := ⟨x, isLt⟩ })) val
                            (fun isLt => h_3 ())
                            (fun n isLt =>
                              Nat.casesOn (motive := fun x =>
                                (isLt : x.succ < 2 ^ 1) → motive (some { toFin := ⟨x.succ, isLt⟩ })) n
                                (fun isLt => h_2 ()) (fun n isLt => ⋯.elim) isLt)
                            isLt)
                  (fun c? => LLVM.IntW 32)
                  (some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1)) h_1 h_2 h_3
  [Meta.isDefEq] [0.003836] ✅️ ?hx =?= congrArg
        (fun x =>
          match some x with
          | none => none
          | some { toFin := ⟨1, .(Fin.ofNat'.proof_1 (2 ^ 1) 1)⟩ } => some 0#32
          | some { toFin := ⟨0, .(Fin.ofNat'.proof_1 (2 ^ 1) 0)⟩ } => some (-1#32))
        (Eq.trans
          (congrArg BitVec.ofBool
            (Eq.trans (BitVec.slt_eq_ult x✝ x✝¹)
              (Eq.trans
                (congrArg (fun x => x ^^ x✝¹ >ᵤ x✝)
                  (Eq.trans (congr (congrArg bne (BitVec.msb_eq_getLsbD_last x✝)) (BitVec.msb_eq_getLsbD_last x✝¹))
                    (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (x✝.getLsbD 31) (x✝¹.getLsbD 31))))
                (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (!x✝.getLsbD 31 == x✝¹.getLsbD 31) (x✝¹ >ᵤ x✝)))))
          (Std.Tactic.BVDecide.Normalize.BitVec.ofBool_eq_if !(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)))
    [Meta.isDefEq.assign] [0.003833] ✅️ ?hx := congrArg
          (fun x =>
            match some x with
            | none => none
            | some { toFin := ⟨1, .(Fin.ofNat'.proof_1 (2 ^ 1) 1)⟩ } => some 0#32
            | some { toFin := ⟨0, .(Fin.ofNat'.proof_1 (2 ^ 1) 0)⟩ } => some (-1#32))
          (Eq.trans
            (congrArg BitVec.ofBool
              (Eq.trans (BitVec.slt_eq_ult x✝ x✝¹)
                (Eq.trans
                  (congrArg (fun x => x ^^ x✝¹ >ᵤ x✝)
                    (Eq.trans (congr (congrArg bne (BitVec.msb_eq_getLsbD_last x✝)) (BitVec.msb_eq_getLsbD_last x✝¹))
                      (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (x✝.getLsbD 31) (x✝¹.getLsbD 31))))
                  (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (!x✝.getLsbD 31 == x✝¹.getLsbD 31) (x✝¹ >ᵤ x✝)))))
            (Std.Tactic.BVDecide.Normalize.BitVec.ofBool_eq_if !(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)))
      [Meta.isDefEq.assign.checkTypes] [0.003810] ✅️ (?hx : (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 0#32
            | some { toFin := ⟨0, ⋯⟩ } => some (-1#32)) =
            match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 0#32
            | some { toFin := ⟨0, ⋯⟩ } => some 4294967295#32) := (congrArg
            (fun x =>
              match some x with
              | none => none
              | some { toFin := ⟨1, .(Fin.ofNat'.proof_1 (2 ^ 1) 1)⟩ } => some 0#32
              | some { toFin := ⟨0, .(Fin.ofNat'.proof_1 (2 ^ 1) 0)⟩ } => some (-1#32))
            (Eq.trans
              (congrArg BitVec.ofBool
                (Eq.trans (BitVec.slt_eq_ult x✝ x✝¹)
                  (Eq.trans
                    (congrArg (fun x => x ^^ x✝¹ >ᵤ x✝)
                      (Eq.trans (congr (congrArg bne (BitVec.msb_eq_getLsbD_last x✝)) (BitVec.msb_eq_getLsbD_last x✝¹))
                        (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (x✝.getLsbD 31) (x✝¹.getLsbD 31))))
                    (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (!x✝.getLsbD 31 == x✝¹.getLsbD 31) (x✝¹ >ᵤ x✝)))))
              (Std.Tactic.BVDecide.Normalize.BitVec.ofBool_eq_if
                !(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝))) : (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 0#32
            | some { toFin := ⟨0, ⋯⟩ } => some (-1#32)) =
            match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 0#32
            | some { toFin := ⟨0, ⋯⟩ } => some (-1#32))
        [Meta.isDefEq] [0.003807] ✅️ (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 0#32
              | some { toFin := ⟨0, ⋯⟩ } => some (-1#32)) =
              match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 0#32
              | some { toFin := ⟨0, ⋯⟩ } => some 4294967295#32 =?= (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 0#32
              | some { toFin := ⟨0, ⋯⟩ } => some (-1#32)) =
              match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 0#32
              | some { toFin := ⟨0, ⋯⟩ } => some (-1#32)
          [Meta.isDefEq] [0.003773] ✅️ match
                some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 0#32
              | some { toFin := ⟨0, ⋯⟩ } =>
                some
                  4294967295#32 =?= match
                some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 0#32
              | some { toFin := ⟨0, ⋯⟩ } => some (-1#32)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 4294967295#32
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
              fun a =>
              Option.bind
                (match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some 0#32
                | some { toFin := ⟨0, ⋯⟩ } => some 4294967295#32)
                fun a_1 => some (a &&& x✝² ||| a_1 &&& x✝³)) ⊑
            match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some x✝³
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:68:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:68:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:68:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:68:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:59:8: error: (kernel) declaration has metavariables 'fold_inverted_icmp_preds_thm'
[bv] [0.090200] Normalizing goal
  [Meta.synthInstance] [0.001292] ✅️ Decidable
        ((Option.bind
            (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (x✝ ≥ₛ x✝¹)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝³
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
              fun a_1 => some (a ||| a_1)) ⊑
          Option.bind
            (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 0#32
              | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
              fun a_1 => some (a ||| a_1))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (x✝ ≥ₛ x✝¹)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝³
                | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
                fun a_1 => some (a ||| a_1)) ⊑
            Option.bind
              (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some 0#32
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun a_1 => some (a ||| a_1)
      ⊢ False
  [Meta.isDefEq] [0.002061] ✅️ ?hf =?= fun a a_1 => Eq.refl (some (a✝² ||| a))
    [Meta.isDefEq.assign] [0.002057] ✅️ ?hf := fun a a_1 => Eq.refl (some (a✝² ||| a))
      [Meta.isDefEq.assign.checkTypes] [0.002015] ✅️ (?hf : ∀
            a ∈
              match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 0#32
              | some { toFin := ⟨0, ⋯⟩ } => some x✝³,
            some (a✝² ||| a) =
              some
                (a✝² |||
                  a)) := (fun a a_1 =>
            Eq.refl
              (some
                (a✝² |||
                  a)) : ∀
            a ∈
              match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 0#32
              | some { toFin := ⟨0, ⋯⟩ } => some x✝³,
            some (a✝² ||| a) = some (a✝² ||| a))
        [Meta.isDefEq] [0.001995] ✅️ ∀
              a ∈
                match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some 0#32
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³,
              some (a✝² ||| a) =
                some
                  (a✝² |||
                    a) =?= ∀
              a ∈
                match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some 0#32
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³,
              some (a✝² ||| a) = some (a✝² ||| a)
          [Meta.isDefEq] [0.001834] ✅️ a ∈
                match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some 0#32
                | some { toFin := ⟨0, ⋯⟩ } =>
                  some
                    x✝³ =?= a ∈
                match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some 0#32
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
              fun a =>
              Option.bind
                (match some (if ((!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝³
                | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
                fun a_1 => some (a ||| a_1)) ⊑
            Option.bind
              (match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
              fun a =>
              Option.bind
                (match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some 0#32
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun a_1 => some (a ||| a_1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:81:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:81:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:81:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:81:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:72:8: error: (kernel) declaration has metavariables 'fold_inverted_icmp_preds_reverse_thm'
[bv] [0.094570] Normalizing goal
  [Meta.synthInstance] [0.001301] ✅️ Decidable
        ((Option.bind
            (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 0#32
            | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (x✝ ≥ₛ x✝¹)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 0#32
              | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
              fun a_1 => some (a ||| a_1)) ⊑
          Option.bind
            (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 0#32
            | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝³
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
              fun a_1 => some (a ||| a_1))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 0#32
              | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (x✝ ≥ₛ x✝¹)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some 0#32
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun a_1 => some (a ||| a_1)) ⊑
            Option.bind
              (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 0#32
              | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝³
                | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
                fun a_1 => some (a ||| a_1)
      ⊢ False
  [Meta.isDefEq] [0.001037] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } =>
        ?h_3 () =?= match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 0#32
      | some { toFin := ⟨0, ⋯⟩ } => some x✝²
  [Meta.whnf] [0.002071] Non-easy whnf: (fun motive c? h_1 h_2 h_3 =>
          Option.casesOn c? (h_1 ()) fun val =>
            BitVec.casesOn val fun toFin =>
              Fin.casesOn toFin fun val isLt =>
                Nat.casesOn (motive := fun x => (isLt : x < 2 ^ 1) → motive (some { toFin := ⟨x, isLt⟩ })) val
                  (fun isLt => h_3 ())
                  (fun n isLt =>
                    Nat.casesOn (motive := fun x => (isLt : x.succ < 2 ^ 1) → motive (some { toFin := ⟨x.succ, isLt⟩ }))
                      n (fun isLt => h_2 ()) (fun n isLt => ⋯.elim) isLt)
                  isLt)
        (fun c? => LLVM.IntW 32)
        (some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1)) h_1 h_2 h_3
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 0#32
              | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
              fun a =>
              Option.bind
                (match some (if ((!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some 0#32
                | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
                fun a_1 => some (a ||| a_1)) ⊑
            Option.bind
              (match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 0#32
              | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
              fun a =>
              Option.bind
                (match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝³
                | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
                fun a_1 => some (a ||| a_1)
      ⊢ False
  [Meta.isDefEq] [0.001913] ✅️ if ?b then ?x
      else ?y =?= if ((!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1
    [Meta.isDefEq] [0.001780] ✅️ ?α =?= BitVec 1
      [Meta.isDefEq.assign] [0.001775] ✅️ ?α := BitVec 1
        [Meta.isDefEq.assign.checkTypes] [0.001765] ✅️ (?α : Sort ?u.195283) := (BitVec 1 : Type)
  [Meta.isDefEq] [0.001046] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } =>
        ?h_3 () =?= match some (if ((!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 0#32
      | some { toFin := ⟨0, ⋯⟩ } => some x✝³
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:93:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:85:8: error: (kernel) declaration has metavariables 'par_thm'
[bv] [0.084914] Normalizing goal
  [Meta.synthInstance] [0.002068] ✅️ Decidable
        ((Option.bind
            (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
              fun a_1 => some (a &&& x✝² ||| (a_1 ^^^ -1#32) &&& x✝³)) ⊑
          match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝²
          | some { toFin := ⟨0, ⋯⟩ } => some x✝³)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
                | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
                fun a_1 => some (a &&& x✝² ||| (a_1 ^^^ -1#32) &&& x✝³)) ⊑
            match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some x✝³
      ⊢ False
  [Meta.isDefEq] [0.005332] ✅️ ?hx =?= congrArg
        (fun x =>
          match some x with
          | none => none
          | some { toFin := ⟨1, .(Fin.ofNat'.proof_1 (2 ^ 1) 1)⟩ } => some (-1#32)
          | some { toFin := ⟨0, .(Fin.ofNat'.proof_1 (2 ^ 1) 0)⟩ } => some 0#32)
        (Eq.trans
          (congrArg BitVec.ofBool
            (Eq.trans (BitVec.slt_eq_ult x✝ x✝¹)
              (Eq.trans
                (congrArg (fun x => x ^^ x✝¹ >ᵤ x✝)
                  (Eq.trans (congr (congrArg bne (BitVec.msb_eq_getLsbD_last x✝)) (BitVec.msb_eq_getLsbD_last x✝¹))
                    (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (x✝.getLsbD 31) (x✝¹.getLsbD 31))))
                (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (!x✝.getLsbD 31 == x✝¹.getLsbD 31) (x✝¹ >ᵤ x✝)))))
          (Std.Tactic.BVDecide.Normalize.BitVec.ofBool_eq_if !(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)))
    [Meta.isDefEq.assign] [0.005328] ✅️ ?hx := congrArg
          (fun x =>
            match some x with
            | none => none
            | some { toFin := ⟨1, .(Fin.ofNat'.proof_1 (2 ^ 1) 1)⟩ } => some (-1#32)
            | some { toFin := ⟨0, .(Fin.ofNat'.proof_1 (2 ^ 1) 0)⟩ } => some 0#32)
          (Eq.trans
            (congrArg BitVec.ofBool
              (Eq.trans (BitVec.slt_eq_ult x✝ x✝¹)
                (Eq.trans
                  (congrArg (fun x => x ^^ x✝¹ >ᵤ x✝)
                    (Eq.trans (congr (congrArg bne (BitVec.msb_eq_getLsbD_last x✝)) (BitVec.msb_eq_getLsbD_last x✝¹))
                      (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (x✝.getLsbD 31) (x✝¹.getLsbD 31))))
                  (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (!x✝.getLsbD 31 == x✝¹.getLsbD 31) (x✝¹ >ᵤ x✝)))))
            (Std.Tactic.BVDecide.Normalize.BitVec.ofBool_eq_if !(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)))
      [Meta.isDefEq.assign.checkTypes] [0.005302] ✅️ (?hx : (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32) =
            match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 4294967295#32
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32) := (congrArg
            (fun x =>
              match some x with
              | none => none
              | some { toFin := ⟨1, .(Fin.ofNat'.proof_1 (2 ^ 1) 1)⟩ } => some (-1#32)
              | some { toFin := ⟨0, .(Fin.ofNat'.proof_1 (2 ^ 1) 0)⟩ } => some 0#32)
            (Eq.trans
              (congrArg BitVec.ofBool
                (Eq.trans (BitVec.slt_eq_ult x✝ x✝¹)
                  (Eq.trans
                    (congrArg (fun x => x ^^ x✝¹ >ᵤ x✝)
                      (Eq.trans (congr (congrArg bne (BitVec.msb_eq_getLsbD_last x✝)) (BitVec.msb_eq_getLsbD_last x✝¹))
                        (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (x✝.getLsbD 31) (x✝¹.getLsbD 31))))
                    (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (!x✝.getLsbD 31 == x✝¹.getLsbD 31) (x✝¹ >ᵤ x✝)))))
              (Std.Tactic.BVDecide.Normalize.BitVec.ofBool_eq_if
                !(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝))) : (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32) =
            match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
        [Meta.isDefEq] [0.005298] ✅️ (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32) =
              match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 4294967295#32
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32 =?= (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32) =
              match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32
          [Meta.isDefEq] [0.005257] ✅️ match
                some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 4294967295#32
              | some { toFin := ⟨0, ⋯⟩ } =>
                some
                  0#32 =?= match
                some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32
            [Meta.whnf] [0.001260] Non-easy whnf: (fun motive c? h_1 h_2 h_3 =>
                    Option.casesOn c? (h_1 ()) fun val =>
                      BitVec.casesOn val fun toFin =>
                        Fin.casesOn toFin fun val isLt =>
                          Nat.casesOn (motive := fun x => (isLt : x < 2 ^ 1) → motive (some { toFin := ⟨x, isLt⟩ })) val
                            (fun isLt => h_3 ())
                            (fun n isLt =>
                              Nat.casesOn (motive := fun x =>
                                (isLt : x.succ < 2 ^ 1) → motive (some { toFin := ⟨x.succ, isLt⟩ })) n
                                (fun isLt => h_2 ()) (fun n isLt => ⋯.elim) isLt)
                            isLt)
                  (fun c? => LLVM.IntW 32)
                  (some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1)) h_1 h_2 h_3
            [Meta.whnf] [0.001197] Non-easy whnf: (fun motive c? h_1 h_2 h_3 =>
                    Option.casesOn c? (h_1 ()) fun val =>
                      BitVec.casesOn val fun toFin =>
                        Fin.casesOn toFin fun val isLt =>
                          Nat.casesOn (motive := fun x => (isLt : x < 2 ^ 1) → motive (some { toFin := ⟨x, isLt⟩ })) val
                            (fun isLt => h_3 ())
                            (fun n isLt =>
                              Nat.casesOn (motive := fun x =>
                                (isLt : x.succ < 2 ^ 1) → motive (some { toFin := ⟨x.succ, isLt⟩ })) n
                                (fun isLt => h_2 ()) (fun n isLt => ⋯.elim) isLt)
                            isLt)
                  (fun c? => LLVM.IntW 32)
                  (some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1)) h_1 h_2 h_3
  [Meta.isDefEq] [0.004745] ✅️ ?hx =?= congrArg
        (fun x =>
          match some x with
          | none => none
          | some { toFin := ⟨1, .(Fin.ofNat'.proof_1 (2 ^ 1) 1)⟩ } => some (-1#32)
          | some { toFin := ⟨0, .(Fin.ofNat'.proof_1 (2 ^ 1) 0)⟩ } => some 0#32)
        (Eq.trans
          (congrArg BitVec.ofBool
            (Eq.trans (BitVec.slt_eq_ult x✝ x✝¹)
              (Eq.trans
                (congrArg (fun x => x ^^ x✝¹ >ᵤ x✝)
                  (Eq.trans (congr (congrArg bne (BitVec.msb_eq_getLsbD_last x✝)) (BitVec.msb_eq_getLsbD_last x✝¹))
                    (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (x✝.getLsbD 31) (x✝¹.getLsbD 31))))
                (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (!x✝.getLsbD 31 == x✝¹.getLsbD 31) (x✝¹ >ᵤ x✝)))))
          (Std.Tactic.BVDecide.Normalize.BitVec.ofBool_eq_if !(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)))
    [Meta.isDefEq.assign] [0.004742] ✅️ ?hx := congrArg
          (fun x =>
            match some x with
            | none => none
            | some { toFin := ⟨1, .(Fin.ofNat'.proof_1 (2 ^ 1) 1)⟩ } => some (-1#32)
            | some { toFin := ⟨0, .(Fin.ofNat'.proof_1 (2 ^ 1) 0)⟩ } => some 0#32)
          (Eq.trans
            (congrArg BitVec.ofBool
              (Eq.trans (BitVec.slt_eq_ult x✝ x✝¹)
                (Eq.trans
                  (congrArg (fun x => x ^^ x✝¹ >ᵤ x✝)
                    (Eq.trans (congr (congrArg bne (BitVec.msb_eq_getLsbD_last x✝)) (BitVec.msb_eq_getLsbD_last x✝¹))
                      (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (x✝.getLsbD 31) (x✝¹.getLsbD 31))))
                  (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (!x✝.getLsbD 31 == x✝¹.getLsbD 31) (x✝¹ >ᵤ x✝)))))
            (Std.Tactic.BVDecide.Normalize.BitVec.ofBool_eq_if !(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)))
      [Meta.isDefEq.assign.checkTypes] [0.004725] ✅️ (?hx : (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32) =
            match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 4294967295#32
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32) := (congrArg
            (fun x =>
              match some x with
              | none => none
              | some { toFin := ⟨1, .(Fin.ofNat'.proof_1 (2 ^ 1) 1)⟩ } => some (-1#32)
              | some { toFin := ⟨0, .(Fin.ofNat'.proof_1 (2 ^ 1) 0)⟩ } => some 0#32)
            (Eq.trans
              (congrArg BitVec.ofBool
                (Eq.trans (BitVec.slt_eq_ult x✝ x✝¹)
                  (Eq.trans
                    (congrArg (fun x => x ^^ x✝¹ >ᵤ x✝)
                      (Eq.trans (congr (congrArg bne (BitVec.msb_eq_getLsbD_last x✝)) (BitVec.msb_eq_getLsbD_last x✝¹))
                        (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (x✝.getLsbD 31) (x✝¹.getLsbD 31))))
                    (Std.Tactic.BVDecide.Normalize.Bool.bne_to_beq (!x✝.getLsbD 31 == x✝¹.getLsbD 31) (x✝¹ >ᵤ x✝)))))
              (Std.Tactic.BVDecide.Normalize.BitVec.ofBool_eq_if
                !(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝))) : (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32) =
            match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
        [Meta.isDefEq] [0.004721] ✅️ (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32) =
              match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 4294967295#32
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32 =?= (match some (BitVec.ofBool (x✝¹ >ₛ x✝)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32) =
              match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32
          [Meta.isDefEq] [0.004689] ✅️ match
                some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 4294967295#32
              | some { toFin := ⟨0, ⋯⟩ } =>
                some
                  0#32 =?= match
                some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32
            [Meta.whnf] [0.001117] Non-easy whnf: (fun motive c? h_1 h_2 h_3 =>
                    Option.casesOn c? (h_1 ()) fun val =>
                      BitVec.casesOn val fun toFin =>
                        Fin.casesOn toFin fun val isLt =>
                          Nat.casesOn (motive := fun x => (isLt : x < 2 ^ 1) → motive (some { toFin := ⟨x, isLt⟩ })) val
                            (fun isLt => h_3 ())
                            (fun n isLt =>
                              Nat.casesOn (motive := fun x =>
                                (isLt : x.succ < 2 ^ 1) → motive (some { toFin := ⟨x.succ, isLt⟩ })) n
                                (fun isLt => h_2 ()) (fun n isLt => ⋯.elim) isLt)
                            isLt)
                  (fun c? => LLVM.IntW 32)
                  (some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1)) h_1 h_2 h_3
            [Meta.whnf] [0.001124] Non-easy whnf: (fun motive c? h_1 h_2 h_3 =>
                    Option.casesOn c? (h_1 ()) fun val =>
                      BitVec.casesOn val fun toFin =>
                        Fin.casesOn toFin fun val isLt =>
                          Nat.casesOn (motive := fun x => (isLt : x < 2 ^ 1) → motive (some { toFin := ⟨x, isLt⟩ })) val
                            (fun isLt => h_3 ())
                            (fun n isLt =>
                              Nat.casesOn (motive := fun x =>
                                (isLt : x.succ < 2 ^ 1) → motive (some { toFin := ⟨x.succ, isLt⟩ })) n
                                (fun isLt => h_2 ()) (fun n isLt => ⋯.elim) isLt)
                            isLt)
                  (fun c? => LLVM.IntW 32)
                  (some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1)) h_1 h_2 h_3
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 e_3 : LLVM.IntW 32
      x✝³ x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(Option.bind
              (match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 4294967295#32
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
              fun a =>
              Option.bind
                (match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some 4294967295#32
                | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
                fun a_1 => some (a &&& x✝² ||| (a_1 ^^^ 4294967295#32) &&& x✝³)) ⊑
            match some (if (!(!x✝.getLsbD 31 == x✝¹.getLsbD 31) == (x✝¹ >ᵤ x✝)) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some x✝³
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:103:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:97:8: error: (kernel) declaration has metavariables 'bools_thm'
[bv] [0.021168] Normalizing goal
  [Meta.synthInstance] [0.001498] ✅️ Decidable
        (some ((x✝ ^^^ 1#1) &&& x✝¹ ||| x✝ &&& x✝²) ⊑
          match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝²
          | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 1
      x✝² x✝¹ x✝ : BitVec 1
      a✝ :
        ¬some ((x✝ ^^^ 1#1) &&& x✝¹ ||| x✝ &&& x✝²) ⊑
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 1
      x✝² x✝¹ x✝ : BitVec 1
      a✝ :
        ¬some ((x✝ ^^^ 1#1) &&& x✝¹ ||| x✝ &&& x✝²) ⊑
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:114:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:114:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:114:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:114:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:107:8: error: (kernel) declaration has metavariables 'bools_logical_thm'
[bv] [0.059304] Normalizing goal
  [Meta.synthInstance] [0.001896] ✅️ Decidable
        ((match
            match some (x✝ ^^^ 1#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some 1#1
          | some { toFin := ⟨0, ⋯⟩ } =>
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some 0#1) ⊑
          match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝²
          | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 1
      x✝² x✝¹ x✝ : BitVec 1
      a✝ :
        ¬(match
              match some (x✝ ^^^ 1#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 1#1
            | some { toFin := ⟨0, ⋯⟩ } =>
              match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some 0#1) ⊑
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
      ⊢ False
  [Meta.isDefEq] [0.001035] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match some (x✝ ^^^ 1#1) with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#1
      | some { toFin := ⟨0, ⋯⟩ } =>
        match some x✝ with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝²
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001044] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match some (x✝ ^^^ 1#1) with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#1
      | some { toFin := ⟨0, ⋯⟩ } =>
        match some x✝ with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝²
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001026] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match some (x✝ ^^^ 1#1) with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#1
      | some { toFin := ⟨0, ⋯⟩ } =>
        match some x✝ with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝²
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001009] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match some (x✝ ^^^ 1#1) with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#1
      | some { toFin := ⟨0, ⋯⟩ } =>
        match some x✝ with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝²
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001052] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match some (x✝ ^^^ 1#1) with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#1
      | some { toFin := ⟨0, ⋯⟩ } =>
        match some x✝ with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝²
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001030] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match some (x✝ ^^^ 1#1) with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#1
      | some { toFin := ⟨0, ⋯⟩ } =>
        match some x✝ with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝²
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 1
      x✝² x✝¹ x✝ : BitVec 1
      a✝ :
        ¬(match
              match some (x✝ ^^^ 1#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 1#1
            | some { toFin := ⟨0, ⋯⟩ } =>
              match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some 0#1) ⊑
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
      ⊢ False
  [Meta.isDefEq] [0.001025] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match some (x✝ ^^^ 1#1) with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#1
      | some { toFin := ⟨0, ⋯⟩ } =>
        match some x✝ with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝²
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001058] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match some (x✝ ^^^ 1#1) with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#1
      | some { toFin := ⟨0, ⋯⟩ } =>
        match some x✝ with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝²
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001046] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match some (x✝ ^^^ 1#1) with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#1
      | some { toFin := ⟨0, ⋯⟩ } =>
        match some x✝ with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝²
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001004] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match some (x✝ ^^^ 1#1) with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#1
      | some { toFin := ⟨0, ⋯⟩ } =>
        match some x✝ with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝²
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001047] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match some (x✝ ^^^ 1#1) with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#1
      | some { toFin := ⟨0, ⋯⟩ } =>
        match some x✝ with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝²
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001078] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match some (x✝ ^^^ 1#1) with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#1
      | some { toFin := ⟨0, ⋯⟩ } =>
        match some x✝ with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝²
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:126:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:118:8: error: (kernel) declaration has metavariables 'bools_multi_uses1_thm'
[bv] [0.028716] Normalizing goal
  [Meta.synthInstance] [0.001240] ✅️ Decidable
        (some (((x✝ ^^^ 1#1) &&& x✝¹ ||| x✝ &&& x✝²) ^^^ (x✝ ^^^ 1#1) &&& x✝¹) ⊑
          Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
            fun a => some (a ^^^ x✝¹ &&& (x✝ ^^^ 1#1)))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 1
      x✝² x✝¹ x✝ : BitVec 1
      a✝ :
        ¬some (((x✝ ^^^ 1#1) &&& x✝¹ ||| x✝ &&& x✝²) ^^^ (x✝ ^^^ 1#1) &&& x✝¹) ⊑
            Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun a => some (a ^^^ x✝¹ &&& (x✝ ^^^ 1#1))
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 1
      x✝² x✝¹ x✝ : BitVec 1
      a✝ :
        ¬some (((x✝ ^^^ 1#1) &&& x✝¹ ||| x✝ &&& x✝²) ^^^ (x✝ ^^^ 1#1) &&& x✝¹) ⊑
            Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun a => some (a ^^^ x✝¹ &&& (x✝ ^^^ 1#1))
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:138:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:138:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:138:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:138:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:130:8: error: (kernel) declaration has metavariables 'bools_multi_uses1_logical_thm'
[bv] [0.074158] Normalizing goal
  [Meta.synthInstance] [0.001266] ✅️ Decidable
        ((Option.bind
            (match
              match some (x✝ ^^^ 1#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 1#1
            | some { toFin := ⟨0, ⋯⟩ } =>
              match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
            fun a =>
            Option.bind
              (match some (x✝ ^^^ 1#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
              fun y' => some (a ^^^ y')) ⊑
          Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
            fun a =>
            Option.bind
              (match some (x✝ ^^^ 1#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
              fun y' => some (a ^^^ y'))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 1
      x✝² x✝¹ x✝ : BitVec 1
      a✝ :
        ¬(Option.bind
              (match
                match some (x✝ ^^^ 1#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
                | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 1#1
              | some { toFin := ⟨0, ⋯⟩ } =>
                match some x✝ with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
              fun a =>
              Option.bind
                (match some (x✝ ^^^ 1#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
                | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
                fun y' => some (a ^^^ y')) ⊑
            Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun a =>
              Option.bind
                (match some (x✝ ^^^ 1#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
                | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
                fun y' => some (a ^^^ y')
      ⊢ False
  [Meta.isDefEq] [0.001011] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match some (x✝ ^^^ 1#1) with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#1
      | some { toFin := ⟨0, ⋯⟩ } =>
        match some x✝ with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝²
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001029] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match some (x✝ ^^^ 1#1) with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#1
      | some { toFin := ⟨0, ⋯⟩ } =>
        match some x✝ with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝²
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001011] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match some (x✝ ^^^ 1#1) with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#1
      | some { toFin := ⟨0, ⋯⟩ } =>
        match some x✝ with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝²
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001017] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match some (x✝ ^^^ 1#1) with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#1
      | some { toFin := ⟨0, ⋯⟩ } =>
        match some x✝ with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝²
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001021] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match some (x✝ ^^^ 1#1) with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#1
      | some { toFin := ⟨0, ⋯⟩ } =>
        match some x✝ with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝²
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 1
      x✝² x✝¹ x✝ : BitVec 1
      a✝ :
        ¬(Option.bind
              (match
                match some (x✝ ^^^ 1#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
                | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 1#1
              | some { toFin := ⟨0, ⋯⟩ } =>
                match some x✝ with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
              fun a =>
              Option.bind
                (match some (x✝ ^^^ 1#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
                | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
                fun y' => some (a ^^^ y')) ⊑
            Option.bind
              (match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
              fun a =>
              Option.bind
                (match some (x✝ ^^^ 1#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
                | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
                fun y' => some (a ^^^ y')
      ⊢ False
  [Meta.isDefEq] [0.001010] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match some (x✝ ^^^ 1#1) with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#1
      | some { toFin := ⟨0, ⋯⟩ } =>
        match some x✝ with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝²
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001036] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match some (x✝ ^^^ 1#1) with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#1
      | some { toFin := ⟨0, ⋯⟩ } =>
        match some x✝ with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝²
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001020] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match some (x✝ ^^^ 1#1) with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#1
      | some { toFin := ⟨0, ⋯⟩ } =>
        match some x✝ with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝²
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001031] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match some (x✝ ^^^ 1#1) with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#1
      | some { toFin := ⟨0, ⋯⟩ } =>
        match some x✝ with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝²
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001017] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match some (x✝ ^^^ 1#1) with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#1
      | some { toFin := ⟨0, ⋯⟩ } =>
        match some x✝ with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝²
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:150:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:142:8: error: (kernel) declaration has metavariables 'bools_multi_uses2_thm'
[bv] [0.023777] Normalizing goal
  [Meta.synthInstance] [0.001441] ✅️ Decidable
        (some (((x✝ ^^^ 1#1) &&& x✝¹ ||| x✝ &&& x✝²) &&& ((x✝ ^^^ 1#1) &&& x✝¹) + (x✝ &&& x✝²)) ⊑
          match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝²
          | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 1
      x✝² x✝¹ x✝ : BitVec 1
      a✝ :
        ¬some (((x✝ ^^^ 1#1) &&& x✝¹ ||| x✝ &&& x✝²) &&& ((x✝ ^^^ 1#1) &&& x✝¹) + (x✝ &&& x✝²)) ⊑
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 1
      x✝² x✝¹ x✝ : BitVec 1
      a✝ :
        ¬some (((x✝ ^^^ 1#1) &&& x✝¹ ||| x✝ &&& x✝²) &&& ((x✝ ^^^ 1#1) &&& x✝¹ ^^^ x✝ &&& x✝²)) ⊑
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:163:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:163:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:163:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:163:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:154:8: error: (kernel) declaration has metavariables 'bools_multi_uses2_logical_thm'
[bv] [0.111955] Normalizing goal
  [Meta.synthInstance] [0.002391] ✅️ Decidable
        ((match
            match
              match some (x✝ ^^^ 1#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 1#1
            | some { toFin := ⟨0, ⋯⟩ } =>
              match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } =>
            Option.bind
              (match some (x✝ ^^^ 1#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
              fun x' =>
              Option.bind
                (match some x✝ with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
                fun y' => some (x' + y')
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1) ⊑
          match
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } =>
            Option.bind
              (match some (x✝ ^^^ 1#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
              | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
              fun x' =>
              Option.bind
                (match some x✝ with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
                fun y' => some (x' ^^^ y')
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 1
      x✝² x✝¹ x✝ : BitVec 1
      a✝ :
        ¬(match
              match
                match some (x✝ ^^^ 1#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
                | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 1#1
              | some { toFin := ⟨0, ⋯⟩ } =>
                match some x✝ with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } =>
              Option.bind
                (match some (x✝ ^^^ 1#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
                | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
                fun x' =>
                Option.bind
                  (match some x✝ with
                  | none => none
                  | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                  | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
                  fun y' => some (x' + y')
            | some { toFin := ⟨0, ⋯⟩ } => some 0#1) ⊑
            match
              match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } =>
              Option.bind
                (match some (x✝ ^^^ 1#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
                | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
                fun x' =>
                Option.bind
                  (match some x✝ with
                  | none => none
                  | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                  | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
                  fun y' => some (x' ^^^ y')
            | some { toFin := ⟨0, ⋯⟩ } => some 0#1
      ⊢ False
  [Meta.isDefEq] [0.001021] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match some (x✝ ^^^ 1#1) with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#1
      | some { toFin := ⟨0, ⋯⟩ } =>
        match some x✝ with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝²
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001037] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match some (x✝ ^^^ 1#1) with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#1
      | some { toFin := ⟨0, ⋯⟩ } =>
        match some x✝ with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝²
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001012] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match some (x✝ ^^^ 1#1) with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#1
      | some { toFin := ⟨0, ⋯⟩ } =>
        match some x✝ with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝²
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001231] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match
          match some (x✝ ^^^ 1#1) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some 1#1
        | some { toFin := ⟨0, ⋯⟩ } =>
          match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝²
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } =>
        Option.bind
          (match some (x✝ ^^^ 1#1) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
          fun x' =>
          Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
            fun y' => some (x' + y')
      | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001297] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match
          match some (x✝ ^^^ 1#1) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some 1#1
        | some { toFin := ⟨0, ⋯⟩ } =>
          match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝²
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } =>
        Option.bind
          (match some (x✝ ^^^ 1#1) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
          fun x' =>
          Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
            fun y' => some (x' + y')
      | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001266] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match
          match some (x✝ ^^^ 1#1) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some 1#1
        | some { toFin := ⟨0, ⋯⟩ } =>
          match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝²
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } =>
        Option.bind
          (match some (x✝ ^^^ 1#1) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
          fun x' =>
          Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
            fun y' => some (x' + y')
      | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001246] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match
          match some (x✝ ^^^ 1#1) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some 1#1
        | some { toFin := ⟨0, ⋯⟩ } =>
          match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝²
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } =>
        Option.bind
          (match some (x✝ ^^^ 1#1) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
          fun a =>
          Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
            fun a_1 => some (a ^^^ a_1)
      | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001305] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match
          match some (x✝ ^^^ 1#1) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some 1#1
        | some { toFin := ⟨0, ⋯⟩ } =>
          match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝²
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } =>
        Option.bind
          (match some (x✝ ^^^ 1#1) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
          fun a =>
          Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
            fun a_1 => some (a ^^^ a_1)
      | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001301] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match
          match some (x✝ ^^^ 1#1) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some 1#1
        | some { toFin := ⟨0, ⋯⟩ } =>
          match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝²
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } =>
        Option.bind
          (match some (x✝ ^^^ 1#1) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
          fun a =>
          Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
            fun a_1 => some (a ^^^ a_1)
      | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001034] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match some (x✝ ^^^ 1#1) with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#1
      | some { toFin := ⟨0, ⋯⟩ } =>
        match some x✝ with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝²
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001228] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match
          match some (x✝ ^^^ 1#1) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some 1#1
        | some { toFin := ⟨0, ⋯⟩ } =>
          match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝²
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } =>
        Option.bind
          (match some (x✝ ^^^ 1#1) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
          fun a =>
          Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
            fun a_1 => some (a ^^^ a_1)
      | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001280] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match
          match some (x✝ ^^^ 1#1) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some 1#1
        | some { toFin := ⟨0, ⋯⟩ } =>
          match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝²
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } =>
        Option.bind
          (match some (x✝ ^^^ 1#1) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
          fun a =>
          Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
            fun a_1 => some (a ^^^ a_1)
      | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001263] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match
          match some (x✝ ^^^ 1#1) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some 1#1
        | some { toFin := ⟨0, ⋯⟩ } =>
          match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝²
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } =>
        Option.bind
          (match some (x✝ ^^^ 1#1) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
          fun a =>
          Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
            fun a_1 => some (a ^^^ a_1)
      | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 1
      x✝² x✝¹ x✝ : BitVec 1
      a✝ :
        ¬(match
              match
                match some (x✝ ^^^ 1#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
                | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 1#1
              | some { toFin := ⟨0, ⋯⟩ } =>
                match some x✝ with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } =>
              Option.bind
                (match some (x✝ ^^^ 1#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
                | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
                fun a =>
                Option.bind
                  (match some x✝ with
                  | none => none
                  | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                  | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
                  fun a_1 => some (a ^^^ a_1)
            | some { toFin := ⟨0, ⋯⟩ } => some 0#1) ⊑
            match
              match some x✝ with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝²
              | some { toFin := ⟨0, ⋯⟩ } => some x✝¹ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } =>
              Option.bind
                (match some (x✝ ^^^ 1#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
                | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
                fun a =>
                Option.bind
                  (match some x✝ with
                  | none => none
                  | some { toFin := ⟨1, ⋯⟩ } => some x✝²
                  | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
                  fun a_1 => some (a ^^^ a_1)
            | some { toFin := ⟨0, ⋯⟩ } => some 0#1
      ⊢ False
  [Meta.isDefEq] [0.001031] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match some (x✝ ^^^ 1#1) with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#1
      | some { toFin := ⟨0, ⋯⟩ } =>
        match some x✝ with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝²
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001041] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match some (x✝ ^^^ 1#1) with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#1
      | some { toFin := ⟨0, ⋯⟩ } =>
        match some x✝ with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝²
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001026] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match some (x✝ ^^^ 1#1) with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#1
      | some { toFin := ⟨0, ⋯⟩ } =>
        match some x✝ with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝²
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001240] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match
          match some (x✝ ^^^ 1#1) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some 1#1
        | some { toFin := ⟨0, ⋯⟩ } =>
          match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝²
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } =>
        Option.bind
          (match some (x✝ ^^^ 1#1) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
          fun a =>
          Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
            fun a_1 => some (a ^^^ a_1)
      | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001304] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match
          match some (x✝ ^^^ 1#1) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some 1#1
        | some { toFin := ⟨0, ⋯⟩ } =>
          match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝²
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } =>
        Option.bind
          (match some (x✝ ^^^ 1#1) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
          fun a =>
          Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
            fun a_1 => some (a ^^^ a_1)
      | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001297] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match
          match some (x✝ ^^^ 1#1) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some 1#1
        | some { toFin := ⟨0, ⋯⟩ } =>
          match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝²
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } =>
        Option.bind
          (match some (x✝ ^^^ 1#1) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
          fun a =>
          Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
            fun a_1 => some (a ^^^ a_1)
      | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001017] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match some (x✝ ^^^ 1#1) with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#1
      | some { toFin := ⟨0, ⋯⟩ } =>
        match some x✝ with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝²
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001008] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match some (x✝ ^^^ 1#1) with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 1#1
      | some { toFin := ⟨0, ⋯⟩ } =>
        match some x✝ with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some x✝²
        | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001229] ❌️ match none with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match
          match some (x✝ ^^^ 1#1) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some 1#1
        | some { toFin := ⟨0, ⋯⟩ } =>
          match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝²
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } =>
        Option.bind
          (match some (x✝ ^^^ 1#1) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
          fun a =>
          Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
            fun a_1 => some (a ^^^ a_1)
      | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001278] ❌️ match some { toFin := ⟨1, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match
          match some (x✝ ^^^ 1#1) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some 1#1
        | some { toFin := ⟨0, ⋯⟩ } =>
          match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝²
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } =>
        Option.bind
          (match some (x✝ ^^^ 1#1) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
          fun a =>
          Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
            fun a_1 => some (a ^^^ a_1)
      | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.isDefEq] [0.001251] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match
        match
          match some (x✝ ^^^ 1#1) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
        | none => none
        | some { toFin := ⟨1, ⋯⟩ } => some 1#1
        | some { toFin := ⟨0, ⋯⟩ } =>
          match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝²
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1 with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } =>
        Option.bind
          (match some (x✝ ^^^ 1#1) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
          fun a =>
          Option.bind
            (match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝²
            | some { toFin := ⟨0, ⋯⟩ } => some 0#1)
            fun a_1 => some (a ^^^ a_1)
      | some { toFin := ⟨0, ⋯⟩ } => some 0#1
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:175:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:175:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/glogicalhselecthinseltpoison_proof.lean:167:8: error: (kernel) declaration has metavariables 'allSignBits_thm'
[bv] [0.061724] Normalizing goal
  [Meta.synthInstance] [0.001399] ✅️ Decidable
        ((if 31#32 ≥ ↑32 then none
          else
            if 31#32 ≥ ↑32 then none
            else some (x✝ &&& x✝¹.sshiftRight (31#32).toNat ||| (x✝¹.sshiftRight (31#32).toNat ^^^ -1#32) &&& x✝²)) ⊑
          Option.bind
            (match some (BitVec.ofBool (0#32 >ₛ x✝¹)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
            fun a =>
            Option.bind
              (match some (BitVec.ofBool (0#32 >ₛ x✝¹)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some 0#32
              | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
              fun y' => some (a ||| y'))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬(if 31#32 ≥ ↑32 then none
            else
              if 31#32 ≥ ↑32 then none
              else some (x✝ &&& x✝¹.sshiftRight (31#32).toNat ||| (x✝¹.sshiftRight (31#32).toNat ^^^ -1#32) &&& x✝²)) ⊑
            Option.bind
              (match some (BitVec.ofBool (0#32 >ₛ x✝¹)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
              fun a =>
              Option.bind
                (match some (BitVec.ofBool (0#32 >ₛ x✝¹)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some 0#32
                | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
                fun y' => some (a ||| y')
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e e_1 e_2 : LLVM.IntW 32
      x✝² x✝¹ x✝ : BitVec 32
      a✝ :
        ¬some (x✝ &&& x✝¹.sshiftRight 31 ||| (x✝¹.sshiftRight 31 ^^^ 4294967295#32) &&& x✝²) ⊑
            Option.bind
              (match some (if (!x✝¹.getLsbD 31 == (0#32 >ᵤ x✝¹)) = true then 1#1 else 0#1) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
              fun a =>
              Option.bind
                (match some (if (!x✝¹.getLsbD 31 == (0#32 >ᵤ x✝¹)) = true then 1#1 else 0#1) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some 0#32
                | some { toFin := ⟨0, ⋯⟩ } => some x✝²)
                fun a_1 => some (a ||| a_1)
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
