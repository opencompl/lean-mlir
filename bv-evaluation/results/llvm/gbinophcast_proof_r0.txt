⚠ [676/892] Replayed SSA.Experimental.Bits.AutoStructs.ForLean
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:24:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:27:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:29:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:31:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:34:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:36:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:38:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:41:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:52:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/ForLean.lean:56:8: declaration uses 'sorry'
⚠ [882/892] Replayed SSA.Experimental.Bits.Fast.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:107:8: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/Fast/FiniteStateMachine.lean:825:8: declaration uses 'sorry'
⚠ [885/892] Replayed SSA.Experimental.Bits.Fast.Tactic
warning: ././././SSA/Experimental/Bits/Fast/Tactic.lean:340:4: declaration uses 'sorry'
⚠ [887/892] Replayed SSA.Experimental.Bits.AutoStructs.Constructions
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:55:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:128:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:163:6: declaration uses 'sorry'
warning: ././././SSA/Experimental/Bits/AutoStructs/Constructions.lean:197:6: declaration uses 'sorry'
⚠ [888/892] Replayed SSA.Experimental.Bits.AutoStructs.FiniteStateMachine
warning: ././././SSA/Experimental/Bits/AutoStructs/FiniteStateMachine.lean:111:8: declaration uses 'sorry'
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophcast_proof.lean:16:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophcast_proof.lean:11:8: error: (kernel) declaration has metavariables 'and_sext_to_sel_thm'
[bv] [0.023611] Normalizing goal
  [Meta.synthInstance] [0.001780] ✅️ Decidable
        (some (BitVec.signExtend 32 x✝ &&& x✝¹) ⊑
          match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
          | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      e_1 : LLVM.IntW 1
      x✝¹ : BitVec 32
      x✝ : BitVec 1
      a✝ :
        ¬some (BitVec.signExtend 32 x✝ &&& x✝¹) ⊑
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      e_1 : LLVM.IntW 1
      x✝¹ : BitVec 32
      x✝ : BitVec 1
      a✝ :
        ¬some (BitVec.signExtend 32 x✝ &&& x✝¹) ⊑
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝¹
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophcast_proof.lean:25:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophcast_proof.lean:20:8: error: (kernel) declaration has metavariables 'or_sext_to_sel_thm'
[bv] [0.029200] Normalizing goal
  [Meta.synthInstance] [0.001378] ✅️ Decidable
        (some (BitVec.signExtend 32 x✝ ||| x✝¹) ⊑
          match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
          | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      e_1 : LLVM.IntW 1
      x✝¹ : BitVec 32
      x✝ : BitVec 1
      a✝ :
        ¬some (BitVec.signExtend 32 x✝ ||| x✝¹) ⊑
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some (-1#32)
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      e_1 : LLVM.IntW 1
      x✝¹ : BitVec 32
      x✝ : BitVec 1
      a✝ :
        ¬some (BitVec.signExtend 32 x✝ ||| x✝¹) ⊑
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 4294967295#32
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
Bitwuzla proved the goal after 66.107210ms, solving context: 1.000000ms
LeanSAT proved the goal after 68.158630ms: rewriting 8.858460ms, bitblasting 0.000000ms, SAT solving 56.665640ms, LRAT trimming 0.000000ms, LRAT checking 1.384210ms
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophcast_proof.lean:44:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophcast_proof.lean:38:8: error: (kernel) declaration has metavariables 'and_add_bool_to_select_thm'
[bv] [0.024067] Normalizing goal
  [Meta.synthInstance] [0.001434] ✅️ Decidable
        (some (-1#32 + BitVec.zeroExtend 32 x✝ &&& x✝¹) ⊑
          match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some 0#32
          | some { toFin := ⟨0, ⋯⟩ } => some x✝¹)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      e_1 : LLVM.IntW 1
      x✝¹ : BitVec 32
      x✝ : BitVec 1
      a✝ :
        ¬some (-1#32 + BitVec.zeroExtend 32 x✝ &&& x✝¹) ⊑
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 0#32
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      e_1 : LLVM.IntW 1
      x✝¹ : BitVec 32
      x✝ : BitVec 1
      a✝ :
        ¬some (4294967295#32 + BitVec.zeroExtend 32 x✝ &&& x✝¹) ⊑
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 0#32
            | some { toFin := ⟨0, ⋯⟩ } => some x✝¹
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophcast_proof.lean:55:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophcast_proof.lean:48:8: error: (kernel) declaration has metavariables 'and_add_bool_no_fold_thm'
[bv] [0.035841] Normalizing goal
  [Meta.synthInstance] [0.001648] ✅️ Decidable
        (some (-1#32 + (x✝ &&& 1#32) &&& x✝) ⊑
          match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some x✝
          | some { toFin := ⟨0, ⋯⟩ } => some 0#32)
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬some (-1#32 + (x✝ &&& 1#32) &&& x✝) ⊑
            match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32
      ⊢ False
  [Meta.appBuilder] [0.001449] ✅️ f: Eq.mp, xs: [congrArg
         (fun x =>
           ¬some (4294967295#32 + (x✝ &&& 1#32) &&& x✝) ⊑
               match some x with
               | none => none
               | some { toFin := ⟨1, .(Fin.ofNat'.proof_1 (2 ^ 1) 1)⟩ } => some x✝
               | some { toFin := ⟨0, .(Fin.ofNat'.proof_1 (2 ^ 1) 0)⟩ } => some 0#32)
         (Std.Tactic.BVDecide.Normalize.BitVec.ofBool_eq_if (x✝ &&& 1#32 == 0#32)),
       a✝]
    [Meta.isDefEq] [0.001325] ✅️ ¬some (4294967295#32 + (x✝ &&& 1#32) &&& x✝) ⊑
            match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝
            | some { toFin := ⟨0, ⋯⟩ } =>
              some 0#32 =?= ¬some (-1#32 + (x✝ &&& 1#32) &&& x✝) ⊑
            match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32
      [Meta.isDefEq] [0.001316] ✅️ ¬some (4294967295#32 + (x✝ &&& 1#32) &&& x✝) ⊑
              match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝
              | some { toFin := ⟨0, ⋯⟩ } =>
                some
                  0#32 =?= ¬some (-1#32 + (x✝ &&& 1#32) &&& x✝) ⊑
              match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
              | none => none
              | some { toFin := ⟨1, ⋯⟩ } => some x✝
              | some { toFin := ⟨0, ⋯⟩ } => some 0#32
        [Meta.isDefEq.delta] [0.001304] ✅️ ¬some (4294967295#32 + (x✝ &&& 1#32) &&& x✝) ⊑
                match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝
                | some { toFin := ⟨0, ⋯⟩ } =>
                  some
                    0#32 =?= ¬some (-1#32 + (x✝ &&& 1#32) &&& x✝) ⊑
                match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝
                | some { toFin := ⟨0, ⋯⟩ } => some 0#32
          [Meta.isDefEq] [0.001300] ✅️ some (4294967295#32 + (x✝ &&& 1#32) &&& x✝) ⊑
                match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝
                | some { toFin := ⟨0, ⋯⟩ } =>
                  some
                    0#32 =?= some (-1#32 + (x✝ &&& 1#32) &&& x✝) ⊑
                match some (BitVec.ofBool (x✝ &&& 1#32 == 0#32)) with
                | none => none
                | some { toFin := ⟨1, ⋯⟩ } => some x✝
                | some { toFin := ⟨0, ⋯⟩ } => some 0#32
            [Meta.isDefEq] [0.001247] ✅️ some
                  (4294967295#32 + (x✝ &&& 1#32) &&& x✝) =?= some (-1#32 + (x✝ &&& 1#32) &&& x✝)
              [Meta.isDefEq] [0.001228] ✅️ 4294967295#32 + (x✝ &&& 1#32) &&& x✝ =?= -1#32 + (x✝ &&& 1#32) &&& x✝
                [Meta.isDefEq] [0.001201] ✅️ instHAndOfAndOp.1 (4294967295#32 + (x✝ &&& 1#32))
                      x✝ =?= instHAndOfAndOp.1 (-1#32 + (x✝ &&& 1#32)) x✝
                  [Meta.isDefEq] [0.001141] ✅️ AndOp.and (4294967295#32 + (x✝ &&& 1#32))
                        x✝ =?= AndOp.and (-1#32 + (x✝ &&& 1#32)) x✝
                    [Meta.isDefEq] [0.001116] ✅️ BitVec.instAndOp.1 (4294967295#32 + (x✝ &&& 1#32))
                          x✝ =?= BitVec.instAndOp.1 (-1#32 + (x✝ &&& 1#32)) x✝
                      [Meta.isDefEq] [0.001069] ✅️ (4294967295#32 + (x✝ &&& 1#32)).and
                            x✝ =?= (-1#32 + (x✝ &&& 1#32)).and x✝
                        [Meta.isDefEq.delta] [0.001057] ✅️ (4294967295#32 + (x✝ &&& 1#32)).and
                              x✝ =?= (-1#32 + (x✝ &&& 1#32)).and x✝
                          [Meta.isDefEq] [0.001029] ✅️ 4294967295#32 + (x✝ &&& 1#32) =?= -1#32 + (x✝ &&& 1#32)
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      x✝ : BitVec 32
      a✝ :
        ¬some (4294967295#32 + (x✝ &&& 1#32) &&& x✝) ⊑
            match some (if (x✝ &&& 1#32 == 0#32) = true then 1#1 else 0#1) with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some x✝
            | some { toFin := ⟨0, ⋯⟩ } => some 0#32
      ⊢ False
  [Meta.Tactic.bv] Pipeline reached a fixpoint
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophcast_proof.lean:66:4: error: None of the hypotheses are in the supported BitVec fragment.
There are two potential fixes for this:
1. If you are using custom BitVec constructs simplify them to built-in ones.
2. If your problem is using only built-in ones it might currently be out of reach.
   Consider expressing it in terms of different operations that are better supported.
/home/tobiascgrosser/Projects/lean-mlir/SSA/Projects/InstCombine/tests/proofs/gbinophcast_proof.lean:59:8: error: (kernel) declaration has metavariables 'and_add_bool_to_select_multi_use_thm'
[bv] [0.031333] Normalizing goal
  [Meta.synthInstance] [0.001475] ✅️ Decidable
        (some ((-1#32 + BitVec.zeroExtend 32 x✝ &&& x✝¹) + (-1#32 + BitVec.zeroExtend 32 x✝)) ⊑
          match some x✝ with
          | none => none
          | some { toFin := ⟨1, ⋯⟩ } => some 0#32
          | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ + -1#32))
  [Meta.Tactic.bv] Running preprocessing pipeline on:
      case h
      e : LLVM.IntW 32
      e_1 : LLVM.IntW 1
      x✝¹ : BitVec 32
      x✝ : BitVec 1
      a✝ :
        ¬some ((-1#32 + BitVec.zeroExtend 32 x✝ &&& x✝¹) + (-1#32 + BitVec.zeroExtend 32 x✝)) ⊑
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 0#32
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ + -1#32)
      ⊢ False
  [Meta.Tactic.bv] Rerunning pipeline on:
      case h
      e : LLVM.IntW 32
      e_1 : LLVM.IntW 1
      x✝¹ : BitVec 32
      x✝ : BitVec 1
      a✝ :
        ¬some ((4294967295#32 + BitVec.zeroExtend 32 x✝ &&& x✝¹) + (4294967295#32 + BitVec.zeroExtend 32 x✝)) ⊑
            match some x✝ with
            | none => none
            | some { toFin := ⟨1, ⋯⟩ } => some 0#32
            | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ + 4294967295#32)
      ⊢ False
  [Meta.isDefEq] [0.001109] ❌️ match some { toFin := ⟨0, ⋯⟩ } with
      | none => ?h_1 ()
      | some { toFin := ⟨1, ⋯⟩ } => ?h_2 ()
      | some { toFin := ⟨0, ⋯⟩ } => ?h_3 () =?= match some x✝ with
      | none => none
      | some { toFin := ⟨1, ⋯⟩ } => some 0#32
      | some { toFin := ⟨0, ⋯⟩ } => some (x✝¹ + 4294967295#32)
  [Meta.Tactic.bv] Pipeline reached a fixpoint
