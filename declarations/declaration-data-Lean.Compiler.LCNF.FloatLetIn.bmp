{"name":"Lean.Compiler.LCNF.FloatLetIn","instances":[{"typeNames":["Lean.Compiler.LCNF.FloatLetIn.Decision"],"name":"Lean.Compiler.LCNF.FloatLetIn.instHashableDecision","className":"Hashable"},{"typeNames":["Lean.Compiler.LCNF.FloatLetIn.Decision"],"name":"Lean.Compiler.LCNF.FloatLetIn.instBEqDecision","className":"BEq"},{"typeNames":["Lean.Compiler.LCNF.FloatLetIn.Decision"],"name":"Lean.Compiler.LCNF.FloatLetIn.instInhabitedDecision","className":"Inhabited"},{"typeNames":["Lean.Compiler.LCNF.FloatLetIn.Decision"],"name":"Lean.Compiler.LCNF.FloatLetIn.instReprDecision","className":"Repr"}],"imports":["Init","Lean.Compiler.LCNF.CompilerM","Lean.Compiler.LCNF.FVarUtil","Lean.Compiler.LCNF.PassManager","Lean.Compiler.LCNF.Types"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L305-L306","name":"Lean.Compiler.LCNF.floatLetIn","kind":"def","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.floatLetIn","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L302-L303","name":"Lean.Compiler.LCNF.Decl.floatLetIn","kind":"def","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.Decl.floatLetIn","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L263-L298","name":"Lean.Compiler.LCNF.FloatLetIn.floatLetIn.go","kind":"opaque","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.FloatLetIn.floatLetIn.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L249-L261","name":"Lean.Compiler.LCNF.FloatLetIn.floatLetIn.goCases","kind":"def","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.FloatLetIn.floatLetIn.goCases","doc":"Iterate through the collected declarations,\ndetermining from the bottom up whether they (and the declarations they refer to)\nshould get moved down into the arms of the cases statement or not.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L240-L298","name":"Lean.Compiler.LCNF.FloatLetIn.floatLetIn","kind":"def","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.FloatLetIn.floatLetIn","doc":"Iterate throgh `decl`, pushing local declarations that are only used in one\ncontrol flow arm into said arm in order to avoid useless computations.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L229-L234","name":"Lean.Compiler.LCNF.FloatLetIn.float.goFVar","kind":"def","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.FloatLetIn.float.goFVar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L224-L234","name":"Lean.Compiler.LCNF.FloatLetIn.float","kind":"def","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.FloatLetIn.float","doc":"Will:\n- put `decl` into the arm it is marked to be moved into\n- for any variables that might occur in `decl` and are of interest:\n  - if they are already meant to be floated into the same arm or not at all leave them untouched:\n    ```\n    let x := ...\n    let y := x + z\n    cases z with\n    | n => x * y\n    | m => z\n    ```\n    If we are at `y` `x` is alreayd marked to be floated into `n` as well.\n  - if there hasn't be a decision yet, that is they are marked with `.unknown` we float\n    them into the same arm as the current value:\n    ```\n    let x := ..\n    let y := x + 2\n    cases z with\n    | n => y\n    | m => z\n    ```\n    Here `x` is initially marked as `.unknown` since it occurs in no branch, however\n    since we want to move `y` into the `n` branch we can also decide to move `x`\n    into the `n` branch. Note that this decision might be revoked later on in the case of:\n    ```\n    let x := ..\n    let a := x + 1\n    let y := x + 2\n    cases z with\n    | n => y\n    | m => a\n    ```\n    When we visit `a` `x` is now marked as getting moved into `n` but since it also occurs\n    in `a` which wants to be moved somewhere else we will instead decide to not move `x`\n    at all.\n  - if they are meant to be floated somewhere else decide that they wont get floated:\n    ```\n    let x := ...\n    let y := x + z\n    cases z with\n    | n => y\n    | m => x\n    ```\n    If we are at `y` `x` is still marked to be moved but we don't want that.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L174-L176","name":"Lean.Compiler.LCNF.FloatLetIn.dontFloat.goFVar","kind":"def","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.FloatLetIn.dontFloat.goFVar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L170-L176","name":"Lean.Compiler.LCNF.FloatLetIn.dontFloat","kind":"def","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.FloatLetIn.dontFloat","doc":"Will:\n- put `decl` into the `dont` arm\n- decide that any free variable that occurs in `decl` and is a declaration\n  of interest as not getting moved either.\n```\nlet x := ...\nlet y := ...\nlet z := x + y\ncases z with\n| n => z * x\n| m => z * y\n```\nHere `x` and `y` are originally marked as getting floated into `n` and `m`\nrespectively but since `z` can't be moved we don't want that to move `x` and `y`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L149-L152","name":"Lean.Compiler.LCNF.FloatLetIn.initialNewArms","kind":"def","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.FloatLetIn.initialNewArms","doc":"Compute the initial new arms. This will just set up a map from all arms of\n`cs` to empty `Array`s, plus one additional entry for `dont`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L142-L143","name":"Lean.Compiler.LCNF.FloatLetIn.initialDecisions.goCases","kind":"def","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.FloatLetIn.initialDecisions.goCases","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L140-L141","name":"Lean.Compiler.LCNF.FloatLetIn.initialDecisions.goAlt","kind":"def","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.FloatLetIn.initialDecisions.goAlt","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L132-L137","name":"Lean.Compiler.LCNF.FloatLetIn.initialDecisions.goFVar","kind":"def","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.FloatLetIn.initialDecisions.goFVar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L118-L143","name":"Lean.Compiler.LCNF.FloatLetIn.initialDecisions","kind":"def","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.FloatLetIn.initialDecisions","doc":"Compute the initial decision for all declarations that `BaseFloatM` collected\nup to this point, with respect to `cs`. The initial decisions are:\n- `dont` if the declaration is detected by `ignore?`\n- `dont` if the declaration is the discriminant of `cs` since we obviously need\n  the discriminant to be computed before the match.\n- `dont` if we see the declaration being used in more than one cases arm\n- `arm` or `default` if we see the declaration only being used in exactly one cases arm\n- `unknown` otherwise\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L100-L106","name":"Lean.Compiler.LCNF.FloatLetIn.ignore?","kind":"def","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.FloatLetIn.ignore?","doc":"Whether to ignore `decl` for the floating mechanism. We want to do this if:\n- `decl`' is storing a typeclass instance\n- `decl` is a projection from a variable that is storing a typeclass instance\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L91-L93","name":"Lean.Compiler.LCNF.FloatLetIn.withNewScope","kind":"def","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.FloatLetIn.withNewScope","doc":"Run `x` with an empty list of declarations.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L84-L86","name":"Lean.Compiler.LCNF.FloatLetIn.withNewCandidate","kind":"def","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.FloatLetIn.withNewCandidate","doc":"Add `decl` to the list of declarations and run `x` with that updated context.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L79-L79","name":"Lean.Compiler.LCNF.FloatLetIn.FloatM","kind":"def","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.FloatLetIn.FloatM","doc":"Use to compute the actual floating.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L74-L74","name":"Lean.Compiler.LCNF.FloatLetIn.BaseFloatM","kind":"def","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.FloatLetIn.BaseFloatM","doc":"Use to collect relevant declarations for the floating mechanism.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L69-L69","name":"Lean.Compiler.LCNF.FloatLetIn.FloatState.newArms","kind":"def","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.FloatLetIn.FloatState.newArms","doc":"A map from decisions (excluding `unknown`) to the declarations with\nthese decisions (in correct order). Basically:\n- Which declarations do we not move\n- Which declarations do we move into a certain arm\n- Which declarations do we move into the default arm\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L61-L61","name":"Lean.Compiler.LCNF.FloatLetIn.FloatState.decision","kind":"def","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.FloatLetIn.FloatState.decision","doc":"A map from identifiers of declarations to their current decision.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L57-L69","name":"Lean.Compiler.LCNF.FloatLetIn.FloatState","kind":"structure","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.FloatLetIn.FloatState","doc":"The state for `FloatM`\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L52-L52","name":"Lean.Compiler.LCNF.FloatLetIn.BaseFloatContext.decls","kind":"def","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.FloatLetIn.BaseFloatContext.decls","doc":"All the declarations that were collected in the current LCNF basic\nblock up to the current statement (in reverse order for efficiency).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L47-L52","name":"Lean.Compiler.LCNF.FloatLetIn.BaseFloatContext","kind":"structure","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.FloatLetIn.BaseFloatContext","doc":"The context for `BaseFloatM`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L40-L42","name":"Lean.Compiler.LCNF.FloatLetIn.Decision.ofAlt","kind":"def","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.FloatLetIn.Decision.ofAlt","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L38-L38","name":"Lean.Compiler.LCNF.FloatLetIn.instReprDecision","kind":"instance","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.FloatLetIn.instReprDecision","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L38-L38","name":"Lean.Compiler.LCNF.FloatLetIn.instInhabitedDecision","kind":"instance","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.FloatLetIn.instInhabitedDecision","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L38-L38","name":"Lean.Compiler.LCNF.FloatLetIn.instBEqDecision","kind":"instance","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.FloatLetIn.instBEqDecision","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L38-L38","name":"Lean.Compiler.LCNF.FloatLetIn.instHashableDecision","kind":"instance","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.FloatLetIn.instHashableDecision","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L33-L37","name":"Lean.Compiler.LCNF.FloatLetIn.Decision.unknown","kind":"ctor","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.FloatLetIn.Decision.unknown","doc":"No decision has been made yet.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L28-L32","name":"Lean.Compiler.LCNF.FloatLetIn.Decision.dont","kind":"ctor","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.FloatLetIn.Decision.dont","doc":"Dont move this declaration it is needed where it is right now.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L24-L27","name":"Lean.Compiler.LCNF.FloatLetIn.Decision.default","kind":"ctor","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.FloatLetIn.Decision.default","doc":"Push into the default arm.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L19-L23","name":"Lean.Compiler.LCNF.FloatLetIn.Decision.arm","kind":"ctor","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.FloatLetIn.Decision.arm","doc":"Push into the arm with name `name`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L18-L38","name":"Lean.Compiler.LCNF.FloatLetIn.Decision","kind":"inductive","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.FloatLetIn.Decision","doc":"The decision of the float mechanism.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L1-L1","name":"Lean.Compiler.LCNF.FloatLetIn.FloatState.mk","kind":"ctor","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.FloatLetIn.FloatState.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Compiler/LCNF/FloatLetIn.lean#L1-L1","name":"Lean.Compiler.LCNF.FloatLetIn.BaseFloatContext.mk","kind":"ctor","docLink":"./Lean/Compiler/LCNF/FloatLetIn.html#Lean.Compiler.LCNF.FloatLetIn.BaseFloatContext.mk","doc":""}]}