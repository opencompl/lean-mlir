{"name":"Lean.Elab.PreDefinition.Structural.FindRecArg","instances":[],"imports":["Init","Lean.Elab.PreDefinition.Structural.Basic"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/PreDefinition/Structural/FindRecArg.lean#L74-L137","name":"Lean.Elab.Structural.findRecArg.go","kind":"opaque","docLink":"./Lean/Elab/PreDefinition/Structural/FindRecArg.html#Lean.Elab.Structural.findRecArg.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/PreDefinition/Structural/FindRecArg.lean#L58-L139","name":"Lean.Elab.Structural.findRecArg","kind":"def","docLink":"./Lean/Elab/PreDefinition/Structural/FindRecArg.html#Lean.Elab.Structural.findRecArg","doc":"Try to find an argument that is structurally smaller in every recursive application.\nWe use this argument to justify termination using the auxiliary `brecOn` construction.\n\nWe give preference for arguments that are *not* indices of inductive types of other arguments.\nSee issue #837 for an example where we can show termination using the index of an inductive family, but\nwe don't get the desired definitional equalities.\n\nWe perform two passes. In the first-pass, we only consider arguments that are not indices.\nIn the second pass, we consider them.\n\nTODO: explore whether there are better solutions, and whether there are other ways to break the heuristic used\nfor creating the smart unfolding auxiliary definition.\n"}]}