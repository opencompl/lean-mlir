{"name":"Lean.Meta.Coe","instances":[],"imports":["Init","Lean.Meta.WHNF","Lean.Meta.Transform","Lean.Meta.SynthInstance","Lean.Meta.AppBuilder"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/Coe.lean#L203-L210","name":"Lean.Meta.coerce?","kind":"def","docLink":"./Lean/Meta/Coe.html#Lean.Meta.coerce?","doc":"Coerces `expr` to the type `expectedType`.\nReturns `.some coerced` on successful coercion,\n`.none` if the expression cannot by coerced to that type,\nor `.undef` if we need more metavariable assignments. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/Coe.lean#L155-L197","name":"Lean.Meta.coerceMonadLift?","kind":"def","docLink":"./Lean/Meta/Coe.html#Lean.Meta.coerceMonadLift?","doc":"Try coercions and monad lifts to make sure `e` has type `expectedType`.\n\nIf `expectedType` is of the form `n β`, we try monad lifts and other extensions.\n\nExtensions for monads.\n\n1. Try to unify `n` and `m`. If it succeeds, then we use\n  ```\n  coeM {m : Type u → Type v} {α β : Type u} [∀ a, CoeT α a β] [Monad m] (x : m α) : m β\n  ```\n  `n` must be a `Monad` to use this one.\n\n2. If there is monad lift from `m` to `n` and we can unify `α` and `β`, we use\n  ```\n  liftM : ∀ {m : Type u_1 → Type u_2} {n : Type u_1 → Type u_3} [self : MonadLiftT m n] {α : Type u_1}, m α → n α\n  ```\n  Note that `n` may not be a `Monad` in this case. This happens quite a bit in code such as\n  ```\n  def g (x : Nat) : IO Nat := do\n    IO.println x\n    pure x\n\n  def f {m} [MonadLiftT IO m] : m Nat :=\n    g 10\n\n  ```\n\n3. If there is a monad lift from `m` to `n` and a coercion from `α` to `β`, we use\n  ```\n  liftCoeM {m : Type u → Type v} {n : Type u → Type w} {α β : Type u} [MonadLiftT m n] [∀ a, CoeT α a β] [Monad n] (x : m α) : n β\n  ```\n\nNote that approach 3 does not subsume 1 because it is only applicable if there is a coercion from `α` to `β` for all values in `α`.\nThis is not the case for example for `pure $ x > 0` when the expected type is `IO Bool`. The given type is `IO Prop`, and\nwe only have a coercion from decidable propositions.  Approach 1 works because it constructs the coercion `CoeT (m Prop) (pure $ x > 0) (m Bool)`\nusing the instance `pureCoeDepProp`.\n\nNote that, approach 2 is more powerful than `tryCoe`.\nRecall that type class resolution never assigns metavariables created by other modules.\nNow, consider the following scenario\n```lean\ndef g (x : Nat) : IO Nat := ...\ndeg h (x : Nat) : StateT Nat IO Nat := do\nv ← g x;\nIO.Println v;\n...\n```\nLet's assume there is no other occurrence of `v` in `h`.\nThus, we have that the expected of `g x` is `StateT Nat IO ?α`,\nand the given type is `IO Nat`. So, even if we add a coercion.\n```\ninstance {α m n} [MonadLiftT m n] {α} : Coe (m α) (n α) := ...\n```\nIt is not applicable because TC would have to assign `?α := Nat`.\nOn the other hand, TC can easily solve `[MonadLiftT IO (StateT Nat IO)]`\nsince this goal does not contain any metavariables. And then, we\nconvert `g x` into `liftM $ g x`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/Coe.lean#L92-L94","name":"Lean.Meta.isMonadApp","kind":"def","docLink":"./Lean/Meta/Coe.html#Lean.Meta.isMonadApp","doc":"Return `true` if `type` is of the form `m α` where `m` is a `Monad`.\nNote that we reduce `type` using transparency `[reducible]`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/Coe.lean#L82-L86","name":"Lean.Meta.isTypeApp?","kind":"def","docLink":"./Lean/Meta/Coe.html#Lean.Meta.isTypeApp?","doc":"Return `some (m, α)` if `type` can be reduced to an application of the form `m α` using `[reducible]` transparency. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/Coe.lean#L69-L79","name":"Lean.Meta.coerceToSort?","kind":"def","docLink":"./Lean/Meta/Coe.html#Lean.Meta.coerceToSort?","doc":"Coerces `expr` to a type. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/Coe.lean#L56-L66","name":"Lean.Meta.coerceToFunction?","kind":"def","docLink":"./Lean/Meta/Coe.html#Lean.Meta.coerceToFunction?","doc":"Coerces `expr` to a function type. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/Coe.lean#L41-L53","name":"Lean.Meta.coerceSimple?","kind":"def","docLink":"./Lean/Meta/Coe.html#Lean.Meta.coerceSimple?","doc":"Coerces `expr` to `expectedType` using `CoeT`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/Coe.lean#L35-L38","name":"Lean.Meta.autoLift","kind":"opaque","docLink":"./Lean/Meta/Coe.html#Lean.Meta.autoLift","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/Coe.lean#L24-L33","name":"Lean.Meta.expandCoe","kind":"def","docLink":"./Lean/Meta/Coe.html#Lean.Meta.expandCoe","doc":"Expand coercions occurring in `e` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/Coe.lean#L20-L21","name":"Lean.Meta.isCoeDecl","kind":"def","docLink":"./Lean/Meta/Coe.html#Lean.Meta.isCoeDecl","doc":"Return true iff `declName` is one of the auxiliary definitions/projections\nused to implement coercions.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/Coe.lean#L13-L14","name":"Lean.Meta.coeDeclAttr","kind":"opaque","docLink":"./Lean/Meta/Coe.html#Lean.Meta.coeDeclAttr","doc":""}]}