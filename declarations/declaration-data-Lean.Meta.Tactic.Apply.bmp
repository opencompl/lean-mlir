{"name":"Lean.Meta.Tactic.Apply","instances":[],"imports":["Init","Lean.Util.FindMVar","Lean.Meta.SynthInstance","Lean.Meta.CollectMVars","Lean.Meta.Tactic.Util"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Meta/Tactic/Apply.lean#L215-L222","name":"Lean.MVarId.exfalso","kind":"def","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.MVarId.exfalso","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Meta/Tactic/Apply.lean#L212-L213","name":"Lean.Meta.splitAnd","kind":"def","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.splitAnd","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Meta/Tactic/Apply.lean#L208-L209","name":"Lean.MVarId.splitAnd","kind":"def","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.MVarId.splitAnd","doc":"Apply `And.intro` as much as possible to goal `mvarId`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Meta/Tactic/Apply.lean#L190-L200","name":"Lean.Meta.splitAndCore.go","kind":"opaque","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.splitAndCore.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Meta/Tactic/Apply.lean#L182-L203","name":"Lean.Meta.splitAndCore","kind":"def","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.splitAndCore","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Meta/Tactic/Apply.lean#L179-L180","name":"Lean.Meta.apply","kind":"def","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.apply","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Meta/Tactic/Apply.lean#L153-L164","name":"Lean.MVarId.apply.go","kind":"def","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.MVarId.apply.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Meta/Tactic/Apply.lean#L121-L176","name":"Lean.MVarId.apply","kind":"def","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.MVarId.apply","doc":"Close the given goal using `apply e`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Meta/Tactic/Apply.lean#L79-L82","name":"Lean.Meta.postprocessAppMVars","kind":"def","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.postprocessAppMVars","doc":"If `synthAssignedInstances` is `true`, then `apply` will synthesize instance implicit arguments\neven if they have assigned by `isDefEq`, and then check whether the synthesized value matches the\none inferred. The `congr` tactic sets this flag to false.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Meta/Tactic/Apply.lean#L60-L72","name":"Lean.Meta.appendParentTag","kind":"def","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.appendParentTag","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Meta/Tactic/Apply.lean#L50-L58","name":"Lean.Meta.synthAppInstances","kind":"def","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.synthAppInstances","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Meta/Tactic/Apply.lean#L43-L45","name":"Lean.Meta.getExpectedNumArgs","kind":"def","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.getExpectedNumArgs","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Meta/Tactic/Apply.lean#L39-L41","name":"Lean.Meta.getExpectedNumArgsAux","kind":"def","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.getExpectedNumArgsAux","doc":"Compute the number of expected arguments and whether the result type is of the form\n(?m ...) where ?m is an unassigned metavariable.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Meta/Tactic/Apply.lean#L33-L33","name":"Lean.Meta.ApplyConfig.approx","kind":"def","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyConfig.approx","doc":"If `approx := true`, then we turn on `isDefEq` approximations. That is, we use\nthe `approxDefEq` combinator.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Meta/Tactic/Apply.lean#L28-L28","name":"Lean.Meta.ApplyConfig.synthAssignedInstances","kind":"def","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyConfig.synthAssignedInstances","doc":"If `synthAssignedInstances` is `true`, then `apply` will synthesize instance implicit arguments\neven if they have assigned by `isDefEq`, and then check whether the synthesized value matches the\none inferred. The `congr` tactic sets this flag to false.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Meta/Tactic/Apply.lean#L22-L22","name":"Lean.Meta.ApplyConfig.newGoals","kind":"def","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyConfig.newGoals","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Meta/Tactic/Apply.lean#L21-L33","name":"Lean.Meta.ApplyConfig","kind":"structure","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyConfig","doc":"Configures the behaviour of the `apply` tactic. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Meta/Tactic/Apply.lean#L18-L18","name":"Lean.Meta.ApplyNewGoals.all","kind":"ctor","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals.all","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Meta/Tactic/Apply.lean#L18-L18","name":"Lean.Meta.ApplyNewGoals.nonDependentOnly","kind":"ctor","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals.nonDependentOnly","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Meta/Tactic/Apply.lean#L18-L18","name":"Lean.Meta.ApplyNewGoals.nonDependentFirst","kind":"ctor","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals.nonDependentFirst","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Meta/Tactic/Apply.lean#L17-L18","name":"Lean.Meta.ApplyNewGoals","kind":"inductive","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals","doc":"Controls which new mvars are turned in to goals by the `apply` tactic.\n- `nonDependentFirst`  mvars that don't depend on other goals appear first in the goal list.\n- `nonDependentOnly` only mvars that don't depend on other goals are added to goal list.\n- `all` all unassigned mvars are added to the goal list.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Meta/Tactic/Apply.lean#L1-L1","name":"Lean.Meta.ApplyConfig.mk","kind":"ctor","docLink":"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyConfig.mk","doc":""}]}