{"name":"Init.System.Mutex","instances":[{"typeNames":["IO.BaseMutex"],"name":"IO.instNonemptyBaseMutex","className":"Nonempty"},{"typeNames":["IO.Condvar"],"name":"IO.instNonemptyCondvar","className":"Nonempty"},{"typeNames":["IO.Mutex"],"name":"IO.instNonemptyMutex","className":"Nonempty"},{"typeNames":["IO.Mutex","IO.BaseMutex"],"name":"IO.instCoeOutMutexBaseMutex","className":"CoeOut"}],"imports":["Init.System.IO","Init.Control.StateRef"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/System/Mutex.lean#L113-L119","name":"IO.Mutex.atomicallyOnce","kind":"def","docLink":"./Init/System/Mutex.html#IO.Mutex.atomicallyOnce","doc":"`mutex.atomicallyOnce condvar pred k` runs `k`,\nwaiting on `condvar` until `pred` returns true.\nBoth `k` and `pred` have access to the mutex's state.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/System/Mutex.lean#L100-L106","name":"IO.Mutex.atomically","kind":"def","docLink":"./Init/System/Mutex.html#IO.Mutex.atomically","doc":"`mutex.atomically k` runs `k` with access to the mutex's state while locking the mutex. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/System/Mutex.lean#L97-L97","name":"IO.AtomicT","kind":"def","docLink":"./Init/System/Mutex.html#IO.AtomicT","doc":"`AtomicT α m` is the monad that can be atomically executed inside a `Mutex α`,\nwith outside monad `m`.\nThe action has access to the state `α` of the mutex (via `get` and `set`).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/System/Mutex.lean#L89-L90","name":"IO.Mutex.new","kind":"def","docLink":"./Init/System/Mutex.html#IO.Mutex.new","doc":"Creates a new mutex. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/System/Mutex.lean#L86-L86","name":"IO.instCoeOutMutexBaseMutex","kind":"instance","docLink":"./Init/System/Mutex.html#IO.instCoeOutMutexBaseMutex","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/System/Mutex.lean#L84-L84","name":"IO.instNonemptyMutex","kind":"instance","docLink":"./Init/System/Mutex.html#IO.instNonemptyMutex","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/System/Mutex.lean#L83-L83","name":"IO.Mutex.mutex","kind":"def","docLink":"./Init/System/Mutex.html#IO.Mutex.mutex","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/System/Mutex.lean#L81-L84","name":"IO.Mutex","kind":"structure","docLink":"./Init/System/Mutex.html#IO.Mutex","doc":"Mutual exclusion primitive (lock) guarding shared state of type `α`.\n\nThe type `Mutex α` is similar to `IO.Ref α`,\nexcept that concurrent accesses are guarded by a mutex\ninstead of atomic pointer operations and busy-waiting.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/System/Mutex.lean#L69-L72","name":"IO.Condvar.waitUntil","kind":"def","docLink":"./Init/System/Mutex.html#IO.Condvar.waitUntil","doc":"Waits on the condition variable until the predicate is true. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/System/Mutex.lean#L66-L66","name":"IO.Condvar.notifyAll","kind":"opaque","docLink":"./Init/System/Mutex.html#IO.Condvar.notifyAll","doc":"Wakes up all other threads executing `wait`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/System/Mutex.lean#L62-L62","name":"IO.Condvar.notifyOne","kind":"opaque","docLink":"./Init/System/Mutex.html#IO.Condvar.notifyOne","doc":"Wakes up a single other thread executing `wait`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/System/Mutex.lean#L58-L58","name":"IO.Condvar.wait","kind":"opaque","docLink":"./Init/System/Mutex.html#IO.Condvar.wait","doc":"Waits until another thread calls `notifyOne` or `notifyAll`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/System/Mutex.lean#L54-L54","name":"IO.Condvar.new","kind":"opaque","docLink":"./Init/System/Mutex.html#IO.Condvar.new","doc":"Creates a new condition variable. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/System/Mutex.lean#L50-L50","name":"IO.instNonemptyCondvar","kind":"instance","docLink":"./Init/System/Mutex.html#IO.instNonemptyCondvar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/System/Mutex.lean#L48-L48","name":"IO.Condvar","kind":"def","docLink":"./Init/System/Mutex.html#IO.Condvar","doc":"Condition variable. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/System/Mutex.lean#L43-L43","name":"IO.BaseMutex.unlock","kind":"opaque","docLink":"./Init/System/Mutex.html#IO.BaseMutex.unlock","doc":"Unlocks a `BaseMutex`.\n\nThe current thread must have already locked the mutex.\nUnlocking an unlocked mutex is undefined behavior (inherited from the C++ implementation).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/System/Mutex.lean#L34-L34","name":"IO.BaseMutex.lock","kind":"opaque","docLink":"./Init/System/Mutex.html#IO.BaseMutex.lock","doc":"Locks a `BaseMutex`.  Waits until no other thread has locked the mutex.\n\nThe current thread must not have already locked the mutex.\nReentrant locking is undefined behavior (inherited from the C++ implementation).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/System/Mutex.lean#L25-L25","name":"IO.BaseMutex.new","kind":"opaque","docLink":"./Init/System/Mutex.html#IO.BaseMutex.new","doc":"Creates a new `BaseMutex`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/System/Mutex.lean#L21-L21","name":"IO.instNonemptyBaseMutex","kind":"instance","docLink":"./Init/System/Mutex.html#IO.instNonemptyBaseMutex","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Init/System/Mutex.lean#L19-L19","name":"IO.BaseMutex","kind":"def","docLink":"./Init/System/Mutex.html#IO.BaseMutex","doc":"Mutual exclusion primitive (a lock).\n\nIf you want to guard shared state, use `Mutex α` instead.\n"}]}