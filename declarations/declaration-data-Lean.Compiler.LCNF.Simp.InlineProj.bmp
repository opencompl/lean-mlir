{"name":"Lean.Compiler.LCNF.Simp.InlineProj","instances":[],"imports":["Init","Lean.Compiler.LCNF.Simp.SimpM"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Compiler/LCNF/Simp/InlineProj.lean#L77-L82","name":"Lean.Compiler.LCNF.Simp.inlineProjInst?.visitCode","kind":"opaque","docLink":"./Lean/Compiler/LCNF/Simp/InlineProj.html#Lean.Compiler.LCNF.Simp.inlineProjInst?.visitCode","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Compiler/LCNF/Simp/InlineProj.lean#L50-L75","name":"Lean.Compiler.LCNF.Simp.inlineProjInst?.visit","kind":"opaque","docLink":"./Lean/Compiler/LCNF/Simp/InlineProj.html#Lean.Compiler.LCNF.Simp.inlineProjInst?.visit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Compiler/LCNF/Simp/InlineProj.lean#L37-L82","name":"Lean.Compiler.LCNF.Simp.inlineProjInst?","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/InlineProj.html#Lean.Compiler.LCNF.Simp.inlineProjInst?","doc":"Auxiliary function for projecting \"type class dictionary access\".\nThat is, we are trying to extract one of the type class instance elements.\nRemark: We do not consider parent instances to be elements.\nFor example, suppose `e` is `_x_4.1`, and we have\n```\n_x_2 : Monad (ReaderT Bool (ExceptT String Id)) := @ReaderT.Monad Bool (ExceptT String Id) _x_1\n_x_3 : Applicative (ReaderT Bool (ExceptT String Id)) := _x_2.1\n_x_4 : Functor (ReaderT Bool (ExceptT String Id)) := _x_3.1\n```\nThen, we will expand `_x_4.1` since it corresponds to the `Functor` `map` element,\nand its type is not a type class, but is of the form\n```\n{α β : Type u} → (α → β) → ...\n```\nIn the example above, the compiler should not expand `_x_3.1` or `_x_2.1` because they are\ntype class applications: `Functor` and `Applicative` respectively.\nBy eagerly expanding them, we may produce inefficient and bloated code.\nFor example, we may be using `_x_3.1` to invoke a function that expects a `Functor` instance.\nBy expanding `_x_3.1` we will be just expanding the code that creates this instance.\n\nThe result is representing a sequence of code containing let-declarations and local function declarations (`Array CodeDecl`)\nand the free variable containing the result (`FVarId`). The resulting `FVarId` often depends only on a small\nsubset of `Array CodeDecl`. However, this method does try to filter the relevant ones.\nWe rely on the `used` var set available in `SimpM` to filter them. See `attachCodeDecls`.\n"}]}