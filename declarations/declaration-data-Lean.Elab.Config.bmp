{"name":"Lean.Elab.Config","instances":[],"imports":["Init","Lean.Meta.Basic"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Config.lean#L56-L57","name":"Lean.Elab.Term.setElabConfig","kind":"def","docLink":"./Lean/Elab/Config.html#Lean.Elab.Term.setElabConfig","doc":"Set `isDefEq` configuration for the elaborator.\nNote that we enable all approximations but `quasiPatternApprox`\n\nIn Lean3 and Lean 4, we used to use the quasi-pattern approximation during elaboration.\nThe example:\n```\ndef ex : StateT δ (StateT σ Id) σ :=\nmonadLift (get : StateT σ Id σ)\n```\ndemonstrates why it produces counterintuitive behavior.\nWe have the `Monad-lift` application:\n```\n@monadLift ?m ?n ?c ?α (get : StateT σ id σ) : ?n ?α\n```\nIt produces the following unification problem when we process the expected type:\n```\n?n ?α =?= StateT δ (StateT σ id) σ\n==> (approximate using first-order unification)\n?n := StateT δ (StateT σ id)\n?α := σ\n```\nThen, we need to solve:\n```\n?m ?α =?= StateT σ id σ\n==> instantiate metavars\n?m σ =?= StateT σ id σ\n==> (approximate since it is a quasi-pattern unification constraint)\n?m := fun σ => StateT σ id σ\n```\nNote that the constraint is not a Milner pattern because σ is in\nthe local context of `?m`. We are ignoring the other possible solutions:\n```\n?m := fun σ' => StateT σ id σ\n?m := fun σ' => StateT σ' id σ\n?m := fun σ' => StateT σ id σ'\n```\n\nWe need the quasi-pattern approximation for elaborating recursor-like expressions (e.g., dependent `match with` expressions).\n\nIf we had use first-order unification, then we would have produced\nthe right answer: `?m := StateT σ id`\n\nHaskell would work on this example since it always uses\nfirst-order unification.\n"}]}