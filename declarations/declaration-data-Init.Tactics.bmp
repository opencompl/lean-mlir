{"name":"Init.Tactics","instances":[],"imports":["Init.Notation"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L838-L839","name":"«term__[_]'_»","kind":"def","docLink":"./Init/Tactics.html#«term__[_]'_»","doc":"The syntax `arr[i]` gets the `i`'th element of the collection `arr`.\nIf there are proof side conditions to the application, they will be automatically\ninferred by the `get_elem_tactic` tactic.\n\nThe actual behavior of this class is type-dependent,\nbut here are some important implementations:\n* `arr[i] : α` where `arr : Array α` and `i : Nat` or `i : USize`:\n  does array indexing with no bounds check and a proof side goal `i < arr.size`.\n* `l[i] : α` where `l : List α` and `i : Nat`: index into a list,\n  with proof side goal `i < l.length`.\n* `stx[i] : Syntax` where `stx : Syntax` and `i : Nat`: get a syntax argument,\n  no side goal (returns `.missing` out of range)\n\nThere are other variations on this syntax:\n* `arr[i]`: proves the proof side goal by `get_elem_tactic`\n* `arr[i]!`: panics if the side goal is false\n* `arr[i]?`: returns `none` if the side goal is false\n* `arr[i]'h`: uses `h` to prove the side goal\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L834-L835","name":"«term__[_]»","kind":"def","docLink":"./Init/Tactics.html#«term__[_]»","doc":"The syntax `arr[i]` gets the `i`'th element of the collection `arr`.\nIf there are proof side conditions to the application, they will be automatically\ninferred by the `get_elem_tactic` tactic.\n\nThe actual behavior of this class is type-dependent,\nbut here are some important implementations:\n* `arr[i] : α` where `arr : Array α` and `i : Nat` or `i : USize`:\n  does array indexing with no bounds check and a proof side goal `i < arr.size`.\n* `l[i] : α` where `l : List α` and `i : Nat`: index into a list,\n  with proof side goal `i < l.length`.\n* `stx[i] : Syntax` where `stx : Syntax` and `i : Nat`: get a syntax argument,\n  no side goal (returns `.missing` out of range)\n\nThere are other variations on this syntax:\n* `arr[i]`: proves the proof side goal by `get_elem_tactic`\n* `arr[i]!`: panics if the side goal is false\n* `arr[i]?`: returns `none` if the side goal is false\n* `arr[i]'h`: uses `h` to prove the side goal\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L824-L832","name":"tacticGet_elem_tactic","kind":"def","docLink":"./Init/Tactics.html#tacticGet_elem_tactic","doc":"`get_elem_tactic` is the tactic automatically called by the notation `arr[i]`\nto prove any side conditions that arise when constructing the term\n(e.g. the index is in bounds of the array). It just delegates to\n`get_elem_tactic_trivial` and gives a diagnostic error message otherwise;\nusers are encouraged to extend `get_elem_tactic_trivial` instead of this tactic.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L804-L812","name":"tacticGet_elem_tactic_trivial","kind":"def","docLink":"./Init/Tactics.html#tacticGet_elem_tactic_trivial","doc":"`get_elem_tactic_trivial` is an extensible tactic automatically called\nby the notation `arr[i]` to prove any side conditions that arise when\nconstructing the term (e.g. the index is in bounds of the array).\nThe default behavior is to just try `trivial` (which handles the case\nwhere `i < arr.size` is in the context) and `simp_arith`\n(for doing linear arithmetic in the index).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L795-L801","name":"«term‹_›»","kind":"def","docLink":"./Init/Tactics.html#«term‹_›»","doc":"`‹t›` resolves to an (arbitrary) hypothesis of type `t`.\nIt is useful for referring to hypotheses without accessible names.\n`t` may contain holes that are solved by unification with the expected type;\nin particular, `‹_›` is a shortcut for `by assumption`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L746-L789","name":"Lean.Parser.Attr.simp","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Attr.simp","doc":"Theorems tagged with the `simp` attribute are by the simplifier\n(i.e., the `simp` tactic, and its variants) to simplify expressions occurring in your goals.\nWe call theorems tagged with the `simp` attribute \"simp theorems\" or \"simp lemmas\".\nLean maintains a database/index containing all active simp theorems.\nHere is an example of a simp theorem.\n```lean\n@[simp] theorem ne_eq (a b : α) : (a ≠ b) = Not (a = b) := rfl\n```\nThis simp theorem instructs the simplifier to replace instances of the term\n`a ≠ b` (e.g. `x + 0 ≠ y`) with `Not (a = b)` (e.g., `Not (x + 0 = y)`).\nThe simplifier applies simp theorems in one direction only:\nif `A = B` is a simp theorem, then `simp` replaces `A`s with `B`s,\nbut it doesn't replace `B`s with `A`s. Hence a simp theorem should have the\nproperty that its right-hand side is \"simpler\" than its left-hand side.\nIn particular, `=` and `↔` should not be viewed as symmetric operators in this situation.\nThe following would be a terrible simp theorem (if it were even allowed):\n```lean\n@[simp] lemma mul_right_inv_bad (a : G) : 1 = a * a⁻¹ := ...\n```\nReplacing 1 with a * a⁻¹ is not a sensible default direction to travel.\nEven worse would be a theorem that causes expressions to grow without bound,\ncausing simp to loop forever.\n\nBy default the simplifier applies `simp` theorems to an expression `e`\nafter its sub-expressions have been simplified.\nWe say it performs a bottom-up simplification.\nYou can instruct the simplifier to apply a theorem before its sub-expressions\nhave been simplified by using the modifier `↓`. Here is an example\n```lean\n@[simp↓] theorem not_and_eq (p q : Prop) : (¬ (p ∧ q)) = (¬p ∨ ¬q) :=\n```\n\nWhen multiple simp theorems are applicable, the simplifier uses the one with highest priority.\nIf there are several with the same priority, it is uses the \"most recent one\". Example:\n```lean\n@[simp high] theorem cond_true (a b : α) : cond true a b = a := rfl\n@[simp low+1] theorem or_true (p : Prop) : (p ∨ True) = True :=\n  propext <| Iff.intro (fun _ => trivial) (fun _ => Or.inr trivial)\n@[simp 100] theorem ite_self {d : Decidable c} (a : α) : ite c a a = a := by\n  cases d <;> rfl\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L733-L741","name":"Lean.Parser.Tactic.congr","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.congr","doc":"Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ HEq (f as) (f bs)`.\nThe optional parameter is the depth of the recursive applications.\nThis is useful when `congr` is too aggressive in breaking down the goal.\nFor example, given `⊢ f (g (x + y)) = f (g (y + x))`,\n`congr` produces the goals `⊢ x = y` and `⊢ y = x`,\nwhile `congr 2` produces the intended `⊢ x + y = y + x`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L730-L731","name":"Lean.Parser.Tactic.«tacticExists_,,»","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.«tacticExists_,,»","doc":"`exists e₁, e₂, ...` is shorthand for `refine ⟨e₁, e₂, ...⟩; try trivial`.\nIt is useful for existential goals.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L720-L724","name":"Lean.Parser.Tactic.sleep","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.sleep","doc":"The tactic `sleep ms` sleeps for `ms` milliseconds and does nothing.\nIt is used for debugging purposes only.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L718-L718","name":"Lean.Parser.Tactic.save","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.save","doc":"`save` is defined to be the same as `skip`, but the elaborator has\nspecial handling for occurrences of `save` in tactic scripts and will transform\n`by tac1; save; tac2` to `by (checkpoint tac1); tac2`, meaning that the effect of `tac1`\nwill be cached and replayed. This is useful for improving responsiveness\nwhen working on a long tactic proof, by using `save` after expensive tactics.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L695-L706","name":"Lean.Parser.Tactic.checkpoint","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.checkpoint","doc":"`checkpoint tac` acts the same as `tac`, but it caches the input and output of `tac`,\nand if the file is re-elaborated and the input matches, the tactic is not re-run and\nits effects are reapplied to the state. This is useful for improving responsiveness\nwhen working on a long tactic proof, by wrapping expensive tactics with `checkpoint`.\n\nSee the `save` tactic, which may be more convenient to use.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L692-L693","name":"Lean.Parser.Tactic.fail","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.fail","doc":"`fail msg` is a tactic that always fails, and produces an error using the given message. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L690-L690","name":"Lean.Parser.Tactic.tacticUnhygienic_","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticUnhygienic_","doc":"`unhygienic tacs` runs `tacs` with name hygiene disabled.\nThis means that tactics that would normally create inaccessible names will instead\nmake regular variables. **Warning**: Tactics may change their variable naming\nstrategies at any time, so code that depends on autogenerated names is brittle.\nUsers should try not to use `unhygienic` if possible.\n```\nexample : ∀ x : Nat, x = x := by unhygienic\n  intro            -- x would normally be intro'd as inaccessible\n  exact Eq.refl x  -- refer to x\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L661-L669","name":"Lean.Parser.Tactic.specialize","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.specialize","doc":"The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`.\nThe premises of this hypothesis, either universal quantifications or\nnon-dependent implications, are instantiated by concrete terms coming\nfrom arguments `a₁` ... `aₙ`.\nThe tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ`\nand tries to clear the previous one.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L659-L659","name":"Lean.Parser.Tactic.tacticStop_","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticStop_","doc":"`stop` is a helper tactic for \"discarding\" the rest of a proof:\nit is defined as `repeat sorry`.\nIt is useful when working on the middle of a complex proofs,\nand less messy than commenting the remainder of the proof.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L642-L651","name":"Lean.Parser.Tactic.dbgTrace","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.dbgTrace","doc":"`dbg_trace \"foo\"` prints `foo` when elaborated.\nUseful for debugging tactic control flow:\n```\nexample : False ∨ True := by\n  first\n  | apply Or.inl; trivial; dbg_trace \"left\"\n  | apply Or.inr; trivial; dbg_trace \"right\"\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L628-L640","name":"Lean.Parser.Tactic.split","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.split","doc":"The `split` tactic is useful for breaking nested if-then-else and `match` expressions into separate cases.\nFor a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals.\n\nFor example, given `n : Nat`, and a target `if n = 0 then Q else R`, `split` will generate\none goal with hypothesis `n = 0` and target `Q`, and a second goal with hypothesis\n`¬n = 0` and target `R`.  Note that the introduced hypothesis is unnamed, and is commonly\nrenamed used the `case` or `next` tactics.\n\n- `split` will split the goal (target).\n- `split at h` will split the hypothesis `h`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L618-L626","name":"Lean.Parser.Tactic.tacticTrivial","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticTrivial","doc":"`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...)\nto close the current goal.\nYou can use the command `macro_rules` to extend the set of tactics used. Example:\n```\nmacro_rules | `(tactic| trivial) => `(tactic| simp)\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L609-L614","name":"Lean.Parser.Tactic.tacticRepeat_","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticRepeat_","doc":"`repeat tac` repeatedly applies `tac` to the main goal until it fails.\nThat is, if `tac` produces multiple subgoals, only subgoals up to the first failure will be visited.\nThe `Std` library provides `repeat'` which repeats separately in each subgoal.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L606-L607","name":"Lean.Parser.Tactic.renameI","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.renameI","doc":"`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L581-L604","name":"Lean.Parser.Tactic.cases","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.cases","doc":"Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L576-L580","name":"Lean.Parser.Tactic.casesTarget","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.casesTarget","doc":"A `cases` argument, of the form `e` or `h : e` (where `h` asserts that\n`e = cᵢ a b` for each constructor `cᵢ` of the inductive).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L567-L574","name":"Lean.Parser.Tactic.generalize","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.generalize","doc":"* `generalize ([h :] e = x),+` replaces all occurrences `e`s in the main goal\n  with a fresh hypothesis `x`s. If `h` is given, `h : e = x` is introduced as well.\n* `generalize e = x at h₁ ... hₙ` also generalizes occurrences of `e`\n  inside `h₁`, ..., `hₙ`.\n* `generalize e = x at *` will generalize occurrences of `e` everywhere.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L564-L565","name":"Lean.Parser.Tactic.generalizeArg","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.generalizeArg","doc":"A `generalize` argument, of the form `term = x` or `h : term = x`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L535-L562","name":"Lean.Parser.Tactic.induction","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.induction","doc":"Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a theorem whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,\n  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂`\n  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L529-L533","name":"Lean.Parser.Tactic.inductionAlts","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.inductionAlts","doc":"After `with`, there is an optional tactic that runs on all branches, and\nthen a list of alternatives.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L524-L528","name":"Lean.Parser.Tactic.inductionAlt","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.inductionAlt","doc":"In induction alternative, which can have 1 or more cases on the left\nand `_`, `?_`, or a tactic sequence after the `=>`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L518-L523","name":"Lean.Parser.Tactic.inductionAltLHS","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.inductionAltLHS","doc":"The left hand side of an induction arm, `| foo a b c` or `| @foo a b c`\nwhere `foo` is a constructor of the inductive type and `a b c` are the arguments\nto the contstructor.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L516-L516","name":"Lean.Parser.Tactic.tacticLet'_","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticLet'_","doc":"Similar to `let`, but using `refine'` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L514-L514","name":"Lean.Parser.Tactic.«tacticHave'_:=_»","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.«tacticHave'_:=_»","doc":"Similar to `have`, but using `refine'` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L512-L512","name":"Lean.Parser.Tactic.tacticHave'_","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticHave'_","doc":"Similar to `have`, but using `refine'` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L510-L510","name":"Lean.Parser.Tactic.tacticRefine_lift'_","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticRefine_lift'_","doc":"Similar to `refine_lift`, but using `refine'` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L503-L505","name":"Lean.Parser.Tactic.letrec","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.letrec","doc":"`let rec f : t := e` adds a recursive definition `f` to the current goal.\nThe syntax is the same as term-mode `let rec`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L502-L502","name":"Lean.Parser.Tactic.tacticShow_","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticShow_","doc":"`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L497-L497","name":"Lean.Parser.Tactic.tacticLet_","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticLet_","doc":"`let h : t := e` adds the hypothesis `h : t := e` to the current goal if `e` a term of type `t`.\nIf `t` is omitted, it will be inferred.\nThe variant `let pattern := e` is equivalent to `match e with | pattern => _`,\nand it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `let ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses\n`h₁ : p`, `h₂ : q`, and `h₃ : r`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L488-L488","name":"Lean.Parser.Tactic.tacticSuffices_","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticSuffices_","doc":"Given a main goal `ctx ⊢ t`, `suffices h : t' from e` replaces the main goal with `ctx ⊢ t'`,\n`e` must have type `t` in the context `ctx, h : t'`.\n\nThe variant `suffices h : t' by tac` is a shorthand for `suffices h : t' from by tac`.\nIf `h :` is omitted, the name `this` is used.\n "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L479-L479","name":"Lean.Parser.Tactic.tacticHave_","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticHave_","doc":"`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term\nof type `t`.\n* If `t` is omitted, it will be inferred.\n* If `h` is omitted, the name `this` is used.\n* The variant `have pattern := e` is equivalent to `match e with | pattern => _`,\n  and it is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L467-L467","name":"Lean.Parser.Tactic.tacticRefine_lift_","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticRefine_lift_","doc":"Auxiliary macro for lifting have/suffices/let/...\nIt makes sure the \"continuation\" `?_` is the main goal after refining.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L453-L461","name":"Lean.Parser.Tactic.unfold","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.unfold","doc":"* `unfold id` unfolds definition `id`.\n* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.\n\nFor non-recursive definitions, this tactic is identical to `delta`.\nFor definitions by pattern matching, it uses \"equation lemmas\" which are\nautogenerated for each match arm.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L446-L451","name":"Lean.Parser.Tactic.delta","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.delta","doc":"`delta id1 id2 ...` delta-expands the definitions `id1`, `id2`, ....\nThis is a low-level tactic, it will expose how recursive definitions have been\ncompiled by Lean.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L438-L444","name":"Lean.Parser.Tactic.dsimp","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.dsimp","doc":"The `dsimp` tactic is the definitional simplifier. It is similar to `simp` but only\napplies theorems that hold by reflexivity. Thus, the result is guaranteed to be\ndefinitionally equal to the input.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L430-L436","name":"Lean.Parser.Tactic.simpAll","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.simpAll","doc":"`simp_all` is a stronger version of `simp [*] at *` where the hypotheses and target\nare simplified multiple times until no simplication is applicable.\nOnly non-dependent propositional hypotheses are considered.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L408-L429","name":"Lean.Parser.Tactic.simp","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.simp","doc":"The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.\n  If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with\n  `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L406-L407","name":"Lean.Parser.Tactic.simpStar","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.simpStar","doc":"The simp lemma specification `*` means to rewrite with all hypotheses "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L404-L405","name":"Lean.Parser.Tactic.simpErase","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.simpErase","doc":"An erasure specification `-thm` says to remove `thm` from the simp set "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L397-L403","name":"Lean.Parser.Tactic.simpLemma","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.simpLemma","doc":"A simp lemma specification is:\n* optional `↑` or `↓` to specify use before or after entering the subterm\n* optional `←` to use the lemma backward\n* `thm` for the theorem to rewrite with\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L395-L396","name":"Lean.Parser.Tactic.simpPost","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.simpPost","doc":"Use this rewrite rule after entering the subterms "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L393-L394","name":"Lean.Parser.Tactic.simpPre","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.simpPre","doc":"Use this rewrite rule before entering the subterms "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L387-L391","name":"Lean.Parser.Tactic.discharger","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.discharger","doc":"The discharger clause of `simp` and related tactics.\nThis is a tactic used to discharge the side conditions on conditional rewrite rules.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L381-L385","name":"Lean.Parser.Tactic.injections","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.injections","doc":"`injections` applies `injection` to all hypotheses recursively\n(since `injection` can produce new hypotheses). Useful for destructing nested\nconstructor equalities like `(a::b::c) = (d::e::f)`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L366-L379","name":"Lean.Parser.Tactic.injection","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.injection","doc":"The `injection` tactic is based on the fact that constructors of inductive data\ntypes are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c t₁)`\nand `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.\nIf `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies\ninjectivity to derive the equality of all arguments of `t₁` and `t₂` placed in\nthe same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.\nTo use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types\n`a = c` and `b = d` to the main goal.\nThe tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L359-L364","name":"Lean.Parser.Tactic.rwSeq","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.rwSeq","doc":"`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L344-L354","name":"Lean.Parser.Tactic.rewriteSeq","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.rewriteSeq","doc":"`rewrite [e]` applies identity `e` as a rewrite rule to the target of the main goal.\nIf `e` is preceded by left arrow (`←` or `<-`), the rewrite is applied in the reverse direction.\nIf `e` is a defined constant, then the equational theorems associated with `e` are used.\nThis provides a convenient way to unfold `e`.\n- `rewrite [e₁, ..., eₙ]` applies the given rules sequentially.\n- `rewrite [e] at l` rewrites `e` at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L341-L342","name":"Lean.Parser.Tactic.rwRuleSeq","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.rwRuleSeq","doc":"A `rwRuleSeq` is a list of `rwRule` in brackets. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L335-L340","name":"Lean.Parser.Tactic.rwRule","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.rwRule","doc":"If `thm` is a theorem `a = b`, then as a rewrite rule,\n* `thm` means to replace `a` with `b`, and\n* `← thm` means to replace `b` with `a`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L328-L333","name":"Lean.Parser.Tactic.changeWith","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.changeWith","doc":"* `change a with b` will change occurrences of `a` to `b` in the goal,\n  assuming `a` and `b` are are definitionally equal.\n* `change a with b at h` similarly changes `a` to `b` in the type of hypothesis `h`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L320-L326","name":"Lean.Parser.Tactic.change","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.change","doc":"* `change tgt'` will change the goal from `tgt` to `tgt'`,\n  assuming these are definitionally equal.\n* `change t' at h` will change hypothesis `h : t` to have type `t'`, assuming\n  assuming `t` and `t'` are definitionally equal.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L309-L318","name":"Lean.Parser.Tactic.location","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.location","doc":"Location specifications are used by many tactics that can operate on either the\nhypotheses or the goal. It can have one of the forms:\n* 'empty' is not actually present in this syntax, but most tactics use\n  `(location)?` matchers. It means to target the goal only.\n* `at h₁ ... hₙ`: target the hypotheses `h₁`, ..., `hₙ`\n* `at h₁ h₂ ⊢`: target the hypotheses `h₁` and `h₂`, and the goal\n* `at *`: target all hypotheses and the goal\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L303-L307","name":"Lean.Parser.Tactic.locationHyp","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.locationHyp","doc":"A hypothesis location specification consists of 1 or more hypothesis references\nand optionally `⊢` denoting the goal.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L300-L301","name":"Lean.Parser.Tactic.locationWildcard","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.locationWildcard","doc":"The `*` location refers to all hypotheses and the goal. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L297-L298","name":"Lean.Parser.Tactic.config","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.config","doc":"Optional configuration option for tactics "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L295-L295","name":"Lean.Parser.Tactic.tacticInfer_instance","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticInfer_instance","doc":"`infer_instance` is an abbreviation for `exact inferInstance`.\nIt synthesizes a value of any target type by typeclass inference.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L289-L289","name":"Lean.Parser.Tactic.tacticAdmit","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticAdmit","doc":"`admit` is a shorthand for `exact sorry`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L286-L286","name":"Lean.Parser.Tactic.tacticSorry","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticSorry","doc":"The `sorry` tactic closes the goal using `sorryAx`. This is intended for stubbing out incomplete\nparts of a proof while still having a syntactically correct proof skeleton. Lean will give\na warning whenever a proof uses `sorry`, so you aren't likely to miss it, but\nyou can double check if a theorem depends on `sorry` by using\n`#print axioms my_thm` and looking for `sorryAx` in the axiom list.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L268-L277","name":"Lean.Parser.Tactic.acRfl","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.acRfl","doc":"`ac_rfl` proves equalities up to application of an associative and commutative operator.\n```\ninstance : IsAssociative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : IsCommutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L266-L266","name":"Lean.Parser.Tactic.tacticRfl'","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticRfl'","doc":"`rfl'` is similar to `rfl`, but disables smart unfolding and unfolds all kinds of definitions,\ntheorems included (relevant for declarations defined by well-founded recursion).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L260-L260","name":"Lean.Parser.Tactic.tacticRfl","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticRfl","doc":"`rfl` tries to close the current goal using reflexivity.\nThis is supposed to be an extensible tactic and users can add their own support\nfor new reflexive relations.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L252-L253","name":"Lean.Parser.Tactic.refl","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.refl","doc":"`eq_refl` is equivalent to `exact rfl`, but has a few optimizations. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L245-L250","name":"Lean.Parser.Tactic.«tactic_<;>_»","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.«tactic_<;>_»","doc":"`tac <;> tac'` runs `tac` on the main goal and `tac'` on each produced goal,\nconcatenating all goals produced by `tac'`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L239-L239","name":"Lean.Parser.Tactic.tacticTry_","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticTry_","doc":"`try tac` runs `tac` and succeeds even if `tac` failed. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L232-L236","name":"Lean.Parser.Tactic.rotateRight","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.rotateRight","doc":"Rotate the goals to the right by `n`. That is, take the goal at the back\nand push it to the front `n` times. If `n` is omitted, it defaults to `1`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L225-L230","name":"Lean.Parser.Tactic.rotateLeft","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.rotateLeft","doc":"`rotate_left n` rotates goals to the left by `n`. That is, `rotate_left 1`\ntakes the main goal and puts it to the back of the subgoal list.\nIf `n` is omitted, it defaults to `1`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L222-L223","name":"Lean.Parser.Tactic.first","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.first","doc":"`first | tac | ...` runs each `tac` until one succeeds, or else fails. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L216-L220","name":"Lean.Parser.Tactic.withUnfoldingAll","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.withUnfoldingAll","doc":"`with_unfolding_all tacs` excutes `tacs` using the `.all` transparency setting.\nIn this setting all definitions that are not opaque are unfolded.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L210-L214","name":"Lean.Parser.Tactic.withReducibleAndInstances","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.withReducibleAndInstances","doc":"`with_reducible_and_instances tacs` excutes `tacs` using the `.instances` transparency setting.\nIn this setting only definitions tagged as `[reducible]` or type class instances are unfolded.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L204-L208","name":"Lean.Parser.Tactic.withReducible","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.withReducible","doc":"`with_reducible tacs` excutes `tacs` using the reducible transparency setting.\nIn this setting only definitions tagged as `[reducible]` are unfolded.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L197-L202","name":"Lean.Parser.Tactic.paren","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.paren","doc":"`(tacs)` executes a list of tactics in sequence, without requiring that\nthe goal be closed at the end like `· tacs`. Like `by` itself, the tactics\ncan be either separated by newlines or `;`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L194-L195","name":"Lean.Parser.Tactic.failIfSuccess","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.failIfSuccess","doc":"`fail_if_success t` fails if the tactic `t` succeeds. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L191-L192","name":"Lean.Parser.Tactic.traceMessage","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.traceMessage","doc":"`trace msg` displays `msg` in the info view. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L188-L189","name":"Lean.Parser.Tactic.traceState","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.traceState","doc":"`trace_state` displays the current state in the info view. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L185-L186","name":"Lean.Parser.Tactic.done","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.done","doc":"`done` succeeds iff there are no remaining goals. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L182-L183","name":"Lean.Parser.Tactic.skip","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.skip","doc":"`skip` does nothing. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L176-L180","name":"Lean.Parser.Tactic.focus","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.focus","doc":"`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.\nUsually `· tac`, which enforces that the goal is closed by `tac`, should be preferred.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L170-L174","name":"Lean.Parser.Tactic.anyGoals","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.anyGoals","doc":"`any_goals tac` applies the tactic `tac` to every goal, and succeeds if at\nleast one application succeeds.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L167-L168","name":"Lean.Parser.Tactic.allGoals","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.allGoals","doc":"`all_goals tac` runs `tac` on each goal, concatenating the resulting goals, if any. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L165-L165","name":"Lean.Parser.Tactic.«tacticNext_=>_»","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.«tacticNext_=>_»","doc":"`next => tac` focuses on the next goal and solves it using `tac`, or else fails.\n`next x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses with\ninaccessible names to the given names.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L152-L158","name":"Lean.Parser.Tactic.case'","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.case'","doc":"`case'` is similar to the `case tag => tac` tactic, but does not ensure the goal\nhas been solved after applying `tac`, nor admits the goal if `tac` failed.\nRecall that `case` closes the goal using `sorry` when `tac` fails, and\nthe tactic execution is not interrupted.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L143-L150","name":"Lean.Parser.Tactic.case","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.case","doc":"* `case tag => tac` focuses on the goal with case name `tag` and solves it using `tac`,\n  or else fails.\n* `case tag x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses\n  with inaccessible names to the given names.\n* `case tag₁ | tag₂ => tac` is equivalent to `(case tag₁ => tac); (case tag₂ => tac)`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L137-L141","name":"Lean.Parser.Tactic.constructor","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.constructor","doc":"If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L131-L135","name":"Lean.Parser.Tactic.refine'","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.refine'","doc":"`refine' e` behaves like `refine e`, except that unsolved placeholders (`_`)\nand implicit parameters are also converted into new goals.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L124-L129","name":"Lean.Parser.Tactic.refine","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.refine","doc":"`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`)\nholes in `e` that are not solved by unification with the main goal's target type\nare converted into new goals, using the hole's name, if any, as the goal case name.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L119-L122","name":"Lean.Parser.Tactic.exact","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.exact","doc":"`exact e` closes the main goal if its target type matches that of `e`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L108-L117","name":"Lean.Parser.Tactic.apply","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.apply","doc":"`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L83-L106","name":"Lean.Parser.Tactic.contradiction","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.contradiction","doc":"`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n- Inductive type/family with no applicable constructors\n```lean\nexample (h : False) : p := by contradiction\n```\n- Injectivity of constructors\n```lean\nexample (h : none = some true) : p := by contradiction  --\n```\n- Decidable false proposition\n```lean\nexample (h : 2 + 2 = 3) : p := by contradiction\n```\n- Contradictory hypotheses\n```lean\nexample (h : p) (h' : ¬ p) : q := by contradiction\n```\n- Other simple contradictions such as\n```lean\nexample (x : Nat) (h : x ≠ x) : p := by contradiction\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L77-L81","name":"Lean.Parser.Tactic.assumption","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.assumption","doc":"`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L72-L75","name":"Lean.Parser.Tactic.substVars","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.substVars","doc":"Applies `subst` to all hypotheses of the form `h : x = t` or `h : t = x`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L65-L70","name":"Lean.Parser.Tactic.subst","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.subst","doc":"`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis\nof type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L59-L63","name":"Lean.Parser.Tactic.clear","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.clear","doc":"`clear x...` removes the given hypotheses, or fails if there are remaining\nreferences to a hypothesis.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L53-L57","name":"Lean.Parser.Tactic.revert","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.revert","doc":"`revert x...` is the inverse of `intro x...`: it moves the given hypotheses\ninto the main goal's target type.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L47-L51","name":"Lean.Parser.Tactic.rename","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.rename","doc":"`rename t => x` renames the most recent hypothesis whose type matches `t`\n(which may contain placeholders) to `x`, or fails if no such hypothesis could be found.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L41-L45","name":"Lean.Parser.Tactic.intros","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.intros","doc":"`intros x...` behaves like `intro x...`, but then keeps introducing (anonymous)\nhypotheses until goal is not of a function type.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L18-L39","name":"Lean.Parser.Tactic.intro","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.intro","doc":"Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Tactics.lean#L11-L16","name":"Lean.Parser.Tactic.withAnnotateState","kind":"def","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState","doc":"`with_annotate_state stx t` annotates the lexical range of `stx : Syntax` with\nthe initial and final state of running tactic `t`.\n"}]}