{"name":"Lean.Elab.App","instances":[{"typeNames":["Lean.Elab.Term.Arg"],"name":"Lean.Elab.Term.instToStringArg","className":"ToString"},{"typeNames":["Lean.Elab.Term.NamedArg"],"name":"Lean.Elab.Term.instToStringNamedArg","className":"ToString"}],"imports":["Init","Lean.Util.FindMVar","Lean.Parser.Term","Lean.Meta.KAbstract","Lean.Meta.Tactic.ElimInfo","Lean.Elab.Term","Lean.Elab.Binders","Lean.Elab.SyntheticMVars","Lean.Elab.Arg","Lean.Elab.RecAppSyntax"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L1493-L1493","name":"Lean.Elab.Term.elabProj","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.elabProj","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L1492-L1492","name":"Lean.Elab.Term.elabChoice","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.elabChoice","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L1484-L1490","name":"Lean.Elab.Term.elabExplicit","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.elabExplicit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L1477-L1482","name":"Lean.Elab.Term.elabPipeProj","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.elabPipeProj","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L1476-L1476","name":"Lean.Elab.Term.elabExplicitUniv","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.elabExplicitUniv","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L1475-L1475","name":"Lean.Elab.Term.elabDotIdent","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.elabDotIdent","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L1474-L1474","name":"Lean.Elab.Term.elabNamedPattern","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.elabNamedPattern","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L1473-L1473","name":"Lean.Elab.Term.elabIdent","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.elabIdent","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L1465-L1468","name":"Lean.Elab.Term.elabApp","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.elabApp","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L1253-L1254","name":"Lean.Elab.Term.elabExplicitUnivs","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.elabExplicitUnivs","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L987-L987","name":"Lean.Elab.Term.LValResolution.localRec","kind":"ctor","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.LValResolution.localRec","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L986-L986","name":"Lean.Elab.Term.LValResolution.const","kind":"ctor","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.LValResolution.const","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L985-L985","name":"Lean.Elab.Term.LValResolution.projIdx","kind":"ctor","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.LValResolution.projIdx","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L984-L984","name":"Lean.Elab.Term.LValResolution.projFn","kind":"ctor","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.LValResolution.projFn","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L983-L987","name":"Lean.Elab.Term.LValResolution","kind":"inductive","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.LValResolution","doc":"Auxiliary inductive datatype that represents the resolution of an `LVal`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L978-L980","name":"Lean.Elab.Term.elabAppArgs.isFirstOrder","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.elabAppArgs.isFirstOrder","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L959-L972","name":"Lean.Elab.Term.elabAppArgs.getElabAsElimExtraArgsPos","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.elabAppArgs.getElabAsElimExtraArgsPos","doc":"Collect extra argument positions that must be elaborated eagerly when using `elab_as_elim`.\nThe idea is that the contribute to motive inference. See comment at `ElamElim.Context.extraArgsPos`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L939-L953","name":"Lean.Elab.Term.elabAppArgs.elabAsElim?","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.elabAppArgs.elabAsElim?","doc":"Return `some info` if we should elaborate as an eliminator. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L907-L980","name":"Lean.Elab.Term.elabAppArgs","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.elabAppArgs","doc":"Elaborate a `f`-application using `namedArgs` and `args` as the arguments.\n- `expectedType?` the expected type if available. It is used to propagate typing information only. This method does **not** ensure the result has this type.\n- `explicit = true` when notation `@` is used, and implicit arguments are assumed to be provided at `namedArgs` and `args`.\n- `ellipsis = true` when notation `..` is used. That is, we add `_` for missing arguments.\n- `resultIsOutParamSupport` is used to control whether special support is used when processing applications of functions that return\n   output parameter of some local instance. Example:\n   ```\n   GetElem.getElem : {Cont : Type u_1} → {Idx : Type u_2} → {elem : Type u_3} → {dom : cont → idx → Prop} → [self : GetElem cont idx elem dom] → (xs : cont) → (i : idx) → dom xs i → elem\n   ```\n   The result type `elem` is the output parameter of the local instance `self`.\n   When this parameter is set to `true`, we execute `synthesizeSyntheticMVarsUsingDefault`. For additional details, see comment at\n   `ElabAppArgs.resultIsOutParam`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L847-L873","name":"Lean.Elab.Term.ElabElim.main","kind":"opaque","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabElim.main","doc":"Main loop of the `elimAsElab` procedure. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L840-L844","name":"Lean.Elab.Term.ElabElim.mkImplicitArg","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabElim.mkImplicitArg","doc":"Create an implicit argument using the given `BinderInfo`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L833-L837","name":"Lean.Elab.Term.ElabElim.saveArgInfo","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabElim.saveArgInfo","doc":"Save information for producing error messages. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L821-L822","name":"Lean.Elab.Term.ElabElim.addDiscr","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabElim.addDiscr","doc":"Push the given expression into the `discrs` field in the state. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L817-L818","name":"Lean.Elab.Term.ElabElim.setMotive","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabElim.setMotive","doc":"Set the `motive` field in the state. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L801-L814","name":"Lean.Elab.Term.ElabElim.getNextArg?","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabElim.getNextArg?","doc":"Return the next argument to be processed.\nThe result is `.none` if it is an implicit argument which was not provided using a named argument.\nThe result is `.undef` if `args` is empty and `namedArgs` does contain an entry for `binderName`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L765-L794","name":"Lean.Elab.Term.ElabElim.finalize","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabElim.finalize","doc":"Construct the resulting application after all discriminants have bee elaborated, and we have\nconsumed as many given arguments as possible.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L749-L759","name":"Lean.Elab.Term.ElabElim.revertArgs","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabElim.revertArgs","doc":"If the eliminator is over-applied, we \"revert\" the extra arguments. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L740-L746","name":"Lean.Elab.Term.ElabElim.mkMotive","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabElim.mkMotive","doc":"Infer the `motive` using the expected type by `kabstract`ing the discriminants. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L737-L737","name":"Lean.Elab.Term.ElabElim.M","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabElim.M","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L735-L735","name":"Lean.Elab.Term.ElabElim.State.motive?","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabElim.State.motive?","doc":"Store the metavariable used to represent the motive that will be computed at `finalize`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L733-L733","name":"Lean.Elab.Term.ElabElim.State.idx","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabElim.State.idx","doc":"Position of the next argument to be processed. We use it to decide whether the argument is the motive or a discriminant. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L731-L731","name":"Lean.Elab.Term.ElabElim.State.instMVars","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabElim.State.instMVars","doc":"Instance implicit arguments collected so far. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L729-L729","name":"Lean.Elab.Term.ElabElim.State.discrs","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabElim.State.discrs","doc":"Discriminants processed so far. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L727-L727","name":"Lean.Elab.Term.ElabElim.State.args","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabElim.State.args","doc":"User-provided arguments that still have to be processed. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L725-L725","name":"Lean.Elab.Term.ElabElim.State.namedArgs","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabElim.State.namedArgs","doc":"User-provided named arguments that still have to be processed. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L723-L723","name":"Lean.Elab.Term.ElabElim.State.fType","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabElim.State.fType","doc":"`f : fType "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L721-L721","name":"Lean.Elab.Term.ElabElim.State.f","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabElim.State.f","doc":"The resultant expression being built. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L719-L735","name":"Lean.Elab.Term.ElabElim.State","kind":"structure","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabElim.State","doc":"State of the `elab_as_elim` elaboration procedure. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L716-L716","name":"Lean.Elab.Term.ElabElim.Context.extraArgsPos","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabElim.Context.extraArgsPos","doc":"Position of additional arguments that should be elaborated eagerly\nbecause they can contribute to the motive inference procedure.\nFor example, in the following theorem the argument `h : a = b`\nshould be elaborated eagerly because it contains `b` which occurs\nin `motive b`.\n```\ntheorem Eq.subst' {α} {motive : α → Prop} {a b : α} (h : a = b) : motive a → motive b\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L705-L705","name":"Lean.Elab.Term.ElabElim.Context.expectedType","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabElim.Context.expectedType","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L704-L704","name":"Lean.Elab.Term.ElabElim.Context.elimInfo","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabElim.Context.elimInfo","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L703-L716","name":"Lean.Elab.Term.ElabElim.Context","kind":"structure","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabElim.Context","doc":"Context of the `elab_as_elim` elaboration procedure. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L682-L697","name":"Lean.Elab.Term.elabAsElim","kind":"opaque","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.elabAsElim","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L654-L676","name":"Lean.Elab.Term.ElabAppArgs.main","kind":"opaque","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabAppArgs.main","doc":"Elaborate function application arguments. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L226-L227","name":"Lean.Elab.Term.ElabAppArgs.eraseNamedArg","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabAppArgs.eraseNamedArg","doc":"Remove named argument with name `binderName` from `namedArgs`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L187-L189","name":"Lean.Elab.Term.ElabAppArgs.synthesizeAppInstMVars","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabAppArgs.synthesizeAppInstMVars","doc":"Try to synthesize metavariables are `instMVars` using type class resolution.\nThe ones that cannot be synthesized yet are registered.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L174-L181","name":"Lean.Elab.Term.ElabAppArgs.trySynthesizeAppInstMVars","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabAppArgs.trySynthesizeAppInstMVars","doc":"Try to synthesize metavariables are `instMVars` using type class resolution.\nThe ones that cannot be synthesized yet stay in the `instMVars` list.\nRemark: we use this method\n  - before trying to apply coercions to function,\n  - before unifying the expected type.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L161-L161","name":"Lean.Elab.Term.ElabAppArgs.M","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabAppArgs.M","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L159-L159","name":"Lean.Elab.Term.ElabAppArgs.State.resultTypeOutParam?","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabAppArgs.State.resultTypeOutParam?","doc":"If the result type may be the `outParam` of some local instance.\nSee comment at `Context.resultIsOutParamSupport`\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L154-L154","name":"Lean.Elab.Term.ElabAppArgs.State.propagateExpected","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabAppArgs.State.propagateExpected","doc":"The following field is used to implement the `propagateExpectedType` heuristic.\nIt is set to `true` true when `expectedType` still has to be propagated.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L149-L149","name":"Lean.Elab.Term.ElabAppArgs.State.instMVars","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabAppArgs.State.instMVars","doc":"Metavariables for the instance implicit arguments that have already been processed. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L147-L147","name":"Lean.Elab.Term.ElabAppArgs.State.toSetErrorCtx","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabAppArgs.State.toSetErrorCtx","doc":"Metavariables that we need to set the error context using the application being built. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L145-L145","name":"Lean.Elab.Term.ElabAppArgs.State.etaArgs","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabAppArgs.State.etaArgs","doc":"When named arguments are provided and explicit arguments occurring before them are missing,\nthe elaborator eta-expands the declaration. For example,\n```\ndef f (x y : Nat) := x + y\n#check f (y := 5)\n-- fun x => f x 5\n```\n`etaArgs` stores the fresh free variables for implementing the eta-expansion.\nWhen `..` is used, eta-expansion is disabled, and missing arguments are treated as `_`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L133-L133","name":"Lean.Elab.Term.ElabAppArgs.State.expectedType?","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabAppArgs.State.expectedType?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L132-L132","name":"Lean.Elab.Term.ElabAppArgs.State.namedArgs","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabAppArgs.State.namedArgs","doc":"remaining named arguments to be processed. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L130-L130","name":"Lean.Elab.Term.ElabAppArgs.State.args","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabAppArgs.State.args","doc":"Remaining regular arguments. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L128-L128","name":"Lean.Elab.Term.ElabAppArgs.State.fType","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabAppArgs.State.fType","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L127-L127","name":"Lean.Elab.Term.ElabAppArgs.State.f","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabAppArgs.State.f","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L126-L159","name":"Lean.Elab.Term.ElabAppArgs.State","kind":"structure","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabAppArgs.State","doc":"Auxiliary structure for elaborating the application `f args namedArgs`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L123-L123","name":"Lean.Elab.Term.ElabAppArgs.Context.resultIsOutParamSupport","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabAppArgs.Context.resultIsOutParamSupport","doc":"If the result type of an application is the `outParam` of some local instance, then special support may be needed\nbecause type class resolution interacts poorly with coercions in this kind of situation.\nThis flag enables the special support.\n\nThe idea is quite simple, if the result type is the `outParam` of some local instance, we simply\nexecute `synthesizeSyntheticMVarsUsingDefault`. We added this feature to make sure examples as follows\nare correctly elaborated.\n```lean\nclass GetElem (Cont : Type u) (Idx : Type v) (Elem : outParam (Type w)) where\n  getElem (xs : Cont) (i : Idx) : Elem\n\nexport GetElem (getElem)\n\ninstance : GetElem (Array α) Nat α where\n  getElem xs i := xs.get ⟨i, sorry⟩\n\nopaque f : Option Bool → Bool\nopaque g : Bool → Bool\n\ndef bad (xs : Array Bool) : Bool :=\n  let x := getElem xs 0\n  f x && g x\n```\nWithout the special support, Lean fails at `g x` saying `x` has type `Option Bool` but is expected to have type `Bool`.\nFrom the user's point of view this is a bug, since `let x := getElem xs 0` clearly constrains `x` to be `Bool`, but\nwe only obtain this information after we apply the `OfNat` default instance for `0`.\n\nBefore converging to this solution, we have tried to create a \"coercion placeholder\" when `resultIsOutParamSupport = true`,\nbut it did not work well in practice. For example, it failed in the example above.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L91-L91","name":"Lean.Elab.Term.ElabAppArgs.Context.explicit","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabAppArgs.Context.explicit","doc":"`true` if `@` modifier was used\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L87-L87","name":"Lean.Elab.Term.ElabAppArgs.Context.ellipsis","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabAppArgs.Context.ellipsis","doc":"`true` if `..` was used\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L83-L123","name":"Lean.Elab.Term.ElabAppArgs.Context","kind":"structure","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabAppArgs.Context","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L69-L70","name":"Lean.Elab.Term.eraseNamedArg","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.eraseNamedArg","doc":"Erase entry for `binderName` from `namedArgs`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L58-L62","name":"Lean.Elab.Term.synthesizeAppInstMVars","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.synthesizeAppInstMVars","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L33-L36","name":"Lean.Elab.Term.throwInvalidNamedArg","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.throwInvalidNamedArg","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L30-L31","name":"Lean.Elab.Term.instToStringNamedArg","kind":"instance","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.instToStringNamedArg","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L25-L28","name":"Lean.Elab.Term.instToStringArg","kind":"instance","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.instToStringArg","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L22-L23","name":"Lean.Elab.Term.hasElabWithoutExpectedType","kind":"def","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.hasElabWithoutExpectedType","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L19-L20","name":"Lean.Elab.Term.elabWithoutExpectedTypeAttr","kind":"opaque","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.elabWithoutExpectedTypeAttr","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L1-L1","name":"Lean.Elab.Term.ElabAppArgs.Context.mk","kind":"ctor","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabAppArgs.Context.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L1-L1","name":"Lean.Elab.Term.ElabElim.State.mk","kind":"ctor","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabElim.State.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L1-L1","name":"Lean.Elab.Term.ElabAppArgs.State.mk","kind":"ctor","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabAppArgs.State.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Elab/App.lean#L1-L1","name":"Lean.Elab.Term.ElabElim.Context.mk","kind":"ctor","docLink":"./Lean/Elab/App.html#Lean.Elab.Term.ElabElim.Context.mk","doc":""}]}