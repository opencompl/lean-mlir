{"name":"Lean.Meta.Transform","instances":[],"imports":["Init","Lean.Meta.Basic"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/Transform.lean#L162-L163","name":"Lean.Meta.erasePatternRefAnnotations","kind":"def","docLink":"./Lean/Meta/Transform.html#Lean.Meta.erasePatternRefAnnotations","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/Transform.lean#L159-L160","name":"Lean.Meta.eraseInaccessibleAnnotations","kind":"def","docLink":"./Lean/Meta/Transform.html#Lean.Meta.eraseInaccessibleAnnotations","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/Transform.lean#L140-L157","name":"Lean.Meta.unfoldDeclsFrom","kind":"def","docLink":"./Lean/Meta/Transform.html#Lean.Meta.unfoldDeclsFrom","doc":"Unfold definitions and theorems in `e` that are not in the current environment, but are in `biggerEnv`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/Transform.lean#L125-L137","name":"Lean.Meta.zetaReduce","kind":"def","docLink":"./Lean/Meta/Transform.html#Lean.Meta.zetaReduce","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/Transform.lean#L101-L106","name":"Lean.Meta.transform.visit.visitLet","kind":"opaque","docLink":"./Lean/Meta/Transform.html#Lean.Meta.transform.visit.visitLet","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/Transform.lean#L95-L100","name":"Lean.Meta.transform.visit.visitForall","kind":"opaque","docLink":"./Lean/Meta/Transform.html#Lean.Meta.transform.visit.visitForall","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/Transform.lean#L89-L94","name":"Lean.Meta.transform.visit.visitLambda","kind":"opaque","docLink":"./Lean/Meta/Transform.html#Lean.Meta.transform.visit.visitLambda","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/Transform.lean#L84-L88","name":"Lean.Meta.transform.visit.visitPost","kind":"opaque","docLink":"./Lean/Meta/Transform.html#Lean.Meta.transform.visit.visitPost","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/Transform.lean#L82-L122","name":"Lean.Meta.transform.visit","kind":"opaque","docLink":"./Lean/Meta/Transform.html#Lean.Meta.transform.visit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/Transform.lean#L74-L123","name":"Lean.Meta.transform","kind":"def","docLink":"./Lean/Meta/Transform.html#Lean.Meta.transform","doc":"Similar to `Core.transform`, but terms provided to `pre` and `post` do not contain loose bound variables.\nSo, it is safe to use any `MetaM` method at `pre` and `post`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/Transform.lean#L64-L65","name":"Lean.Core.betaReduce","kind":"def","docLink":"./Lean/Meta/Transform.html#Lean.Core.betaReduce","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/Transform.lean#L44-L48","name":"Lean.Core.transform.visit.visitPost","kind":"opaque","docLink":"./Lean/Meta/Transform.html#Lean.Core.transform.visit.visitPost","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/Transform.lean#L42-L61","name":"Lean.Core.transform.visit","kind":"opaque","docLink":"./Lean/Meta/Transform.html#Lean.Core.transform.visit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/Transform.lean#L35-L62","name":"Lean.Core.transform","kind":"def","docLink":"./Lean/Meta/Transform.html#Lean.Core.transform","doc":"Transform the expression `input` using `pre` and `post`.\n- First `pre` is invoked with the current expression and recursion is continued according to the `TransformStep` result.\n  In all cases, the expression contained in the result, if any, must be definitionally equal to the current expression.\n- After recursion, if any, `post` is invoked on the resulting expression.\n\nThe term `s` in both `pre s` and `post s` may contain loose bound variables. So, this method is not appropriate for\nif one needs to apply operations (e.g., `whnf`, `inferType`) that do not handle loose bound variables.\nConsider using `Meta.transform` to avoid loose bound variables.\n\nThis method is useful for applying transformations such as beta-reduction and delta-reduction.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/Transform.lean#L15-L19","name":"Lean.TransformStep.continue","kind":"ctor","docLink":"./Lean/Meta/Transform.html#Lean.TransformStep.continue","doc":"Continue transformation with the given expression (defaults to current expression).\nFor `pre`, this means visiting the children of the expression.\nFor `post`, this is equivalent to returning `done`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/Transform.lean#L13-L14","name":"Lean.TransformStep.visit","kind":"ctor","docLink":"./Lean/Meta/Transform.html#Lean.TransformStep.visit","doc":"Visit expression (which should be different from current expression) instead. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/Transform.lean#L11-L12","name":"Lean.TransformStep.done","kind":"ctor","docLink":"./Lean/Meta/Transform.html#Lean.TransformStep.done","doc":"Return expression without visiting any subexpressions. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/Transform.lean#L10-L19","name":"Lean.TransformStep","kind":"inductive","docLink":"./Lean/Meta/Transform.html#Lean.TransformStep","doc":""}]}