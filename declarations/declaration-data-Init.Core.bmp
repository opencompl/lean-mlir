{"name":"Init.Core","instances":[{"typeNames":["Thunk"],"name":"thunkCoe","className":"CoeTail"},{"typeNames":["ForInStep"],"name":"instInhabitedForInStep","className":"Inhabited"},{"typeNames":["Task"],"name":"instInhabitedTask","className":"Inhabited"},{"typeNames":["Task"],"name":"instNonemptyTask","className":"Nonempty"},{"typeNames":["Bool","instBEq","Bool","instDecidableEqBool"],"name":"instLawfulBEqBoolInstBEqInstDecidableEqBool","className":"LawfulBEq"},{"typeNames":["instBEq"],"name":"instLawfulBEqInstBEq","className":"LawfulBEq"},{"typeNames":["Char","instBEq","Char","instDecidableEqChar"],"name":"instLawfulBEqCharInstBEqInstDecidableEqChar","className":"LawfulBEq"},{"typeNames":["String","instBEq","String","instDecidableEqString"],"name":"instLawfulBEqStringInstBEqInstDecidableEqString","className":"LawfulBEq"},{"typeNames":["True"],"name":"instDecidableTrue","className":"Decidable"},{"typeNames":["False"],"name":"instDecidableFalse","className":"Decidable"},{"typeNames":[],"name":"instDecidableForAll","className":"Decidable"},{"typeNames":["Iff"],"name":"instDecidableIff","className":"Decidable"},{"typeNames":["ite","_builtin_prop"],"name":"instDecidableIteProp","className":"Decidable"},{"typeNames":["dite","_builtin_prop","Not"],"name":"instDecidableDitePropNot","className":"Decidable"},{"typeNames":["_builtin_prop"],"name":"instInhabitedProp","className":"Inhabited"},{"typeNames":["NonScalar"],"name":"instInhabitedNonScalar","className":"Inhabited"},{"typeNames":["PNonScalar"],"name":"instInhabitedPNonScalar","className":"Inhabited"},{"typeNames":["ForInStep"],"name":"instInhabitedForInStep_1","className":"Inhabited"},{"typeNames":["True"],"name":"instInhabitedTrue","className":"Inhabited"},{"typeNames":[],"name":"instSubsingleton","className":"Subsingleton"},{"typeNames":["Decidable"],"name":"instSubsingletonDecidable","className":"Subsingleton"},{"typeNames":["Subtype"],"name":"Subtype.instInhabitedSubtype","className":"Inhabited"},{"typeNames":["Eq","Subtype"],"name":"Subtype.instDecidableEqSubtype","className":"Decidable"},{"typeNames":["Sum"],"name":"Sum.inhabitedLeft","className":"Inhabited"},{"typeNames":["Sum"],"name":"Sum.inhabitedRight","className":"Inhabited"},{"typeNames":["Eq","Sum"],"name":"instDecidableEqSum","className":"Decidable"},{"typeNames":["Prod"],"name":"instInhabitedProd","className":"Inhabited"},{"typeNames":["MProd"],"name":"instInhabitedMProd","className":"Inhabited"},{"typeNames":["PProd"],"name":"instInhabitedPProd","className":"Inhabited"},{"typeNames":["Eq","Prod"],"name":"instDecidableEqProd","className":"Decidable"},{"typeNames":["Prod"],"name":"instBEqProd","className":"BEq"},{"typeNames":["Prod.lexLt"],"name":"Prod.lexLtDec","className":"Decidable"},{"typeNames":["PUnit"],"name":"instSubsingletonPUnit","className":"Subsingleton"},{"typeNames":["PUnit"],"name":"instInhabitedPUnit","className":"Inhabited"},{"typeNames":["Eq","PUnit"],"name":"instDecidableEqPUnit","className":"Decidable"},{"typeNames":[],"name":"instHasEquiv","className":"HasEquiv"},{"typeNames":["Eq","_builtin_prop"],"name":"instDecidableEqProp","className":"Decidable"},{"typeNames":["Eq","Quotient"],"name":"instDecidableEqQuotient","className":"Decidable"},{"typeNames":[],"name":"instSubsingletonForAll","className":"Subsingleton"},{"typeNames":["Squash"],"name":"instSubsingletonSquash","className":"Subsingleton"}],"imports":["Init.Prelude","Init.SizeOf"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1698-L1698","name":"Lean.IsNeutral.right_neutral","kind":"def","docLink":"./Init/Core.html#Lean.IsNeutral.right_neutral","doc":"A neutral element can be cancelled on the right: `a ∘ e = a`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1696-L1696","name":"Lean.IsNeutral.left_neutral","kind":"def","docLink":"./Init/Core.html#Lean.IsNeutral.left_neutral","doc":"A neutral element can be cancelled on the left: `e ∘ a = a`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1694-L1694","name":"Lean.IsNeutral.mk","kind":"ctor","docLink":"./Init/Core.html#Lean.IsNeutral.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1694-L1698","name":"Lean.IsNeutral","kind":"class","docLink":"./Init/Core.html#Lean.IsNeutral","doc":"`IsNeutral op e` says that `e` is a neutral operation for `op`,\ni.e. `a ∘ e = a = e ∘ a`. It is used by the `ac_rfl` tactic\n(which also simplifies neutral elements when available).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1687-L1687","name":"Lean.IsIdempotent.idempotent","kind":"def","docLink":"./Init/Core.html#Lean.IsIdempotent.idempotent","doc":"An idempotent operation satisfies `a ∘ a = a`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1685-L1685","name":"Lean.IsIdempotent.mk","kind":"ctor","docLink":"./Init/Core.html#Lean.IsIdempotent.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1685-L1687","name":"Lean.IsIdempotent","kind":"class","docLink":"./Init/Core.html#Lean.IsIdempotent","doc":"`IsIdempotent op` says that `op` is an idempotent operation,\ni.e. `a ∘ a = a`. It is used by the `ac_rfl` tactic\n(which also simplifies up to idempotence when available).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1678-L1678","name":"Lean.IsCommutative.comm","kind":"def","docLink":"./Init/Core.html#Lean.IsCommutative.comm","doc":"A commutative operation satisfies `a ∘ b = b ∘ a`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1676-L1676","name":"Lean.IsCommutative.mk","kind":"ctor","docLink":"./Init/Core.html#Lean.IsCommutative.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1676-L1678","name":"Lean.IsCommutative","kind":"class","docLink":"./Init/Core.html#Lean.IsCommutative","doc":"`IsCommutative op` says that `op` is a commutative operation,\ni.e. `a ∘ b = b ∘ a`. It is used by the `ac_rfl` tactic.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1670-L1670","name":"Lean.IsAssociative.assoc","kind":"def","docLink":"./Init/Core.html#Lean.IsAssociative.assoc","doc":"An associative operation satisfies `(a ∘ b) ∘ c = a ∘ (b ∘ c)`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1668-L1668","name":"Lean.IsAssociative.mk","kind":"ctor","docLink":"./Init/Core.html#Lean.IsAssociative.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1668-L1670","name":"Lean.IsAssociative","kind":"class","docLink":"./Init/Core.html#Lean.IsAssociative","doc":"`IsAssociative op` says that `op` is an associative operation,\ni.e. `(a ∘ b) ∘ c = a ∘ (b ∘ c)`. It is used by the `ac_rfl` tactic.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1662-L1662","name":"Lean.ofReduceNat","kind":"axiom","docLink":"./Init/Core.html#Lean.ofReduceNat","doc":"The axiom `ofReduceNat` is used to perform proofs by reflection. See `reduceBool`.\n\nWarning: by using this feature, the Lean compiler and interpreter become part of your trusted code base.\nThis is extra 30k lines of code. More importantly, you will probably not be able to check your development using\nexternal type checkers (e.g., Trepplein) that do not implement this feature.\nKeep in mind that if you are using Lean as programming language, you are already trusting the Lean compiler and interpreter.\nSo, you are mainly losing the capability of type checking your development using external checkers.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1651-L1651","name":"Lean.ofReduceBool","kind":"axiom","docLink":"./Init/Core.html#Lean.ofReduceBool","doc":"The axiom `ofReduceBool` is used to perform proofs by reflection. See `reduceBool`.\n\nThis axiom is usually not used directly, because it has some syntactic restrictions.\nInstead, the `native_decide` tactic can be used to prove any proposition whose\ndecidability instance can be evaluated to `true` using the lean compiler / interpreter.\n\nWarning: by using this feature, the Lean compiler and interpreter become part of your trusted code base.\nThis is extra 30k lines of code. More importantly, you will probably not be able to check your development using\nexternal type checkers (e.g., Trepplein) that do not implement this feature.\nKeep in mind that if you are using Lean as programming language, you are already trusting the Lean compiler and interpreter.\nSo, you are mainly losing the capability of type checking your development using external checkers.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1636-L1636","name":"Lean.reduceNat","kind":"opaque","docLink":"./Init/Core.html#Lean.reduceNat","doc":"Similar to `Lean.reduceBool` for closed `Nat` terms.\n\nRemark: we do not have plans for supporting a generic `reduceValue {α} (a : α) : α := a`.\nThe main issue is that it is non-trivial to convert an arbitrary runtime object back into a Lean expression.\nWe believe `Lean.reduceBool` enables most interesting applications (e.g., proof by reflection).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1627-L1627","name":"Lean.reduceBool","kind":"opaque","docLink":"./Init/Core.html#Lean.reduceBool","doc":"When the kernel tries to reduce a term `Lean.reduceBool c`, it will invoke the Lean interpreter to evaluate `c`.\nThe kernel will not use the interpreter if `c` is not a constant.\nThis feature is useful for performing proofs by reflection.\n\nRemark: the Lean frontend allows terms of the from `Lean.reduceBool t` where `t` is a term not containing\nfree variables. The frontend automatically declares a fresh auxiliary constant `c` and replaces the term with\n`Lean.reduceBool c`. The main motivation is that the code for `t` will be pre-compiled.\n\nWarning: by using this feature, the Lean compiler and interpreter become part of your trusted code base.\nThis is extra 30k lines of code. More importantly, you will probably not be able to check your development using\nexternal type checkers (e.g., Trepplein) that do not implement this feature.\nKeep in mind that if you are using Lean as programming language, you are already trusting the Lean compiler and interpreter.\nSo, you are mainly losing the capability of type checking your development using external checkers.\n\nRecall that the compiler trusts the correctness of all `[implemented_by ...]` and `[extern ...]` annotations.\nIf an extern function is executed, then the trusted code base will also include the implementation of the associated\nforeign function.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1603-L1603","name":"Antisymm.antisymm","kind":"def","docLink":"./Init/Core.html#Antisymm.antisymm","doc":"An antisymmetric relation `(·≤·)` satisfies `a ≤ b → b ≤ a → a = b`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1601-L1601","name":"Antisymm.mk","kind":"ctor","docLink":"./Init/Core.html#Antisymm.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1601-L1603","name":"Antisymm","kind":"class","docLink":"./Init/Core.html#Antisymm","doc":"`Antisymm (·≤·)` says that `(·≤·)` is antisymmetric, that is, `a ≤ b → b ≤ a → a = b`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1589-L1594","name":"instSubsingletonSquash","kind":"instance","docLink":"./Init/Core.html#instSubsingletonSquash","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1586-L1587","name":"Squash.lift","kind":"def","docLink":"./Init/Core.html#Squash.lift","doc":"If `β` is a subsingleton, then a function `α → β` lifts to `Squash α → β`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1582-L1583","name":"Squash.ind","kind":"theorem","docLink":"./Init/Core.html#Squash.ind","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1580-L1580","name":"Squash.mk","kind":"def","docLink":"./Init/Core.html#Squash.mk","doc":"The canonical quotient map into `Squash α`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1577-L1577","name":"Squash","kind":"def","docLink":"./Init/Core.html#Squash","doc":"`Squash α` is the quotient of `α` by the always true relation.\nIt is empty if `α` is empty, otherwise it is a singleton.\n(Thus it is unconditionally a `Subsingleton`.)\nIt is the \"universal `Subsingleton`\" mapped from `α`.\n\nIt is similar to `Nonempty α`, which has the same properties, but unlike\n`Nonempty` this is a `Type u`, that is, it is \"data\", and the compiler\nrepresents an element of `Squash α` the same as `α` itself\n(as compared to `Nonempty α`, whose elements are represented by a dummy value).\n\n`Squash.lift` will extract a value in any subsingleton `β` from a function on `α`,\nwhile `Nonempty.rec` can only do the same when `β` is a proposition.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1558-L1559","name":"instSubsingletonForAll","kind":"instance","docLink":"./Init/Core.html#instSubsingletonForAll","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1548-L1556","name":"funext","kind":"theorem","docLink":"./Init/Core.html#funext","doc":"**Function extensionality** is the statement that if two functions take equal values\nevery point, then the functions themselves are equal: `(∀ x, f x = g x) → f = g`.\nIt is called \"extensionality\" because it talks about how to prove two objects are equal\nbased on the properties of the object (compare with set extensionality,\nwhich is `(∀ x, x ∈ s ↔ x ∈ t) → s = t`).\n\nThis is often an axiom in dependent type theory systems, because it cannot be proved\nfrom the core logic alone. However in lean's type theory this follows from the existence\nof quotient types (note the `Quot.sound` in the proof, as well as the `show` line\nwhich makes use of the definitional equality `Quot.lift f h (Quot.mk x) = f x`).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1526-L1532","name":"instDecidableEqQuotient","kind":"instance","docLink":"./Init/Core.html#instDecidableEqQuotient","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1504-L1517","name":"Quotient.recOnSubsingleton₂","kind":"def","docLink":"./Init/Core.html#Quotient.recOnSubsingleton₂","doc":"Lift a binary function to a quotient on both arguments. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1492-L1493","name":"Quotient.exact","kind":"theorem","docLink":"./Init/Core.html#Quotient.exact","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1459-L1470","name":"Quotient.inductionOn₃","kind":"theorem","docLink":"./Init/Core.html#Quotient.inductionOn₃","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1448-L1456","name":"Quotient.inductionOn₂","kind":"theorem","docLink":"./Init/Core.html#Quotient.inductionOn₂","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1437-L1445","name":"Quotient.ind₂","kind":"theorem","docLink":"./Init/Core.html#Quotient.ind₂","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1428-L1434","name":"Quotient.liftOn₂","kind":"def","docLink":"./Init/Core.html#Quotient.liftOn₂","doc":"Lift a binary function to a quotient on both arguments. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1417-L1425","name":"Quotient.lift₂","kind":"def","docLink":"./Init/Core.html#Quotient.lift₂","doc":"Lift a binary function to a quotient on both arguments. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1403-L1408","name":"Quotient.hrecOn","kind":"def","docLink":"./Init/Core.html#Quotient.hrecOn","doc":"The analogue of `Quot.hrecOn` for `Quotient`. See `Quot.hrecOn`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1394-L1399","name":"Quotient.recOnSubsingleton","kind":"def","docLink":"./Init/Core.html#Quotient.recOnSubsingleton","doc":"The analogue of `Quot.recOnSubsingleton` for `Quotient`. See `Quot.recOnSubsingleton`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1385-L1390","name":"Quotient.recOn","kind":"def","docLink":"./Init/Core.html#Quotient.recOn","doc":"The analogue of `Quot.recOn` for `Quotient`. See `Quot.recOn`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1376-L1381","name":"Quotient.rec","kind":"def","docLink":"./Init/Core.html#Quotient.rec","doc":"The analogue of `Quot.rec` for `Quotient`. See `Quot.rec`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1366-L1367","name":"Quotient.exists_rep","kind":"theorem","docLink":"./Init/Core.html#Quotient.exists_rep","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1360-L1364","name":"Quotient.inductionOn","kind":"theorem","docLink":"./Init/Core.html#Quotient.inductionOn","doc":"The analogue of `Quot.inductionOn`: every element of `Quotient s` is of the form `Quotient.mk s a`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1355-L1356","name":"Quotient.liftOn","kind":"def","docLink":"./Init/Core.html#Quotient.liftOn","doc":"The analogue of `Quot.liftOn`: if `f : α → β` respects the equivalence relation `≈`,\nthen it lifts to a function on `Quotient s` such that `lift (mk a) f h = f a`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1348-L1349","name":"Quotient.ind","kind":"theorem","docLink":"./Init/Core.html#Quotient.ind","doc":"The analogue of `Quot.ind`: every element of `Quotient s` is of the form `Quotient.mk s a`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1344-L1345","name":"Quotient.lift","kind":"def","docLink":"./Init/Core.html#Quotient.lift","doc":"The analogue of `Quot.lift`: if `f : α → β` respects the equivalence relation `≈`,\nthen it lifts to a function on `Quotient s` such that `lift f h (mk a) = f a`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1337-L1338","name":"Quotient.sound","kind":"def","docLink":"./Init/Core.html#Quotient.sound","doc":"The analogue of `Quot.sound`: If `a` and `b` are related by the equivalence relation,\nthen they have equal equivalence classes.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1330-L1331","name":"Quotient.mk'","kind":"def","docLink":"./Init/Core.html#Quotient.mk'","doc":"The canonical quotient map into a `Quotient`.\n(This synthesizes the setoid by typeclass inference.)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1323-L1324","name":"Quotient.mk","kind":"def","docLink":"./Init/Core.html#Quotient.mk","doc":"The canonical quotient map into a `Quotient`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1316-L1317","name":"Quotient","kind":"def","docLink":"./Init/Core.html#Quotient","doc":"`Quotient α s` is the same as `Quot α r`, but it is specialized to a setoid `s`\n(that is, an equivalence relation) instead of an arbitrary relation.\nPrefer `Quotient` over `Quot` if your relation is actually an equivalence relation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1298-L1305","name":"Quot.hrecOn","kind":"def","docLink":"./Init/Core.html#Quot.hrecOn","doc":"Heterogeneous dependent recursion principle for a quotient.\nThis may be easier to work with since it uses `HEq` instead of\nan `Eq.ndrec` in the hypothesis.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1284-L1291","name":"Quot.recOnSubsingleton","kind":"def","docLink":"./Init/Core.html#Quot.recOnSubsingleton","doc":"Dependent induction principle for a quotient, when the target type is a `Subsingleton`.\nIn this case the quotient's side condition is trivial so any function can be lifted.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1273-L1278","name":"Quot.recOn","kind":"def","docLink":"./Init/Core.html#Quot.recOn","doc":"Dependent recursion principle for `Quot`. This constructor can be tricky to use,\nso you should consider the simpler versions if they apply:\n* `Quot.lift`, for nondependent functions\n* `Quot.ind`, for theorems / proofs of propositions about quotients\n* `Quot.recOnSubsingleton`, when the target type is a `Subsingleton`\n* `Quot.hrecOn`, which uses `HEq (f a) (f b)` instead of a `sound p ▸ f a = f b` assummption\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1267-L1271","name":"Quot.rec","kind":"def","docLink":"./Init/Core.html#Quot.rec","doc":"Dependent recursion principle for `Quot`. This constructor can be tricky to use,\nso you should consider the simpler versions if they apply:\n* `Quot.lift`, for nondependent functions\n* `Quot.ind`, for theorems / proofs of propositions about quotients\n* `Quot.recOnSubsingleton`, when the target type is a `Subsingleton`\n* `Quot.hrecOn`, which uses `HEq (f a) (f b)` instead of a `sound p ▸ f a = f b` assummption\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1251-L1257","name":"Quot.liftIndepPr1","kind":"theorem","docLink":"./Init/Core.html#Quot.liftIndepPr1","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1245-L1249","name":"Quot.indepCoherent","kind":"theorem","docLink":"./Init/Core.html#Quot.indepCoherent","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1242-L1243","name":"Quot.indep","kind":"def","docLink":"./Init/Core.html#Quot.indep","doc":"Auxiliary definition for `Quot.rec`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1232-L1233","name":"Quot.exists_rep","kind":"theorem","docLink":"./Init/Core.html#Quot.exists_rep","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1226-L1230","name":"Quot.inductionOn","kind":"theorem","docLink":"./Init/Core.html#Quot.inductionOn","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1221-L1223","name":"Quot.liftOn","kind":"def","docLink":"./Init/Core.html#Quot.liftOn","doc":"`Quot.liftOn q f h` is the same as `Quot.lift f h q`. It just reorders\nthe argument `q : Quot r` to be first.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1211-L1215","name":"Quot.indBeta","kind":"theorem","docLink":"./Init/Core.html#Quot.indBeta","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1204-L1209","name":"Quot.liftBeta","kind":"theorem","docLink":"./Init/Core.html#Quot.liftBeta","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1202-L1202","name":"Quot.sound","kind":"axiom","docLink":"./Init/Core.html#Quot.sound","doc":"The **quotient axiom**, or at least the nontrivial part of the quotient\naxiomatization. Quotient types are introduced by the `init_quot` command\nin `Init.Prelude` which introduces the axioms:\n\n```\nopaque Quot {α : Sort u} (r : α → α → Prop) : Sort u\n\nopaque Quot.mk {α : Sort u} (r : α → α → Prop) (a : α) : Quot r\n\nopaque Quot.lift {α : Sort u} {r : α → α → Prop} {β : Sort v} (f : α → β) :\n  (∀ a b : α, r a b → f a = f b) → Quot r → β\n\nopaque Quot.ind {α : Sort u} {r : α → α → Prop} {β : Quot r → Prop} :\n  (∀ a : α, β (Quot.mk r a)) → ∀ q : Quot r, β q\n```\nAll of these axioms are true if we assume `Quot α r = α` and `Quot.mk` and\n`Quot.lift` are identity functions, so they do not add much. However this axiom\ncannot be explained in that way (it is false for that interpretation), so the\nreal power of quotient types come from this axiom.\n\nIt says that the quotient by `r` maps elements which are related by `r` to equal\nvalues in the quotient. Together with `Quot.lift` which says that functions\nwhich respect `r` can be lifted to functions on the quotient, we can deduce that\n`Quot α r` exactly consists of the equivalence classes with respect to `r`.\n\nIt is important to note that `r` need not be an equivalence relation in this axiom.\nWhen `r` is not an equivalence relation, we are actually taking a quotient with\nrespect to the equivalence relation generated by `r`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1168-L1169","name":"Iff.subst","kind":"theorem","docLink":"./Init/Core.html#Iff.subst","doc":"Iff can now be used to do substitutions in a calculation "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1162-L1163","name":"beq_iff_eq","kind":"theorem","docLink":"./Init/Core.html#beq_iff_eq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1141-L1144","name":"instDecidableEqProp","kind":"instance","docLink":"./Init/Core.html#instDecidableEqProp","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1137-L1138","name":"Eq.propIntro","kind":"theorem","docLink":"./Init/Core.html#Eq.propIntro","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1135-L1135","name":"propext","kind":"axiom","docLink":"./Init/Core.html#propext","doc":"The axiom of **propositional extensionality**. It asserts that if propositions\n`a` and `b` are logically equivalent (i.e. we can prove `a` from `b` and vice versa),\nthen `a` and `b` are *equal*, meaning that we can replace `a` with `b` in all\ncontexts.\n\nFor simple expressions like `a ∧ c ∨ d → e` we can prove that because all the logical\nconnectives respect logical equivalence, we can replace `a` with `b` in this expression\nwithout using `propext`. However, for higher order expressions like `P a` where\n`P : Prop → Prop` is unknown, or indeed for `a = b` itself, we cannot replace `a` with `b`\nwithout an axiom which says exactly this.\n\nThis is a relatively uncontroversial axiom, which is intuitionistically valid.\nIt does however block computation when using `#reduce` to reduce proofs directly\n(which is not recommended), meaning that canonicity,\nthe property that all closed terms of type `Nat` normalize to numerals,\nfails to hold when this (or any) axiom is used:\n```\nset_option pp.proofs true\n\ndef foo : Nat := by\n  have : (True → True) ↔ True := ⟨λ _ => trivial, λ _ _ => trivial⟩\n  have := propext this ▸ (2 : Nat)\n  exact this\n\n#reduce foo\n-- propext { mp := fun x x => True.intro, mpr := fun x => True.intro } ▸ 2\n\n#eval foo -- 2\n```\n`#eval` can evaluate it to a numeral because the compiler erases casts and\ndoes not evaluate proofs, so `propext`, whose return type is a proposition,\ncan never block it.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1093-L1094","name":"Setoid.trans","kind":"theorem","docLink":"./Init/Core.html#Setoid.trans","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1090-L1091","name":"Setoid.symm","kind":"theorem","docLink":"./Init/Core.html#Setoid.symm","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1087-L1088","name":"Setoid.refl","kind":"theorem","docLink":"./Init/Core.html#Setoid.refl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1080-L1081","name":"instHasEquiv","kind":"instance","docLink":"./Init/Core.html#instHasEquiv","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1078-L1078","name":"Setoid.iseqv","kind":"def","docLink":"./Init/Core.html#Setoid.iseqv","doc":"The relation `x ≈ y` is an equivalence relation. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1076-L1076","name":"Setoid.r","kind":"def","docLink":"./Init/Core.html#Setoid.r","doc":"`x ≈ y` is the distinguished equivalence relation of a setoid. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1074-L1074","name":"Setoid.mk","kind":"ctor","docLink":"./Init/Core.html#Setoid.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1074-L1078","name":"Setoid","kind":"class","docLink":"./Init/Core.html#Setoid","doc":"A setoid is a type with a distinguished equivalence relation, denoted `≈`.\nThis is mainly used as input to the `Quotient` type constructor.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1065-L1066","name":"instDecidableEqPUnit","kind":"instance","docLink":"./Init/Core.html#instDecidableEqPUnit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1062-L1063","name":"instInhabitedPUnit","kind":"instance","docLink":"./Init/Core.html#instInhabitedPUnit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1059-L1060","name":"instSubsingletonPUnit","kind":"instance","docLink":"./Init/Core.html#instSubsingletonPUnit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1056-L1057","name":"PUnit.eq_punit","kind":"theorem","docLink":"./Init/Core.html#PUnit.eq_punit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1053-L1054","name":"PUnit.subsingleton","kind":"theorem","docLink":"./Init/Core.html#PUnit.subsingleton","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1045-L1049","name":"PSigma.eta","kind":"theorem","docLink":"./Init/Core.html#PSigma.eta","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1042-L1043","name":"ex_of_PSigma","kind":"theorem","docLink":"./Init/Core.html#ex_of_PSigma","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1036-L1038","name":"Prod.map","kind":"def","docLink":"./Init/Core.html#Prod.map","doc":"`Prod.map f g : α₁ × β₁ → α₂ × β₂` maps across a pair\nby applying `f` to the first component and `g` to the second.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1030-L1030","name":"Prod.eta","kind":"theorem","docLink":"./Init/Core.html#Prod.eta","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1027-L1028","name":"Prod.lexLt_def","kind":"theorem","docLink":"./Init/Core.html#Prod.lexLt_def","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1021-L1025","name":"Prod.lexLtDec","kind":"instance","docLink":"./Init/Core.html#Prod.lexLtDec","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1018-L1019","name":"Prod.lexLt","kind":"def","docLink":"./Init/Core.html#Prod.lexLt","doc":"Lexicographical order for products "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1014-L1015","name":"instBEqProd","kind":"instance","docLink":"./Init/Core.html#instBEqProd","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1005-L1012","name":"instDecidableEqProd","kind":"instance","docLink":"./Init/Core.html#instDecidableEqProd","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L1002-L1003","name":"instInhabitedPProd","kind":"instance","docLink":"./Init/Core.html#instInhabitedPProd","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L999-L1000","name":"instInhabitedMProd","kind":"instance","docLink":"./Init/Core.html#instInhabitedMProd","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L996-L997","name":"instInhabitedProd","kind":"instance","docLink":"./Init/Core.html#instInhabitedProd","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L981-L990","name":"instDecidableEqSum","kind":"instance","docLink":"./Init/Core.html#instDecidableEqSum","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L978-L979","name":"Sum.inhabitedRight","kind":"instance","docLink":"./Init/Core.html#Sum.inhabitedRight","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L975-L976","name":"Sum.inhabitedLeft","kind":"instance","docLink":"./Init/Core.html#Sum.inhabitedLeft","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L963-L966","name":"Subtype.instDecidableEqSubtype","kind":"instance","docLink":"./Init/Core.html#Subtype.instDecidableEqSubtype","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L960-L961","name":"Subtype.instInhabitedSubtype","kind":"instance","docLink":"./Init/Core.html#Subtype.instInhabitedSubtype","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L956-L958","name":"Subtype.eta","kind":"theorem","docLink":"./Init/Core.html#Subtype.eta","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L953-L954","name":"Subtype.eq","kind":"theorem","docLink":"./Init/Core.html#Subtype.eq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L948-L949","name":"Subtype.existsOfSubtype","kind":"theorem","docLink":"./Init/Core.html#Subtype.existsOfSubtype","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L942-L943","name":"TC.trans","kind":"ctor","docLink":"./Init/Core.html#TC.trans","doc":"The transitive closure is transitive. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L940-L941","name":"TC.base","kind":"ctor","docLink":"./Init/Core.html#TC.base","doc":"If `r a b` then `r⁺ a b`. This is the base case of the transitive closure. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L939-L943","name":"TC","kind":"inductive","docLink":"./Init/Core.html#TC","doc":"The transitive closure `r⁺` of a relation `r` is the smallest relation which is\ntransitive and contains `r`. `r⁺ a z` if and only if there exists a sequence\n`a r b r ... r z` of length at least 1 connecting `a` to `z`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L931-L932","name":"InvImage","kind":"def","docLink":"./Init/Core.html#InvImage","doc":"The inverse image of `r : β → β → Prop` by a function `α → β` is the relation\n`s : α → α → Prop` defined by `s a b = r (f a) (f b)`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L924-L925","name":"Subrelation","kind":"def","docLink":"./Init/Core.html#Subrelation","doc":"`Subrelation q r` means that `q ⊆ r` or `∀ x y, q x y → r x y`.\nIt is the analogue of the subset relation on relations.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L917-L918","name":"emptyRelation","kind":"def","docLink":"./Init/Core.html#emptyRelation","doc":"The empty relation is the relation on `α` which is always `False`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L914-L914","name":"Equivalence.trans","kind":"def","docLink":"./Init/Core.html#Equivalence.trans","doc":"An equivalence relation is transitive: `x ~ y` and `y ~ z` implies `x ~ z` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L912-L912","name":"Equivalence.symm","kind":"def","docLink":"./Init/Core.html#Equivalence.symm","doc":"An equivalence relation is symmetric: `x ~ y` implies `y ~ x` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L910-L910","name":"Equivalence.refl","kind":"def","docLink":"./Init/Core.html#Equivalence.refl","doc":"An equivalence relation is reflexive: `x ~ x` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L908-L908","name":"Equivalence.mk","kind":"ctor","docLink":"./Init/Core.html#Equivalence.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L908-L914","name":"Equivalence","kind":"structure","docLink":"./Init/Core.html#Equivalence","doc":"An equivalence relation `~ : α → α → Prop` is a relation that is:\n\n* reflexive: `x ~ x`\n* symmetric: `x ~ y` implies `y ~ x`\n* transitive: `x ~ y` and `y ~ z` implies `x ~ z`\n\nEquality is an equivalence relation, and equivalence relations share many of\nthe properties of equality. In particular, `Quot α r` is most well behaved\nwhen `r` is an equivalence relation, and in this case we use `Quotient` instead.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L886-L895","name":"recSubsingleton","kind":"theorem","docLink":"./Init/Core.html#recSubsingleton","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L877-L884","name":"instSubsingletonDecidable","kind":"instance","docLink":"./Init/Core.html#instSubsingletonDecidable","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L874-L875","name":"instSubsingleton","kind":"instance","docLink":"./Init/Core.html#instSubsingleton","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L869-L872","name":"Subsingleton.helim","kind":"theorem","docLink":"./Init/Core.html#Subsingleton.helim","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L866-L867","name":"Subsingleton.elim","kind":"theorem","docLink":"./Init/Core.html#Subsingleton.elim","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L864-L864","name":"Subsingleton.allEq","kind":"def","docLink":"./Init/Core.html#Subsingleton.allEq","doc":"Any two elements of a subsingleton are equal. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L862-L862","name":"Subsingleton.intro","kind":"ctor","docLink":"./Init/Core.html#Subsingleton.intro","doc":"Construct a proof that `α` is a subsingleton by showing that any two elements are equal. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L860-L864","name":"Subsingleton","kind":"class","docLink":"./Init/Core.html#Subsingleton","doc":"A \"subsingleton\" is a type with at most one element.\nIn other words, it is either empty, or has a unique element.\nAll propositions are subsingletons because of proof irrelevance, but some other types\nare subsingletons as well and they inherit many of the same properties as propositions.\n`Subsingleton α` is a typeclass, so it is usually used as an implicit argument and\ninferred by typeclass inference.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L847-L848","name":"nonempty_of_exists","kind":"theorem","docLink":"./Init/Core.html#nonempty_of_exists","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L845-L845","name":"instInhabitedTrue","kind":"instance","docLink":"./Init/Core.html#instInhabitedTrue","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L845-L845","name":"instInhabitedForInStep_1","kind":"instance","docLink":"./Init/Core.html#instInhabitedForInStep_1","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L845-L845","name":"instInhabitedPNonScalar","kind":"instance","docLink":"./Init/Core.html#instInhabitedPNonScalar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L845-L845","name":"instInhabitedNonScalar","kind":"instance","docLink":"./Init/Core.html#instInhabitedNonScalar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L842-L843","name":"instInhabitedProp","kind":"instance","docLink":"./Init/Core.html#instInhabitedProp","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L833-L838","name":"noConfusionEnum","kind":"def","docLink":"./Init/Core.html#noConfusionEnum","doc":"Auxiliary definition for generating compact `noConfusion` for enumeration types "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L827-L830","name":"noConfusionTypeEnum","kind":"def","docLink":"./Init/Core.html#noConfusionTypeEnum","doc":"Auxiliary definition for generating compact `noConfusion` for enumeration types "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L821-L824","name":"instDecidableDitePropNot","kind":"instance","docLink":"./Init/Core.html#instDecidableDitePropNot","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L816-L819","name":"instDecidableIteProp","kind":"instance","docLink":"./Init/Core.html#instDecidableIteProp","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L811-L814","name":"dif_eq_if","kind":"theorem","docLink":"./Init/Core.html#dif_eq_if","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L805-L808","name":"dif_neg","kind":"theorem","docLink":"./Init/Core.html#dif_neg","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L800-L803","name":"dif_pos","kind":"theorem","docLink":"./Init/Core.html#dif_pos","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L795-L798","name":"if_neg","kind":"theorem","docLink":"./Init/Core.html#if_neg","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L790-L793","name":"if_pos","kind":"theorem","docLink":"./Init/Core.html#if_pos","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L776-L786","name":"instDecidableIff","kind":"instance","docLink":"./Init/Core.html#instDecidableIff","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L770-L774","name":"instDecidableForAll","kind":"instance","docLink":"./Init/Core.html#instDecidableForAll","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L766-L767","name":"decidable_of_decidable_of_eq","kind":"def","docLink":"./Init/Core.html#decidable_of_decidable_of_eq","doc":"Transfer a decidability proof across an equality of propositions. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L759-L763","name":"decidable_of_decidable_of_iff","kind":"def","docLink":"./Init/Core.html#decidable_of_decidable_of_iff","doc":"Transfer a decidability proof across an equivalence of propositions. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L744-L752","name":"Decidable.not_and_iff_or_not","kind":"theorem","docLink":"./Init/Core.html#Decidable.not_and_iff_or_not","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L741-L742","name":"Decidable.of_not_not","kind":"theorem","docLink":"./Init/Core.html#Decidable.of_not_not","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L738-L739","name":"Decidable.byContradiction","kind":"theorem","docLink":"./Init/Core.html#Decidable.byContradiction","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L734-L735","name":"Decidable.em","kind":"theorem","docLink":"./Init/Core.html#Decidable.em","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L729-L732","name":"Decidable.byCases","kind":"def","docLink":"./Init/Core.html#Decidable.byCases","doc":"Synonym for `dite` (dependent if-then-else). We can construct an element `q`\n(of any sort, not just a proposition) by cases on whether `p` is true or false,\nprovided `p` is decidable.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L718-L719","name":"instDecidableFalse","kind":"instance","docLink":"./Init/Core.html#instDecidableFalse","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L715-L716","name":"instDecidableTrue","kind":"instance","docLink":"./Init/Core.html#instDecidableTrue","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L712-L713","name":"ofBoolUsing_eq_false","kind":"theorem","docLink":"./Init/Core.html#ofBoolUsing_eq_false","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L709-L710","name":"ofBoolUsing_eq_true","kind":"theorem","docLink":"./Init/Core.html#ofBoolUsing_eq_true","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L706-L707","name":"toBoolUsing_eq_true","kind":"theorem","docLink":"./Init/Core.html#toBoolUsing_eq_true","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L703-L704","name":"toBoolUsing","kind":"def","docLink":"./Init/Core.html#toBoolUsing","doc":"Similar to `decide`, but uses an explicit instance "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L697-L700","name":"decide_false_eq_false","kind":"theorem","docLink":"./Init/Core.html#decide_false_eq_false","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L692-L695","name":"decide_true_eq_true","kind":"theorem","docLink":"./Init/Core.html#decide_true_eq_true","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L685-L688","name":"Exists.elim","kind":"theorem","docLink":"./Init/Core.html#Exists.elim","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L680-L681","name":"And.comm","kind":"theorem","docLink":"./Init/Core.html#And.comm","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L677-L678","name":"Iff.of_eq","kind":"theorem","docLink":"./Init/Core.html#Iff.of_eq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L674-L675","name":"Iff.comm","kind":"theorem","docLink":"./Init/Core.html#Iff.comm","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L671-L672","name":"Iff.symm","kind":"theorem","docLink":"./Init/Core.html#Iff.symm","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L666-L669","name":"Iff.trans","kind":"theorem","docLink":"./Init/Core.html#Iff.trans","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L663-L664","name":"Iff.rfl","kind":"theorem","docLink":"./Init/Core.html#Iff.rfl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L660-L661","name":"Iff.refl","kind":"theorem","docLink":"./Init/Core.html#Iff.refl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L657-L658","name":"iff_iff_implies_and_implies","kind":"theorem","docLink":"./Init/Core.html#iff_iff_implies_and_implies","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L652-L653","name":"cast_heq","kind":"theorem","docLink":"./Init/Core.html#cast_heq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L647-L650","name":"heq_of_eqRec_eq","kind":"theorem","docLink":"./Init/Core.html#heq_of_eqRec_eq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L644-L645","name":"eqRec_heq","kind":"theorem","docLink":"./Init/Core.html#eqRec_heq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L639-L640","name":"type_eq_of_heq","kind":"theorem","docLink":"./Init/Core.html#type_eq_of_heq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L636-L637","name":"heq_of_eq_of_heq","kind":"theorem","docLink":"./Init/Core.html#heq_of_eq_of_heq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L633-L634","name":"heq_of_heq_of_eq","kind":"theorem","docLink":"./Init/Core.html#heq_of_heq_of_eq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L630-L631","name":"HEq.trans","kind":"theorem","docLink":"./Init/Core.html#HEq.trans","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L627-L628","name":"heq_of_eq","kind":"theorem","docLink":"./Init/Core.html#heq_of_eq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L624-L625","name":"HEq.symm","kind":"theorem","docLink":"./Init/Core.html#HEq.symm","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L621-L622","name":"HEq.subst","kind":"theorem","docLink":"./Init/Core.html#HEq.subst","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L618-L619","name":"HEq.elim","kind":"theorem","docLink":"./Init/Core.html#HEq.elim","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L615-L616","name":"HEq.ndrecOn","kind":"theorem","docLink":"./Init/Core.html#HEq.ndrecOn","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L612-L613","name":"HEq.ndrec","kind":"theorem","docLink":"./Init/Core.html#HEq.ndrec","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L604-L607","name":"beq_false_of_ne","kind":"theorem","docLink":"./Init/Core.html#beq_false_of_ne","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L601-L602","name":"ne_of_beq_false","kind":"theorem","docLink":"./Init/Core.html#ne_of_beq_false","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L597-L599","name":"Bool.of_not_eq_false","kind":"theorem","docLink":"./Init/Core.html#Bool.of_not_eq_false","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L593-L595","name":"Bool.of_not_eq_true","kind":"theorem","docLink":"./Init/Core.html#Bool.of_not_eq_true","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L588-L589","name":"true_ne_false","kind":"theorem","docLink":"./Init/Core.html#true_ne_false","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L583-L586","name":"ne_true_of_not","kind":"theorem","docLink":"./Init/Core.html#ne_true_of_not","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L580-L581","name":"ne_false_of_self","kind":"theorem","docLink":"./Init/Core.html#ne_false_of_self","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L578-L578","name":"false_of_ne","kind":"theorem","docLink":"./Init/Core.html#false_of_ne","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L575-L576","name":"Ne.symm","kind":"theorem","docLink":"./Init/Core.html#Ne.symm","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L573-L573","name":"Ne.irrefl","kind":"theorem","docLink":"./Init/Core.html#Ne.irrefl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L571-L571","name":"Ne.elim","kind":"theorem","docLink":"./Init/Core.html#Ne.elim","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L569-L569","name":"Ne.intro","kind":"theorem","docLink":"./Init/Core.html#Ne.intro","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L563-L563","name":"«term_≠_»","kind":"def","docLink":"./Init/Core.html#«term_≠_»","doc":"`a ≠ b`, or `Ne a b` is defined as `¬ (a = b)` or `a = b → False`,\nand asserts that `a` and `b` are not equal.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L560-L561","name":"Ne","kind":"def","docLink":"./Init/Core.html#Ne","doc":"`a ≠ b`, or `Ne a b` is defined as `¬ (a = b)` or `a = b → False`,\nand asserts that `a` and `b` are not equal.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L553-L554","name":"cast_eq","kind":"theorem","docLink":"./Init/Core.html#cast_eq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L550-L551","name":"Eq.substr","kind":"theorem","docLink":"./Init/Core.html#Eq.substr","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L546-L547","name":"Eq.mpr","kind":"def","docLink":"./Init/Core.html#Eq.mpr","doc":"If `h : α = β` is a proof of type equality, then `h.mpr : β → α` is the induced\n\"cast\" operation in the reverse direction, mapping elements of `β` to elements of `α`.\n\nYou can prove theorems about the resulting element by induction on `h`, since\n`rfl.mpr` is definitionally the identity function.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L536-L537","name":"Eq.mp","kind":"def","docLink":"./Init/Core.html#Eq.mp","doc":"If `h : α = β` is a proof of type equality, then `h.mp : α → β` is the induced\n\"cast\" operation, mapping elements of `α` to elements of `β`.\n\nYou can prove theorems about the resulting element by induction on `h`, since\n`rfl.mp` is definitionally the identity function.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L527-L527","name":"id.def","kind":"theorem","docLink":"./Init/Core.html#id.def","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L525-L525","name":"proofIrrel","kind":"theorem","docLink":"./Init/Core.html#proofIrrel","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L521-L522","name":"not_not_intro","kind":"theorem","docLink":"./Init/Core.html#not_not_intro","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L519-L519","name":"not_false","kind":"theorem","docLink":"./Init/Core.html#not_false","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L516-L517","name":"mt","kind":"theorem","docLink":"./Init/Core.html#mt","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L514-L514","name":"trivial","kind":"def","docLink":"./Init/Core.html#trivial","doc":"`True` is true, and `True.intro` (or more commonly, `trivial`)\nis the proof. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L510-L510","name":"instLawfulBEqStringInstBEqInstDecidableEqString","kind":"instance","docLink":"./Init/Core.html#instLawfulBEqStringInstBEqInstDecidableEqString","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L508-L508","name":"instLawfulBEqCharInstBEqInstDecidableEqChar","kind":"instance","docLink":"./Init/Core.html#instLawfulBEqCharInstBEqInstDecidableEqChar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L504-L506","name":"instLawfulBEqInstBEq","kind":"instance","docLink":"./Init/Core.html#instLawfulBEqInstBEq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L500-L502","name":"instLawfulBEqBoolInstBEqInstDecidableEqBool","kind":"instance","docLink":"./Init/Core.html#instLawfulBEqBoolInstBEqInstDecidableEqBool","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L496-L496","name":"LawfulBEq.rfl","kind":"def","docLink":"./Init/Core.html#LawfulBEq.rfl","doc":"`==` is reflexive, that is, `(a == a) = true`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L494-L494","name":"LawfulBEq.eq_of_beq","kind":"def","docLink":"./Init/Core.html#LawfulBEq.eq_of_beq","doc":"If `a == b` evaluates to `true`, then `a` and `b` are equal in the logic. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L492-L492","name":"LawfulBEq.mk","kind":"ctor","docLink":"./Init/Core.html#LawfulBEq.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L492-L496","name":"LawfulBEq","kind":"class","docLink":"./Init/Core.html#LawfulBEq","doc":"`LawfulBEq α` is a typeclass which asserts that the `BEq α` implementation\n(which supplies the `a == b` notation) coincides with logical equality `a = b`.\nIn other words, `a == b` implies `a = b`, and `a == a` is true.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L485-L485","name":"«term_!=_»","kind":"def","docLink":"./Init/Core.html#«term_!=_»","doc":"`x != y` is boolean not-equal. It is the negation of `x == y` which is supplied by\nthe `BEq` typeclass.\n\nUnlike `x ≠ y` (which is notation for `Ne x y`), this is `Bool` valued instead of\n`Prop` valued. It is mainly intended for programming applications.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L482-L483","name":"bne","kind":"def","docLink":"./Init/Core.html#bne","doc":"`x != y` is boolean not-equal. It is the negation of `x == y` which is supplied by\nthe `BEq` typeclass.\n\nUnlike `x ≠ y` (which is notation for `Ne x y`), this is `Bool` valued instead of\n`Prop` valued. It is mainly intended for programming applications.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L473-L473","name":"strictAnd","kind":"def","docLink":"./Init/Core.html#strictAnd","doc":"`strictAnd` is the same as `and`, but it does not use short-circuit evaluation semantics:\nboth sides are evaluated, even if the first value is `false`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L467-L467","name":"strictOr","kind":"def","docLink":"./Init/Core.html#strictOr","doc":"`strictOr` is the same as `or`, but it does not use short-circuit evaluation semantics:\nboth sides are evaluated, even if the first value is `true`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L459-L459","name":"optParam_eq","kind":"theorem","docLink":"./Init/Core.html#optParam_eq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L457-L457","name":"Nat.add_zero","kind":"theorem","docLink":"./Init/Core.html#Nat.add_zero","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L454-L455","name":"PNonScalar.mk","kind":"ctor","docLink":"./Init/Core.html#PNonScalar.mk","doc":"You should not use this function "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L453-L455","name":"PNonScalar","kind":"inductive","docLink":"./Init/Core.html#PNonScalar","doc":"`PNonScalar` is a type that is not a scalar value in our runtime.\nIt is used as a stand-in for an arbitrary boxed value to avoid excessive\nmonomorphization, and it is only created using `unsafeCast`. It is somewhat\nanalogous to C `void*` in usage, but the type itself is not special.\n\nThis is the universe-polymorphic version of `PNonScalar`; it is preferred to use\n`NonScalar` instead where applicable.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L442-L442","name":"NonScalar.val","kind":"def","docLink":"./Init/Core.html#NonScalar.val","doc":"You should not use this function "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L441-L441","name":"NonScalar.mk","kind":"ctor","docLink":"./Init/Core.html#NonScalar.mk","doc":"You should not use this function "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L440-L442","name":"NonScalar","kind":"structure","docLink":"./Init/Core.html#NonScalar","doc":"`NonScalar` is a type that is not a scalar value in our runtime.\nIt is used as a stand-in for an arbitrary boxed value to avoid excessive\nmonomorphization, and it is only created using `unsafeCast`. It is somewhat\nanalogous to C `void*` in usage, but the type itself is not special.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L429-L430","name":"Task.bind","kind":"def","docLink":"./Init/Core.html#Task.bind","doc":"`bind x f` does a monad \"bind\" operation on the task `x` with function `f`:\nthat is, it constructs (and immediately launches) a new task which will wait\nfor the value of `x` to be available and then calls `f` on the result,\nresulting in a new task which is then run for a result.\n\n`prio`, if provided, is the priority of the task.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L416-L417","name":"Task.map","kind":"def","docLink":"./Init/Core.html#Task.map","doc":"`map f x` maps function `f` over the task `x`: that is, it constructs\n(and immediately launches) a new task which will wait for the value of `x` to\nbe available and then calls `f` on the result.\n\n`prio`, if provided, is the priority of the task.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L404-L405","name":"Task.spawn","kind":"def","docLink":"./Init/Core.html#Task.spawn","doc":"`spawn fn : Task α` constructs and immediately launches a new task for\nevaluating the function `fn () : α` asynchronously.\n\n`prio`, if provided, is the priority of the task.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L394-L394","name":"Task.Priority.dedicated","kind":"def","docLink":"./Init/Core.html#Task.Priority.dedicated","doc":"Any priority higher than `Task.Priority.max` will result in the task being scheduled\nimmediately on a dedicated thread. This is particularly useful for long-running and/or\nI/O-bound tasks since Lean will by default allocate no more non-dedicated workers\nthan the number of cores to reduce context switches.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L387-L387","name":"Task.Priority.max","kind":"def","docLink":"./Init/Core.html#Task.Priority.max","doc":"The highest regular priority for spawned tasks: `8`.\n\nSpawning a task with a priority higher than `Task.Priority.max` is not an error but\nwill spawn a dedicated worker for the task, see `Task.Priority.dedicated`.\nRegular priority tasks are placed in a thread pool and worked on according to the priority order.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L378-L378","name":"Task.Priority.default","kind":"def","docLink":"./Init/Core.html#Task.Priority.default","doc":"The default priority for spawned tasks, also the lowest priority: `0`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L375-L375","name":"Task.Priority","kind":"def","docLink":"./Init/Core.html#Task.Priority","doc":"Task priority. Tasks with higher priority will always be scheduled before ones with lower priority. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L368-L368","name":"instNonemptyTask","kind":"instance","docLink":"./Init/Core.html#instNonemptyTask","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L368-L368","name":"instInhabitedTask","kind":"instance","docLink":"./Init/Core.html#instInhabitedTask","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L367-L367","name":"Task.get","kind":"def","docLink":"./Init/Core.html#Task.get","doc":"If `task : Task α` then `task.get : α` blocks the current thread until the\nvalue is available, and then returns the result of the task. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L364-L364","name":"Task.pure","kind":"ctor","docLink":"./Init/Core.html#Task.pure","doc":"`Task.pure (a : α)` constructs a task that is already resolved with value `a`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L362-L368","name":"Task","kind":"structure","docLink":"./Init/Core.html#Task","doc":"`Task α` is a primitive for asynchronous computation.\nIt represents a computation that will resolve to a value of type `α`,\npossibly being computed on another thread. This is similar to `Future` in Scala,\n`Promise` in Javascript, and `JoinHandle` in Rust.\n\nThe tasks have an overridden representation in the runtime.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L352-L352","name":"«term∅»","kind":"def","docLink":"./Init/Core.html#«term∅»","doc":"`∅` or `{}` is the empty set or empty collection.\nIt is supported by the `EmptyCollection` typeclass. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L351-L351","name":"«term{}»","kind":"def","docLink":"./Init/Core.html#«term{}»","doc":"`∅` or `{}` is the empty set or empty collection.\nIt is supported by the `EmptyCollection` typeclass. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L349-L349","name":"EmptyCollection.emptyCollection","kind":"def","docLink":"./Init/Core.html#EmptyCollection.emptyCollection","doc":"`∅` or `{}` is the empty set or empty collection.\nIt is supported by the `EmptyCollection` typeclass. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L346-L346","name":"EmptyCollection.mk","kind":"ctor","docLink":"./Init/Core.html#EmptyCollection.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L346-L349","name":"EmptyCollection","kind":"class","docLink":"./Init/Core.html#EmptyCollection","doc":"`EmptyCollection α` is the typeclass which supports the notation `∅`, also written as `{}`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L343-L343","name":"«term_≈_»","kind":"def","docLink":"./Init/Core.html#«term_≈_»","doc":"`x ≈ y` says that `x` and `y` are equivalent. Because this is a typeclass,\nthe notion of equivalence is type-dependent. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L341-L341","name":"HasEquiv.Equiv","kind":"def","docLink":"./Init/Core.html#HasEquiv.Equiv","doc":"`x ≈ y` says that `x` and `y` are equivalent. Because this is a typeclass,\nthe notion of equivalence is type-dependent. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L338-L338","name":"HasEquiv.mk","kind":"ctor","docLink":"./Init/Core.html#HasEquiv.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L338-L341","name":"HasEquiv","kind":"class","docLink":"./Init/Core.html#HasEquiv","doc":"`HasEquiv α` is the typeclass which supports the notation `x ≈ y` where `x y : α`."},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L333-L335","name":"DoResultSBC.continue","kind":"ctor","docLink":"./Init/Core.html#DoResultSBC.continue","doc":"`continue s` means that `continue` was called, meaning that we should continue\nto the next iteration of the containing loop "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L330-L332","name":"DoResultSBC.break","kind":"ctor","docLink":"./Init/Core.html#DoResultSBC.break","doc":"`break s` means that `break` was called, meaning that we should exit\nfrom the containing loop "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L324-L329","name":"DoResultSBC.pureReturn","kind":"ctor","docLink":"./Init/Core.html#DoResultSBC.pureReturn","doc":"This encodes either `pure (a : α)` or `return (a : α)`:\n* `pure (a : α) s` means that the block exited normally with return value `a`\n* `return (b : β) s` means that the block exited via a `return b` early-exit command\n\nThe one that is actually encoded depends on the context of use. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L323-L335","name":"DoResultSBC","kind":"inductive","docLink":"./Init/Core.html#DoResultSBC","doc":"Auxiliary type used to compile `do` notation. It is an optimization of\neither `DoResultPRBC α PEmpty σ` or `DoResultPRBC PEmpty α σ` to remove the\nimpossible case, used when either `pure` or `return` is never used.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L314-L316","name":"DoResultBC.continue","kind":"ctor","docLink":"./Init/Core.html#DoResultBC.continue","doc":"`continue s` means that `continue` was called, meaning that we should continue\nto the next iteration of the containing loop "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L311-L313","name":"DoResultBC.break","kind":"ctor","docLink":"./Init/Core.html#DoResultBC.break","doc":"`break s` means that `break` was called, meaning that we should exit\nfrom the containing loop "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L310-L316","name":"DoResultBC","kind":"inductive","docLink":"./Init/Core.html#DoResultBC","doc":"Auxiliary type used to compile `do` notation. It is an optimization of\n`DoResultPRBC PEmpty PEmpty σ` to remove the impossible cases,\nused when neither `pure` nor `return` are possible exit paths.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L302-L303","name":"DoResultPR.return","kind":"ctor","docLink":"./Init/Core.html#DoResultPR.return","doc":"`return (b : β) s` means that the block exited via a `return b` early-exit command "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L300-L301","name":"DoResultPR.pure","kind":"ctor","docLink":"./Init/Core.html#DoResultPR.pure","doc":"`pure (a : α) s` means that the block exited normally with return value `a` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L299-L303","name":"DoResultPR","kind":"inductive","docLink":"./Init/Core.html#DoResultPR","doc":"Auxiliary type used to compile `do` notation. It is the same as\n`DoResultPRBC α β σ` except that `break` and `continue` are not available\nbecause we are not in a loop context.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L290-L292","name":"DoResultPRBC.continue","kind":"ctor","docLink":"./Init/Core.html#DoResultPRBC.continue","doc":"`continue s` means that `continue` was called, meaning that we should continue\nto the next iteration of the containing loop "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L287-L289","name":"DoResultPRBC.break","kind":"ctor","docLink":"./Init/Core.html#DoResultPRBC.break","doc":"`break s` means that `break` was called, meaning that we should exit\nfrom the containing loop "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L285-L286","name":"DoResultPRBC.return","kind":"ctor","docLink":"./Init/Core.html#DoResultPRBC.return","doc":"`return (b : β) s` means that the block exited via a `return b` early-exit command "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L283-L284","name":"DoResultPRBC.pure","kind":"ctor","docLink":"./Init/Core.html#DoResultPRBC.pure","doc":"`pure (a : α) s` means that the block exited normally with return value `a` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L282-L292","name":"DoResultPRBC","kind":"inductive","docLink":"./Init/Core.html#DoResultPRBC","doc":"Auxiliary type used to compile `do` notation. It is used when compiling a do block\nnested inside a combinator like `tryCatch`. It encodes the possible ways the\nblock can exit:\n* `pure (a : α) s` means that the block exited normally with return value `a`.\n* `return (b : β) s` means that the block exited via a `return b` early-exit command.\n* `break s` means that `break` was called, meaning that we should exit\n  from the containing loop.\n* `continue s` means that `continue` was called, meaning that we should continue\n  to the next iteration of the containing loop.\n\nAll cases return a value `s : σ` which bundles all the mutable variables of the do-block.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L264-L264","name":"ForIn'.forIn'","kind":"def","docLink":"./Init/Core.html#ForIn'.forIn'","doc":"`forIn' x b f : m β` runs a for-loop in the monad `m` with additional state `β`.\nThis traverses over the \"contents\" of `x`, and passes the elements `a : α` along\nwith a proof that `a ∈ x` to `f : (a : α) → a ∈ x → β → m (ForInStep β)`.\n`b : β` is the initial state, and the return value\nof `f` is the new state as well as a directive `.done` or `.yield`\nwhich indicates whether to abort early or continue iteration. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L257-L257","name":"ForIn'.mk","kind":"ctor","docLink":"./Init/Core.html#ForIn'.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L257-L264","name":"ForIn'","kind":"class","docLink":"./Init/Core.html#ForIn'","doc":"`ForIn' m ρ α d` is a variation on the `ForIn m ρ α` typeclass which supports the\n`for h : x in xs` notation. It is the same as `for x in xs` except that `h : x ∈ xs`\nis provided as an additional argument to the body of the for-loop.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L248-L248","name":"ForIn.forIn","kind":"def","docLink":"./Init/Core.html#ForIn.forIn","doc":"`forIn x b f : m β` runs a for-loop in the monad `m` with additional state `β`.\nThis traverses over the \"contents\" of `x`, and passes the elements `a : α` to\n`f : α → β → m (ForInStep β)`. `b : β` is the initial state, and the return value\nof `f` is the new state as well as a directive `.done` or `.yield`\nwhich indicates whether to abort early or continue iteration.\n\nThe expression\n```\nlet mut b := ...\nfor x in xs do\n  b ← foo x b\n```\nin a `do` block is syntactic sugar for:\n```\nlet b := ...\nlet b ← forIn xs b (fun x b => do\n  let b ← foo x b\n  return .yield b)\n```\n(Here `b` corresponds to the variables mutated in the loop.) "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L227-L227","name":"ForIn.mk","kind":"ctor","docLink":"./Init/Core.html#ForIn.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L227-L248","name":"ForIn","kind":"class","docLink":"./Init/Core.html#ForIn","doc":"`ForIn m ρ α` is the typeclass which supports `for x in xs` notation.\nHere `xs : ρ` is the type of the collection to iterate over, `x : α`\nis the element type which is made available inside the loop, and `m` is the monad\nfor the encompassing `do` block.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L219-L219","name":"instInhabitedForInStep","kind":"instance","docLink":"./Init/Core.html#instInhabitedForInStep","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L216-L218","name":"ForInStep.yield","kind":"ctor","docLink":"./Init/Core.html#ForInStep.yield","doc":"`.yield a` means that we should continue the loop.\n`.yield` is produced by `continue` and reaching the bottom of the loop body. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L213-L215","name":"ForInStep.done","kind":"ctor","docLink":"./Init/Core.html#ForInStep.done","doc":"`.done a` means that we should early-exit the loop.\n`.done` is produced by calls to `break` or `return` in the loop. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L212-L219","name":"ForInStep","kind":"inductive","docLink":"./Init/Core.html#ForInStep","doc":"Auxiliary type used to compile `for x in xs` notation.\n\nThis is the return value of the body of a `ForIn` call,\nrepresenting the body of a for loop. It can be:\n\n* `.yield (a : α)`, meaning that we should continue the loop and `a` is the new state.\n  `.yield` is produced by `continue` and reaching the bottom of the loop body.\n* `.done (a : α)`, meaning that we should early-exit the loop with state `a`.\n  `.done` is produced by calls to `break` or `return` in the loop,\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L197-L199","name":"Exists.intro","kind":"ctor","docLink":"./Init/Core.html#Exists.intro","doc":"Existential introduction. If `a : α` and `h : p a`,\nthen `⟨a, h⟩` is a proof that `∃ x : α, p x`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L196-L199","name":"Exists","kind":"inductive","docLink":"./Init/Core.html#Exists","doc":"Existential quantification. If `p : α → Prop` is a predicate, then `∃ x : α, p x`\nasserts that there is some `x` of type `α` such that `p x` holds.\nTo create an existential proof, use the `exists` tactic,\nor the anonymous constructor notation `⟨x, h⟩`.\nTo unpack an existential, use `cases h` where `h` is a proof of `∃ x : α, p x`,\nor `let ⟨x, hx⟩ := h` where `.\n\nBecause Lean has proof irrelevance, any two proofs of an existential are\ndefinitionally equal. One consequence of this is that it is impossible to recover the\nwitness of an existential from the mere fact of its existence.\nFor example, the following does not compile:\n```\nexample (h : ∃ x : Nat, x = x) : Nat :=\n  let ⟨x, _⟩ := h  -- fail, because the goal is `Nat : Type`\n  x\n```\nThe error message `recursor 'Exists.casesOn' can only eliminate into Prop` means\nthat this only works when the current goal is another proposition:\n```\nexample (h : ∃ x : Nat, x = x) : True :=\n  let ⟨x, _⟩ := h  -- ok, because the goal is `True : Prop`\n  trivial\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L169-L169","name":"PSigma.snd","kind":"def","docLink":"./Init/Core.html#PSigma.snd","doc":"The second component of a dependent pair. If `p : Sigma β` then `p.2 : β p.1`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L167-L167","name":"PSigma.fst","kind":"def","docLink":"./Init/Core.html#PSigma.fst","doc":"The first component of a dependent pair. If `p : @Sigma α β` then `p.1 : α`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L165-L165","name":"PSigma.mk","kind":"ctor","docLink":"./Init/Core.html#PSigma.mk","doc":"Constructor for a dependent pair. If `a : α` and `b : β a` then `⟨a, b⟩ : PSigma β`.\n(This will usually require a type ascription to determine `β`\nsince it is not determined from `a` and `b` alone.) "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L161-L169","name":"PSigma","kind":"structure","docLink":"./Init/Core.html#PSigma","doc":"`PSigma β`, also denoted `Σ' a : α, β a` or `(a : α) ×' β a`, is the type of dependent pairs\nwhose first component is `a : α` and whose second component is `b : β a`\n(so the type of the second component can depend on the value of the first component).\nIt differs from `Σ a : α, β a` in that it allows `α` and `β` to have arbitrary sorts\n`Sort u` and `Sort v`, instead of restricting to `Type u` and `Type v`. This means\nthat it can be used in situations where one side is a proposition, like `(p : Nat) ×' p = p`.\n\nThe reason this is not the default is that this type lives in the universe `Sort (max 1 u v)`,\nwhich can cause problems for universe level unification,\nbecause the equation `max 1 u v = ?u + 1` has no solution in level arithmetic.\n`PSigma` is usually only used in automation that constructs pairs of arbitrary types.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L144-L144","name":"Sigma.snd","kind":"def","docLink":"./Init/Core.html#Sigma.snd","doc":"The second component of a dependent pair. If `p : Sigma β` then `p.2 : β p.1`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L142-L142","name":"Sigma.fst","kind":"def","docLink":"./Init/Core.html#Sigma.fst","doc":"The first component of a dependent pair. If `p : @Sigma α β` then `p.1 : α`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L140-L140","name":"Sigma.mk","kind":"ctor","docLink":"./Init/Core.html#Sigma.mk","doc":"Constructor for a dependent pair. If `a : α` and `b : β a` then `⟨a, b⟩ : Sigma β`.\n(This will usually require a type ascription to determine `β`\nsince it is not determined from `a` and `b` alone.) "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L136-L144","name":"Sigma","kind":"structure","docLink":"./Init/Core.html#Sigma","doc":"`Sigma β`, also denoted `Σ a : α, β a` or `(a : α) × β a`, is the type of dependent pairs\nwhose first component is `a : α` and whose second component is `b : β a`\n(so the type of the second component can depend on the value of the first component).\nIt is sometimes known as the dependent sum type, since it is the type level version\nof an indexed summation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L127-L127","name":"«term_⊕'_»","kind":"def","docLink":"./Init/Core.html#«term_⊕'_»","doc":"`PSum α β`, or `α ⊕' β`, is the disjoint union of types `α` and `β`.\nIt differs from `α ⊕ β` in that it allows `α` and `β` to have arbitrary sorts\n`Sort u` and `Sort v`, instead of restricting to `Type u` and `Type v`. This means\nthat it can be used in situations where one side is a proposition, like `True ⊕' Nat`.\n\nThe reason this is not the default is that this type lives in the universe `Sort (max 1 u v)`,\nwhich can cause problems for universe level unification,\nbecause the equation `max 1 u v = ?u + 1` has no solution in level arithmetic.\n`PSum` is usually only used in automation that constructs sums of arbitrary types.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L124-L125","name":"PSum.inr","kind":"ctor","docLink":"./Init/Core.html#PSum.inr","doc":"Right injection into the sum type `α ⊕' β`. If `b : β` then `.inr b : α ⊕' β`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L122-L123","name":"PSum.inl","kind":"ctor","docLink":"./Init/Core.html#PSum.inl","doc":"Left injection into the sum type `α ⊕' β`. If `a : α` then `.inl a : α ⊕' β`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L121-L125","name":"PSum","kind":"inductive","docLink":"./Init/Core.html#PSum","doc":"`PSum α β`, or `α ⊕' β`, is the disjoint union of types `α` and `β`.\nIt differs from `α ⊕ β` in that it allows `α` and `β` to have arbitrary sorts\n`Sort u` and `Sort v`, instead of restricting to `Type u` and `Type v`. This means\nthat it can be used in situations where one side is a proposition, like `True ⊕' Nat`.\n\nThe reason this is not the default is that this type lives in the universe `Sort (max 1 u v)`,\nwhich can cause problems for universe level unification,\nbecause the equation `max 1 u v = ?u + 1` has no solution in level arithmetic.\n`PSum` is usually only used in automation that constructs sums of arbitrary types.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L108-L108","name":"«term_⊕_»","kind":"def","docLink":"./Init/Core.html#«term_⊕_»","doc":"`Sum α β`, or `α ⊕ β`, is the disjoint union of types `α` and `β`.\nAn element of `α ⊕ β` is either of the form `.inl a` where `a : α`,\nor `.inr b` where `b : β`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L105-L106","name":"Sum.inr","kind":"ctor","docLink":"./Init/Core.html#Sum.inr","doc":"Right injection into the sum type `α ⊕ β`. If `b : β` then `.inr b : α ⊕ β`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L103-L104","name":"Sum.inl","kind":"ctor","docLink":"./Init/Core.html#Sum.inl","doc":"Left injection into the sum type `α ⊕ β`. If `a : α` then `.inl a : α ⊕ β`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L102-L106","name":"Sum","kind":"inductive","docLink":"./Init/Core.html#Sum","doc":"`Sum α β`, or `α ⊕ β`, is the disjoint union of types `α` and `β`.\nAn element of `α ⊕ β` is either of the form `.inl a` where `a : α`,\nor `.inr b` where `b : β`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L95-L95","name":"«term_↔_»","kind":"def","docLink":"./Init/Core.html#«term_↔_»","doc":"If and only if, or logical bi-implication. `a ↔ b` means that `a` implies `b` and vice versa.\nBy `propext`, this implies that `a` and `b` are equal and hence any expression involving `a`\nis equivalent to the corresponding expression with `b` instead.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L94-L94","name":"«term_<->_»","kind":"def","docLink":"./Init/Core.html#«term_<->_»","doc":"If and only if, or logical bi-implication. `a ↔ b` means that `a` implies `b` and vice versa.\nBy `propext`, this implies that `a` and `b` are equal and hence any expression involving `a`\nis equivalent to the corresponding expression with `b` instead.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L92-L92","name":"Iff.mpr","kind":"def","docLink":"./Init/Core.html#Iff.mpr","doc":"Modus ponens for if and only if, reversed. If `a ↔ b` and `b`, then `a`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L90-L90","name":"Iff.mp","kind":"def","docLink":"./Init/Core.html#Iff.mp","doc":"Modus ponens for if and only if. If `a ↔ b` and `a`, then `b`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L88-L88","name":"Iff.intro","kind":"ctor","docLink":"./Init/Core.html#Iff.intro","doc":"If `a → b` and `b → a` then `a` and `b` are equivalent. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L86-L92","name":"Iff","kind":"structure","docLink":"./Init/Core.html#Iff","doc":"If and only if, or logical bi-implication. `a ↔ b` means that `a` implies `b` and vice versa.\nBy `propext`, this implies that `a` and `b` are equal and hence any expression involving `a`\nis equivalent to the corresponding expression with `b` instead.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L73-L75","name":"thunkCoe","kind":"instance","docLink":"./Init/Core.html#thunkCoe","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L70-L71","name":"Thunk.sizeOf_eq","kind":"theorem","docLink":"./Init/Core.html#Thunk.sizeOf_eq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L67-L68","name":"Thunk.bind","kind":"def","docLink":"./Init/Core.html#Thunk.bind","doc":"Constructs a thunk that applies `f` to the result of `x` when forced. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L64-L65","name":"Thunk.map","kind":"def","docLink":"./Init/Core.html#Thunk.map","doc":"Map a function over a thunk. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L60-L61","name":"Thunk.get","kind":"def","docLink":"./Init/Core.html#Thunk.get","doc":"Forces a thunk to extract the value. This will cache the result,\nso a second call to the same function will return the value in O(1)\ninstead of calling the stored getter function.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L51-L52","name":"Thunk.pure","kind":"def","docLink":"./Init/Core.html#Thunk.pure","doc":"Store a value in a thunk. Note that the value has already been computed, so there is no laziness. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L44-L44","name":"Thunk.mk","kind":"ctor","docLink":"./Init/Core.html#Thunk.mk","doc":"Constructs a new thunk from a function `Unit → α`\nthat will be called when the thunk is forced. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L41-L46","name":"Thunk","kind":"structure","docLink":"./Init/Core.html#Thunk","doc":"Thunks are \"lazy\" values that are evaluated when first accessed using `Thunk.get/map/bind`.\nThe value is then stored and not recomputed for all further accesses. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L33-L33","name":"Function.comp_apply","kind":"theorem","docLink":"./Init/Core.html#Function.comp_apply","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L31-L31","name":"Function.const_apply","kind":"theorem","docLink":"./Init/Core.html#Function.const_apply","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L28-L29","name":"flip","kind":"def","docLink":"./Init/Core.html#flip","doc":"`flip f a b` is `f b a`. It is useful for \"point-free\" programming,\nsince it can sometimes be used to avoid introducing variables.\nFor example, `(·<·)` is the less-than relation,\nand `flip (·<·)` is the greater-than relation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Core.lean#L20-L20","name":"inline","kind":"def","docLink":"./Init/Core.html#inline","doc":"`inline (f x)` is an indication to the compiler to inline the definition of `f`\nat the application site itself (by comparison to the `@[inline]` attribute,\nwhich applies to all applications of the function).\n"}]}