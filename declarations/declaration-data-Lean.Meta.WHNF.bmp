{"name":"Lean.Meta.WHNF","instances":[],"imports":["Init","Lean.Structure","Lean.Util.Recognizers","Lean.Meta.GetConst","Lean.Meta.FunInfo","Lean.Meta.Match.MatcherInfo","Lean.Meta.Match.MatchPatternAttr"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L865-L878","name":"Lean.Meta.reduceProjOf?","kind":"def","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.reduceProjOf?","doc":"If `e` is a projection function that satisfies `p`, then reduce it "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L846-L862","name":"Lean.Meta.whnfImp","kind":"opaque","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.whnfImp","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L795-L814","name":"Lean.Meta.reduceNat?","kind":"def","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.reduceNat?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L790-L793","name":"Lean.Meta.reduceBinNatPred","kind":"def","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.reduceBinNatPred","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L784-L788","name":"Lean.Meta.reduceBinNatOp","kind":"def","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.reduceBinNatOp","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L780-L782","name":"Lean.Meta.reduceUnaryNatOp","kind":"def","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.reduceUnaryNatOp","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L773-L778","name":"Lean.Meta.withNatValue","kind":"def","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.withNatValue","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L761-L771","name":"Lean.Meta.reduceNative?","kind":"def","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.reduceNative?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L759-L759","name":"Lean.Meta.reduceNatNative","kind":"opaque","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.reduceNatNative","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L758-L758","name":"Lean.Meta.reduceBoolNative","kind":"opaque","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.reduceBoolNative","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L757-L757","name":"Lean.Meta.reduceNatNativeUnsafe","kind":"def","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.reduceNatNativeUnsafe","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L756-L756","name":"Lean.Meta.reduceBoolNativeUnsafe","kind":"def","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.reduceBoolNativeUnsafe","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L740-L754","name":"Lean.Meta.reduceRecMatcher?","kind":"def","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.reduceRecMatcher?","doc":"Try to reduce matcher/recursor/quot applications. We say they are all \"morally\" recursor applications. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L732-L737","name":"Lean.Meta.whnfUntil","kind":"def","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.whnfUntil","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L722-L730","name":"Lean.Meta.whnfHeadPred","kind":"opaque","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.whnfHeadPred","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L718-L720","name":"Lean.Meta.unfoldDefinition","kind":"def","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.unfoldDefinition","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L637-L715","name":"Lean.Meta.unfoldDefinition?","kind":"opaque","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.unfoldDefinition?","doc":"Unfold definition using \"smart unfolding\" if possible. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L630-L634","name":"Lean.Meta.unfoldProjInstWhenIntances?","kind":"opaque","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.unfoldProjInstWhenIntances?","doc":"Auxiliary method for unfolding a class projection. when transparency is set to `TransparencyMode.instances`.\nRecall that class instance projections are not marked with `[reducible]` because we want them to be\nin \"reducible canonical form\".\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L611-L623","name":"Lean.Meta.unfoldProjInst?","kind":"opaque","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.unfoldProjInst?","doc":"Auxiliary method for unfolding a class projection.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L590-L604","name":"Lean.Meta.smartUnfoldingReduce?.goMatch","kind":"opaque","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.smartUnfoldingReduce?.goMatch","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L577-L588","name":"Lean.Meta.smartUnfoldingReduce?.go","kind":"opaque","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.smartUnfoldingReduce?.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L574-L604","name":"Lean.Meta.smartUnfoldingReduce?","kind":"def","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.smartUnfoldingReduce?","doc":"Recall that `_sunfold` auxiliary definitions contains the markers: `markSmartUnfoldingMatch` (*) and `markSmartUnfoldingMatchAlt` (**).\nFor example, consider the following definition\n```\ndef r (i j : Nat) : Nat :=\n  i +\n    match j with\n    | Nat.zero => 1\n    | Nat.succ j =>\n      i + match j with\n          | Nat.zero => 2\n          | Nat.succ j => r i j\n```\nproduces the following `_sunfold` auxiliary definition with the markers\n```\ndef r._sunfold (i j : Nat) : Nat :=\n  i +\n    (*) match j with\n    | Nat.zero => (**) 1\n    | Nat.succ j =>\n      i + (*) match j with\n          | Nat.zero => (**) 2\n          | Nat.succ j => (**) r i j\n```\n\n`match` expressions marked with `markSmartUnfoldingMatch` (*) must be reduced, otherwise the resulting term is not definitionally\n equal to the given expression. The recursion may be interrupted as soon as the annotation `markSmartUnfoldingAlt` (**) is reached.\n\nFor example, the term `r i j.succ.succ` reduces to the definitionally equal term `i + i * r i j`\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L500-L542","name":"Lean.Meta.whnfCore.go","kind":"opaque","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.whnfCore.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L497-L542","name":"Lean.Meta.whnfCore","kind":"opaque","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.whnfCore","doc":"Apply beta-reduction, zeta-reduction (i.e., unfold let local-decls), iota-reduction,\nexpand let-expressions, expand assigned meta-variables.\n\nThe parameter `deltaAtProj` controls how to reduce projections `s.i`. If `deltaAtProj == true`,\nthen delta reduction is used to reduce `s` (i.e., `whnf` is used), otherwise `whnfCore`.\n\nIf `simpleReduceOnly`, then `iota` and projection reduction are not performed.\nNote that the value of `deltaAtProj` is irrelevant if `simpleReduceOnly = true`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L457-L460","name":"Lean.Meta.reduceProj?","kind":"def","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.reduceProj?","doc":"Reduce kernel projection `Expr.proj ..` expression. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L453-L454","name":"Lean.Meta.project?","kind":"def","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.project?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L416-L441","name":"Lean.Meta.reduceMatcher?","kind":"def","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.reduceMatcher?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L378-L401","name":"Lean.Meta.canUnfoldAtMatcher","kind":"def","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.canUnfoldAtMatcher","doc":"The \"match\" compiler uses `if-then-else` expressions and other auxiliary declarations to compile match-expressions such as\n```\nmatch v with\n| 'a' => 1\n| 'b' => 2\n| _   => 3\n```\nbecause it is more efficient than using `casesOn` recursors.\nThe method `reduceMatcher?` fails if these auxiliary definitions (e.g., `ite`) cannot be unfolded in the current\ntransparency setting. This is problematic because tactics such as `simp` use `TransparencyMode.reducible`, and\nmost users assume that expressions such as\n```\nmatch 0 with\n| 0 => 1\n| 100 => 2\n| _ => 3\n```\nshould reduce in any transparency mode.\nThus, we define a custom `canUnfoldAtMatcher` predicate for `whnfMatcher`.\n\nThis solution is not very modular because modifications at the `match` compiler require changes here.\nWe claim this is defensible because it is reducing the auxiliary declaration defined by the `match` compiler.\n\nAlternative solution: tactics that use `TransparencyMode.reducible` should rely on the equations we generated for match-expressions.\nThis solution is also not perfect because the match-expression above will not reduce during type checking when we are not using\n`TransparencyMode.default` or `TransparencyMode.all`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L348-L348","name":"Lean.Meta.ReduceMatcherResult.partialApp","kind":"ctor","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.ReduceMatcherResult.partialApp","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L347-L347","name":"Lean.Meta.ReduceMatcherResult.notMatcher","kind":"ctor","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.ReduceMatcherResult.notMatcher","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L346-L346","name":"Lean.Meta.ReduceMatcherResult.stuck","kind":"ctor","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.ReduceMatcherResult.stuck","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L345-L345","name":"Lean.Meta.ReduceMatcherResult.reduced","kind":"ctor","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.ReduceMatcherResult.reduced","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L344-L348","name":"Lean.Meta.ReduceMatcherResult","kind":"inductive","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.ReduceMatcherResult","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L299-L326","name":"Lean.Meta.whnfEasyCases","kind":"opaque","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.whnfEasyCases","doc":"Auxiliary combinator for handling easy WHNF cases. It takes a function for handling the \"hard\" cases as an argument "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L245-L291","name":"Lean.Meta.getStuckMVar?","kind":"opaque","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.getStuckMVar?","doc":"Return `some (Expr.mvar mvarId)` if metavariable `mvarId` is blocking reduction. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L117-L122","name":"Lean.Meta.mkProjFn","kind":"def","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.mkProjFn","doc":"Create the `i`th projection `major`. It tries to use the auto-generated projection functions if available. Otherwise falls back\nto `Expr.proj`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L58-L60","name":"Lean.Meta.isAuxDef","kind":"def","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.isAuxDef","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L51-L52","name":"Lean.Meta.smartUnfoldingMatchAlt?","kind":"def","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.smartUnfoldingMatchAlt?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L48-L49","name":"Lean.Meta.markSmartUnfoldingMatchAlt","kind":"def","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.markSmartUnfoldingMatchAlt","doc":"Add auxiliary annotation to indicate expression `e` (a `match` alternative rhs) was successfully reduced by smart unfolding. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L44-L45","name":"Lean.Meta.smartUnfoldingMatch?","kind":"def","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.smartUnfoldingMatch?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L41-L42","name":"Lean.Meta.markSmartUnfoldingMatch","kind":"def","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.markSmartUnfoldingMatch","doc":"Add auxiliary annotation to indicate the `match`-expression `e` must be reduced when performing smart unfolding. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L35-L38","name":"Lean.Meta.smartUnfolding","kind":"opaque","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.smartUnfolding","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L32-L33","name":"Lean.Meta.hasSmartUnfoldingDecl","kind":"def","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.hasSmartUnfoldingDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L29-L30","name":"Lean.Meta.mkSmartUnfoldingNameFor","kind":"def","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.mkSmartUnfoldingNameFor","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L27-L27","name":"Lean.Meta.smartUnfoldingSuffix","kind":"def","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.smartUnfoldingSuffix","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/WHNF.lean#L25-L25","name":"Lean.Meta.getStructuralRecArgPos?","kind":"opaque","docLink":"./Lean/Meta/WHNF.html#Lean.Meta.getStructuralRecArgPos?","doc":"Forward declaration. It is defined in the module `src/Lean/Elab/PreDefinition/Structural/Eqns.lean`.\nIt is possible to avoid this hack if we move `Structural.EqnInfo` and `Structural.eqnInfoExt`\nto this module.\n"}]}