{"name":"Init.Prelude","instances":[{"typeNames":[],"name":"instNonempty","className":"Nonempty"},{"typeNames":[],"name":"instNonemptyForAll","className":"Nonempty"},{"typeNames":[],"name":"instNonemptyForAll_1","className":"Nonempty"},{"typeNames":["_builtin_sortu"],"name":"instInhabitedSort","className":"Inhabited"},{"typeNames":[],"name":"instInhabitedForAll","className":"Inhabited"},{"typeNames":[],"name":"instInhabitedForAll_1","className":"Inhabited"},{"typeNames":["Bool"],"name":"instInhabitedBool","className":"Inhabited"},{"typeNames":["NonemptyType"],"name":"instInhabitedNonemptyType","className":"Inhabited"},{"typeNames":["Eq","Bool"],"name":"instDecidableEqBool","className":"Decidable"},{"typeNames":[],"name":"instBEq","className":"BEq"},{"typeNames":["And"],"name":"instDecidableAnd","className":"Decidable"},{"typeNames":["Or"],"name":"instDecidableOr","className":"Decidable"},{"typeNames":["Not"],"name":"instDecidableNot","className":"Decidable"},{"typeNames":["Nat"],"name":"instInhabitedNat","className":"Inhabited"},{"typeNames":["Nat"],"name":"instOfNatNat","className":"OfNat"},{"typeNames":["Eq"],"name":"instTransEq","className":"Trans"},{"typeNames":["Eq"],"name":"instTransEq_1","className":"Trans"},{"typeNames":[],"name":"instHAdd","className":"HAdd"},{"typeNames":[],"name":"instHSub","className":"HSub"},{"typeNames":[],"name":"instHMul","className":"HMul"},{"typeNames":[],"name":"instHDiv","className":"HDiv"},{"typeNames":[],"name":"instHMod","className":"HMod"},{"typeNames":[],"name":"instHPow","className":"HPow"},{"typeNames":[],"name":"instHAppend","className":"HAppend"},{"typeNames":[],"name":"instHOrElse","className":"HOrElse"},{"typeNames":[],"name":"instHAndThen","className":"HAndThen"},{"typeNames":[],"name":"instHAnd","className":"HAnd"},{"typeNames":[],"name":"instHXor","className":"HXor"},{"typeNames":[],"name":"instHOr","className":"HOr"},{"typeNames":[],"name":"instHShiftLeft","className":"HShiftLeft"},{"typeNames":[],"name":"instHShiftRight","className":"HShiftRight"},{"typeNames":["Nat"],"name":"instAddNat","className":"Add"},{"typeNames":["Nat"],"name":"instMulNat","className":"Mul"},{"typeNames":["Nat","Nat"],"name":"instPowNat","className":"Pow"},{"typeNames":["Nat"],"name":"instBEqNat","className":"BEq"},{"typeNames":["Eq","Nat"],"name":"instDecidableEqNat","className":"Decidable"},{"typeNames":["Nat"],"name":"instLENat","className":"LE"},{"typeNames":["Nat"],"name":"instLTNat","className":"LT"},{"typeNames":["LE.le","Nat","instLENat"],"name":"Nat.decLe","className":"Decidable"},{"typeNames":["LT.lt","Nat","instLTNat"],"name":"Nat.decLt","className":"Decidable"},{"typeNames":["Nat"],"name":"instMinNat","className":"Min"},{"typeNames":["Nat"],"name":"instSubNat","className":"Sub"},{"typeNames":["Eq","Fin"],"name":"instDecidableEqFin","className":"Decidable"},{"typeNames":["Fin"],"name":"instLTFin","className":"LT"},{"typeNames":["Fin"],"name":"instLEFin","className":"LE"},{"typeNames":["LT.lt","Fin","instLTFin"],"name":"Fin.decLt","className":"Decidable"},{"typeNames":["LE.le","Fin","instLEFin"],"name":"Fin.decLe","className":"Decidable"},{"typeNames":["Eq","UInt8"],"name":"instDecidableEqUInt8","className":"Decidable"},{"typeNames":["UInt8"],"name":"instInhabitedUInt8","className":"Inhabited"},{"typeNames":["Eq","UInt16"],"name":"instDecidableEqUInt16","className":"Decidable"},{"typeNames":["UInt16"],"name":"instInhabitedUInt16","className":"Inhabited"},{"typeNames":["Eq","UInt32"],"name":"instDecidableEqUInt32","className":"Decidable"},{"typeNames":["UInt32"],"name":"instInhabitedUInt32","className":"Inhabited"},{"typeNames":["UInt32"],"name":"instLTUInt32","className":"LT"},{"typeNames":["UInt32"],"name":"instLEUInt32","className":"LE"},{"typeNames":["LT.lt","UInt32","instLTUInt32"],"name":"instDecidableLtUInt32InstLTUInt32","className":"Decidable"},{"typeNames":["LE.le","UInt32","instLEUInt32"],"name":"instDecidableLeUInt32InstLEUInt32","className":"Decidable"},{"typeNames":["UInt32"],"name":"instMaxUInt32","className":"Max"},{"typeNames":["UInt32"],"name":"instMinUInt32","className":"Min"},{"typeNames":["Eq","UInt64"],"name":"instDecidableEqUInt64","className":"Decidable"},{"typeNames":["UInt64"],"name":"instInhabitedUInt64","className":"Inhabited"},{"typeNames":["Eq","USize"],"name":"instDecidableEqUSize","className":"Decidable"},{"typeNames":["USize"],"name":"instInhabitedUSize","className":"Inhabited"},{"typeNames":["Eq","Char"],"name":"instDecidableEqChar","className":"Decidable"},{"typeNames":["Option"],"name":"instInhabitedOption","className":"Inhabited"},{"typeNames":["List"],"name":"instInhabitedList","className":"Inhabited"},{"typeNames":["Eq","List"],"name":"instDecidableEqList","className":"Decidable"},{"typeNames":["Eq","String"],"name":"instDecidableEqString","className":"Decidable"},{"typeNames":["String.Pos"],"name":"instInhabitedPos","className":"Inhabited"},{"typeNames":["Eq","String.Pos"],"name":"instDecidableEqPos","className":"Decidable"},{"typeNames":["Substring"],"name":"instInhabitedSubstring","className":"Inhabited"},{"typeNames":["String.Pos","String.Pos","String.Pos"],"name":"instHAddPos","className":"HAdd"},{"typeNames":["String.Pos","String.Pos","String.Pos"],"name":"instHSubPos","className":"HSub"},{"typeNames":["String.Pos","Char","String.Pos"],"name":"instHAddPosChar","className":"HAdd"},{"typeNames":["String.Pos","String","String.Pos"],"name":"instHAddPosString","className":"HAdd"},{"typeNames":["String.Pos"],"name":"instLEPos","className":"LE"},{"typeNames":["String.Pos"],"name":"instLTPos","className":"LT"},{"typeNames":["LE.le","String.Pos","instLEPos"],"name":"instDecidableLePosInstLEPos","className":"Decidable"},{"typeNames":["LT.lt","String.Pos","instLTPos"],"name":"instDecidableLtPosInstLTPos","className":"Decidable"},{"typeNames":["Array","Nat","Array","Nat","LT.lt","instLTNat","Array.size"],"name":"instGetElemArrayNatLtInstLTNatSize","className":"GetElem"},{"typeNames":[],"name":"instInhabitedForAll_2","className":"Inhabited"},{"typeNames":[],"name":"instInhabited","className":"Inhabited"},{"typeNames":[],"name":"instForAllNonemptyNonempty","className":"Nonempty"},{"typeNames":[],"name":"instMonadLiftT","className":"MonadLiftT"},{"typeNames":[],"name":"instMonadLiftT_1","className":"MonadLiftT"},{"typeNames":[],"name":"instMonadFunctorT","className":"MonadFunctorT"},{"typeNames":[],"name":"monadFunctorRefl","className":"MonadFunctorT"},{"typeNames":["Except"],"name":"instInhabitedExcept","className":"Inhabited"},{"typeNames":[],"name":"instMonadExcept","className":"MonadExcept"},{"typeNames":[],"name":"MonadExcept.instOrElse","className":"OrElse"},{"typeNames":["ReaderT"],"name":"instInhabitedReaderT","className":"Inhabited"},{"typeNames":["ReaderT"],"name":"ReaderT.instMonadLiftReaderT","className":"MonadLift"},{"typeNames":["ReaderT"],"name":"ReaderT.instMonadExceptOfReaderT","className":"MonadExceptOf"},{"typeNames":["ReaderT"],"name":"ReaderT.instFunctorReaderT","className":"Functor"},{"typeNames":["ReaderT"],"name":"ReaderT.instApplicativeReaderT","className":"Applicative"},{"typeNames":["ReaderT"],"name":"ReaderT.instMonadReaderT","className":"Monad"},{"typeNames":["ReaderT"],"name":"ReaderT.instMonadFunctorReaderT","className":"MonadFunctor"},{"typeNames":[],"name":"instMonadReader","className":"MonadReader"},{"typeNames":[],"name":"instMonadReaderOf","className":"MonadReaderOf"},{"typeNames":["ReaderT"],"name":"instMonadReaderOfReaderT","className":"MonadReaderOf"},{"typeNames":[],"name":"instMonadWithReader","className":"MonadWithReader"},{"typeNames":[],"name":"instMonadWithReaderOf","className":"MonadWithReaderOf"},{"typeNames":["ReaderT"],"name":"instMonadWithReaderOfReaderT","className":"MonadWithReaderOf"},{"typeNames":[],"name":"instMonadState","className":"MonadState"},{"typeNames":[],"name":"instMonadStateOf","className":"MonadStateOf"},{"typeNames":["EStateM.Result"],"name":"EStateM.instInhabitedResult","className":"Inhabited"},{"typeNames":["EStateM"],"name":"EStateM.instInhabitedEStateM","className":"Inhabited"},{"typeNames":["EStateM"],"name":"EStateM.instMonadEStateM","className":"Monad"},{"typeNames":["EStateM"],"name":"EStateM.instOrElseEStateM","className":"OrElse"},{"typeNames":["EStateM"],"name":"EStateM.instMonadStateOfEStateM","className":"MonadStateOf"},{"typeNames":["EStateM"],"name":"EStateM.instMonadExceptOfEStateM","className":"MonadExceptOf"},{"typeNames":["PUnit"],"name":"EStateM.nonBacktrackable","className":"EStateM.Backtrackable"},{"typeNames":["Subtype"],"name":"instHashableSubtype","className":"Hashable"},{"typeNames":["String"],"name":"instHashableString","className":"Hashable"},{"typeNames":["Lean.Name"],"name":"Lean.instInhabitedName","className":"Inhabited"},{"typeNames":["Lean.Name"],"name":"Lean.instHashableName","className":"Hashable"},{"typeNames":["Lean.Name"],"name":"Lean.Name.instBEqName","className":"BEq"},{"typeNames":["Lean.SourceInfo"],"name":"Lean.instInhabitedSourceInfo","className":"Inhabited"},{"typeNames":["Lean.Syntax"],"name":"Lean.instInhabitedSyntax","className":"Inhabited"},{"typeNames":["Lean.TSyntax"],"name":"Lean.instInhabitedTSyntax","className":"Inhabited"},{"typeNames":["Lean.Syntax","Nat","Lean.Syntax","Lean.Syntax","Nat","True"],"name":"Lean.Syntax.instGetElemSyntaxNatTrue","className":"GetElem"},{"typeNames":["Lean.ParserDescr"],"name":"Lean.instInhabitedParserDescr","className":"Inhabited"},{"typeNames":[],"name":"Lean.instMonadRef","className":"Lean.MonadRef"},{"typeNames":[],"name":"Lean.instMonadQuotation","className":"Lean.MonadQuotation"},{"typeNames":["Lean.MacroScopesView"],"name":"Lean.instInhabitedMacroScopesView","className":"Inhabited"},{"typeNames":["Lean.Name"],"name":"Lean.instAppendName","className":"Append"},{"typeNames":["_private.Init.Prelude.0.Lean.Macro.MethodsRef"],"name":"Lean.Macro.instNonemptyMethodsRef","className":"Nonempty"},{"typeNames":["Lean.Macro.State"],"name":"Lean.Macro.instInhabitedState","className":"Inhabited"},{"typeNames":["Lean.MacroM"],"name":"Lean.Macro.instMonadRefMacroM","className":"Lean.MonadRef"},{"typeNames":["Lean.MacroM"],"name":"Lean.Macro.instMonadQuotationMacroM","className":"Lean.MonadQuotation"},{"typeNames":["Lean.Macro.Methods"],"name":"Lean.Macro.instInhabitedMethods","className":"Inhabited"},{"typeNames":["_private.Init.Prelude.0.Lean.Macro.MethodsRef"],"name":"Lean.Macro.instInhabitedMethodsRef","className":"Inhabited"},{"typeNames":["Lean.PrettyPrinter.UnexpandM"],"name":"Lean.PrettyPrinter.instMonadQuotationUnexpandM","className":"Lean.MonadQuotation"}],"imports":[],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4508-L4514","name":"Lean.PrettyPrinter.instMonadQuotationUnexpandM","kind":"instance","docLink":"./Init/Prelude.html#Lean.PrettyPrinter.instMonadQuotationUnexpandM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4506-L4506","name":"Lean.PrettyPrinter.Unexpander","kind":"def","docLink":"./Init/Prelude.html#Lean.PrettyPrinter.Unexpander","doc":"Function that tries to reverse macro expansions as a post-processing step of delaboration.\nWhile less general than an arbitrary delaborator, it can be declared without importing `Lean`.\nUsed by the `[app_unexpander]` attribute.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4498-L4498","name":"Lean.PrettyPrinter.UnexpandM","kind":"def","docLink":"./Init/Prelude.html#Lean.PrettyPrinter.UnexpandM","doc":"The unexpander monad, essentially `Syntax → Option α`. The `Syntax` is the `ref`,\nand it has the possibility of failure without an error message.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4485-L4486","name":"Lean.Macro.trace","kind":"def","docLink":"./Init/Prelude.html#Lean.Macro.trace","doc":"Add a new trace message, with the given trace class and message. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4481-L4482","name":"Lean.Macro.resolveGlobalName","kind":"def","docLink":"./Init/Prelude.html#Lean.Macro.resolveGlobalName","doc":"Resolves the given name to an overload list of global definitions.\nThe `List String` in each alternative is the deduced list of projections\n(which are ambiguous with name components).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4473-L4474","name":"Lean.Macro.resolveNamespace","kind":"def","docLink":"./Init/Prelude.html#Lean.Macro.resolveNamespace","doc":"Resolves the given name to an overload list of namespaces. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4469-L4470","name":"Lean.Macro.getCurrNamespace","kind":"def","docLink":"./Init/Prelude.html#Lean.Macro.getCurrNamespace","doc":"Gets the current namespace given the position in the file. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4465-L4466","name":"Lean.Macro.hasDecl","kind":"def","docLink":"./Init/Prelude.html#Lean.Macro.hasDecl","doc":"Returns `true` if the environment contains a declaration with name `declName` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4461-L4462","name":"Lean.Macro.expandMacro?","kind":"def","docLink":"./Init/Prelude.html#Lean.Macro.expandMacro?","doc":"`expandMacro? stx` returns `some stxNew` if `stx` is a macro,\nand `stxNew` is its expansion.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4455-L4455","name":"Lean.Macro.getMethods","kind":"opaque","docLink":"./Init/Prelude.html#Lean.Macro.getMethods","doc":"Extract the methods list from the `MacroM` state. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4451-L4452","name":"Lean.Macro.getMethodsImp","kind":"def","docLink":"./Init/Prelude.html#Lean.Macro.getMethodsImp","doc":"Implementation of `getMethods`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4447-L4448","name":"Lean.Macro.instInhabitedMethodsRef","kind":"instance","docLink":"./Init/Prelude.html#Lean.Macro.instInhabitedMethodsRef","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4445-L4445","name":"Lean.Macro.mkMethods","kind":"opaque","docLink":"./Init/Prelude.html#Lean.Macro.mkMethods","doc":"Make an opaque reference to a `Methods`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4440-L4441","name":"Lean.Macro.mkMethodsImp","kind":"def","docLink":"./Init/Prelude.html#Lean.Macro.mkMethodsImp","doc":"Implementation of `mkMethods`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4437-L4437","name":"Lean.Macro.instInhabitedMethods","kind":"instance","docLink":"./Init/Prelude.html#Lean.Macro.instInhabitedMethods","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4436-L4436","name":"Lean.Macro.Methods.resolveGlobalName","kind":"def","docLink":"./Init/Prelude.html#Lean.Macro.Methods.resolveGlobalName","doc":"Resolves the given name to an overload list of global definitions.\nThe `List String` in each alternative is the deduced list of projections\n(which are ambiguous with name components). "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4432-L4432","name":"Lean.Macro.Methods.resolveNamespace","kind":"def","docLink":"./Init/Prelude.html#Lean.Macro.Methods.resolveNamespace","doc":"Resolves the given name to an overload list of namespaces. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4430-L4430","name":"Lean.Macro.Methods.hasDecl","kind":"def","docLink":"./Init/Prelude.html#Lean.Macro.Methods.hasDecl","doc":"Check if a given name refers to a declaration. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4428-L4428","name":"Lean.Macro.Methods.getCurrNamespace","kind":"def","docLink":"./Init/Prelude.html#Lean.Macro.Methods.getCurrNamespace","doc":"Get the current namespace in the file. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4426-L4426","name":"Lean.Macro.Methods.expandMacro?","kind":"def","docLink":"./Init/Prelude.html#Lean.Macro.Methods.expandMacro?","doc":"Expands macros in the given syntax. A return value of `none` means there\nwas nothing to expand. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4423-L4437","name":"Lean.Macro.Methods","kind":"structure","docLink":"./Init/Prelude.html#Lean.Macro.Methods","doc":"The opaque methods that are available to `MacroM`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4417-L4420","name":"Lean.Macro.instMonadQuotationMacroM","kind":"instance","docLink":"./Init/Prelude.html#Lean.Macro.instMonadQuotationMacroM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4411-L4415","name":"Lean.Macro.withIncRecDepth","kind":"def","docLink":"./Init/Prelude.html#Lean.Macro.withIncRecDepth","doc":"Run `x` with an incremented recursion depth counter. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4406-L4408","name":"Lean.Macro.withFreshMacroScope","kind":"def","docLink":"./Init/Prelude.html#Lean.Macro.withFreshMacroScope","doc":"Increments the macro scope counter so that inside the body of `x` the macro\nscope is fresh.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4399-L4400","name":"Lean.Macro.throwErrorAt","kind":"def","docLink":"./Init/Prelude.html#Lean.Macro.throwErrorAt","doc":"Throw an error with the given message and location information. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4394-L4396","name":"Lean.Macro.throwError","kind":"def","docLink":"./Init/Prelude.html#Lean.Macro.throwError","doc":"Throw an error with the given message,\nusing the `ref` for the location information.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4387-L4388","name":"Lean.Macro.throwUnsupported","kind":"def","docLink":"./Init/Prelude.html#Lean.Macro.throwUnsupported","doc":"Throw an `unsupportedSyntax` exception. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4382-L4384","name":"Lean.Macro.addMacroScope","kind":"def","docLink":"./Init/Prelude.html#Lean.Macro.addMacroScope","doc":"Add a new macro scope to the name `n`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4377-L4379","name":"Lean.Macro.instMonadRefMacroM","kind":"instance","docLink":"./Init/Prelude.html#Lean.Macro.instMonadRefMacroM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4373-L4373","name":"Lean.Macro","kind":"def","docLink":"./Init/Prelude.html#Lean.Macro","doc":"A `macro` has type `Macro`, which is a `Syntax → MacroM Syntax`: it\nreceives an input syntax and is supposed to \"expand\" it into another piece of\nsyntax.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4366-L4366","name":"Lean.MacroM","kind":"def","docLink":"./Init/Prelude.html#Lean.MacroM","doc":"The `MacroM` monad is the main monad for macro expansion. It has the\ninformation needed to handle hygienic name generation, and is the monad that\n`macro` definitions live in.\n\nNotably, this is a (relatively) pure monad: there is no `IO` and no access to\nthe `Environment`. That means that things like declaration lookup are\nimpossible here, as well as `IO.Ref` or other side-effecting operations.\nFor more capabilities, macros can instead be written as `elab` using `adaptExpander`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4352-L4352","name":"Lean.Macro.instInhabitedState","kind":"instance","docLink":"./Init/Prelude.html#Lean.Macro.instInhabitedState","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4351-L4351","name":"Lean.Macro.State.traceMsgs","kind":"def","docLink":"./Init/Prelude.html#Lean.Macro.State.traceMsgs","doc":"The list of trace messages that have been produced, each with a trace\nclass and a message. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4348-L4348","name":"Lean.Macro.State.macroScope","kind":"def","docLink":"./Init/Prelude.html#Lean.Macro.State.macroScope","doc":"The global macro scope counter, used for producing fresh scope names. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4346-L4352","name":"Lean.Macro.State","kind":"structure","docLink":"./Init/Prelude.html#Lean.Macro.State","doc":"The mutable state for the `MacroM` monad. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4340-L4343","name":"Lean.Macro.Exception.unsupportedSyntax","kind":"ctor","docLink":"./Init/Prelude.html#Lean.Macro.Exception.unsupportedSyntax","doc":"An unsupported syntax exception. We keep this separate because it is\nused for control flow: if one macro does not support a syntax then we try\nthe next one. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4338-L4339","name":"Lean.Macro.Exception.error","kind":"ctor","docLink":"./Init/Prelude.html#Lean.Macro.Exception.error","doc":"A general error, given a message and a span (expressed as a `Syntax`). "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4337-L4343","name":"Lean.Macro.Exception","kind":"inductive","docLink":"./Init/Prelude.html#Lean.Macro.Exception","doc":"An exception in the `MacroM` monad. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4334-L4334","name":"Lean.Macro.Context.ref","kind":"def","docLink":"./Init/Prelude.html#Lean.Macro.Context.ref","doc":"The syntax which supplies the position of error messages. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4332-L4332","name":"Lean.Macro.Context.maxRecDepth","kind":"def","docLink":"./Init/Prelude.html#Lean.Macro.Context.maxRecDepth","doc":"The maximum recursion depth. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4330-L4330","name":"Lean.Macro.Context.currRecDepth","kind":"def","docLink":"./Init/Prelude.html#Lean.Macro.Context.currRecDepth","doc":"The current recursion depth. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4328-L4328","name":"Lean.Macro.Context.currMacroScope","kind":"def","docLink":"./Init/Prelude.html#Lean.Macro.Context.currMacroScope","doc":"The current macro scope. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4326-L4326","name":"Lean.Macro.Context.mainModule","kind":"def","docLink":"./Init/Prelude.html#Lean.Macro.Context.mainModule","doc":"The currently parsing module. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4324-L4324","name":"Lean.Macro.Context.methods","kind":"def","docLink":"./Init/Prelude.html#Lean.Macro.Context.methods","doc":"An opaque reference to the `Methods` object. This is done to break a\ndependency cycle: the `Methods` involve `MacroM` which has not been defined yet. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4321-L4334","name":"Lean.Macro.Context","kind":"structure","docLink":"./Init/Prelude.html#Lean.Macro.Context","doc":"The read-only context for the `MacroM` monad. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4318-L4318","name":"Lean.Macro.instNonemptyMethodsRef","kind":"instance","docLink":"./Init/Prelude.html#Lean.Macro.instNonemptyMethodsRef","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4302-L4307","name":"Lean.Syntax.matchesLit","kind":"def","docLink":"./Init/Prelude.html#Lean.Syntax.matchesLit","doc":"Is this syntax a node kind `k` wrapping an `atom _ val`? "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4298-L4299","name":"Lean.Syntax.matchesIdent","kind":"def","docLink":"./Init/Prelude.html#Lean.Syntax.matchesIdent","doc":"Function used for determining whether a syntax pattern `` `(id) `` is matched.\nThere are various conceivable notions of when two syntactic identifiers should be regarded as identical,\nbut semantic definitions like whether they refer to the same global name cannot be implemented without\ncontext information (i.e. `MonadResolveName`). Thus in patterns we default to the structural solution\nof comparing the identifiers' `Name` values, though we at least do so modulo macro scopes so that\nidentifiers that \"look\" the same match. This is particularly useful when dealing with identifiers that\ndo not actually refer to Lean bindings, e.g. in the `stx` pattern `` `(many($p)) ``. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4287-L4288","name":"Lean.Syntax.matchesNull","kind":"def","docLink":"./Init/Prelude.html#Lean.Syntax.matchesNull","doc":"Is this syntax a null `node`? "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4281-L4282","name":"Lean.maxRecDepthErrorMessage","kind":"def","docLink":"./Init/Prelude.html#Lean.maxRecDepthErrorMessage","doc":"The message to display on stack overflow. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4278-L4278","name":"Lean.defaultMaxRecDepth","kind":"def","docLink":"./Init/Prelude.html#Lean.defaultMaxRecDepth","doc":"The default maximum recursion depth. This is adjustable using the `maxRecDepth` option. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4272-L4275","name":"Lean.MonadQuotation.addMacroScope","kind":"def","docLink":"./Init/Prelude.html#Lean.MonadQuotation.addMacroScope","doc":"Add a new macro scope onto the name `n`, using the monad state to supply the\nmain module and current macro scope.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4265-L4266","name":"Lean.instAppendName","kind":"instance","docLink":"./Init/Prelude.html#Lean.instAppendName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4253-L4263","name":"Lean.Name.append","kind":"def","docLink":"./Init/Prelude.html#Lean.Name.append","doc":"Append two names that may have macro scopes. The macro scopes in `b` are always erased.\nIf `a` has macro scopes, then they are propagated to the result of `append a b`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4234-L4247","name":"Lean.addMacroScope","kind":"def","docLink":"./Init/Prelude.html#Lean.addMacroScope","doc":"Add a new macro scope onto the name `n`, in the given `mainModule`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4228-L4231","name":"Lean.extractMacroScopes","kind":"def","docLink":"./Init/Prelude.html#Lean.extractMacroScopes","doc":"Revert all `addMacroScope` calls. `v = extractMacroScopes n → n = v.review`.\nThis operation is useful for analyzing/transforming the original identifiers, then adding back\nthe scopes (via `MacroScopesView.review`). "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4190-L4195","name":"Lean.MacroScopesView.review","kind":"def","docLink":"./Init/Prelude.html#Lean.MacroScopesView.review","doc":"Encode a hygienic name from the parsed pieces. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4186-L4187","name":"Lean.instInhabitedMacroScopesView","kind":"instance","docLink":"./Init/Prelude.html#Lean.instInhabitedMacroScopesView","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4184-L4184","name":"Lean.MacroScopesView.scopes","kind":"def","docLink":"./Init/Prelude.html#Lean.MacroScopesView.scopes","doc":"The list of macro scopes. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4182-L4182","name":"Lean.MacroScopesView.mainModule","kind":"def","docLink":"./Init/Prelude.html#Lean.MacroScopesView.mainModule","doc":"The main module in which this identifier was parsed. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4180-L4180","name":"Lean.MacroScopesView.imported","kind":"def","docLink":"./Init/Prelude.html#Lean.MacroScopesView.imported","doc":"All the name components `(<module_name>.<scopes>)*` from the imports\nconcatenated together. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4177-L4177","name":"Lean.MacroScopesView.name","kind":"def","docLink":"./Init/Prelude.html#Lean.MacroScopesView.name","doc":"The original (unhygienic) name. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4175-L4184","name":"Lean.MacroScopesView","kind":"structure","docLink":"./Init/Prelude.html#Lean.MacroScopesView","doc":"A `MacroScopesView` represents a parsed hygienic name. `extractMacroScopes`\nwill decode it from a `Name`, and `.review` will re-encode it. The grammar of a\nhygienic name is:\n```\n<name>._@.(<module_name>.<scopes>)*.<mainModule>._hyg.<scopes>\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4162-L4165","name":"Lean.Name.simpMacroScopes","kind":"def","docLink":"./Init/Prelude.html#Lean.Name.simpMacroScopes","doc":"Helper function we use to create binder names that do not need to be unique. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4151-L4154","name":"Lean.Name.eraseMacroScopes","kind":"def","docLink":"./Init/Prelude.html#Lean.Name.eraseMacroScopes","doc":"Remove the macro scopes from the name. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4137-L4140","name":"Lean.Name.hasMacroScopes","kind":"def","docLink":"./Init/Prelude.html#Lean.Name.hasMacroScopes","doc":"Does this name have hygienic macro scopes? "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4110-L4113","name":"Lean.instMonadQuotation","kind":"instance","docLink":"./Init/Prelude.html#Lean.instMonadQuotation","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4107-L4108","name":"Lean.MonadRef.mkInfoFromRefPos","kind":"def","docLink":"./Init/Prelude.html#Lean.MonadRef.mkInfoFromRefPos","doc":"Construct a synthetic `SourceInfo` from the `ref` in the monad state. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4101-L4101","name":"Lean.MonadQuotation.withFreshMacroScope","kind":"def","docLink":"./Init/Prelude.html#Lean.MonadQuotation.withFreshMacroScope","doc":"Execute action in a new macro invocation context. This transformer should be\nused at all places that morally qualify as the beginning of a \"macro call\",\ne.g. `elabCommand` and `elabTerm` in the case of the elaborator. However, it\ncan also be used internally inside a \"macro\" if identifiers introduced by\ne.g. different recursive calls should be independent and not collide. While\nreturning an intermediate syntax tree that will recursively be expanded by\nthe elaborator can be used for the same effect, doing direct recursion inside\nthe macro guarded by this transformer is often easier because one is not\nrestricted to passing a single syntax tree. Modelling this helper as a\ntransformer and not just a monadic action ensures that the current macro\nscope before the recursive call is restored after it, as expected.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4087-L4087","name":"Lean.MonadQuotation.getMainModule","kind":"def","docLink":"./Init/Prelude.html#Lean.MonadQuotation.getMainModule","doc":"Get the module name of the current file. This is used to ensure that\nhygienic names don't clash across multiple files. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4084-L4084","name":"Lean.MonadQuotation.getCurrMacroScope","kind":"def","docLink":"./Init/Prelude.html#Lean.MonadQuotation.getCurrMacroScope","doc":"Get the fresh scope of the current macro invocation "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4082-L4082","name":"Lean.MonadQuotation.mk","kind":"ctor","docLink":"./Init/Prelude.html#Lean.MonadQuotation.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4082-L4101","name":"Lean.MonadQuotation","kind":"class","docLink":"./Init/Prelude.html#Lean.MonadQuotation","doc":"A monad that supports syntax quotations. Syntax quotations (in term\nposition) are monadic values that when executed retrieve the current \"macro\nscope\" from the monad and apply it to every identifier they introduce\n(independent of whether this identifier turns out to be a reference to an\nexisting declaration, or an actually fresh binding during further\nelaboration). We also apply the position of the result of `getRef` to each\nintroduced symbol, which results in better error positions than not applying\nany position. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4069-L4072","name":"Lean.withRef","kind":"def","docLink":"./Init/Prelude.html#Lean.withRef","doc":"Run `x : m α` with a modified value for the `ref`. This is not exactly\nthe same as `MonadRef.withRef`, because it uses `replaceRef` to avoid putting\nsyntax with bad spans in the state.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4058-L4061","name":"Lean.replaceRef","kind":"def","docLink":"./Init/Prelude.html#Lean.replaceRef","doc":"Replaces `oldRef` with `ref`, unless `ref` has no position info.\nThis biases us to having a valid span to report an error on.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4050-L4052","name":"Lean.instMonadRef","kind":"instance","docLink":"./Init/Prelude.html#Lean.instMonadRef","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4046-L4046","name":"Lean.MonadRef.withRef","kind":"def","docLink":"./Init/Prelude.html#Lean.MonadRef.withRef","doc":"Run `x : m α` with a modified value for the `ref` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4044-L4044","name":"Lean.MonadRef.getRef","kind":"def","docLink":"./Init/Prelude.html#Lean.MonadRef.getRef","doc":"Get the current value of the `ref` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4042-L4042","name":"Lean.MonadRef.mk","kind":"ctor","docLink":"./Init/Prelude.html#Lean.MonadRef.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4042-L4046","name":"Lean.MonadRef","kind":"class","docLink":"./Init/Prelude.html#Lean.MonadRef","doc":"A `MonadRef` is a monad that has a `ref : Syntax` in the read-only state.\nThis is used to keep track of the location where we are working; if an exception\nis thrown, the `ref` gives the location where the error will be reported,\nassuming no more specific location is provided.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4034-L4034","name":"Lean.firstFrontendMacroScope","kind":"def","docLink":"./Init/Prelude.html#Lean.firstFrontendMacroScope","doc":"First macro scope available for our frontend "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4032-L4032","name":"Lean.reservedMacroScope","kind":"def","docLink":"./Init/Prelude.html#Lean.reservedMacroScope","doc":"Macro scope used internally. It is not available for our frontend. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4030-L4030","name":"Lean.MacroScope","kind":"def","docLink":"./Init/Prelude.html#Lean.MacroScope","doc":"A macro scope identifier is just a `Nat` that gets bumped every time we\nenter a new macro scope. Within a macro scope, all occurrences of identifier `x`\nparse to the same thing, but `x` parsed from different macro scopes will\nproduce different identifiers.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4016-L4016","name":"Lean.TrailingParserDescr","kind":"def","docLink":"./Init/Prelude.html#Lean.TrailingParserDescr","doc":"Although `TrailingParserDescr` is an abbreviation for `ParserDescr`, Lean will\nlook at the declared type in order to determine whether to add the parser to\nthe leading or trailing parser table. The determination is done automatically\nby the `syntax` command.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4007-L4008","name":"Lean.instInhabitedParserDescr","kind":"instance","docLink":"./Init/Prelude.html#Lean.instInhabitedParserDescr","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L4003-L4005","name":"Lean.ParserDescr.sepBy1","kind":"ctor","docLink":"./Init/Prelude.html#Lean.ParserDescr.sepBy1","doc":"`sepBy1` is just like `sepBy`, except it takes 1 or more instead of\n0 or more occurrences of `p`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3998-L4002","name":"Lean.ParserDescr.sepBy","kind":"ctor","docLink":"./Init/Prelude.html#Lean.ParserDescr.sepBy","doc":"A `sepBy(p, sep)` parses 0 or more occurrences of `p` separated by `sep`.\n`psep` is usually the same as `symbol sep`, but it can be overridden.\n`sep` is only used in the antiquot syntax: `$x;*` would match if `sep` is `\";\"`.\n`allowTrailingSep` is true if e.g. `a, b,` is also allowed to match. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3994-L3997","name":"Lean.ParserDescr.nodeWithAntiquot","kind":"ctor","docLink":"./Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot","doc":"Like `node`, but also declares that the body can be matched using an antiquotation\nwith name `name`. For example, `def $id:declId := 1` uses an antiquotation with\nname `declId` in the place where a `declId` is expected. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3991-L3993","name":"Lean.ParserDescr.parser","kind":"ctor","docLink":"./Init/Prelude.html#Lean.ParserDescr.parser","doc":"Parses using another parser `declName`, which can be either\na `Parser` or `ParserDescr`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3988-L3990","name":"Lean.ParserDescr.cat","kind":"ctor","docLink":"./Init/Prelude.html#Lean.ParserDescr.cat","doc":"Parses using the category parser `catName` with right binding power\n(i.e. precedence) `rbp`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3985-L3987","name":"Lean.ParserDescr.nonReservedSymbol","kind":"ctor","docLink":"./Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol","doc":"Like `symbol`, but without reserving `val` as a keyword.\nIf `includeIdent` is true then `ident` will be reinterpreted as `atom` if it matches. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3981-L3984","name":"Lean.ParserDescr.symbol","kind":"ctor","docLink":"./Init/Prelude.html#Lean.ParserDescr.symbol","doc":"A literal symbol parser: parses `val` as a literal.\nThis parser does not work on identifiers, so `symbol` arguments are declared\nas \"keywords\" and cannot be used as identifiers anywhere in the file. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3975-L3980","name":"Lean.ParserDescr.trailingNode","kind":"ctor","docLink":"./Init/Prelude.html#Lean.ParserDescr.trailingNode","doc":"Like `node` but for trailing parsers (which start with a nonterminal).\nAssumes the lhs is already on the stack, and parses using `p`, then pops the\nstack including the lhs to create a new node with kind `kind`.\nThe precedence `prec` and `lhsPrec` are used to determine whether the parser\nshould apply. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3971-L3974","name":"Lean.ParserDescr.node","kind":"ctor","docLink":"./Init/Prelude.html#Lean.ParserDescr.node","doc":"Parses using `p`, then pops the stack to create a new node with kind `kind`.\nThe precedence `prec` is used to determine whether the parser should apply given\nthe current precedence level. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3968-L3970","name":"Lean.ParserDescr.binary","kind":"ctor","docLink":"./Init/Prelude.html#Lean.ParserDescr.binary","doc":"A (named) binary parser, like `orelse` or `andthen`\n(written as `p1 <|> p2` and `p1 p2` respectively in `syntax`) "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3966-L3967","name":"Lean.ParserDescr.unary","kind":"ctor","docLink":"./Init/Prelude.html#Lean.ParserDescr.unary","doc":"A (named) unary parser, like `group(p)` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3964-L3965","name":"Lean.ParserDescr.const","kind":"ctor","docLink":"./Init/Prelude.html#Lean.ParserDescr.const","doc":"A (named) nullary parser, like `ppSpace` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3963-L4005","name":"Lean.ParserDescr","kind":"inductive","docLink":"./Init/Prelude.html#Lean.ParserDescr","doc":"A `ParserDescr` is a grammar for parsers. This is used by the `syntax` command\nto produce parsers without having to `import Lean`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3954-L3955","name":"Lean.mkAtomFrom","kind":"def","docLink":"./Init/Prelude.html#Lean.mkAtomFrom","doc":"Constructs a synthetic `atom` with source info coming from `src`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3950-L3951","name":"Lean.mkAtom","kind":"def","docLink":"./Init/Prelude.html#Lean.mkAtom","doc":"Constructs a synthetic `atom` with no source info. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3937-L3947","name":"Lean.SourceInfo.fromRef","kind":"def","docLink":"./Init/Prelude.html#Lean.SourceInfo.fromRef","doc":"Constructs a synthetic `SourceInfo` using a `ref : Syntax` for the span. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3934-L3934","name":"Lean.TSyntaxArray.mk","kind":"opaque","docLink":"./Init/Prelude.html#Lean.TSyntaxArray.mk","doc":"Converts an `Array Syntax` to a `TSyntaxArray`, without reallocation. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3930-L3930","name":"Lean.TSyntaxArray.mkImpl","kind":"def","docLink":"./Init/Prelude.html#Lean.TSyntaxArray.mkImpl","doc":"Implementation of `TSyntaxArray.mk`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3927-L3927","name":"Lean.TSyntaxArray.raw","kind":"opaque","docLink":"./Init/Prelude.html#Lean.TSyntaxArray.raw","doc":"Converts a `TSyntaxArray` to an `Array Syntax`, without reallocation. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3923-L3923","name":"Lean.TSyntaxArray.rawImpl","kind":"def","docLink":"./Init/Prelude.html#Lean.TSyntaxArray.rawImpl","doc":"Implementation of `TSyntaxArray.raw`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3920-L3920","name":"Lean.TSyntaxArray","kind":"def","docLink":"./Init/Prelude.html#Lean.TSyntaxArray","doc":"An array of syntaxes of kind `ks`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3915-L3915","name":"Lean.Syntax.TSepArray.elemsAndSeps","kind":"def","docLink":"./Init/Prelude.html#Lean.Syntax.TSepArray.elemsAndSeps","doc":"The array of elements and separators, ordered like\n`#[el1, sep1, el2, sep2, el3]`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3912-L3912","name":"Lean.Syntax.TSepArray.mk","kind":"ctor","docLink":"./Init/Prelude.html#Lean.Syntax.TSepArray.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3912-L3915","name":"Lean.Syntax.TSepArray","kind":"structure","docLink":"./Init/Prelude.html#Lean.Syntax.TSepArray","doc":"A typed version of `SepArray`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3909-L3909","name":"Lean.Syntax.SepArray.elemsAndSeps","kind":"def","docLink":"./Init/Prelude.html#Lean.Syntax.SepArray.elemsAndSeps","doc":"The array of elements and separators, ordered like\n`#[el1, sep1, el2, sep2, el3]`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3906-L3906","name":"Lean.Syntax.SepArray.mk","kind":"ctor","docLink":"./Init/Prelude.html#Lean.Syntax.SepArray.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3906-L3909","name":"Lean.Syntax.SepArray","kind":"structure","docLink":"./Init/Prelude.html#Lean.Syntax.SepArray","doc":"An array of syntax elements interspersed with separators. Can be coerced\nto/from `Array Syntax` to automatically remove/insert the separators.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3893-L3898","name":"Lean.Syntax.getTailPos?.loop","kind":"opaque","docLink":"./Init/Prelude.html#Lean.Syntax.getTailPos?.loop","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3881-L3900","name":"Lean.Syntax.getTailPos?","kind":"opaque","docLink":"./Init/Prelude.html#Lean.Syntax.getTailPos?","doc":"Get the ending position of the syntax, if possible.\nIf `canonicalOnly` is true, non-canonical `synthetic` nodes are treated as not carrying\nposition information.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3872-L3873","name":"Lean.Syntax.getPos?","kind":"def","docLink":"./Init/Prelude.html#Lean.Syntax.getPos?","doc":"Get the starting position of the syntax, if possible.\nIf `canonicalOnly` is true, non-canonical `synthetic` nodes are treated as not carrying\nposition information.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3862-L3865","name":"Lean.Syntax.getHeadInfo","kind":"def","docLink":"./Init/Prelude.html#Lean.Syntax.getHeadInfo","doc":"Retrieve the left-most leaf's info in the Syntax tree, or `none` if there is no token. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3851-L3856","name":"Lean.Syntax.getHeadInfo?.loop","kind":"opaque","docLink":"./Init/Prelude.html#Lean.Syntax.getHeadInfo?.loop","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3847-L3859","name":"Lean.Syntax.getHeadInfo?","kind":"opaque","docLink":"./Init/Prelude.html#Lean.Syntax.getHeadInfo?","doc":"Retrieve the left-most node or leaf's info in the Syntax tree. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3841-L3844","name":"Lean.Syntax.setArg","kind":"def","docLink":"./Init/Prelude.html#Lean.Syntax.setArg","doc":"Updates the `i`'th argument of the syntax.\nDoes nothing for non-`node` nodes, or if `i` is out of bounds of the node list.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3832-L3835","name":"Lean.Syntax.setArgs","kind":"def","docLink":"./Init/Prelude.html#Lean.Syntax.setArgs","doc":"Updates the argument list without changing the node kind.\nDoes nothing for non-`node` nodes.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3824-L3826","name":"Lean.Syntax.getId","kind":"def","docLink":"./Init/Prelude.html#Lean.Syntax.getId","doc":"If this is an `ident`, return the parsed value, else `.anonymous`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3819-L3821","name":"Lean.Syntax.isIdent","kind":"def","docLink":"./Init/Prelude.html#Lean.Syntax.isIdent","doc":"`stx.isIdent` is `true` iff `stx` is an identifier. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3815-L3816","name":"Lean.Syntax.isNodeOf","kind":"def","docLink":"./Init/Prelude.html#Lean.Syntax.isNodeOf","doc":"Is this syntax a `node` with kind `k`? "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3810-L3812","name":"Lean.Syntax.isMissing","kind":"def","docLink":"./Init/Prelude.html#Lean.Syntax.isMissing","doc":"Is this syntax `.missing`? "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3802-L3807","name":"Lean.Syntax.getOptional?","kind":"def","docLink":"./Init/Prelude.html#Lean.Syntax.getOptional?","doc":"Assuming `stx` was parsed by `optional`, returns the enclosed syntax\nif it parsed something and `none` otherwise.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3793-L3796","name":"Lean.Syntax.getNumArgs","kind":"def","docLink":"./Init/Prelude.html#Lean.Syntax.getNumArgs","doc":"Gets the number of arguments of the syntax node, or `0` if it's not a `node`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3787-L3790","name":"Lean.Syntax.getArgs","kind":"def","docLink":"./Init/Prelude.html#Lean.Syntax.getArgs","doc":"Gets the list of arguments of the syntax node, or `#[]` if it's not a `node`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3783-L3784","name":"Lean.Syntax.instGetElemSyntaxNatTrue","kind":"instance","docLink":"./Init/Prelude.html#Lean.Syntax.instGetElemSyntaxNatTrue","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3778-L3781","name":"Lean.Syntax.getArg","kind":"def","docLink":"./Init/Prelude.html#Lean.Syntax.getArg","doc":"Gets the `i`'th argument of the syntax node. This can also be written `stx[i]`.\nReturns `missing` if `i` is out of range.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3771-L3772","name":"Lean.Syntax.isOfKind","kind":"def","docLink":"./Init/Prelude.html#Lean.Syntax.isOfKind","doc":"Is this a syntax with node kind `k`? "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3765-L3768","name":"Lean.Syntax.setKind","kind":"def","docLink":"./Init/Prelude.html#Lean.Syntax.setKind","doc":"Changes the kind at the root of a `Syntax` node to `k`.\nDoes nothing for non-`node` nodes.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3751-L3759","name":"Lean.Syntax.getKind","kind":"def","docLink":"./Init/Prelude.html#Lean.Syntax.getKind","doc":"Gets the kind of a `Syntax` node. For non-`node` syntax, we use \"pseudo kinds\":\n`identKind` for `ident`, `missing` for `missing`, and the atom's string literal\nfor atoms.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3741-L3742","name":"Lean.mkNullNode","kind":"def","docLink":"./Init/Prelude.html#Lean.mkNullNode","doc":"Creates an info-less `nullKind` node with the given children, if any. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3736-L3737","name":"Lean.mkNode","kind":"def","docLink":"./Init/Prelude.html#Lean.mkNode","doc":"Creates an info-less node of the given kind and children. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3733-L3733","name":"Lean.interpolatedStrKind","kind":"def","docLink":"./Init/Prelude.html#Lean.interpolatedStrKind","doc":"`interpolatedStrKind` is the node kind of an interpolated string literal\nlike `\"value = {x}\"` in `s!\"value = {x}\"`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3728-L3728","name":"Lean.interpolatedStrLitKind","kind":"def","docLink":"./Init/Prelude.html#Lean.interpolatedStrLitKind","doc":"`interpolatedStrLitKind` is the node kind of interpolated string literal\nfragments like `\"value = {` and `}\"` in `s!\"value = {x}\"`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3722-L3722","name":"Lean.fieldIdxKind","kind":"def","docLink":"./Init/Prelude.html#Lean.fieldIdxKind","doc":"`fieldIdx` is the node kind of projection indices like the `2` in `x.2`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3719-L3719","name":"Lean.nameLitKind","kind":"def","docLink":"./Init/Prelude.html#Lean.nameLitKind","doc":"`name` is the node kind of name literals like `` `foo ``. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3716-L3716","name":"Lean.scientificLitKind","kind":"def","docLink":"./Init/Prelude.html#Lean.scientificLitKind","doc":"`scientific` is the node kind of floating point literals like `1.23e-3`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3713-L3713","name":"Lean.numLitKind","kind":"def","docLink":"./Init/Prelude.html#Lean.numLitKind","doc":"`num` is the node kind of number literals like `42`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3710-L3710","name":"Lean.charLitKind","kind":"def","docLink":"./Init/Prelude.html#Lean.charLitKind","doc":"`char` is the node kind of character literals like `'A'`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3707-L3707","name":"Lean.strLitKind","kind":"def","docLink":"./Init/Prelude.html#Lean.strLitKind","doc":"`str` is the node kind of string literals like `\"foo\"`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3704-L3704","name":"Lean.identKind","kind":"def","docLink":"./Init/Prelude.html#Lean.identKind","doc":"`ident` is not actually used as a node kind, but it is returned by\n`getKind` in the `ident` case so that things that handle different node\nkinds can also handle `ident`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3697-L3697","name":"Lean.groupKind","kind":"def","docLink":"./Init/Prelude.html#Lean.groupKind","doc":"The `group` kind is by the `group` parser, to avoid confusing with the null\nkind when used inside `optional`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3691-L3691","name":"Lean.nullKind","kind":"def","docLink":"./Init/Prelude.html#Lean.nullKind","doc":"The null kind is used for raw list parsers like `many`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3688-L3688","name":"Lean.choiceKind","kind":"def","docLink":"./Init/Prelude.html#Lean.choiceKind","doc":"The `choice` kind is used when a piece of syntax has multiple parses, and the\ndetermination of which to use is deferred until typing information is available.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3679-L3680","name":"Lean.instInhabitedTSyntax","kind":"instance","docLink":"./Init/Prelude.html#Lean.instInhabitedTSyntax","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3676-L3677","name":"Lean.instInhabitedSyntax","kind":"instance","docLink":"./Init/Prelude.html#Lean.instInhabitedSyntax","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3674-L3674","name":"Lean.TSyntax.raw","kind":"def","docLink":"./Init/Prelude.html#Lean.TSyntax.raw","doc":"The underlying `Syntax` value. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3672-L3672","name":"Lean.TSyntax.mk","kind":"ctor","docLink":"./Init/Prelude.html#Lean.TSyntax.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3672-L3674","name":"Lean.TSyntax","kind":"structure","docLink":"./Init/Prelude.html#Lean.TSyntax","doc":"A `Syntax` value of one of the given syntax kinds.\nNote that while syntax quotations produce/expect `TSyntax` values of the correct kinds,\nthis is not otherwise enforced and can easily be circumvented by direct use of the constructor.\nThe namespace `TSyntax.Compat` can be opened to expose a general coercion from `Syntax` to any\n`TSyntax ks` for porting older code.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3663-L3663","name":"Lean.SyntaxNodeKinds","kind":"def","docLink":"./Init/Prelude.html#Lean.SyntaxNodeKinds","doc":"`SyntaxNodeKinds` is a set of `SyntaxNodeKind` (implemented as a list). "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3659-L3660","name":"Lean.Syntax.node8","kind":"def","docLink":"./Init/Prelude.html#Lean.Syntax.node8","doc":"Create syntax node with 8 children "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3655-L3656","name":"Lean.Syntax.node7","kind":"def","docLink":"./Init/Prelude.html#Lean.Syntax.node7","doc":"Create syntax node with 7 children "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3651-L3652","name":"Lean.Syntax.node6","kind":"def","docLink":"./Init/Prelude.html#Lean.Syntax.node6","doc":"Create syntax node with 6 children "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3647-L3648","name":"Lean.Syntax.node5","kind":"def","docLink":"./Init/Prelude.html#Lean.Syntax.node5","doc":"Create syntax node with 5 children "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3643-L3644","name":"Lean.Syntax.node4","kind":"def","docLink":"./Init/Prelude.html#Lean.Syntax.node4","doc":"Create syntax node with 4 children "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3639-L3640","name":"Lean.Syntax.node3","kind":"def","docLink":"./Init/Prelude.html#Lean.Syntax.node3","doc":"Create syntax node with 3 children "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3635-L3636","name":"Lean.Syntax.node2","kind":"def","docLink":"./Init/Prelude.html#Lean.Syntax.node2","doc":"Create syntax node with 2 children "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3631-L3632","name":"Lean.Syntax.node1","kind":"def","docLink":"./Init/Prelude.html#Lean.Syntax.node1","doc":"Create syntax node with 1 child "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3622-L3628","name":"Lean.Syntax.ident","kind":"ctor","docLink":"./Init/Prelude.html#Lean.Syntax.ident","doc":"An `ident` corresponds to an identifier as parsed by the `ident` or\n`rawIdent` parsers.\n* `rawVal` is the literal substring from the input file\n* `val` is the parsed identifier (with hygiene)\n* `preresolved` is the list of possible declarations this could refer to\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3617-L3621","name":"Lean.Syntax.atom","kind":"ctor","docLink":"./Init/Prelude.html#Lean.Syntax.atom","doc":"An `atom` corresponds to a keyword or piece of literal unquoted syntax.\nThese correspond to quoted strings inside `syntax` declarations.\nFor example, in `(x + y)`, `\"(\"`, `\"+\"` and `\")\"` are `atom`\nand `x` and `y` are `ident`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3598-L3616","name":"Lean.Syntax.node","kind":"ctor","docLink":"./Init/Prelude.html#Lean.Syntax.node","doc":"Node in the syntax tree.\n\nThe `info` field is used by the delaborator to store the position of the\nsubexpression corresponding to this node. The parser sets the `info` field\nto `none`.\nThe parser sets the `info` field to `none`, with position retrieval continuing recursively.\nNodes created by quotations use the result from `SourceInfo.fromRef` so that they are marked\nas synthetic even when the leading/trailing token is not.\nThe delaborator uses the `info` field to store the position of the subexpression\ncorresponding to this node.\n\n(Remark: the `node` constructor did not have an `info` field in previous\nversions. This caused a bug in the interactive widgets, where the popup for\n`a + b` was the same as for `a`. The delaborator used to associate\nsubexpressions with pretty-printed syntax by setting the (string) position\nof the first atom/identifier to the (expression) position of the\nsubexpression. For example, both `a` and `a + b` have the same first\nidentifier, and so their infos got mixed up.) "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3594-L3597","name":"Lean.Syntax.missing","kind":"ctor","docLink":"./Init/Prelude.html#Lean.Syntax.missing","doc":"A `missing` syntax corresponds to a portion of the syntax tree that is\nmissing because of a parse error. The indexing operator on Syntax also\nreturns `missing` for indexing out of bounds. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3593-L3628","name":"Lean.Syntax","kind":"inductive","docLink":"./Init/Prelude.html#Lean.Syntax","doc":"Syntax objects used by the parser, macro expander, delaborator, etc.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3587-L3588","name":"Lean.Syntax.Preresolved.decl","kind":"ctor","docLink":"./Init/Prelude.html#Lean.Syntax.Preresolved.decl","doc":"A potential global constant or section variable reference, with additional field accesses "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3585-L3586","name":"Lean.Syntax.Preresolved.namespace","kind":"ctor","docLink":"./Init/Prelude.html#Lean.Syntax.Preresolved.namespace","doc":"A potential namespace reference "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3584-L3588","name":"Lean.Syntax.Preresolved","kind":"inductive","docLink":"./Init/Prelude.html#Lean.Syntax.Preresolved","doc":"Binding information resolved and stored at compile time of a syntax quotation.\nNote: We do not statically know whether a syntax expects a namespace or term name,\nso a `Syntax.ident` may contain both preresolution kinds.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3575-L3575","name":"Lean.SyntaxNodeKind","kind":"def","docLink":"./Init/Prelude.html#Lean.SyntaxNodeKind","doc":"A `SyntaxNodeKind` classifies `Syntax.node` values. It is an abbreviation for\n`Name`, and you can use name literals to construct `SyntaxNodeKind`s, but\nthey need not refer to declarations in the environment. Conventionally, a\n`SyntaxNodeKind` will correspond to the `Parser` or `ParserDesc` declaration\nthat parses it.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3559-L3564","name":"Lean.SourceInfo.getPos?","kind":"def","docLink":"./Init/Prelude.html#Lean.SourceInfo.getPos?","doc":"Gets the position information from a `SourceInfo`, if available.\nIf `originalOnly` is true, then `.synthetic` syntax will also return `none`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3551-L3551","name":"Lean.instInhabitedSourceInfo","kind":"instance","docLink":"./Init/Prelude.html#Lean.instInhabitedSourceInfo","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3548-L3549","name":"Lean.SourceInfo.none","kind":"ctor","docLink":"./Init/Prelude.html#Lean.SourceInfo.none","doc":"Synthesized token without position information. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3524-L3547","name":"Lean.SourceInfo.synthetic","kind":"ctor","docLink":"./Init/Prelude.html#Lean.SourceInfo.synthetic","doc":"Synthesized syntax (e.g. from a quotation) annotated with a span from the original source.\nIn the delaborator, we \"misuse\" this constructor to store synthetic positions identifying\nsubterms.\n\nThe `canonical` flag on synthetic syntax is enabled for syntax that is not literally part\nof the original input syntax but should be treated \"as if\" the user really wrote it\nfor the purpose of hovers and error messages. This is usually used on identifiers,\nto connect the binding site to the user's original syntax even if the name of the identifier\nchanges during expansion, as well as on tokens where we will attach targeted messages.\n\nThe syntax `token%$stx` in a syntax quotation will annotate the token `token` with the span\nfrom `stx` and also mark it as canonical.\n\nAs a rough guide, a macro expansion should only use a given piece of input syntax in\na single canonical token, although this is sometimes violated when the same identifier\nis used to declare two binders, as in the macro expansion for dependent if:\n```\n`(if $h : $cond then $t else $e) ~>\n`(dite $cond (fun $h => $t) (fun $h => $t))\n```\nIn these cases if the user hovers over `h` they will see information about both binding sites.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3518-L3523","name":"Lean.SourceInfo.original","kind":"ctor","docLink":"./Init/Prelude.html#Lean.SourceInfo.original","doc":"Token from original input with whitespace and position information.\n`leading` will be inferred after parsing by `Syntax.updateLeading`. During parsing,\nit is not at all clear what the preceding token was, especially with backtracking.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3517-L3549","name":"Lean.SourceInfo","kind":"inductive","docLink":"./Init/Prelude.html#Lean.SourceInfo","doc":"Source information of tokens. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3507-L3510","name":"Lean.Name.appendCore","kind":"def","docLink":"./Init/Prelude.html#Lean.Name.appendCore","doc":"This function does not have special support for macro scopes.\nSee `Name.append`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3500-L3501","name":"Lean.Name.instBEqName","kind":"instance","docLink":"./Init/Prelude.html#Lean.Name.instBEqName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3494-L3498","name":"Lean.Name.beq","kind":"def","docLink":"./Init/Prelude.html#Lean.Name.beq","doc":"(Boolean) equality comparator for names. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3489-L3490","name":"Lean.Name.mkStr8","kind":"def","docLink":"./Init/Prelude.html#Lean.Name.mkStr8","doc":"Make name `s₁.s₂.s₃.s₄.s₅.s₆.s₇.s₈` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3485-L3486","name":"Lean.Name.mkStr7","kind":"def","docLink":"./Init/Prelude.html#Lean.Name.mkStr7","doc":"Make name `s₁.s₂.s₃.s₄.s₅.s₆.s₇` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3481-L3482","name":"Lean.Name.mkStr6","kind":"def","docLink":"./Init/Prelude.html#Lean.Name.mkStr6","doc":"Make name `s₁.s₂.s₃.s₄.s₅.s₆` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3477-L3478","name":"Lean.Name.mkStr5","kind":"def","docLink":"./Init/Prelude.html#Lean.Name.mkStr5","doc":"Make name `s₁.s₂.s₃.s₄.s₅` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3473-L3474","name":"Lean.Name.mkStr4","kind":"def","docLink":"./Init/Prelude.html#Lean.Name.mkStr4","doc":"Make name `s₁.s₂.s₃.s₄` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3469-L3470","name":"Lean.Name.mkStr3","kind":"def","docLink":"./Init/Prelude.html#Lean.Name.mkStr3","doc":"Make name `s₁.s₂.s₃` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3465-L3466","name":"Lean.Name.mkStr2","kind":"def","docLink":"./Init/Prelude.html#Lean.Name.mkStr2","doc":"Make name `s₁.s₂` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3461-L3462","name":"Lean.Name.mkStr1","kind":"def","docLink":"./Init/Prelude.html#Lean.Name.mkStr1","doc":"Make name `s₁` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3457-L3458","name":"Lean.Name.mkSimple","kind":"def","docLink":"./Init/Prelude.html#Lean.Name.mkSimple","doc":"Short for `.str .anonymous s`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3451-L3452","name":"Lean.Name.mkNum","kind":"def","docLink":"./Init/Prelude.html#Lean.Name.mkNum","doc":"`.num p v` is now the preferred form.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3444-L3445","name":"Lean.Name.mkStr","kind":"def","docLink":"./Init/Prelude.html#Lean.Name.mkStr","doc":"`.str p s` is now the preferred form.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3435-L3436","name":"Lean.instHashableName","kind":"instance","docLink":"./Init/Prelude.html#Lean.instHashableName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3432-L3433","name":"Lean.instInhabitedName","kind":"instance","docLink":"./Init/Prelude.html#Lean.instInhabitedName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3416-L3423","name":"Lean.Name.num","kind":"ctor","docLink":"./Init/Prelude.html#Lean.Name.num","doc":"A numerical name. This kind of name is used, for example, to create hierarchical names for\nfree variables and metavariables. The identifier `_uniq.231` is represented as\n```lean\n.num (.str .anonymous \"_uniq\") 231\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3409-L3415","name":"Lean.Name.str","kind":"ctor","docLink":"./Init/Prelude.html#Lean.Name.str","doc":"A string name. The name `Lean.Meta.run` is represented at\n```lean\n.str (.str (.str .anonymous \"Lean\") \"Meta\") \"run\"\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3407-L3408","name":"Lean.Name.anonymous","kind":"ctor","docLink":"./Init/Prelude.html#Lean.Name.anonymous","doc":"The \"anonymous\" name. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3406-L3430","name":"Lean.Name","kind":"inductive","docLink":"./Init/Prelude.html#Lean.Name","doc":"Hierarchical names. We use hierarchical names to name declarations and\nfor creating unique identifiers for free variables and metavariables.\n\nYou can create hierarchical names using the following quotation notation.\n```\n`Lean.Meta.whnf\n```\nIt is short for `.str (.str (.str .anonymous \"Lean\") \"Meta\") \"whnf\"`\nYou can use double quotes to request Lean to statically check whether the name\ncorresponds to a Lean declaration in scope.\n```\n``Lean.Meta.whnf\n```\nIf the name is not in scope, Lean will report an error.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3390-L3430","name":"Lean.Name.hash","kind":"def","docLink":"./Init/Prelude.html#Lean.Name.hash","doc":"A hash function for names, which is stored inside the name itself as a\ncomputed field. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3385-L3386","name":"instHashableString","kind":"instance","docLink":"./Init/Prelude.html#instHashableString","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3383-L3383","name":"String.hash","kind":"opaque","docLink":"./Init/Prelude.html#String.hash","doc":"An opaque string hash function. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3378-L3379","name":"instHashableSubtype","kind":"instance","docLink":"./Init/Prelude.html#instHashableSubtype","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3376-L3376","name":"mixHash","kind":"opaque","docLink":"./Init/Prelude.html#mixHash","doc":"An opaque hash mixing operation, used to implement hashing for tuples. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3363-L3372","name":"USize.toUInt64","kind":"def","docLink":"./Init/Prelude.html#USize.toUInt64","doc":"Upcast a `USize` to a `UInt64`.\nThis is lossless because `USize.size` is either `2^32` or `2^64`.\nThis function is overridden with a native implementation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3355-L3355","name":"UInt64.toUSize","kind":"opaque","docLink":"./Init/Prelude.html#UInt64.toUSize","doc":"Converts a `UInt64` to a `USize` by reducing modulo `USize.size`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3349-L3349","name":"Hashable.hash","kind":"def","docLink":"./Init/Prelude.html#Hashable.hash","doc":"Hashes the value `a : α` into a `UInt64`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3347-L3347","name":"Hashable.mk","kind":"ctor","docLink":"./Init/Prelude.html#Hashable.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3347-L3349","name":"Hashable","kind":"class","docLink":"./Init/Prelude.html#Hashable","doc":"A class for types that can be hashed into a `UInt64`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3340-L3342","name":"EStateM.nonBacktrackable","kind":"instance","docLink":"./Init/Prelude.html#EStateM.nonBacktrackable","doc":"Dummy default instance. This makes every `σ` trivially \"backtrackable\"\nby doing nothing on backtrack. Because this is the first declared instance\nof `Backtrackable _ σ`, it will be picked only if there are no other\n`Backtrackable _ σ` instances registered.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3332-L3332","name":"EStateM.dummyRestore","kind":"def","docLink":"./Init/Prelude.html#EStateM.dummyRestore","doc":"The `restore` implementation for `Backtrackable PUnit σ`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3329-L3329","name":"EStateM.dummySave","kind":"def","docLink":"./Init/Prelude.html#EStateM.dummySave","doc":"The `save` implementation for `Backtrackable PUnit σ`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3323-L3326","name":"EStateM.run'","kind":"def","docLink":"./Init/Prelude.html#EStateM.run'","doc":"Execute an `EStateM` on initial state `s` for the returned value `α`.\nIf the monadic action throws an exception, returns `none` instead.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3316-L3316","name":"EStateM.run","kind":"def","docLink":"./Init/Prelude.html#EStateM.run","doc":"Execute an `EStateM` on initial state `s` to get a `Result`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3310-L3312","name":"EStateM.instMonadExceptOfEStateM","kind":"instance","docLink":"./Init/Prelude.html#EStateM.instMonadExceptOfEStateM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3305-L3308","name":"EStateM.instMonadStateOfEStateM","kind":"instance","docLink":"./Init/Prelude.html#EStateM.instMonadStateOfEStateM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3302-L3303","name":"EStateM.instOrElseEStateM","kind":"instance","docLink":"./Init/Prelude.html#EStateM.instOrElseEStateM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3296-L3300","name":"EStateM.instMonadEStateM","kind":"instance","docLink":"./Init/Prelude.html#EStateM.instMonadEStateM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3290-L3293","name":"EStateM.seqRight","kind":"def","docLink":"./Init/Prelude.html#EStateM.seqRight","doc":"The `seqRight` operation of the `EStateM` monad. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3283-L3286","name":"EStateM.map","kind":"def","docLink":"./Init/Prelude.html#EStateM.map","doc":"The `map` operation of the `EStateM` monad. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3276-L3279","name":"EStateM.bind","kind":"def","docLink":"./Init/Prelude.html#EStateM.bind","doc":"The `bind` operation of the `EStateM` monad. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3269-L3272","name":"EStateM.adaptExcept","kind":"def","docLink":"./Init/Prelude.html#EStateM.adaptExcept","doc":"Map the exception type of a `EStateM ε σ α` by a function `f : ε → ε'`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3261-L3265","name":"EStateM.orElse","kind":"def","docLink":"./Init/Prelude.html#EStateM.orElse","doc":"Implementation of `orElse` for `EStateM` where the state is `Backtrackable`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3253-L3257","name":"EStateM.tryCatch","kind":"def","docLink":"./Init/Prelude.html#EStateM.tryCatch","doc":"Implementation of `tryCatch` for `EStateM` where the state is `Backtrackable`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3249-L3249","name":"EStateM.Backtrackable.restore","kind":"def","docLink":"./Init/Prelude.html#EStateM.Backtrackable.restore","doc":"`restore (s : σ) (x : δ) : σ` applies the old backtracking state `x` to\nthe state `s` to get a backtracked state `s'`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3246-L3246","name":"EStateM.Backtrackable.save","kind":"def","docLink":"./Init/Prelude.html#EStateM.Backtrackable.save","doc":"`save s : δ` retrieves a copy of the backtracking state out of the state. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3244-L3244","name":"EStateM.Backtrackable.mk","kind":"ctor","docLink":"./Init/Prelude.html#EStateM.Backtrackable.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3244-L3249","name":"EStateM.Backtrackable","kind":"class","docLink":"./Init/Prelude.html#EStateM.Backtrackable","doc":"Auxiliary instance for saving/restoring the \"backtrackable\" part of the state.\nHere `σ` is the state, and `δ` is some subpart of it, and we have a\ngetter and setter for it (a \"lens\" in the Haskell terminology).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3236-L3237","name":"EStateM.throw","kind":"def","docLink":"./Init/Prelude.html#EStateM.throw","doc":"The `throw` operation of the `EStateM` monad. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3230-L3232","name":"EStateM.modifyGet","kind":"def","docLink":"./Init/Prelude.html#EStateM.modifyGet","doc":"The `modifyGet` operation of the `EStateM` monad. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3225-L3226","name":"EStateM.get","kind":"def","docLink":"./Init/Prelude.html#EStateM.get","doc":"The `get` operation of the `EStateM` monad. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3220-L3221","name":"EStateM.set","kind":"def","docLink":"./Init/Prelude.html#EStateM.set","doc":"The `set` operation of the `EStateM` monad. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3215-L3216","name":"EStateM.pure","kind":"def","docLink":"./Init/Prelude.html#EStateM.pure","doc":"The `pure` operation of the `EStateM` monad. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3210-L3211","name":"EStateM.instInhabitedEStateM","kind":"instance","docLink":"./Init/Prelude.html#EStateM.instInhabitedEStateM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3204-L3204","name":"EStateM","kind":"def","docLink":"./Init/Prelude.html#EStateM","doc":"`EStateM ε σ` is a combined error and state monad, equivalent to\n`ExceptT ε (StateM σ)` but more efficient.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3194-L3195","name":"EStateM.instInhabitedResult","kind":"instance","docLink":"./Init/Prelude.html#EStateM.instInhabitedResult","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3189-L3190","name":"EStateM.Result.error","kind":"ctor","docLink":"./Init/Prelude.html#EStateM.Result.error","doc":"A failure value of type `ε`, and a new state `σ`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3187-L3188","name":"EStateM.Result.ok","kind":"ctor","docLink":"./Init/Prelude.html#EStateM.Result.ok","doc":"A success value of type `α`, and a new state `σ`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3186-L3190","name":"EStateM.Result","kind":"inductive","docLink":"./Init/Prelude.html#EStateM.Result","doc":"`Result ε σ α` is equivalent to `Except ε α × σ`, but using a single\ncombined inductive yields a more efficient data representation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3175-L3178","name":"instMonadStateOf","kind":"instance","docLink":"./Init/Prelude.html#instMonadStateOf","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3169-L3170","name":"getModify","kind":"def","docLink":"./Init/Prelude.html#getModify","doc":"`getModify f` gets the state, applies function `f`, and returns the old value\nof the state. It is equivalent to `get <* modify f` but may be more efficient.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3161-L3162","name":"modify","kind":"def","docLink":"./Init/Prelude.html#modify","doc":"`modify (f : σ → σ)` applies the function `f` to the state.\n\nIt is equivalent to `do put (f (← get))`, but `modify f` may be preferable\nbecause the former does not use the state linearly (without sufficient inlining).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3149-L3152","name":"instMonadState","kind":"instance","docLink":"./Init/Prelude.html#instMonadState","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3145-L3145","name":"MonadState.modifyGet","kind":"def","docLink":"./Init/Prelude.html#MonadState.modifyGet","doc":"`modifyGet (f : σ → α × σ)` applies `f` to the current state, replaces\nthe state with the return value, and returns a computed value.\n\nIt is equivalent to `do let (a, s) := f (← get); put s; pure a`, but\n`modifyGet f` may be preferable because the former does not use the state\nlinearly (without sufficient inlining). "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3138-L3138","name":"MonadState.set","kind":"def","docLink":"./Init/Prelude.html#MonadState.set","doc":"`set (s : σ)` replaces the state with value `s`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3136-L3136","name":"MonadState.get","kind":"def","docLink":"./Init/Prelude.html#MonadState.get","doc":"`(← get) : σ` gets the state out of a monad `m`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3134-L3134","name":"MonadState.mk","kind":"ctor","docLink":"./Init/Prelude.html#MonadState.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3134-L3145","name":"MonadState","kind":"class","docLink":"./Init/Prelude.html#MonadState","doc":"Similar to `MonadStateOf`, but `σ` is an `outParam` for convenience. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3130-L3131","name":"modifyGetThe","kind":"def","docLink":"./Init/Prelude.html#modifyGetThe","doc":"Like `modifyGet`, but with `σ` explicit. This is useful if a monad supports\n`MonadStateOf` for multiple different types `σ`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3122-L3123","name":"modifyThe","kind":"def","docLink":"./Init/Prelude.html#modifyThe","doc":"Like `modify`, but with `σ` explicit. This is useful if a monad supports\n`MonadStateOf` for multiple different types `σ`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3114-L3115","name":"getThe","kind":"def","docLink":"./Init/Prelude.html#getThe","doc":"Like `withReader`, but with `ρ` explicit. This is useful if a monad supports\n`MonadWithReaderOf` for multiple different types `ρ`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3106-L3106","name":"MonadStateOf.modifyGet","kind":"def","docLink":"./Init/Prelude.html#MonadStateOf.modifyGet","doc":"`modifyGet (f : σ → α × σ)` applies `f` to the current state, replaces\nthe state with the return value, and returns a computed value.\n\nIt is equivalent to `do let (a, s) := f (← get); put s; pure a`, but\n`modifyGet f` may be preferable because the former does not use the state\nlinearly (without sufficient inlining). "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3099-L3099","name":"MonadStateOf.set","kind":"def","docLink":"./Init/Prelude.html#MonadStateOf.set","doc":"`set (s : σ)` replaces the state with value `s`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3097-L3097","name":"MonadStateOf.get","kind":"def","docLink":"./Init/Prelude.html#MonadStateOf.get","doc":"`(← get) : σ` gets the state out of a monad `m`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3095-L3095","name":"MonadStateOf.mk","kind":"ctor","docLink":"./Init/Prelude.html#MonadStateOf.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3095-L3106","name":"MonadStateOf","kind":"class","docLink":"./Init/Prelude.html#MonadStateOf","doc":"An implementation of [`MonadState`]. In contrast to the Haskell implementation,\nwe use overlapping instances to derive instances automatically from `monadLift`.\n\n  [`MonadState`]: https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Class.html\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3086-L3087","name":"instMonadWithReaderOfReaderT","kind":"instance","docLink":"./Init/Prelude.html#instMonadWithReaderOfReaderT","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3083-L3084","name":"instMonadWithReaderOf","kind":"instance","docLink":"./Init/Prelude.html#instMonadWithReaderOf","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3080-L3081","name":"instMonadWithReader","kind":"instance","docLink":"./Init/Prelude.html#instMonadWithReader","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3076-L3076","name":"MonadWithReader.withReader","kind":"def","docLink":"./Init/Prelude.html#MonadWithReader.withReader","doc":"`withReader (f : ρ → ρ) (x : m α) : m α`  runs the inner `x : m α` inside\na modified context after applying the function `f : ρ → ρ`."},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3073-L3073","name":"MonadWithReader.mk","kind":"ctor","docLink":"./Init/Prelude.html#MonadWithReader.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3073-L3076","name":"MonadWithReader","kind":"class","docLink":"./Init/Prelude.html#MonadWithReader","doc":"Similar to `MonadWithReaderOf`, but `ρ` is an `outParam` for convenience. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3069-L3070","name":"withTheReader","kind":"def","docLink":"./Init/Prelude.html#withTheReader","doc":"Like `withReader`, but with `ρ` explicit. This is useful if a monad supports\n`MonadWithReaderOf` for multiple different types `ρ`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3062-L3062","name":"MonadWithReaderOf.withReader","kind":"def","docLink":"./Init/Prelude.html#MonadWithReaderOf.withReader","doc":"`withReader (f : ρ → ρ) (x : m α) : m α`  runs the inner `x : m α` inside\na modified context after applying the function `f : ρ → ρ`."},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3059-L3059","name":"MonadWithReaderOf.mk","kind":"ctor","docLink":"./Init/Prelude.html#MonadWithReaderOf.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3059-L3062","name":"MonadWithReaderOf","kind":"class","docLink":"./Init/Prelude.html#MonadWithReaderOf","doc":"`MonadWithReaderOf ρ` adds the operation `withReader : (ρ → ρ) → m α → m α`.\nThis runs the inner `x : m α` inside a modified context after applying the\nfunction `f : ρ → ρ`. In addition to `ReaderT` itself, this operation lifts\nover most monad transformers, so it allows us to apply `withReader` to monads\ndeeper in the stack.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3049-L3050","name":"instMonadReaderOfReaderT","kind":"instance","docLink":"./Init/Prelude.html#instMonadReaderOfReaderT","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3046-L3047","name":"instMonadReaderOf","kind":"instance","docLink":"./Init/Prelude.html#instMonadReaderOf","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3043-L3044","name":"instMonadReader","kind":"instance","docLink":"./Init/Prelude.html#instMonadReader","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3039-L3039","name":"MonadReader.read","kind":"def","docLink":"./Init/Prelude.html#MonadReader.read","doc":"`(← read) : ρ` reads the state out of monad `m`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3037-L3037","name":"MonadReader.mk","kind":"ctor","docLink":"./Init/Prelude.html#MonadReader.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3037-L3039","name":"MonadReader","kind":"class","docLink":"./Init/Prelude.html#MonadReader","doc":"Similar to `MonadReaderOf`, but `ρ` is an `outParam` for convenience. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3033-L3034","name":"readThe","kind":"def","docLink":"./Init/Prelude.html#readThe","doc":"Like `read`, but with `ρ` explicit. This is useful if a monad supports\n`MonadReaderOf` for multiple different types `ρ`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3026-L3026","name":"MonadReaderOf.read","kind":"def","docLink":"./Init/Prelude.html#MonadReaderOf.read","doc":"`(← read) : ρ` reads the state out of monad `m`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3024-L3024","name":"MonadReaderOf.mk","kind":"ctor","docLink":"./Init/Prelude.html#MonadReaderOf.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3024-L3026","name":"MonadReaderOf","kind":"class","docLink":"./Init/Prelude.html#MonadReaderOf","doc":"An implementation of Haskell's [`MonadReader`] (sans functional dependency; see also `MonadReader`\nin this module). It does not contain `local` because this\nfunction cannot be lifted using `monadLift`. `local` is instead provided by\nthe `MonadWithReader` class as `withReader`.\n\nNote: This class can be seen as a simplification of the more \"principled\" definition\n```\nclass MonadReaderOf (ρ : Type u) (n : Type u → Type u) where\n  lift {α : Type u} : ({m : Type u → Type u} → [Monad m] → ReaderT ρ m α) → n α\n```\n\n  [`MonadReader`]: https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader-Class.html#t:MonadReader\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L3004-L3005","name":"ReaderT.adapt","kind":"def","docLink":"./Init/Prelude.html#ReaderT.adapt","doc":"`adapt (f : ρ' → ρ)` precomposes function `f` on the reader state of a\n`ReaderT ρ`, yielding a `ReaderT ρ'`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2996-L2997","name":"ReaderT.instMonadFunctorReaderT","kind":"instance","docLink":"./Init/Prelude.html#ReaderT.instMonadFunctorReaderT","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2993-L2994","name":"ReaderT.instMonadReaderT","kind":"instance","docLink":"./Init/Prelude.html#ReaderT.instMonadReaderT","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2987-L2991","name":"ReaderT.instApplicativeReaderT","kind":"instance","docLink":"./Init/Prelude.html#ReaderT.instApplicativeReaderT","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2982-L2984","name":"ReaderT.instFunctorReaderT","kind":"instance","docLink":"./Init/Prelude.html#ReaderT.instFunctorReaderT","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2978-L2979","name":"ReaderT.bind","kind":"def","docLink":"./Init/Prelude.html#ReaderT.bind","doc":"The `bind` operation of the `ReaderT` monad. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2973-L2974","name":"ReaderT.pure","kind":"def","docLink":"./Init/Prelude.html#ReaderT.pure","doc":"The `pure` operation of the `ReaderT` monad. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2968-L2969","name":"ReaderT.read","kind":"def","docLink":"./Init/Prelude.html#ReaderT.read","doc":"`(← read) : ρ` gets the read-only state of a `ReaderT ρ`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2957-L2959","name":"ReaderT.instMonadExceptOfReaderT","kind":"instance","docLink":"./Init/Prelude.html#ReaderT.instMonadExceptOfReaderT","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2953-L2954","name":"ReaderT.instMonadLiftReaderT","kind":"instance","docLink":"./Init/Prelude.html#ReaderT.instMonadLiftReaderT","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2945-L2946","name":"ReaderT.run","kind":"def","docLink":"./Init/Prelude.html#ReaderT.run","doc":"If `x : ReaderT ρ m α` and `r : ρ`, then `x.run r : ρ` runs the monad with the\ngiven reader state.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2937-L2938","name":"instInhabitedReaderT","kind":"instance","docLink":"./Init/Prelude.html#instInhabitedReaderT","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2934-L2935","name":"ReaderT","kind":"def","docLink":"./Init/Prelude.html#ReaderT","doc":"An implementation of Haskell's [`ReaderT`]. This is a monad transformer which\nequips a monad with additional read-only state, of type `ρ`.\n\n  [`ReaderT`]: https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Reader.html#t:ReaderT\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2923-L2924","name":"MonadExcept.instOrElse","kind":"instance","docLink":"./Init/Prelude.html#MonadExcept.instOrElse","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2920-L2921","name":"MonadExcept.orElse","kind":"def","docLink":"./Init/Prelude.html#MonadExcept.orElse","doc":"A `MonadExcept` can implement `t₁ <|> t₂` as `try t₁ catch _ => t₂`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2912-L2914","name":"instMonadExcept","kind":"instance","docLink":"./Init/Prelude.html#instMonadExcept","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2906-L2908","name":"MonadExcept.ofExcept","kind":"def","docLink":"./Init/Prelude.html#MonadExcept.ofExcept","doc":"\"Unwraps\" an `Except ε α` to get the `α`, or throws the exception otherwise. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2903-L2903","name":"MonadExcept.tryCatch","kind":"def","docLink":"./Init/Prelude.html#MonadExcept.tryCatch","doc":"`tryCatch (body : m α) (handler : ε → m α) : m α` will catch any errors in\n`body` and pass the resulting error to `handler`.\nErrors in `handler` will not be caught. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2899-L2899","name":"MonadExcept.throw","kind":"def","docLink":"./Init/Prelude.html#MonadExcept.throw","doc":"`throw : ε → m α` \"throws an error\" of type `ε` to the nearest enclosing\ncatch block. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2896-L2896","name":"MonadExcept.mk","kind":"ctor","docLink":"./Init/Prelude.html#MonadExcept.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2896-L2903","name":"MonadExcept","kind":"class","docLink":"./Init/Prelude.html#MonadExcept","doc":"Similar to `MonadExceptOf`, but `ε` is an `outParam` for convenience. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2892-L2893","name":"tryCatchThe","kind":"def","docLink":"./Init/Prelude.html#tryCatchThe","doc":"This is the same as `tryCatch`, but allows specifying the particular error type\nin case the monad supports throwing more than one type of error.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2885-L2886","name":"throwThe","kind":"def","docLink":"./Init/Prelude.html#throwThe","doc":"This is the same as `throw`, but allows specifying the particular error type\nin case the monad supports throwing more than one type of error.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2879-L2879","name":"MonadExceptOf.tryCatch","kind":"def","docLink":"./Init/Prelude.html#MonadExceptOf.tryCatch","doc":"`tryCatch (body : m α) (handler : ε → m α) : m α` will catch any errors in\n`body` and pass the resulting error to `handler`.\nErrors in `handler` will not be caught. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2875-L2875","name":"MonadExceptOf.throw","kind":"def","docLink":"./Init/Prelude.html#MonadExceptOf.throw","doc":"`throw : ε → m α` \"throws an error\" of type `ε` to the nearest enclosing\ncatch block. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2872-L2872","name":"MonadExceptOf.mk","kind":"ctor","docLink":"./Init/Prelude.html#MonadExceptOf.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2872-L2879","name":"MonadExceptOf","kind":"class","docLink":"./Init/Prelude.html#MonadExceptOf","doc":"An implementation of Haskell's [`MonadError`] class. A `MonadError ε m` is a\nmonad `m` with two operations:\n\n* `throw : ε → m α` \"throws an error\" of type `ε` to the nearest enclosing\n  catch block\n* `tryCatch (body : m α) (handler : ε → m α) : m α` will catch any errors in\n  `body` and pass the resulting error to `handler`.\n  Errors in `handler` will not be caught.\n\nThe `try ... catch e => ...` syntax inside `do` blocks is sugar for the\n`tryCatch` operation.\n\n  [`MonadError`]: https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Except.html#t:MonadError\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2854-L2855","name":"instInhabitedExcept","kind":"instance","docLink":"./Init/Prelude.html#instInhabitedExcept","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2849-L2850","name":"Except.ok","kind":"ctor","docLink":"./Init/Prelude.html#Except.ok","doc":"A success value of type `α` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2847-L2848","name":"Except.error","kind":"ctor","docLink":"./Init/Prelude.html#Except.error","doc":"A failure value of type `ε` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2846-L2850","name":"Except","kind":"inductive","docLink":"./Init/Prelude.html#Except","doc":"`Except ε α` is a type which represents either an error of type `ε`, or an \"ok\"\nvalue of type `α`. The error type is listed first because\n`Except ε : Type → Type` is a `Monad`: the pure operation is `ok` and the bind\noperation returns the first encountered `error`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2837-L2838","name":"monadFunctorRefl","kind":"instance","docLink":"./Init/Prelude.html#monadFunctorRefl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2834-L2835","name":"instMonadFunctorT","kind":"instance","docLink":"./Init/Prelude.html#instMonadFunctorT","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2829-L2829","name":"MonadFunctorT.monadMap","kind":"def","docLink":"./Init/Prelude.html#MonadFunctorT.monadMap","doc":"Lifts a monad morphism `f : {β : Type u} → m β → m β` to\n`monadMap f : {α : Type u} → n α → n α`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2826-L2826","name":"MonadFunctorT.mk","kind":"ctor","docLink":"./Init/Prelude.html#MonadFunctorT.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2826-L2829","name":"MonadFunctorT","kind":"class","docLink":"./Init/Prelude.html#MonadFunctorT","doc":"The reflexive-transitive closure of `MonadFunctor`.\n`monadMap` is used to transitively lift `Monad` morphisms. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2822-L2822","name":"MonadFunctor.monadMap","kind":"def","docLink":"./Init/Prelude.html#MonadFunctor.monadMap","doc":"Lifts a monad morphism `f : {β : Type u} → m β → m β` to\n`monadMap f : {α : Type u} → n α → n α`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2819-L2819","name":"MonadFunctor.mk","kind":"ctor","docLink":"./Init/Prelude.html#MonadFunctor.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2819-L2822","name":"MonadFunctor","kind":"class","docLink":"./Init/Prelude.html#MonadFunctor","doc":"A functor in the category of monads. Can be used to lift monad-transforming functions.\nBased on [`MFunctor`] from the `pipes` Haskell package, but not restricted to\nmonad transformers. Alternatively, an implementation of [`MonadTransFunctor`].\n\n  [`MFunctor`]: https://hackage.haskell.org/package/pipes-2.4.0/docs/Control-MFunctor.html\n  [`MonadTransFunctor`]: http://duairc.netsoc.ie/layers-docs/Control-Monad-Layer.html#t:MonadTransFunctor\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2808-L2809","name":"instMonadLiftT_1","kind":"instance","docLink":"./Init/Prelude.html#instMonadLiftT_1","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2805-L2806","name":"instMonadLiftT","kind":"instance","docLink":"./Init/Prelude.html#instMonadLiftT","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2802-L2802","name":"liftM","kind":"def","docLink":"./Init/Prelude.html#liftM","doc":"Lifts a value from monad `m` into monad `n`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2797-L2797","name":"MonadLiftT.monadLift","kind":"def","docLink":"./Init/Prelude.html#MonadLiftT.monadLift","doc":"Lifts a value from monad `m` into monad `n`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2795-L2795","name":"MonadLiftT.mk","kind":"ctor","docLink":"./Init/Prelude.html#MonadLiftT.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2795-L2797","name":"MonadLiftT","kind":"class","docLink":"./Init/Prelude.html#MonadLiftT","doc":"The reflexive-transitive closure of `MonadLift`. `monadLift` is used to\ntransitively lift monadic computations such as `StateT.get` or `StateT.put s`.\nCorresponds to Haskell's [`MonadLift`].\n\n  [`MonadLift`]: https://hackage.haskell.org/package/layers-0.1/docs/Control-Monad-Layer.html#t:MonadLift\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2786-L2786","name":"MonadLift.monadLift","kind":"def","docLink":"./Init/Prelude.html#MonadLift.monadLift","doc":"Lifts a value from monad `m` into monad `n`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2784-L2784","name":"MonadLift.mk","kind":"ctor","docLink":"./Init/Prelude.html#MonadLift.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2784-L2786","name":"MonadLift","kind":"class","docLink":"./Init/Prelude.html#MonadLift","doc":"A function for lifting a computation from an inner `Monad` to an outer `Monad`.\nLike Haskell's [`MonadTrans`], but `n` does not have to be a monad transformer.\nAlternatively, an implementation of [`MonadLayer`] without `layerInvmap` (so far).\n\n  [`MonadTrans`]: https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Class.html\n  [`MonadLayer`]: https://hackage.haskell.org/package/layers-0.1/docs/Control-Monad-Layer.html#t:MonadLayer\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2767-L2773","name":"Array.sequenceMap.loop","kind":"def","docLink":"./Init/Prelude.html#Array.sequenceMap.loop","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2766-L2774","name":"Array.sequenceMap","kind":"def","docLink":"./Init/Prelude.html#Array.sequenceMap","doc":"A fusion of Haskell's `sequence` and `map`. Used in syntax quotations. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2762-L2763","name":"instForAllNonemptyNonempty","kind":"instance","docLink":"./Init/Prelude.html#instForAllNonemptyNonempty","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2759-L2760","name":"instInhabited","kind":"instance","docLink":"./Init/Prelude.html#instInhabited","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2756-L2757","name":"instInhabitedForAll_2","kind":"instance","docLink":"./Init/Prelude.html#instInhabitedForAll_2","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2750-L2750","name":"Monad.mk","kind":"ctor","docLink":"./Init/Prelude.html#Monad.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2750-L2754","name":"Monad","kind":"class","docLink":"./Init/Prelude.html#Monad","doc":"A [monad](https://en.wikipedia.org/wiki/Monad_(functional_programming)) is a\nstructure which abstracts the concept of sequential control flow.\nIt mainly consists of two operations:\n\n* `pure : α → F α`\n* `bind : F α → (α → F β) → F β` (written as `>>=`)\n\nLike many functional programming languages, Lean makes extensive use of monads\nfor structuring programs. In particular, the `do` notation is a very powerful\nsyntax over monad operations, and it depends on a `Monad` instance.\n\nSee [the `do` notation](https://leanprover.github.io/lean4/doc/do.html)\nchapter of the manual for details.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2730-L2730","name":"Applicative.mk","kind":"ctor","docLink":"./Init/Prelude.html#Applicative.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2730-L2733","name":"Applicative","kind":"class","docLink":"./Init/Prelude.html#Applicative","doc":"An [applicative functor](https://en.wikipedia.org/wiki/Applicative_functor) is\nan intermediate structure between `Functor` and `Monad`. It mainly consists of\ntwo operations:\n\n* `pure : α → F α`\n* `seq : F (α → β) → F α → F β` (written as `<*>`)\n\nThe `seq` operator gives a notion of evaluation order to the effects, where\nthe first argument is executed before the second, but unlike a monad the results\nof earlier computations cannot be used to define later actions.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2716-L2716","name":"SeqRight.seqRight","kind":"def","docLink":"./Init/Prelude.html#SeqRight.seqRight","doc":"If `x : F α` and `y : F β`, then `x *> y` evaluates `x`, then `y`,\nand returns the result of `y`.\n\nTo avoid surprising evaluation semantics, `y` is taken \"lazily\", using a\n`Unit → f β` function. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2710-L2710","name":"SeqRight.mk","kind":"ctor","docLink":"./Init/Prelude.html#SeqRight.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2710-L2716","name":"SeqRight","kind":"class","docLink":"./Init/Prelude.html#SeqRight","doc":"The typeclass which supplies the `*>` \"seqRight\" function. See `Applicative`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2707-L2707","name":"SeqLeft.seqLeft","kind":"def","docLink":"./Init/Prelude.html#SeqLeft.seqLeft","doc":"If `x : F α` and `y : F β`, then `x <* y` evaluates `x`, then `y`,\nand returns the result of `x`.\n\nTo avoid surprising evaluation semantics, `y` is taken \"lazily\", using a\n`Unit → f β` function. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2701-L2701","name":"SeqLeft.mk","kind":"ctor","docLink":"./Init/Prelude.html#SeqLeft.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2701-L2707","name":"SeqLeft","kind":"class","docLink":"./Init/Prelude.html#SeqLeft","doc":"The typeclass which supplies the `<*` \"seqLeft\" function. See `Applicative`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2698-L2698","name":"Seq.seq","kind":"def","docLink":"./Init/Prelude.html#Seq.seq","doc":"If `mf : F (α → β)` and `mx : F α`, then `mf <*> mx : F β`.\nIn a monad this is the same as `do let f ← mf; x ← mx; pure (f x)`:\nit evaluates first the function, then the argument, and applies one to the other.\n\nTo avoid surprising evaluation semantics, `mx` is taken \"lazily\", using a\n`Unit → f α` function. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2691-L2691","name":"Seq.mk","kind":"ctor","docLink":"./Init/Prelude.html#Seq.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2691-L2698","name":"Seq","kind":"class","docLink":"./Init/Prelude.html#Seq","doc":"The typeclass which supplies the `<*>` \"seq\" function. See `Applicative`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2688-L2688","name":"Functor.mapConst","kind":"def","docLink":"./Init/Prelude.html#Functor.mapConst","doc":"The special case `const a <$> x`, which can sometimes be implemented more\nefficiently. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2685-L2685","name":"Functor.map","kind":"def","docLink":"./Init/Prelude.html#Functor.map","doc":"If `f : α → β` and `x : F α` then `f <$> x : F β`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2683-L2683","name":"Functor.mk","kind":"ctor","docLink":"./Init/Prelude.html#Functor.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2683-L2688","name":"Functor","kind":"class","docLink":"./Init/Prelude.html#Functor","doc":"In functional programming, a \"functor\" is a function on types `F : Type u → Type v`\nequipped with an operator called `map` or `<$>` such that if `f : α → β` then\n`map f : F α → F β`, so `f <$> x : F β` if `x : F α`. This corresponds to the\ncategory-theory notion of [functor](https://en.wikipedia.org/wiki/Functor) in\nthe special case where the category is the category of types and functions\nbetween them, except that this class supplies only the operations and not the\nlaws (see `LawfulFunctor`).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2670-L2670","name":"Pure.pure","kind":"def","docLink":"./Init/Prelude.html#Pure.pure","doc":"If `a : α`, then `pure a : f α` represents a monadic action that does\nnothing and returns `a`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2667-L2667","name":"Pure.mk","kind":"ctor","docLink":"./Init/Prelude.html#Pure.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2667-L2670","name":"Pure","kind":"class","docLink":"./Init/Prelude.html#Pure","doc":"The typeclass which supplies the `pure` function. See `Monad`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2662-L2662","name":"Bind.bind","kind":"def","docLink":"./Init/Prelude.html#Bind.bind","doc":"If `x : m α` and `f : α → m β`, then `x >>= f : m β` represents the\nresult of executing `x` to get a value of type `α` and then passing it to `f`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2659-L2659","name":"Bind.mk","kind":"ctor","docLink":"./Init/Prelude.html#Bind.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2659-L2662","name":"Bind","kind":"class","docLink":"./Init/Prelude.html#Bind","doc":"The typeclass which supplies the `>>=` \"bind\" function. See `Monad`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2655-L2656","name":"List.toArray","kind":"def","docLink":"./Init/Prelude.html#List.toArray","doc":"Convert a `List α` into an `Array α`. This is O(n) in the length of the list.\n\nThis function is exported to C, where it is called by `Array.mk`\n(the constructor) to implement this functionality.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2644-L2646","name":"List.redLength","kind":"def","docLink":"./Init/Prelude.html#List.redLength","doc":"A non-tail-recursive version of `List.length`, used for `List.toArray`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2638-L2640","name":"List.toArrayAux","kind":"def","docLink":"./Init/Prelude.html#List.toArrayAux","doc":"Auxiliary definition for `List.toArray`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2626-L2632","name":"Array.extract.loop","kind":"def","docLink":"./Init/Prelude.html#Array.extract.loop","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2625-L2634","name":"Array.extract","kind":"def","docLink":"./Init/Prelude.html#Array.extract","doc":"Returns the slice of `as` from indices `start` to `stop` (exclusive).\nIf `start` is greater or equal to `stop`, the result is empty.\nIf `stop` is greater than the length of `as`, the length is used instead. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2611-L2617","name":"Array.appendCore.loop","kind":"def","docLink":"./Init/Prelude.html#Array.appendCore.loop","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2610-L2618","name":"Array.appendCore","kind":"def","docLink":"./Init/Prelude.html#Array.appendCore","doc":"Slower `Array.append` used in quotations. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2606-L2607","name":"Array.set!","kind":"def","docLink":"./Init/Prelude.html#Array.set!","doc":"Set an element in an array, or panic if the index is out of bounds.\n\nThis will perform the update destructively provided that `a` has a reference\ncount of 1 when called.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2596-L2597","name":"Array.setD","kind":"def","docLink":"./Init/Prelude.html#Array.setD","doc":"Set an element in an array, or do nothing if the index is out of bounds.\n\nThis will perform the update destructively provided that `a` has a reference\ncount of 1 when called.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2587-L2588","name":"Array.set","kind":"def","docLink":"./Init/Prelude.html#Array.set","doc":"Set an element in an array without bounds checks, using a `Fin` index.\n\nThis will perform the update destructively provided that `a` has a reference\ncount of 1 when called.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2577-L2578","name":"Array.mkArray8","kind":"def","docLink":"./Init/Prelude.html#Array.mkArray8","doc":"Create array `#[a₁, a₂, a₃, a₄, a₅, a₆, a₇, a₈]` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2573-L2574","name":"Array.mkArray7","kind":"def","docLink":"./Init/Prelude.html#Array.mkArray7","doc":"Create array `#[a₁, a₂, a₃, a₄, a₅, a₆, a₇]` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2569-L2570","name":"Array.mkArray6","kind":"def","docLink":"./Init/Prelude.html#Array.mkArray6","doc":"Create array `#[a₁, a₂, a₃, a₄, a₅, a₆]` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2565-L2566","name":"Array.mkArray5","kind":"def","docLink":"./Init/Prelude.html#Array.mkArray5","doc":"Create array `#[a₁, a₂, a₃, a₄, a₅]` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2561-L2562","name":"Array.mkArray4","kind":"def","docLink":"./Init/Prelude.html#Array.mkArray4","doc":"Create array `#[a₁, a₂, a₃, a₄]` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2557-L2558","name":"Array.mkArray3","kind":"def","docLink":"./Init/Prelude.html#Array.mkArray3","doc":"Create array `#[a₁, a₂, a₃]` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2553-L2554","name":"Array.mkArray2","kind":"def","docLink":"./Init/Prelude.html#Array.mkArray2","doc":"Create array `#[a₁, a₂]` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2549-L2550","name":"Array.mkArray1","kind":"def","docLink":"./Init/Prelude.html#Array.mkArray1","doc":"Create array `#[a₁]` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2545-L2546","name":"Array.mkArray0","kind":"def","docLink":"./Init/Prelude.html#Array.mkArray0","doc":"Create array `#[]` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2541-L2542","name":"Array.push","kind":"def","docLink":"./Init/Prelude.html#Array.push","doc":"Push an element onto the end of an array. This is amortized O(1) because\n`Array α` is internally a dynamic array.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2533-L2534","name":"instGetElemArrayNatLtInstLTNatSize","kind":"instance","docLink":"./Init/Prelude.html#instGetElemArrayNatLtInstLTNatSize","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2530-L2531","name":"Array.get!","kind":"def","docLink":"./Init/Prelude.html#Array.get!","doc":"Access an element from an array, or panic if the index is out of bounds. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2525-L2526","name":"Array.getD","kind":"def","docLink":"./Init/Prelude.html#Array.getD","doc":"Access an element from an array, or return `v₀` if the index is out of bounds. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2521-L2522","name":"Array.get","kind":"def","docLink":"./Init/Prelude.html#Array.get","doc":"Access an element from an array without bounds checks, using a `Fin` index. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2516-L2517","name":"Array.size","kind":"def","docLink":"./Init/Prelude.html#Array.size","doc":"Get the size of an array. This is a cached value, so it is O(1) to access. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2512-L2512","name":"Array.empty","kind":"def","docLink":"./Init/Prelude.html#Array.empty","doc":"Construct a new empty array. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2508-L2509","name":"Array.mkEmpty","kind":"def","docLink":"./Init/Prelude.html#Array.mkEmpty","doc":"Construct a new empty array with initial capacity `c`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2501-L2501","name":"Array.data","kind":"def","docLink":"./Init/Prelude.html#Array.data","doc":"Convert an `Array α` into a `List α`. This function is overridden\nto `Array.toList` and is O(n) in the length of the list. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2498-L2498","name":"Array.mk","kind":"ctor","docLink":"./Init/Prelude.html#Array.mk","doc":"Convert a `List α` into an `Array α`. This function is overridden\nto `List.toArray` and is O(n) in the length of the list. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2495-L2501","name":"Array","kind":"structure","docLink":"./Init/Prelude.html#Array","doc":"`Array α` is the type of [dynamic arrays](https://en.wikipedia.org/wiki/Dynamic_array)\nwith elements from `α`. This type has special support in the runtime.\n\nAn array has a size and a capacity; the size is `Array.size` but the capacity\nis not observable from lean code. Arrays perform best when unshared; as long\nas they are used \"linearly\" all updates will be performed destructively on the\narray, so it has comparable performance to mutable arrays in imperative\nprogramming languages.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2481-L2481","name":"GetElem.getElem","kind":"def","docLink":"./Init/Prelude.html#GetElem.getElem","doc":"The syntax `arr[i]` gets the `i`'th element of the collection `arr`.\nIf there are proof side conditions to the application, they will be automatically\ninferred by the `get_elem_tactic` tactic.\n\nThe actual behavior of this class is type-dependent,\nbut here are some important implementations:\n* `arr[i] : α` where `arr : Array α` and `i : Nat` or `i : USize`:\n  does array indexing with no bounds check and a proof side goal `i < arr.size`.\n* `l[i] : α` where `l : List α` and `i : Nat`: index into a list,\n  with proof side goal `i < l.length`.\n* `stx[i] : Syntax` where `stx : Syntax` and `i : Nat`: get a syntax argument,\n  no side goal (returns `.missing` out of range)\n\nThere are other variations on this syntax:\n* `arr[i]`: proves the proof side goal by `get_elem_tactic`\n* `arr[i]!`: panics if the side goal is false\n* `arr[i]?`: returns `none` if the side goal is false\n* `arr[i]'h`: uses `h` to prove the side goal\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2460-L2460","name":"GetElem.mk","kind":"ctor","docLink":"./Init/Prelude.html#GetElem.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2460-L2481","name":"GetElem","kind":"class","docLink":"./Init/Prelude.html#GetElem","doc":"The class `GetElem cont idx elem dom` implements the `xs[i]` notation.\nWhen you write this, given `xs : cont` and `i : idx`, lean looks for an instance\nof `GetElem cont idx elem dom`. Here `elem` is the type of `xs[i]`, while\n`dom` is whatever proof side conditions are required to make this applicable.\nFor example, the instance for arrays looks like\n`GetElem (Array α) Nat α (fun xs i => i < xs.size)`.\n\nThe proof side-condition `dom xs i` is automatically dispatched by the\n`get_elem_tactic` tactic, which can be extended by adding more clauses to\n`get_elem_tactic_trivial`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2442-L2443","name":"panic","kind":"def","docLink":"./Init/Prelude.html#panic","doc":"`(panic \"msg\" : α)` has a built-in implementation which prints `msg` to\nthe error buffer. It *does not* terminate execution, and because it is a safe\nfunction, it still has to return an element of `α`, so it takes `[Inhabited α]`\nand returns `default`. It is primarily intended for debugging in pure contexts,\nand assertion failures.\n\nBecause this is a pure function with side effects, it is marked as\n`@[never_extract]` so that the compiler will not perform common sub-expression\nelimination and other optimizations that assume that the expression is pure.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2428-L2428","name":"panicCore","kind":"def","docLink":"./Init/Prelude.html#panicCore","doc":"Auxiliary definition for `panic`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2412-L2413","name":"unsafeCast","kind":"def","docLink":"./Init/Prelude.html#unsafeCast","doc":"This function will cast a value of type `α` to type `β`, and is a no-op in the\ncompiler. This function is **extremely dangerous** because there is no guarantee\nthat types `α` and `β` have the same data representation, and this can lead to\nmemory unsafety. It is also logically unsound, since you could just cast\n`True` to `False`. For all those reasons this function is marked as `unsafe`.\n\nIt is implemented by lifting both `α` and `β` into a common universe, and then\nusing `cast (lcProof : ULift (PLift α) = ULift (PLift β))` to actually perform\nthe cast. All these operations are no-ops in the compiler.\n\nUsing this function correctly requires some knowledge of the data representation\nof the source and target types. Some general classes of casts which are safe in\nthe current runtime:\n\n* `Array α` to `Array β` where `α` and `β` have compatible representations,\n  or more generally for other inductive types.\n* `Quot α r` and `α`.\n* `@Subtype α p` and `α`, or generally any structure containing only one\n  non-`Prop` field of type `α`.\n* Casting `α` to/from `NonScalar` when `α` is a boxed generic type\n  (i.e. a function that accepts an arbitrary type `α` and is not specialized to\n  a scalar type like `UInt8`).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2385-L2386","name":"String.toSubstring'","kind":"def","docLink":"./Init/Prelude.html#String.toSubstring'","doc":"`String.toSubstring` without `[inline]` annotation. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2379-L2382","name":"String.toSubstring","kind":"def","docLink":"./Init/Prelude.html#String.toSubstring","doc":"Convert a `String` into a `Substring` denoting the entire string. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2375-L2376","name":"String.endPos","kind":"def","docLink":"./Init/Prelude.html#String.endPos","doc":"A `String.Pos` pointing at the end of this string. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2371-L2372","name":"instDecidableLtPosInstLTPos","kind":"instance","docLink":"./Init/Prelude.html#instDecidableLtPosInstLTPos","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2368-L2369","name":"instDecidableLePosInstLEPos","kind":"instance","docLink":"./Init/Prelude.html#instDecidableLePosInstLEPos","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2365-L2366","name":"instLTPos","kind":"instance","docLink":"./Init/Prelude.html#instLTPos","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2362-L2363","name":"instLEPos","kind":"instance","docLink":"./Init/Prelude.html#instLEPos","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2359-L2360","name":"instHAddPosString","kind":"instance","docLink":"./Init/Prelude.html#instHAddPosString","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2356-L2357","name":"instHAddPosChar","kind":"instance","docLink":"./Init/Prelude.html#instHAddPosChar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2353-L2354","name":"instHSubPos","kind":"instance","docLink":"./Init/Prelude.html#instHSubPos","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2350-L2351","name":"instHAddPos","kind":"instance","docLink":"./Init/Prelude.html#instHAddPos","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2346-L2348","name":"String.utf8ByteSize.go","kind":"def","docLink":"./Init/Prelude.html#String.utf8ByteSize.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2343-L2348","name":"String.utf8ByteSize","kind":"def","docLink":"./Init/Prelude.html#String.utf8ByteSize","doc":"The UTF-8 byte length of this string.\nThis is overridden by the compiler to be cached and O(1).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2335-L2336","name":"String.csize","kind":"def","docLink":"./Init/Prelude.html#String.csize","doc":"Returns the number of bytes required to encode this `Char` in UTF-8. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2331-L2332","name":"Substring.bsize","kind":"def","docLink":"./Init/Prelude.html#Substring.bsize","doc":"The byte length of the substring. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2327-L2328","name":"instInhabitedSubstring","kind":"instance","docLink":"./Init/Prelude.html#instInhabitedSubstring","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2325-L2325","name":"Substring.stopPos","kind":"def","docLink":"./Init/Prelude.html#Substring.stopPos","doc":"The byte position of the end of the string slice. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2323-L2323","name":"Substring.startPos","kind":"def","docLink":"./Init/Prelude.html#Substring.startPos","doc":"The byte position of the start of the string slice. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2321-L2321","name":"Substring.str","kind":"def","docLink":"./Init/Prelude.html#Substring.str","doc":"The underlying string to slice. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2319-L2325","name":"Substring","kind":"structure","docLink":"./Init/Prelude.html#Substring","doc":"A `Substring` is a view into some subslice of a `String`.\nThe actual string slicing is deferred because this would require copying the\nstring; here we only store a reference to the original string for\ngarbage collection purposes.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2308-L2311","name":"instDecidableEqPos","kind":"instance","docLink":"./Init/Prelude.html#instDecidableEqPos","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2305-L2306","name":"instInhabitedPos","kind":"instance","docLink":"./Init/Prelude.html#instInhabitedPos","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2303-L2303","name":"String.Pos.byteIdx","kind":"def","docLink":"./Init/Prelude.html#String.Pos.byteIdx","doc":"Get the underlying byte index of a `String.Pos` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2301-L2303","name":"String.Pos","kind":"structure","docLink":"./Init/Prelude.html#String.Pos","doc":"A byte position in a `String`. Internally, `String`s are UTF-8 encoded.\nCodepoint positions (counting the Unicode codepoints rather than bytes)\nare represented by plain `Nat`s instead.\nIndexing a `String` by a byte position is constant-time, while codepoint\npositions need to be translated internally to byte positions in linear-time.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2292-L2292","name":"instDecidableEqString","kind":"instance","docLink":"./Init/Prelude.html#instDecidableEqString","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2287-L2290","name":"String.decEq","kind":"def","docLink":"./Init/Prelude.html#String.decEq","doc":"Decides equality on `String`.\nThis function is overridden with a native implementation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2277-L2277","name":"String.data","kind":"def","docLink":"./Init/Prelude.html#String.data","doc":"Unpack `String` into a `List Char`. This function is overridden by the\ncompiler and is O(n) in the length of the list. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2274-L2274","name":"String.mk","kind":"ctor","docLink":"./Init/Prelude.html#String.mk","doc":"Pack a `List Char` into a `String`. This function is overridden by the\ncompiler and is O(n) in the length of the list. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2271-L2277","name":"String","kind":"structure","docLink":"./Init/Prelude.html#String","doc":"`String` is the type of (UTF-8 encoded) strings.\n\nThe compiler overrides the data representation of this type to a byte sequence,\nand both `String.utf8ByteSize` and `String.length` are cached and O(1).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2261-L2263","name":"List.get","kind":"def","docLink":"./Init/Prelude.html#List.get","doc":"`as.get i` returns the `i`'th element of the list `as`.\nThis version of the function uses `i : Fin as.length` to ensure that it will\nnot index out of bounds.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2252-L2254","name":"List.concat","kind":"def","docLink":"./Init/Prelude.html#List.concat","doc":"`l.concat a` appends `a` at the *end* of `l`, that is, `l ++ [a]`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2248-L2249","name":"List.length_cons","kind":"theorem","docLink":"./Init/Prelude.html#List.length_cons","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2245-L2246","name":"List.lengthTR","kind":"def","docLink":"./Init/Prelude.html#List.lengthTR","doc":"A tail-recursive version of `List.length`, used to implement `List.length`\nwithout running out of stack space.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2237-L2239","name":"List.lengthTRAux","kind":"def","docLink":"./Init/Prelude.html#List.lengthTRAux","doc":"Auxiliary function for `List.lengthTR`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2232-L2234","name":"List.length","kind":"def","docLink":"./Init/Prelude.html#List.length","doc":"The length of a list: `[].length = 0` and `(a :: l).length = l.length + 1`.\n\nThis function is overridden in the compiler to `lengthTR`, which uses constant\nstack space, while leaving this function to use the \"naive\" recursion which is\neasier for reasoning.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2220-L2223","name":"List.set","kind":"def","docLink":"./Init/Prelude.html#List.set","doc":"`l.set n a` sets the value of list `l` at (zero-based) index `n` to `a`:\n`[a, b, c, d].set 1 b' = [a, b', c, d]`\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2212-L2214","name":"List.foldl","kind":"def","docLink":"./Init/Prelude.html#List.foldl","doc":"Folds a function over a list from the left:\n`foldl f z [a, b, c] = f (f (f z a) b) c`\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2205-L2205","name":"instDecidableEqList","kind":"instance","docLink":"./Init/Prelude.html#instDecidableEqList","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2193-L2203","name":"List.hasDecEq","kind":"def","docLink":"./Init/Prelude.html#List.hasDecEq","doc":"Implements decidable equality for `List α`, assuming `α` has decidable equality. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2189-L2190","name":"instInhabitedList","kind":"instance","docLink":"./Init/Prelude.html#instInhabitedList","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2185-L2187","name":"List.cons","kind":"ctor","docLink":"./Init/Prelude.html#List.cons","doc":"If `a : α` and `l : List α`, then `cons a l`, or `a :: l`, is the\nlist whose first element is `a` and with `l` as the rest of the list. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2183-L2184","name":"List.nil","kind":"ctor","docLink":"./Init/Prelude.html#List.nil","doc":"`[]` is the empty list. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2182-L2187","name":"List","kind":"inductive","docLink":"./Init/Prelude.html#List","doc":"`List α` is the type of ordered lists with elements of type `α`.\nIt is implemented as a linked list.\n\n`List α` is isomorphic to `Array α`, but they are useful for different things:\n* `List α` is easier for reasoning, and\n  `Array α` is modeled as a wrapper around `List α`\n* `List α` works well as a persistent data structure, when many copies of the\n  tail are shared. When the value is not shared, `Array α` will have better\n  performance because it can do destructive updates.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2167-L2169","name":"Option.map","kind":"def","docLink":"./Init/Prelude.html#Option.map","doc":"Map a function over an `Option` by applying the function to the contained\nvalue if present.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2159-L2161","name":"Option.getD","kind":"def","docLink":"./Init/Prelude.html#Option.getD","doc":"Get with default. If `opt : Option α` and `dflt : α`, then `opt.getD dflt`\nreturns `a` if `opt = some a` and `dflt` otherwise.\n\nThis function is `@[macro_inline]`, so `dflt` will not be evaluated unless\n`opt` turns out to be `none`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2149-L2150","name":"instInhabitedOption","kind":"instance","docLink":"./Init/Prelude.html#instInhabitedOption","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2142-L2143","name":"Option.some","kind":"ctor","docLink":"./Init/Prelude.html#Option.some","doc":"Some value of type `α`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2140-L2141","name":"Option.none","kind":"ctor","docLink":"./Init/Prelude.html#Option.none","doc":"No value. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2139-L2143","name":"Option","kind":"inductive","docLink":"./Init/Prelude.html#Option","doc":"`Option α` is the type of values which are either `some a` for some `a : α`,\nor `none`. In functional programming languages, this type is used to represent\nthe possibility of failure, or sometimes nullability.\n\nFor example, the function `HashMap.find? : HashMap α β → α → Option β` looks up\na specified key `a : α` inside the map. Because we do not know in advance\nwhether the key is actually in the map, the return type is `Option β`, where\n`none` means the value was not in the map, and `some b` means that the value\nwas found and `b` is the value retrieved.\n\nTo extract a value from an `Option α`, we use pattern matching:\n```\ndef map (f : α → β) (x : Option α) : Option β :=\n  match x with\n  | some a => some (f a)\n  | none => none\n```\nWe can also use `if let` to pattern match on `Option` and get the value\nin the branch:\n```\ndef map (f : α → β) (x : Option α) : Option β :=\n  if let some a := x then\n    some (f a)\n  else\n    none\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2101-L2109","name":"Char.utf8Size","kind":"def","docLink":"./Init/Prelude.html#Char.utf8Size","doc":"Returns the number of bytes required to encode this `Char` in UTF-8. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2094-L2098","name":"instDecidableEqChar","kind":"instance","docLink":"./Init/Prelude.html#instDecidableEqChar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2091-L2092","name":"Char.val_ne_of_ne","kind":"theorem","docLink":"./Init/Prelude.html#Char.val_ne_of_ne","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2088-L2089","name":"Char.ne_of_val_ne","kind":"theorem","docLink":"./Init/Prelude.html#Char.ne_of_val_ne","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2085-L2086","name":"Char.val_eq_of_eq","kind":"theorem","docLink":"./Init/Prelude.html#Char.val_eq_of_eq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2082-L2083","name":"Char.eq_of_val_eq","kind":"theorem","docLink":"./Init/Prelude.html#Char.eq_of_val_eq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2077-L2080","name":"Char.ofNat","kind":"def","docLink":"./Init/Prelude.html#Char.ofNat","doc":"Convert a `Nat` into a `Char`. If the `Nat` does not encode a valid unicode scalar value,\n`'\\0'` is returned instead.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2069-L2070","name":"Char.ofNatAux","kind":"def","docLink":"./Init/Prelude.html#Char.ofNatAux","doc":"Pack a `Nat` encoding a valid codepoint into a `Char`.\nThis function is overridden with a native implementation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2057-L2057","name":"Char.valid","kind":"def","docLink":"./Init/Prelude.html#Char.valid","doc":"The value must be a legal codepoint. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2055-L2055","name":"Char.val","kind":"def","docLink":"./Init/Prelude.html#Char.val","doc":"The underlying unicode scalar value as a `UInt32`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2053-L2057","name":"Char","kind":"structure","docLink":"./Init/Prelude.html#Char","doc":"The `Char` Type represents an unicode scalar value.\nSee http://www.unicode.org/glossary/#unicode_scalar_value). "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2048-L2049","name":"UInt32.isValidChar","kind":"def","docLink":"./Init/Prelude.html#UInt32.isValidChar","doc":"A `UInt32` denotes a valid unicode codepoint if it is less than `0x110000`, and\nit is also not a \"surrogate\" character (the range `0xd800` to `0xdfff` inclusive).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2041-L2042","name":"Nat.isValidChar","kind":"def","docLink":"./Init/Prelude.html#Nat.isValidChar","doc":"A `Nat` denotes a valid unicode codepoint if it is less than `0x110000`, and\nit is also not a \"surrogate\" character (the range `0xd800` to `0xdfff` inclusive).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2029-L2035","name":"USize.ofNat32","kind":"def","docLink":"./Init/Prelude.html#USize.ofNat32","doc":"Upcast a `Nat` less than `2^32` to a `USize`.\nThis is lossless because `USize.size` is either `2^32` or `2^64`.\nThis function is overridden with a native implementation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2018-L2021","name":"instInhabitedUSize","kind":"instance","docLink":"./Init/Prelude.html#instInhabitedUSize","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2016-L2016","name":"instDecidableEqUSize","kind":"instance","docLink":"./Init/Prelude.html#instDecidableEqUSize","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2011-L2014","name":"USize.decEq","kind":"def","docLink":"./Init/Prelude.html#USize.decEq","doc":"Decides equality on `USize`.\nThis function is overridden with a native implementation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L2001-L2003","name":"USize.ofNatCore","kind":"def","docLink":"./Init/Prelude.html#USize.ofNatCore","doc":"Pack a `Nat` less than `USize.size` into a `USize`.\nThis function is overridden with a native implementation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1991-L1991","name":"USize.val","kind":"def","docLink":"./Init/Prelude.html#USize.val","doc":"Unpack a `USize` as a `Nat` less than `USize.size`.\nThis function is overridden with a native implementation. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1988-L1991","name":"USize","kind":"structure","docLink":"./Init/Prelude.html#USize","doc":"A `USize` is an unsigned integer with the size of a word\nfor the platform's architecture.\n\nFor example, if running on a 32-bit machine, USize is equivalent to UInt32.\nOr on a 64-bit machine, UInt64.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1975-L1979","name":"usize_size_eq","kind":"theorem","docLink":"./Init/Prelude.html#usize_size_eq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1973-L1973","name":"USize.size","kind":"def","docLink":"./Init/Prelude.html#USize.size","doc":"The size of type `UInt16`, that is, `2^System.Platform.numBits`, which may\nbe either `2^32` or `2^64` depending on the platform's architecture.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1966-L1967","name":"instInhabitedUInt64","kind":"instance","docLink":"./Init/Prelude.html#instInhabitedUInt64","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1964-L1964","name":"instDecidableEqUInt64","kind":"instance","docLink":"./Init/Prelude.html#instDecidableEqUInt64","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1959-L1962","name":"UInt64.decEq","kind":"def","docLink":"./Init/Prelude.html#UInt64.decEq","doc":"Decides equality on `UInt64`.\nThis function is overridden with a native implementation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1950-L1951","name":"UInt64.ofNatCore","kind":"def","docLink":"./Init/Prelude.html#UInt64.ofNatCore","doc":"Pack a `Nat` less than `2^64` into a `UInt64`.\nThis function is overridden with a native implementation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1940-L1940","name":"UInt64.val","kind":"def","docLink":"./Init/Prelude.html#UInt64.val","doc":"Unpack a `UInt64` as a `Nat` less than `2^64`.\nThis function is overridden with a native implementation. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1937-L1940","name":"UInt64","kind":"structure","docLink":"./Init/Prelude.html#UInt64","doc":"The type of unsigned 64-bit integers. This type has special support in the\ncompiler to make it actually 64 bits rather than wrapping a `Nat`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1932-L1932","name":"UInt64.size","kind":"def","docLink":"./Init/Prelude.html#UInt64.size","doc":"The size of type `UInt64`, that is, `2^64 = 18446744073709551616`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1929-L1929","name":"instMinUInt32","kind":"instance","docLink":"./Init/Prelude.html#instMinUInt32","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1928-L1928","name":"instMaxUInt32","kind":"instance","docLink":"./Init/Prelude.html#instMaxUInt32","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1927-L1927","name":"instDecidableLeUInt32InstLEUInt32","kind":"instance","docLink":"./Init/Prelude.html#instDecidableLeUInt32InstLEUInt32","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1926-L1926","name":"instDecidableLtUInt32InstLTUInt32","kind":"instance","docLink":"./Init/Prelude.html#instDecidableLtUInt32InstLTUInt32","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1922-L1924","name":"UInt32.decLe","kind":"def","docLink":"./Init/Prelude.html#UInt32.decLe","doc":"Decides less-than on `UInt32`.\nThis function is overridden with a native implementation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1912-L1914","name":"UInt32.decLt","kind":"def","docLink":"./Init/Prelude.html#UInt32.decLt","doc":"Decides less-equal on `UInt32`.\nThis function is overridden with a native implementation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1903-L1904","name":"instLEUInt32","kind":"instance","docLink":"./Init/Prelude.html#instLEUInt32","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1900-L1901","name":"instLTUInt32","kind":"instance","docLink":"./Init/Prelude.html#instLTUInt32","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1897-L1898","name":"instInhabitedUInt32","kind":"instance","docLink":"./Init/Prelude.html#instInhabitedUInt32","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1895-L1895","name":"instDecidableEqUInt32","kind":"instance","docLink":"./Init/Prelude.html#instDecidableEqUInt32","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1890-L1893","name":"UInt32.decEq","kind":"def","docLink":"./Init/Prelude.html#UInt32.decEq","doc":"Decides equality on `UInt32`.\nThis function is overridden with a native implementation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1882-L1882","name":"UInt32.toNat","kind":"def","docLink":"./Init/Prelude.html#UInt32.toNat","doc":"Unpack a `UInt32` as a `Nat`.\nThis function is overridden with a native implementation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1874-L1875","name":"UInt32.ofNatCore","kind":"def","docLink":"./Init/Prelude.html#UInt32.ofNatCore","doc":"Pack a `Nat` less than `2^32` into a `UInt32`.\nThis function is overridden with a native implementation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1864-L1864","name":"UInt32.val","kind":"def","docLink":"./Init/Prelude.html#UInt32.val","doc":"Unpack a `UInt32` as a `Nat` less than `2^32`.\nThis function is overridden with a native implementation. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1861-L1864","name":"UInt32","kind":"structure","docLink":"./Init/Prelude.html#UInt32","doc":"The type of unsigned 32-bit integers. This type has special support in the\ncompiler to make it actually 32 bits rather than wrapping a `Nat`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1855-L1855","name":"UInt32.size","kind":"def","docLink":"./Init/Prelude.html#UInt32.size","doc":"The size of type `UInt32`, that is, `2^32 = 4294967296`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1851-L1852","name":"instInhabitedUInt16","kind":"instance","docLink":"./Init/Prelude.html#instInhabitedUInt16","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1849-L1849","name":"instDecidableEqUInt16","kind":"instance","docLink":"./Init/Prelude.html#instDecidableEqUInt16","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1844-L1847","name":"UInt16.decEq","kind":"def","docLink":"./Init/Prelude.html#UInt16.decEq","doc":"Decides equality on `UInt16`.\nThis function is overridden with a native implementation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1835-L1836","name":"UInt16.ofNatCore","kind":"def","docLink":"./Init/Prelude.html#UInt16.ofNatCore","doc":"Pack a `Nat` less than `2^16` into a `UInt16`.\nThis function is overridden with a native implementation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1825-L1825","name":"UInt16.val","kind":"def","docLink":"./Init/Prelude.html#UInt16.val","doc":"Unpack a `UInt16` as a `Nat` less than `2^16`.\nThis function is overridden with a native implementation. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1822-L1825","name":"UInt16","kind":"structure","docLink":"./Init/Prelude.html#UInt16","doc":"The type of unsigned 16-bit integers. This type has special support in the\ncompiler to make it actually 16 bits rather than wrapping a `Nat`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1816-L1816","name":"UInt16.size","kind":"def","docLink":"./Init/Prelude.html#UInt16.size","doc":"The size of type `UInt16`, that is, `2^16 = 65536`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1812-L1813","name":"instInhabitedUInt8","kind":"instance","docLink":"./Init/Prelude.html#instInhabitedUInt8","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1810-L1810","name":"instDecidableEqUInt8","kind":"instance","docLink":"./Init/Prelude.html#instDecidableEqUInt8","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1805-L1808","name":"UInt8.decEq","kind":"def","docLink":"./Init/Prelude.html#UInt8.decEq","doc":"Decides equality on `UInt8`.\nThis function is overridden with a native implementation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1796-L1797","name":"UInt8.ofNatCore","kind":"def","docLink":"./Init/Prelude.html#UInt8.ofNatCore","doc":"Pack a `Nat` less than `2^8` into a `UInt8`.\nThis function is overridden with a native implementation.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1786-L1786","name":"UInt8.val","kind":"def","docLink":"./Init/Prelude.html#UInt8.val","doc":"Unpack a `UInt8` as a `Nat` less than `2^8`.\nThis function is overridden with a native implementation. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1783-L1786","name":"UInt8","kind":"structure","docLink":"./Init/Prelude.html#UInt8","doc":"The type of unsigned 8-bit integers. This type has special support in the\ncompiler to make it actually 8 bits rather than wrapping a `Nat`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1777-L1777","name":"UInt8.size","kind":"def","docLink":"./Init/Prelude.html#UInt8.size","doc":"The size of type `UInt8`, that is, `2^8 = 256`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1774-L1774","name":"Fin.decLe","kind":"instance","docLink":"./Init/Prelude.html#Fin.decLe","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1773-L1773","name":"Fin.decLt","kind":"instance","docLink":"./Init/Prelude.html#Fin.decLt","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1770-L1771","name":"instLEFin","kind":"instance","docLink":"./Init/Prelude.html#instLEFin","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1767-L1768","name":"instLTFin","kind":"instance","docLink":"./Init/Prelude.html#instLTFin","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1761-L1765","name":"instDecidableEqFin","kind":"instance","docLink":"./Init/Prelude.html#instDecidableEqFin","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1758-L1759","name":"Fin.ne_of_val_ne","kind":"theorem","docLink":"./Init/Prelude.html#Fin.ne_of_val_ne","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1755-L1756","name":"Fin.val_eq_of_eq","kind":"theorem","docLink":"./Init/Prelude.html#Fin.val_eq_of_eq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1752-L1753","name":"Fin.eq_of_val_eq","kind":"theorem","docLink":"./Init/Prelude.html#Fin.eq_of_val_eq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1750-L1750","name":"Fin.isLt","kind":"def","docLink":"./Init/Prelude.html#Fin.isLt","doc":"If `i : Fin n`, then `i.2` is a proof that `i.1 < n`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1748-L1748","name":"Fin.val","kind":"def","docLink":"./Init/Prelude.html#Fin.val","doc":"If `i : Fin n`, then `i.val : ℕ` is the described number. It can also be\nwritten as `i.1` or just `i` when the target type is known. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1745-L1745","name":"Fin.mk","kind":"ctor","docLink":"./Init/Prelude.html#Fin.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1745-L1750","name":"Fin","kind":"structure","docLink":"./Init/Prelude.html#Fin","doc":"`Fin n` is a natural number `i` with the constraint that `0 ≤ i < n`.\nIt is the \"canonical type with `n` elements\".\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1738-L1739","name":"System.Platform.numBits_eq","kind":"theorem","docLink":"./Init/Prelude.html#System.Platform.numBits_eq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1735-L1736","name":"System.Platform.numBits","kind":"def","docLink":"./Init/Prelude.html#System.Platform.numBits","doc":"Gets the word size of the platform. That is, whether the platform is 64 or 32 bits. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1731-L1732","name":"System.Platform.getNumBits","kind":"opaque","docLink":"./Init/Prelude.html#System.Platform.getNumBits","doc":"Gets the word size of the platform. That is, whether the platform is 64 or 32 bits.\n\nThis function is opaque because we cannot guarantee at compile time that the target\nwill have the same size as the host, and also because we would like to avoid\ntypechecking being architecture-dependent. Nevertheless, lean only works on\n64 and 32 bit systems so we can encode this as a fact available for proof purposes.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1720-L1721","name":"instSubNat","kind":"instance","docLink":"./Init/Prelude.html#instSubNat","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1716-L1718","name":"Nat.sub","kind":"def","docLink":"./Init/Prelude.html#Nat.sub","doc":"(Truncated) subtraction of natural numbers. Because natural numbers are not\nclosed under subtraction, we define `m - n` to be `0` when `n < m`.\n\nThis definition is overridden in both the kernel and the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model (and it is soundness-critical that they coincide).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1704-L1704","name":"instMinNat","kind":"instance","docLink":"./Init/Prelude.html#instMinNat","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1701-L1702","name":"Nat.decLt","kind":"instance","docLink":"./Init/Prelude.html#Nat.decLt","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1697-L1698","name":"Nat.decLe","kind":"instance","docLink":"./Init/Prelude.html#Nat.decLe","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1693-L1694","name":"Nat.not_le_of_not_ble_eq_true","kind":"theorem","docLink":"./Init/Prelude.html#Nat.not_le_of_not_ble_eq_true","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1688-L1691","name":"Nat.ble_eq_true_of_le","kind":"theorem","docLink":"./Init/Prelude.html#Nat.ble_eq_true_of_le","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1684-L1686","name":"Nat.ble_succ_eq_true","kind":"theorem","docLink":"./Init/Prelude.html#Nat.ble_succ_eq_true","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1680-L1682","name":"Nat.ble_self_eq_true","kind":"theorem","docLink":"./Init/Prelude.html#Nat.ble_self_eq_true","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1675-L1678","name":"Nat.le_of_ble_eq_true","kind":"theorem","docLink":"./Init/Prelude.html#Nat.le_of_ble_eq_true","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1670-L1673","name":"Nat.lt_of_le_of_ne","kind":"theorem","docLink":"./Init/Prelude.html#Nat.lt_of_le_of_ne","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1665-L1668","name":"Nat.le_antisymm","kind":"theorem","docLink":"./Init/Prelude.html#Nat.le_antisymm","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1662-L1663","name":"Nat.lt_of_le_of_lt","kind":"theorem","docLink":"./Init/Prelude.html#Nat.lt_of_le_of_lt","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1659-L1660","name":"Nat.lt_irrefl","kind":"theorem","docLink":"./Init/Prelude.html#Nat.lt_irrefl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1655-L1657","name":"Nat.not_succ_le_self","kind":"theorem","docLink":"./Init/Prelude.html#Nat.not_succ_le_self","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1644-L1653","name":"Nat.lt_or_ge","kind":"theorem","docLink":"./Init/Prelude.html#Nat.lt_or_ge","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1634-L1642","name":"Nat.eq_or_lt_of_le","kind":"theorem","docLink":"./Init/Prelude.html#Nat.eq_or_lt_of_le","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1631-L1632","name":"Nat.le_of_lt_succ","kind":"theorem","docLink":"./Init/Prelude.html#Nat.le_of_lt_succ","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1628-L1629","name":"Nat.le_of_succ_le_succ","kind":"theorem","docLink":"./Init/Prelude.html#Nat.le_of_succ_le_succ","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1623-L1626","name":"Nat.pred_le_pred","kind":"theorem","docLink":"./Init/Prelude.html#Nat.pred_le_pred","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1619-L1621","name":"Nat.pred","kind":"def","docLink":"./Init/Prelude.html#Nat.pred","doc":"The predecessor function on natural numbers.\n\nThis definition is overridden in the compiler to use `n - 1` instead.\nThe definition provided here is the logical model.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1608-L1609","name":"Nat.succ_pos","kind":"theorem","docLink":"./Init/Prelude.html#Nat.succ_pos","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1605-L1606","name":"Nat.le_refl","kind":"theorem","docLink":"./Init/Prelude.html#Nat.le_refl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1602-L1603","name":"Nat.le_succ_of_le","kind":"theorem","docLink":"./Init/Prelude.html#Nat.le_succ_of_le","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1599-L1600","name":"Nat.le_succ","kind":"theorem","docLink":"./Init/Prelude.html#Nat.le_succ","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1596-L1597","name":"Nat.lt_trans","kind":"theorem","docLink":"./Init/Prelude.html#Nat.lt_trans","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1592-L1594","name":"Nat.le_trans","kind":"theorem","docLink":"./Init/Prelude.html#Nat.le_trans","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1589-L1590","name":"Nat.le_step","kind":"theorem","docLink":"./Init/Prelude.html#Nat.le_step","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1586-L1587","name":"Nat.zero_lt_succ","kind":"theorem","docLink":"./Init/Prelude.html#Nat.zero_lt_succ","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1582-L1584","name":"Nat.succ_le_succ","kind":"theorem","docLink":"./Init/Prelude.html#Nat.succ_le_succ","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1578-L1580","name":"Nat.zero_le","kind":"theorem","docLink":"./Init/Prelude.html#Nat.zero_le","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1575-L1576","name":"Nat.not_lt_zero","kind":"theorem","docLink":"./Init/Prelude.html#Nat.not_lt_zero","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1571-L1573","name":"Nat.not_succ_le_zero","kind":"theorem","docLink":"./Init/Prelude.html#Nat.not_succ_le_zero","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1568-L1569","name":"instLTNat","kind":"instance","docLink":"./Init/Prelude.html#instLTNat","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1565-L1566","name":"Nat.lt","kind":"def","docLink":"./Init/Prelude.html#Nat.lt","doc":"The strict less than relation on natural numbers is defined as `n < m := n + 1 ≤ m`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1561-L1562","name":"instLENat","kind":"instance","docLink":"./Init/Prelude.html#instLENat","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1558-L1559","name":"Nat.le.step","kind":"ctor","docLink":"./Init/Prelude.html#Nat.le.step","doc":"If `n ≤ m`, then `n ≤ m + 1`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1556-L1557","name":"Nat.le.refl","kind":"ctor","docLink":"./Init/Prelude.html#Nat.le.refl","doc":"Less-equal is reflexive: `n ≤ n` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1555-L1559","name":"Nat.le","kind":"inductive","docLink":"./Init/Prelude.html#Nat.le","doc":"An inductive definition of the less-equal relation on natural numbers,\ncharacterized as the least relation `≤` such that `n ≤ n` and `n ≤ m → n ≤ m + 1`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1545-L1549","name":"Nat.ble","kind":"def","docLink":"./Init/Prelude.html#Nat.ble","doc":"The (Boolean) less-equal relation on natural numbers.\n\nThis definition is overridden in both the kernel and the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model (and it is soundness-critical that they coincide).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1534-L1534","name":"instDecidableEqNat","kind":"instance","docLink":"./Init/Prelude.html#instDecidableEqNat","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1529-L1532","name":"Nat.decEq","kind":"def","docLink":"./Init/Prelude.html#Nat.decEq","doc":"A decision procedure for equality of natural numbers.\n\nThis definition is overridden in the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1513-L1519","name":"Nat.ne_of_beq_eq_false","kind":"theorem","docLink":"./Init/Prelude.html#Nat.ne_of_beq_eq_false","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1504-L1511","name":"Nat.eq_of_beq_eq_true","kind":"theorem","docLink":"./Init/Prelude.html#Nat.eq_of_beq_eq_true","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1501-L1502","name":"instBEqNat","kind":"instance","docLink":"./Init/Prelude.html#instBEqNat","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1495-L1499","name":"Nat.beq","kind":"def","docLink":"./Init/Prelude.html#Nat.beq","doc":"(Boolean) equality of natural numbers.\n\nThis definition is overridden in both the kernel and the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model (and it is soundness-critical that they coincide).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1483-L1484","name":"instPowNat","kind":"instance","docLink":"./Init/Prelude.html#instPowNat","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1479-L1481","name":"Nat.pow","kind":"def","docLink":"./Init/Prelude.html#Nat.pow","doc":"The power operation on natural numbers.\n\nThis definition is overridden in the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1467-L1468","name":"instMulNat","kind":"instance","docLink":"./Init/Prelude.html#instMulNat","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1463-L1465","name":"Nat.mul","kind":"def","docLink":"./Init/Prelude.html#Nat.mul","doc":"Multiplication of natural numbers.\n\nThis definition is overridden in both the kernel and the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model (and it is soundness-critical that they coincide).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1447-L1448","name":"instAddNat","kind":"instance","docLink":"./Init/Prelude.html#instAddNat","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1443-L1445","name":"Nat.add","kind":"def","docLink":"./Init/Prelude.html#Nat.add","doc":"Addition of natural numbers.\n\nThis definition is overridden in both the kernel and the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model (and it is soundness-critical that they coincide).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1432-L1432","name":"Membership.mem","kind":"def","docLink":"./Init/Prelude.html#Membership.mem","doc":"The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1430-L1430","name":"Membership.mk","kind":"ctor","docLink":"./Init/Prelude.html#Membership.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1430-L1432","name":"Membership","kind":"class","docLink":"./Init/Prelude.html#Membership","doc":"The typeclass behind the notation `a ∈ s : Prop` where `a : α`, `s : γ`.\nBecause `α` is an `outParam`, the \"container type\" `γ` determines the type\nof the elements of the container.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1417-L1418","name":"instHShiftRight","kind":"instance","docLink":"./Init/Prelude.html#instHShiftRight","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1413-L1414","name":"instHShiftLeft","kind":"instance","docLink":"./Init/Prelude.html#instHShiftLeft","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1409-L1410","name":"instHOr","kind":"instance","docLink":"./Init/Prelude.html#instHOr","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1405-L1406","name":"instHXor","kind":"instance","docLink":"./Init/Prelude.html#instHXor","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1401-L1402","name":"instHAnd","kind":"instance","docLink":"./Init/Prelude.html#instHAnd","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1397-L1398","name":"instHAndThen","kind":"instance","docLink":"./Init/Prelude.html#instHAndThen","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1393-L1394","name":"instHOrElse","kind":"instance","docLink":"./Init/Prelude.html#instHOrElse","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1389-L1390","name":"instHAppend","kind":"instance","docLink":"./Init/Prelude.html#instHAppend","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1385-L1386","name":"instHPow","kind":"instance","docLink":"./Init/Prelude.html#instHPow","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1381-L1382","name":"instHMod","kind":"instance","docLink":"./Init/Prelude.html#instHMod","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1377-L1378","name":"instHDiv","kind":"instance","docLink":"./Init/Prelude.html#instHDiv","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1373-L1374","name":"instHMul","kind":"instance","docLink":"./Init/Prelude.html#instHMul","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1369-L1370","name":"instHSub","kind":"instance","docLink":"./Init/Prelude.html#instHSub","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1365-L1366","name":"instHAdd","kind":"instance","docLink":"./Init/Prelude.html#instHAdd","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1362-L1362","name":"ShiftRight.shiftRight","kind":"def","docLink":"./Init/Prelude.html#ShiftRight.shiftRight","doc":"The implementation of `a >>> b : α`. See `HShiftRight`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1360-L1360","name":"ShiftRight.mk","kind":"ctor","docLink":"./Init/Prelude.html#ShiftRight.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1360-L1362","name":"ShiftRight","kind":"class","docLink":"./Init/Prelude.html#ShiftRight","doc":"The homogeneous version of `HShiftRight`: `a >>> b : α` where `a b : α`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1357-L1357","name":"ShiftLeft.shiftLeft","kind":"def","docLink":"./Init/Prelude.html#ShiftLeft.shiftLeft","doc":"The implementation of `a <<< b : α`. See `HShiftLeft`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1355-L1355","name":"ShiftLeft.mk","kind":"ctor","docLink":"./Init/Prelude.html#ShiftLeft.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1355-L1357","name":"ShiftLeft","kind":"class","docLink":"./Init/Prelude.html#ShiftLeft","doc":"The homogeneous version of `HShiftLeft`: `a <<< b : α` where `a b : α`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1352-L1352","name":"Complement.complement","kind":"def","docLink":"./Init/Prelude.html#Complement.complement","doc":"The implementation of `~~~a : α`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1350-L1350","name":"Complement.mk","kind":"ctor","docLink":"./Init/Prelude.html#Complement.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1350-L1352","name":"Complement","kind":"class","docLink":"./Init/Prelude.html#Complement","doc":"The typeclass behind the notation `~~~a : α` where `a : α`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1347-L1347","name":"OrOp.or","kind":"def","docLink":"./Init/Prelude.html#OrOp.or","doc":"The implementation of `a ||| b : α`. See `HOr`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1345-L1345","name":"OrOp.mk","kind":"ctor","docLink":"./Init/Prelude.html#OrOp.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1345-L1347","name":"OrOp","kind":"class","docLink":"./Init/Prelude.html#OrOp","doc":"The homogeneous version of `HOr`: `a ||| b : α` where `a b : α`.\n(It is called `OrOp` because `Or` is taken for the propositional connective.)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1339-L1339","name":"Xor.xor","kind":"def","docLink":"./Init/Prelude.html#Xor.xor","doc":"The implementation of `a ^^^ b : α`. See `HXor`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1337-L1337","name":"Xor.mk","kind":"ctor","docLink":"./Init/Prelude.html#Xor.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1337-L1339","name":"Xor","kind":"class","docLink":"./Init/Prelude.html#Xor","doc":"The homogeneous version of `HXor`: `a ^^^ b : α` where `a b : α`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1334-L1334","name":"AndOp.and","kind":"def","docLink":"./Init/Prelude.html#AndOp.and","doc":"The implementation of `a &&& b : α`. See `HAnd`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1332-L1332","name":"AndOp.mk","kind":"ctor","docLink":"./Init/Prelude.html#AndOp.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1332-L1334","name":"AndOp","kind":"class","docLink":"./Init/Prelude.html#AndOp","doc":"The homogeneous version of `HAnd`: `a &&& b : α` where `a b : α`.\n(It is called `AndOp` because `And` is taken for the propositional connective.)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1326-L1326","name":"AndThen.andThen","kind":"def","docLink":"./Init/Prelude.html#AndThen.andThen","doc":"The implementation of `a >> b : α`. See `HAndThen`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1324-L1324","name":"AndThen.mk","kind":"ctor","docLink":"./Init/Prelude.html#AndThen.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1324-L1326","name":"AndThen","kind":"class","docLink":"./Init/Prelude.html#AndThen","doc":"The homogeneous version of `HAndThen`: `a >> b : α` where `a b : α`.\nBecause `b` is \"lazy\" in this notation, it is passed as `Unit → α` to the\nimplementation so it can decide when to evaluate it.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1317-L1317","name":"OrElse.orElse","kind":"def","docLink":"./Init/Prelude.html#OrElse.orElse","doc":"The implementation of `a <|> b : α`. See `HOrElse`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1315-L1315","name":"OrElse.mk","kind":"ctor","docLink":"./Init/Prelude.html#OrElse.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1315-L1317","name":"OrElse","kind":"class","docLink":"./Init/Prelude.html#OrElse","doc":"The homogeneous version of `HOrElse`: `a <|> b : α` where `a b : α`.\nBecause `b` is \"lazy\" in this notation, it is passed as `Unit → α` to the\nimplementation so it can decide when to evaluate it.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1308-L1308","name":"Append.append","kind":"def","docLink":"./Init/Prelude.html#Append.append","doc":"`a ++ b` is the result of concatenation of `a` and `b`. See `HAppend`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1306-L1306","name":"Append.mk","kind":"ctor","docLink":"./Init/Prelude.html#Append.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1306-L1308","name":"Append","kind":"class","docLink":"./Init/Prelude.html#Append","doc":"The homogeneous version of `HAppend`: `a ++ b : α` where `a b : α`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1303-L1303","name":"Pow.pow","kind":"def","docLink":"./Init/Prelude.html#Pow.pow","doc":"`a ^ b` computes `a` to the power of `b`. See `HPow`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1301-L1301","name":"Pow.mk","kind":"ctor","docLink":"./Init/Prelude.html#Pow.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1301-L1303","name":"Pow","kind":"class","docLink":"./Init/Prelude.html#Pow","doc":"The homogeneous version of `HPow`: `a ^ b : α` where `a : α`, `b : β`.\n(The right argument is not the same as the left since we often want this even\nin the homogeneous case.)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1294-L1294","name":"Mod.mod","kind":"def","docLink":"./Init/Prelude.html#Mod.mod","doc":"`a % b` computes the remainder upon dividing `a` by `b`. See `HMod`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1292-L1292","name":"Mod.mk","kind":"ctor","docLink":"./Init/Prelude.html#Mod.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1292-L1294","name":"Mod","kind":"class","docLink":"./Init/Prelude.html#Mod","doc":"The homogeneous version of `HMod`: `a % b : α` where `a b : α`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1289-L1289","name":"Div.div","kind":"def","docLink":"./Init/Prelude.html#Div.div","doc":"`a / b` computes the result of dividing `a` by `b`. See `HDiv`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1287-L1287","name":"Div.mk","kind":"ctor","docLink":"./Init/Prelude.html#Div.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1287-L1289","name":"Div","kind":"class","docLink":"./Init/Prelude.html#Div","doc":"The homogeneous version of `HDiv`: `a / b : α` where `a b : α`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1284-L1284","name":"Neg.neg","kind":"def","docLink":"./Init/Prelude.html#Neg.neg","doc":"`-a` computes the negative or opposite of `a`.\nThe meaning of this notation is type-dependent. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1281-L1281","name":"Neg.mk","kind":"ctor","docLink":"./Init/Prelude.html#Neg.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1281-L1284","name":"Neg","kind":"class","docLink":"./Init/Prelude.html#Neg","doc":"The notation typeclass for negation.\nThis enables the notation `-a : α` where `a : α`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1275-L1275","name":"Mul.mul","kind":"def","docLink":"./Init/Prelude.html#Mul.mul","doc":"`a * b` computes the product of `a` and `b`. See `HMul`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1273-L1273","name":"Mul.mk","kind":"ctor","docLink":"./Init/Prelude.html#Mul.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1273-L1275","name":"Mul","kind":"class","docLink":"./Init/Prelude.html#Mul","doc":"The homogeneous version of `HMul`: `a * b : α` where `a b : α`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1270-L1270","name":"Sub.sub","kind":"def","docLink":"./Init/Prelude.html#Sub.sub","doc":"`a - b` computes the difference of `a` and `b`. See `HSub`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1268-L1268","name":"Sub.mk","kind":"ctor","docLink":"./Init/Prelude.html#Sub.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1268-L1270","name":"Sub","kind":"class","docLink":"./Init/Prelude.html#Sub","doc":"The homogeneous version of `HSub`: `a - b : α` where `a b : α`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1265-L1265","name":"Add.add","kind":"def","docLink":"./Init/Prelude.html#Add.add","doc":"`a + b` computes the sum of `a` and `b`. See `HAdd`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1263-L1263","name":"Add.mk","kind":"ctor","docLink":"./Init/Prelude.html#Add.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1263-L1265","name":"Add","kind":"class","docLink":"./Init/Prelude.html#Add","doc":"The homogeneous version of `HAdd`: `a + b : α` where `a b : α`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1260-L1260","name":"HShiftRight.hShiftRight","kind":"def","docLink":"./Init/Prelude.html#HShiftRight.hShiftRight","doc":"`a >>> b` computes `a` shifted to the right by `b` places.\nThe meaning of this notation is type-dependent.\n* On `Nat` and fixed width unsigned types like `UInt8`,\n  this is equivalent to `a / 2 ^ b`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1255-L1255","name":"HShiftRight.mk","kind":"ctor","docLink":"./Init/Prelude.html#HShiftRight.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1255-L1260","name":"HShiftRight","kind":"class","docLink":"./Init/Prelude.html#HShiftRight","doc":"The typeclass behind the notation `a >>> b : γ` where `a : α`, `b : β`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1252-L1252","name":"HShiftLeft.hShiftLeft","kind":"def","docLink":"./Init/Prelude.html#HShiftLeft.hShiftLeft","doc":"`a <<< b` computes `a` shifted to the left by `b` places.\nThe meaning of this notation is type-dependent.\n* On `Nat`, this is equivalent to `a * 2 ^ b`.\n* On `UInt8` and other fixed width unsigned types, this is the same but\n  truncated to the bit width. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1246-L1246","name":"HShiftLeft.mk","kind":"ctor","docLink":"./Init/Prelude.html#HShiftLeft.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1246-L1252","name":"HShiftLeft","kind":"class","docLink":"./Init/Prelude.html#HShiftLeft","doc":"The typeclass behind the notation `a <<< b : γ` where `a : α`, `b : β`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1243-L1243","name":"HOr.hOr","kind":"def","docLink":"./Init/Prelude.html#HOr.hOr","doc":"`a ||| b` computes the bitwise OR of `a` and `b`.\nThe meaning of this notation is type-dependent. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1240-L1240","name":"HOr.mk","kind":"ctor","docLink":"./Init/Prelude.html#HOr.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1240-L1243","name":"HOr","kind":"class","docLink":"./Init/Prelude.html#HOr","doc":"The typeclass behind the notation `a ||| b : γ` where `a : α`, `b : β`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1237-L1237","name":"HXor.hXor","kind":"def","docLink":"./Init/Prelude.html#HXor.hXor","doc":"`a ^^^ b` computes the bitwise XOR of `a` and `b`.\nThe meaning of this notation is type-dependent. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1234-L1234","name":"HXor.mk","kind":"ctor","docLink":"./Init/Prelude.html#HXor.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1234-L1237","name":"HXor","kind":"class","docLink":"./Init/Prelude.html#HXor","doc":"The typeclass behind the notation `a ^^^ b : γ` where `a : α`, `b : β`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1231-L1231","name":"HAnd.hAnd","kind":"def","docLink":"./Init/Prelude.html#HAnd.hAnd","doc":"`a &&& b` computes the bitwise AND of `a` and `b`.\nThe meaning of this notation is type-dependent. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1228-L1228","name":"HAnd.mk","kind":"ctor","docLink":"./Init/Prelude.html#HAnd.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1228-L1231","name":"HAnd","kind":"class","docLink":"./Init/Prelude.html#HAnd","doc":"The typeclass behind the notation `a &&& b : γ` where `a : α`, `b : β`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1225-L1225","name":"HAndThen.hAndThen","kind":"def","docLink":"./Init/Prelude.html#HAndThen.hAndThen","doc":"`a >> b` executes `a`, ignores the result, and then executes `b`.\nIf `a` fails then `b` is not executed. Because `b` is not always executed, it\nis passed as a thunk so it can be forced only when needed.\nThe meaning of this notation is type-dependent. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1220-L1220","name":"HAndThen.mk","kind":"ctor","docLink":"./Init/Prelude.html#HAndThen.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1220-L1225","name":"HAndThen","kind":"class","docLink":"./Init/Prelude.html#HAndThen","doc":"The typeclass behind the notation `a >> b : γ` where `a : α`, `b : β`.\nBecause `b` is \"lazy\" in this notation, it is passed as `Unit → β` to the\nimplementation so it can decide when to evaluate it.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1213-L1213","name":"HOrElse.hOrElse","kind":"def","docLink":"./Init/Prelude.html#HOrElse.hOrElse","doc":"`a <|> b` executes `a` and returns the result, unless it fails in which\ncase it executes and returns `b`. Because `b` is not always executed, it\nis passed as a thunk so it can be forced only when needed.\nThe meaning of this notation is type-dependent. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1208-L1208","name":"HOrElse.mk","kind":"ctor","docLink":"./Init/Prelude.html#HOrElse.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1208-L1213","name":"HOrElse","kind":"class","docLink":"./Init/Prelude.html#HOrElse","doc":"The typeclass behind the notation `a <|> b : γ` where `a : α`, `b : β`.\nBecause `b` is \"lazy\" in this notation, it is passed as `Unit → β` to the\nimplementation so it can decide when to evaluate it.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1201-L1201","name":"HAppend.hAppend","kind":"def","docLink":"./Init/Prelude.html#HAppend.hAppend","doc":"`a ++ b` is the result of concatenation of `a` and `b`, usually read \"append\".\nThe meaning of this notation is type-dependent. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1198-L1198","name":"HAppend.mk","kind":"ctor","docLink":"./Init/Prelude.html#HAppend.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1198-L1201","name":"HAppend","kind":"class","docLink":"./Init/Prelude.html#HAppend","doc":"The notation typeclass for heterogeneous append.\nThis enables the notation `a ++ b : γ` where `a : α`, `b : β`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1192-L1192","name":"HPow.hPow","kind":"def","docLink":"./Init/Prelude.html#HPow.hPow","doc":"`a ^ b` computes `a` to the power of `b`.\nThe meaning of this notation is type-dependent. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1189-L1189","name":"HPow.mk","kind":"ctor","docLink":"./Init/Prelude.html#HPow.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1189-L1192","name":"HPow","kind":"class","docLink":"./Init/Prelude.html#HPow","doc":"The notation typeclass for heterogeneous exponentiation.\nThis enables the notation `a ^ b : γ` where `a : α`, `b : β`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1183-L1183","name":"HMod.hMod","kind":"def","docLink":"./Init/Prelude.html#HMod.hMod","doc":"`a % b` computes the remainder upon dividing `a` by `b`.\nThe meaning of this notation is type-dependent.\n* For `Nat` and `Int`, `a % 0` is defined to be `a`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1179-L1179","name":"HMod.mk","kind":"ctor","docLink":"./Init/Prelude.html#HMod.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1179-L1183","name":"HMod","kind":"class","docLink":"./Init/Prelude.html#HMod","doc":"The notation typeclass for heterogeneous modulo / remainder.\nThis enables the notation `a % b : γ` where `a : α`, `b : β`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1173-L1173","name":"HDiv.hDiv","kind":"def","docLink":"./Init/Prelude.html#HDiv.hDiv","doc":"`a / b` computes the result of dividing `a` by `b`.\nThe meaning of this notation is type-dependent.\n* For most types like `Nat`, `Int`, `Rat`, `Real`, `a / 0` is defined to be `0`.\n* For `Nat` and `Int`, `a / b` rounds toward 0.\n* For `Float`, `a / 0` follows the IEEE 754 semantics for division,\n  usually resulting in `inf` or `nan`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1166-L1166","name":"HDiv.mk","kind":"ctor","docLink":"./Init/Prelude.html#HDiv.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1166-L1173","name":"HDiv","kind":"class","docLink":"./Init/Prelude.html#HDiv","doc":"The notation typeclass for heterogeneous division.\nThis enables the notation `a / b : γ` where `a : α`, `b : β`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1160-L1160","name":"HMul.hMul","kind":"def","docLink":"./Init/Prelude.html#HMul.hMul","doc":"`a * b` computes the product of `a` and `b`.\nThe meaning of this notation is type-dependent. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1157-L1157","name":"HMul.mk","kind":"ctor","docLink":"./Init/Prelude.html#HMul.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1157-L1160","name":"HMul","kind":"class","docLink":"./Init/Prelude.html#HMul","doc":"The notation typeclass for heterogeneous multiplication.\nThis enables the notation `a * b : γ` where `a : α`, `b : β`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1151-L1151","name":"HSub.hSub","kind":"def","docLink":"./Init/Prelude.html#HSub.hSub","doc":"`a - b` computes the difference of `a` and `b`.\nThe meaning of this notation is type-dependent.\n* For natural numbers, this operator saturates at 0: `a - b = 0` when `a ≤ b`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1147-L1147","name":"HSub.mk","kind":"ctor","docLink":"./Init/Prelude.html#HSub.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1147-L1151","name":"HSub","kind":"class","docLink":"./Init/Prelude.html#HSub","doc":"The notation typeclass for heterogeneous subtraction.\nThis enables the notation `a - b : γ` where `a : α`, `b : β`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1141-L1141","name":"HAdd.hAdd","kind":"def","docLink":"./Init/Prelude.html#HAdd.hAdd","doc":"`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1138-L1138","name":"HAdd.mk","kind":"ctor","docLink":"./Init/Prelude.html#HAdd.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1138-L1141","name":"HAdd","kind":"class","docLink":"./Init/Prelude.html#HAdd","doc":"The notation typeclass for heterogeneous addition.\nThis enables the notation `a + b : γ` where `a : α`, `b : β`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1131-L1132","name":"instTransEq_1","kind":"instance","docLink":"./Init/Prelude.html#instTransEq_1","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1128-L1129","name":"instTransEq","kind":"instance","docLink":"./Init/Prelude.html#instTransEq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1124-L1124","name":"Trans.trans","kind":"def","docLink":"./Init/Prelude.html#Trans.trans","doc":"Compose two proofs by transitivity, generalized over the relations involved. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1122-L1122","name":"Trans.mk","kind":"ctor","docLink":"./Init/Prelude.html#Trans.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1122-L1124","name":"Trans","kind":"class","docLink":"./Init/Prelude.html#Trans","doc":"Transitive chaining of proofs, used e.g. by `calc`.\n\nIt takes two relations `r` and `s` as \"input\", and produces an \"output\"\nrelation `t`, with the property that `r a b` and `s b c` implies `t a c`.\nThe `calc` tactic uses this so that when it sees a chain with `a ≤ b` and `b < c`\nit knows that this should be a proof of `a < c` because there is an instance\n`Trans (·≤·) (·<·) (·<·)`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1110-L1111","name":"minOfLe","kind":"def","docLink":"./Init/Prelude.html#minOfLe","doc":"Implementation of the `min` operation using `≤`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1103-L1103","name":"Min.min","kind":"def","docLink":"./Init/Prelude.html#Min.min","doc":"The minimum operation: `min x y`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1101-L1101","name":"Min.mk","kind":"ctor","docLink":"./Init/Prelude.html#Min.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1101-L1103","name":"Min","kind":"class","docLink":"./Init/Prelude.html#Min","doc":"`Min α` is the typeclass which supports the operation `min x y` where `x y : α`."},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1097-L1098","name":"maxOfLe","kind":"def","docLink":"./Init/Prelude.html#maxOfLe","doc":"Implementation of the `max` operation using `≤`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1090-L1090","name":"Max.max","kind":"def","docLink":"./Init/Prelude.html#Max.max","doc":"The maximum operation: `max x y`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1088-L1088","name":"Max.mk","kind":"ctor","docLink":"./Init/Prelude.html#Max.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1088-L1090","name":"Max","kind":"class","docLink":"./Init/Prelude.html#Max","doc":"`Max α` is the typeclass which supports the operation `max x y` where `x y : α`."},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1085-L1085","name":"GT.gt","kind":"def","docLink":"./Init/Prelude.html#GT.gt","doc":"`a > b` is an abbreviation for `b < a`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1083-L1083","name":"GE.ge","kind":"def","docLink":"./Init/Prelude.html#GE.ge","doc":"`a ≥ b` is an abbreviation for `b ≤ a`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1080-L1080","name":"LT.lt","kind":"def","docLink":"./Init/Prelude.html#LT.lt","doc":"The less-than relation: `x < y` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1078-L1078","name":"LT.mk","kind":"ctor","docLink":"./Init/Prelude.html#LT.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1078-L1080","name":"LT","kind":"class","docLink":"./Init/Prelude.html#LT","doc":"`LT α` is the typeclass which supports the notation `x < y` where `x y : α`."},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1075-L1075","name":"LE.le","kind":"def","docLink":"./Init/Prelude.html#LE.le","doc":"The less-equal relation: `x ≤ y` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1073-L1073","name":"LE.mk","kind":"ctor","docLink":"./Init/Prelude.html#LE.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1073-L1075","name":"LE","kind":"class","docLink":"./Init/Prelude.html#LE","doc":"`LE α` is the typeclass which supports the notation `x ≤ y` where `x y : α`."},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1069-L1070","name":"instOfNatNat","kind":"instance","docLink":"./Init/Prelude.html#instOfNatNat","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1066-L1066","name":"OfNat.ofNat","kind":"def","docLink":"./Init/Prelude.html#OfNat.ofNat","doc":"The `OfNat.ofNat` function is automatically inserted by the parser when\nthe user writes a numeric literal like `1 : α`. Implementations of this\ntypeclass can therefore customize the behavior of `n : α` based on `n` and\n`α`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1061-L1061","name":"OfNat.mk","kind":"ctor","docLink":"./Init/Prelude.html#OfNat.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1061-L1066","name":"OfNat","kind":"class","docLink":"./Init/Prelude.html#OfNat","doc":"The class `OfNat α n` powers the numeric literal parser. If you write\n`37 : α`, lean will attempt to synthesize `OfNat α 37`, and will generate\nthe term `(OfNat.ofNat 37 : α)`.\n\nThere is a bit of infinite regress here since the desugaring apparently\nstill contains a literal `37` in it. The type of expressions contains a\nprimitive constructor for \"raw natural number literals\", which you can directly\naccess using the macro `nat_lit 37`. Raw number literals are always of type `Nat`.\nSo it would be more correct to say that lean looks for an instance of\n`OfNat α (nat_lit 37)`, and it generates the term `(OfNat.ofNat (nat_lit 37) : α)`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1046-L1047","name":"instInhabitedNat","kind":"instance","docLink":"./Init/Prelude.html#instInhabitedNat","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1042-L1044","name":"Nat.succ","kind":"ctor","docLink":"./Init/Prelude.html#Nat.succ","doc":"The successor function on natural numbers, `succ n = n + 1`.\nThis is one of the two constructors of `Nat`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1039-L1041","name":"Nat.zero","kind":"ctor","docLink":"./Init/Prelude.html#Nat.zero","doc":"`Nat.zero`, normally written `0 : Nat`, is the smallest natural number.\nThis is one of the two constructors of `Nat`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1038-L1044","name":"Nat","kind":"inductive","docLink":"./Init/Prelude.html#Nat","doc":"The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1002-L1004","name":"not","kind":"def","docLink":"./Init/Prelude.html#not","doc":"`not x`, or `!x`, is the boolean \"not\" operation (not to be confused\nwith `Not : Prop → Prop`, which is the propositional connective).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L993-L996","name":"and","kind":"def","docLink":"./Init/Prelude.html#and","doc":"`and x y`, or `x && y`, is the boolean \"and\" operation (not to be confused\nwith `And : Prop → Prop → Prop`, which is the propositional connective).\nIt is `@[macro_inline]` because it has C-like short-circuiting behavior:\nif `x` is false then `y` is not evaluated.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L982-L985","name":"or","kind":"def","docLink":"./Init/Prelude.html#or","doc":"`or x y`, or `x || y`, is the boolean \"or\" operation (not to be confused\nwith `Or : Prop → Prop → Prop`, which is the propositional connective).\nIt is `@[macro_inline]` because it has C-like short-circuiting behavior:\nif `x` is true then `y` is not evaluated.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L971-L974","name":"cond","kind":"def","docLink":"./Init/Prelude.html#cond","doc":"`cond b x y` is the same as `if b then x else y`, but optimized for a\nboolean condition. It can also be written as `bif b then x else y`.\nThis is `@[macro_inline]` because `x` and `y` should not\nbe eagerly evaluated (see `ite`).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L958-L961","name":"instDecidableNot","kind":"instance","docLink":"./Init/Prelude.html#instDecidableNot","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L947-L956","name":"instDecidableOr","kind":"instance","docLink":"./Init/Prelude.html#instDecidableOr","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L938-L945","name":"instDecidableAnd","kind":"instance","docLink":"./Init/Prelude.html#instDecidableAnd","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L935-L936","name":"ite","kind":"def","docLink":"./Init/Prelude.html#ite","doc":"`if c then t else e` is notation for `ite c t e`, \"if-then-else\", which decides to\nreturn `t` or `e` depending on whether `c` is true or false. The explicit argument\n`c : Prop` does not have any actual computational content, but there is an additional\n`[Decidable c]` argument synthesized by typeclass inference which actually\ndetermines how to evaluate `c` to true or false.\n\nBecause lean uses a strict (call-by-value) evaluation strategy, the signature of this\nfunction is problematic in that it would require `t` and `e` to be evaluated before\ncalling the `ite` function, which would cause both sides of the `if` to be evaluated.\nEven if the result is discarded, this would be a big performance problem,\nand is undesirable for users in any case. To resolve this, `ite` is marked as\n`@[macro_inline]`, which means that it is unfolded during code generation, and\nthe definition of the function uses `fun _ => t` and `fun _ => e` so this recovers\nthe expected \"lazy\" behavior of `if`: the `t` and `e` arguments delay evaluation\nuntil `c` is known.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L913-L914","name":"dite","kind":"def","docLink":"./Init/Prelude.html#dite","doc":"\"Dependent\" if-then-else, normally written via the notation `if h : c then t(h) else e(h)`,\nis sugar for `dite c (fun h => t(h)) (fun h => e(h))`, and it is the same as\n`if c then t else e` except that `t` is allowed to depend on a proof `h : c`,\nand `e` can depend on `h : ¬c`. (Both branches use the same name for the hypothesis,\neven though it has different types in the two cases.)\n\nWe use this to be able to communicate the if-then-else condition to the branches.\nFor example, `Array.get arr ⟨i, h⟩` expects a proof `h : i < arr.size` in order to\navoid a bounds check, so you can write `if h : i < arr.size then arr.get ⟨i, h⟩ else ...`\nto avoid the bounds check inside the if branch. (Of course in this case we have only\nlifted the check into an explicit `if`, but we could also use this proof multiple times\nor derive `i < arr.size` from some other proposition that we are checking in the `if`.)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L895-L896","name":"instBEq","kind":"instance","docLink":"./Init/Prelude.html#instBEq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L891-L891","name":"BEq.beq","kind":"def","docLink":"./Init/Prelude.html#BEq.beq","doc":"Boolean equality, notated as `a == b`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L889-L889","name":"BEq.mk","kind":"ctor","docLink":"./Init/Prelude.html#BEq.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L889-L891","name":"BEq","kind":"class","docLink":"./Init/Prelude.html#BEq","doc":"`BEq α` is a typeclass for supplying a boolean-valued equality relation on\n`α`, notated as `a == b`. Unlike `DecidableEq α` (which uses `a = b`), this\nis `Bool` valued instead of `Prop` valued, and it also does not have any\naxioms like being reflexive or agreeing with `=`. It is mainly intended for\nprogramming applications. See `LawfulBEq` for a version that requires that\n`==` and `=` coincide.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L878-L879","name":"instDecidableEqBool","kind":"instance","docLink":"./Init/Prelude.html#instDecidableEqBool","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L871-L876","name":"Bool.decEq","kind":"def","docLink":"./Init/Prelude.html#Bool.decEq","doc":"Decidable equality for Bool "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L865-L868","name":"of_decide_eq_self_eq_true","kind":"theorem","docLink":"./Init/Prelude.html#of_decide_eq_self_eq_true","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L860-L863","name":"of_decide_eq_false","kind":"theorem","docLink":"./Init/Prelude.html#of_decide_eq_false","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L855-L858","name":"of_decide_eq_true","kind":"theorem","docLink":"./Init/Prelude.html#of_decide_eq_true","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L851-L853","name":"decide_eq_false","kind":"theorem","docLink":"./Init/Prelude.html#decide_eq_false","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L847-L849","name":"decide_eq_true","kind":"theorem","docLink":"./Init/Prelude.html#decide_eq_true","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L843-L844","name":"decEq","kind":"def","docLink":"./Init/Prelude.html#decEq","doc":"Proves that `a = b` is decidable given `DecidableEq α`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L839-L840","name":"DecidableEq","kind":"def","docLink":"./Init/Prelude.html#DecidableEq","doc":"Asserts that `α` has decidable equality, that is, `a = b` is decidable\nfor all `a b : α`. See `Decidable`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L832-L833","name":"DecidableRel","kind":"def","docLink":"./Init/Prelude.html#DecidableRel","doc":"A decidable relation. See `Decidable`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L828-L829","name":"DecidablePred","kind":"def","docLink":"./Init/Prelude.html#DecidablePred","doc":"A decidable predicate. See `Decidable`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L822-L823","name":"Decidable.decide","kind":"def","docLink":"./Init/Prelude.html#Decidable.decide","doc":"Convert a decidable proposition into a boolean value.\n\nIf `p : Prop` is decidable, then `decide p : Bool` is the boolean value\nwhich is `true` if `p` is true and `false` if `p` is false.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L813-L814","name":"Decidable.isTrue","kind":"ctor","docLink":"./Init/Prelude.html#Decidable.isTrue","doc":"Prove that `p` is decidable by supplying a proof of `p` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L811-L812","name":"Decidable.isFalse","kind":"ctor","docLink":"./Init/Prelude.html#Decidable.isFalse","doc":"Prove that `p` is decidable by supplying a proof of `¬p` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L810-L814","name":"Decidable","kind":"class","docLink":"./Init/Prelude.html#Decidable","doc":"`Decidable p` is a data-carrying class that supplies a proof that `p` is\neither `true` or `false`. It is equivalent to `Bool` (and in fact it has the\nsame code generation as `Bool`) together with a proof that the `Bool` is\ntrue iff `p` is.\n\n`Decidable` instances are used to infer \"computation strategies\" for\npropositions, so that you can have the convenience of writing propositions\ninside `if` statements and executing them (which actually executes the inferred\ndecidability instance instead of the proposition, which has no code).\n\nIf a proposition `p` is `Decidable`, then `(by decide : p)` will prove it by\nevaluating the decidability instance to `isTrue h` and returning `h`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L794-L794","name":"ULift.down_up","kind":"theorem","docLink":"./Init/Prelude.html#ULift.down_up","doc":"Bijection between `α` and `ULift.{v} α` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L791-L791","name":"ULift.up_down","kind":"theorem","docLink":"./Init/Prelude.html#ULift.up_down","doc":"Bijection between `α` and `ULift.{v} α` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L788-L788","name":"ULift.down","kind":"def","docLink":"./Init/Prelude.html#ULift.down","doc":"Extract a value from `ULift α` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L787-L787","name":"ULift.up","kind":"ctor","docLink":"./Init/Prelude.html#ULift.up","doc":"Lift a value into `ULift α` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L786-L788","name":"ULift","kind":"structure","docLink":"./Init/Prelude.html#ULift","doc":"Universe lifting operation from a lower `Type` universe to a higher one.\nTo express this using level variables, the input is `Type s` and the output is\n`Type (max s r)`, so if `s ≤ r` then the latter is (definitionally) `Type r`.\n\nThe universe variable `r` is written first so that `ULift.{r} α` can be used\nwhen `s` can be inferred from the type of `α`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L775-L776","name":"instInhabitedNonemptyType","kind":"instance","docLink":"./Init/Prelude.html#instInhabitedNonemptyType","doc":"`NonemptyType` is inhabited, because `PUnit` is a nonempty type. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L771-L772","name":"NonemptyType.type","kind":"def","docLink":"./Init/Prelude.html#NonemptyType.type","doc":"The underlying type of a `NonemptyType`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L768-L768","name":"NonemptyType","kind":"def","docLink":"./Init/Prelude.html#NonemptyType","doc":"`NonemptyType.{u}` is the type of nonempty types in universe `u`.\nIt is mainly used in constant declarations where we wish to introduce a type\nand simultaneously assert that it is nonempty, but otherwise make the type\nopaque.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L760-L760","name":"PLift.down_up","kind":"theorem","docLink":"./Init/Prelude.html#PLift.down_up","doc":"Bijection between `α` and `PLift α` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L757-L757","name":"PLift.up_down","kind":"theorem","docLink":"./Init/Prelude.html#PLift.up_down","doc":"Bijection between `α` and `PLift α` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L754-L754","name":"PLift.down","kind":"def","docLink":"./Init/Prelude.html#PLift.down","doc":"Extract a value from `PLift α` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L753-L753","name":"PLift.up","kind":"ctor","docLink":"./Init/Prelude.html#PLift.up","doc":"Lift a value into `PLift α` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L752-L754","name":"PLift","kind":"structure","docLink":"./Init/Prelude.html#PLift","doc":"Universe lifting operation from `Sort u` to `Type u`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L749-L749","name":"instInhabitedBool","kind":"instance","docLink":"./Init/Prelude.html#instInhabitedBool","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L746-L747","name":"instInhabitedForAll_1","kind":"instance","docLink":"./Init/Prelude.html#instInhabitedForAll_1","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L743-L744","name":"instInhabitedForAll","kind":"instance","docLink":"./Init/Prelude.html#instInhabitedForAll","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L740-L741","name":"instInhabitedSort","kind":"instance","docLink":"./Init/Prelude.html#instInhabitedSort","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L737-L738","name":"instNonemptyForAll_1","kind":"instance","docLink":"./Init/Prelude.html#instNonemptyForAll_1","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L734-L735","name":"instNonemptyForAll","kind":"instance","docLink":"./Init/Prelude.html#instNonemptyForAll","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L731-L732","name":"Classical.ofNonempty","kind":"def","docLink":"./Init/Prelude.html#Classical.ofNonempty","doc":"A variation on `Classical.choice` that uses typeclass inference to\ninfer the proof of `Nonempty α`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L724-L725","name":"instNonempty","kind":"instance","docLink":"./Init/Prelude.html#instNonempty","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L720-L722","name":"Nonempty.elim","kind":"def","docLink":"./Init/Prelude.html#Nonempty.elim","doc":"The elimination principle for `Nonempty α`. If `Nonempty α`, and we can\nprove `p` given any element `x : α`, then `p` holds. Note that it is essential\nthat `p` is a `Prop` here; the version with `p` being a `Sort u` is equivalent\nto `Classical.choice`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L712-L712","name":"Classical.choice","kind":"axiom","docLink":"./Init/Prelude.html#Classical.choice","doc":"**The axiom of choice**. `Nonempty α` is a proof that `α` has an element,\nbut the element itself is erased. The axiom `choice` supplies a particular\nelement of `α` given only this proof.\n\nThe textbook axiom of choice normally makes a family of choices all at once,\nbut that is implied from this formulation, because if `α : ι → Type` is a\nfamily of types and `h : ∀ i, Nonempty (α i)` is a proof that they are all\nnonempty, then `fun i => Classical.choice (h i) : ∀ i, α i` is a family of\nchosen elements. This is actually a bit stronger than the ZFC choice axiom;\nthis is sometimes called \"[global choice](https://en.wikipedia.org/wiki/Axiom_of_global_choice)\".\n\nIn lean, we use the axiom of choice to derive the law of excluded middle\n(see `Classical.em`), so it will often show up in axiom listings where you\nmay not expect. You can use `#print axioms my_thm` to find out if a given\ntheorem depends on this or other axioms.\n\nThis axiom can be used to construct \"data\", but obviously there is no algorithm\nto compute it, so lean will require you to mark any definition that would\ninvolve executing `Classical.choice` or other axioms as `noncomputable`, and\nwill not produce any executable code for such definitions.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L687-L688","name":"Nonempty.intro","kind":"ctor","docLink":"./Init/Prelude.html#Nonempty.intro","doc":"If `val : α`, then `α` is nonempty. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L686-L688","name":"Nonempty","kind":"class","docLink":"./Init/Prelude.html#Nonempty","doc":"`Nonempty α` is a typeclass that says that `α` is not an empty type,\nthat is, there exists an element in the type. It differs from `Inhabited α`\nin that `Nonempty α` is a `Prop`, which means that it does not actually carry\nan element of `α`, only a proof that *there exists* such an element.\nGiven `Nonempty α`, you can construct an element of `α` *nonconstructively*\nusing `Classical.choice`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L674-L674","name":"Inhabited.default","kind":"def","docLink":"./Init/Prelude.html#Inhabited.default","doc":"`default` is a function that produces a \"default\" element of any\n`Inhabited` type. This element does not have any particular specified\nproperties, but it is often an all-zeroes value. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L670-L670","name":"Inhabited.mk","kind":"ctor","docLink":"./Init/Prelude.html#Inhabited.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L670-L674","name":"Inhabited","kind":"class","docLink":"./Init/Prelude.html#Inhabited","doc":"`Inhabited α` is a typeclass that says that `α` has a designated element,\ncalled `(default : α)`. This is sometimes referred to as a \"pointed type\".\n\nThis class is used by functions that need to return a value of the type\nwhen called \"out of domain\". For example, `Array.get! arr i : α` returns\na value of type `α` when `arr : Array α`, but if `i` is not in range of\nthe array, it reports a panic message, but this does not halt the program,\nso it must still return a value of type `α` (and in fact this is required\nfor logical consistency), so in this case it returns `default`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L655-L657","name":"ne_true_of_eq_false","kind":"theorem","docLink":"./Init/Prelude.html#ne_true_of_eq_false","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L651-L653","name":"ne_false_of_eq_true","kind":"theorem","docLink":"./Init/Prelude.html#ne_false_of_eq_true","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L647-L649","name":"eq_true_of_ne_false","kind":"theorem","docLink":"./Init/Prelude.html#eq_true_of_ne_false","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L643-L645","name":"eq_false_of_ne_true","kind":"theorem","docLink":"./Init/Prelude.html#eq_false_of_ne_true","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L641-L641","name":"sorryAx","kind":"axiom","docLink":"./Init/Prelude.html#sorryAx","doc":"Auxiliary axiom used to implement `sorry`.\n\nThe `sorry` term/tactic expands to `sorryAx _ (synthetic := false)`. This is a\nproof of anything, which is intended for stubbing out incomplete parts of a\nproof while still having a syntactically correct proof skeleton. Lean will give\na warning whenever a proof uses `sorry`, so you aren't likely to miss it, but\nyou can double check if a theorem depends on `sorry` by using\n`#print axioms my_thm` and looking for `sorryAx` in the axiom list.\n\nThe `synthetic` flag is false when written explicitly by the user, but it is\nset to `true` when a tactic fails to prove a goal, or if there is a type error\nin the expression. A synthetic `sorry` acts like a regular one, except that it\nsuppresses follow-up errors in order to prevent one error from causing a cascade\nof other errors because the desired term was not constructed.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L622-L622","name":"namedPattern","kind":"def","docLink":"./Init/Prelude.html#namedPattern","doc":"Auxiliary declaration used to implement named patterns like `x@h:p`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L618-L618","name":"semiOutParam","kind":"def","docLink":"./Init/Prelude.html#semiOutParam","doc":"Gadget for marking semi output parameters in type classes.\n\nSemi-output parameters influence the order in which arguments to type class\ninstances are processed.  Lean determines an order where all non-(semi-)output\nparameters to the instance argument have to be figured out before attempting to\nsynthesize an argument (that is, they do not contain assignable metavariables\ncreated during TC synthesis). This rules out instances such as `[Mul β] : Add\nα` (because `β` could be anything). Marking a parameter as semi-output is a\npromise that instances of the type class will always fill in a value for that\nparameter.\n\nFor example, the `Coe` class is defined as:\n```\nclass Coe (α : semiOutParam (Type u)) (β : Type v)\n```\nThis means that all `Coe` instances should provide a concrete value for `α`\n(i.e., not an assignable metavariable). An instance like `Coe Nat Int` or `Coe\nα (Option α)` is fine, but `Coe α Nat` is not since it does not provide a value\nfor `α`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L595-L595","name":"outParam","kind":"def","docLink":"./Init/Prelude.html#outParam","doc":"Gadget for marking output parameters in type classes.\n\nFor example, the `Membership` class is defined as:\n```\nclass Membership (α : outParam (Type u)) (γ : Type v)\n```\nThis means that whenever a typeclass goal of the form `Membership ?α ?γ` comes\nup, lean will wait to solve it until `?γ` is known, but then it will run\ntypeclass inference, and take the first solution it finds, for any value of `?α`,\nwhich thereby determines what `?α` should be.\n\nThis expresses that in a term like `a ∈ s`, `s` might be a `Set α` or\n`List α` or some other type with a membership operation, and in each case\nthe \"member\" type `α` is determined by looking at the container type.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L577-L577","name":"optParam","kind":"def","docLink":"./Init/Prelude.html#optParam","doc":"Gadget for optional parameter support.\n\nA binder like `(x : α := default)` in a declaration is syntax sugar for\n`x : optParam α default`, and triggers the elaborator to attempt to use\n`default` to supply the argument if it is not supplied.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L567-L567","name":"Subtype.property","kind":"def","docLink":"./Init/Prelude.html#Subtype.property","doc":"If `s : {x // p x}` then `s.2` or `s.property` is the assertion that\n`p s.1`, that is, that `s` is in fact an element for which `p` holds. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L564-L564","name":"Subtype.val","kind":"def","docLink":"./Init/Prelude.html#Subtype.val","doc":"If `s : {x // p x}` then `s.val : α` is the underlying element in the base\ntype. You can also write this as `s.1`, or simply as `s` when the type is\nknown from context. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L560-L560","name":"Subtype.mk","kind":"ctor","docLink":"./Init/Prelude.html#Subtype.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L560-L567","name":"Subtype","kind":"structure","docLink":"./Init/Prelude.html#Subtype","doc":"`Subtype p`, usually written as `{x : α // p x}`, is a type which\nrepresents all the elements `x : α` for which `p x` is true. It is structurally\na pair-like type, so if you have `x : α` and `h : p x` then\n`⟨x, h⟩ : {x // p x}`. An element `s : {x // p x}` will coerce to `α` but\nyou can also make it explicit using `s.1` or `s.val`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L548-L549","name":"Bool.true","kind":"ctor","docLink":"./Init/Prelude.html#Bool.true","doc":"The boolean value `true`, not to be confused with the proposition `True`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L546-L547","name":"Bool.false","kind":"ctor","docLink":"./Init/Prelude.html#Bool.false","doc":"The boolean value `false`, not to be confused with the proposition `False`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L545-L549","name":"Bool","kind":"inductive","docLink":"./Init/Prelude.html#Bool","doc":"`Bool` is the type of boolean values, `true` and `false`. Classically,\nthis is equivalent to `Prop` (the type of propositions), but the distinction\nis important for programming, because values of type `Prop` are erased in the\ncode generator, while `Bool` corresponds to the type called `bool` or `boolean`\nin most programming languages.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L533-L536","name":"Or.elim","kind":"theorem","docLink":"./Init/Prelude.html#Or.elim","doc":"Proof by cases on an `Or`. If `a ∨ b`, and both `a` and `b` imply\nproposition `c`, then `c` is true.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L526-L527","name":"Or.intro_right","kind":"theorem","docLink":"./Init/Prelude.html#Or.intro_right","doc":"Alias for `Or.inr`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L522-L523","name":"Or.intro_left","kind":"theorem","docLink":"./Init/Prelude.html#Or.intro_left","doc":"Alias for `Or.inl`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L518-L519","name":"Or.inr","kind":"ctor","docLink":"./Init/Prelude.html#Or.inr","doc":"`Or.inr` is \"right injection\" into an `Or`. If `h : b` then `Or.inr h : a ∨ b`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L516-L517","name":"Or.inl","kind":"ctor","docLink":"./Init/Prelude.html#Or.inl","doc":"`Or.inl` is \"left injection\" into an `Or`. If `h : a` then `Or.inl h : a ∨ b`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L515-L519","name":"Or","kind":"inductive","docLink":"./Init/Prelude.html#Or","doc":"`Or a b`, or `a ∨ b`, is the disjunction of propositions. There are two\nconstructors for `Or`, called `Or.inl : a → a ∨ b` and `Or.inr : b → a ∨ b`,\nand you can use `match` or `cases` to destruct an `Or` assumption into the\ntwo cases.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L507-L507","name":"And.right","kind":"def","docLink":"./Init/Prelude.html#And.right","doc":"Extract the right conjunct from a conjunction. `h : a ∧ b` then\n`h.right`, also notated as `h.2`, is a proof of `b`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L504-L504","name":"And.left","kind":"def","docLink":"./Init/Prelude.html#And.left","doc":"Extract the left conjunct from a conjunction. `h : a ∧ b` then\n`h.left`, also notated as `h.1`, is a proof of `a`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L501-L501","name":"And.intro","kind":"ctor","docLink":"./Init/Prelude.html#And.intro","doc":"`And.intro : a → b → a ∧ b` is the constructor for the And operation. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L499-L507","name":"And","kind":"structure","docLink":"./Init/Prelude.html#And","doc":"`And a b`, or `a ∧ b`, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`⟨ha, hb⟩ : a ∧ b`, and if `h : a ∧ b` then `h.left : a` and `h.right : b`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L492-L492","name":"MProd.snd","kind":"def","docLink":"./Init/Prelude.html#MProd.snd","doc":"The second projection out of a pair. if `p : MProd α β` then `p.2 : β`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L490-L490","name":"MProd.fst","kind":"def","docLink":"./Init/Prelude.html#MProd.fst","doc":"The first projection out of a pair. if `p : MProd α β` then `p.1 : α`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L488-L488","name":"MProd.mk","kind":"ctor","docLink":"./Init/Prelude.html#MProd.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L488-L492","name":"MProd","kind":"structure","docLink":"./Init/Prelude.html#MProd","doc":"Similar to `Prod`, but `α` and `β` are in the same universe.\nWe say `MProd` is the universe monomorphic product type.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L482-L482","name":"PProd.snd","kind":"def","docLink":"./Init/Prelude.html#PProd.snd","doc":"The second projection out of a pair. if `p : PProd α β` then `p.2 : β`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L480-L480","name":"PProd.fst","kind":"def","docLink":"./Init/Prelude.html#PProd.fst","doc":"The first projection out of a pair. if `p : PProd α β` then `p.1 : α`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L478-L478","name":"PProd.mk","kind":"ctor","docLink":"./Init/Prelude.html#PProd.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L478-L482","name":"PProd","kind":"structure","docLink":"./Init/Prelude.html#PProd","doc":"Similar to `Prod`, but `α` and `β` can be propositions.\nWe use this type internally to automatically generate the `brecOn` recursor.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L470-L470","name":"Prod.snd","kind":"def","docLink":"./Init/Prelude.html#Prod.snd","doc":"The second projection out of a pair. if `p : α × β` then `p.2 : β`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L468-L468","name":"Prod.fst","kind":"def","docLink":"./Init/Prelude.html#Prod.fst","doc":"The first projection out of a pair. if `p : α × β` then `p.1 : α`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L466-L466","name":"Prod.mk","kind":"ctor","docLink":"./Init/Prelude.html#Prod.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L466-L470","name":"Prod","kind":"structure","docLink":"./Init/Prelude.html#Prod","doc":"Product type (aka pair). You can use `α × β` as notation for `Prod α β`.\nGiven `a : α` and `b : β`, `Prod.mk a b : Prod α β`. You can use `(a, b)`\nas notation for `Prod.mk a b`. Moreover, `(a, b, c)` is notation for\n`Prod.mk a (Prod.mk b c)`.\nGiven `p : Prod α β`, `p.1 : α` and `p.2 : β`. They are short for `Prod.fst p`\nand `Prod.snd p` respectively. You can also write `p.fst` and `p.snd`.\nFor more information: [Constructors with Arguments](https://leanprover.github.io/theorem_proving_in_lean4/inductive_types.html?highlight=Prod#constructors-with-arguments)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L451-L455","name":"eq_of_heq","kind":"theorem","docLink":"./Init/Prelude.html#eq_of_heq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L448-L449","name":"HEq.rfl","kind":"def","docLink":"./Init/Prelude.html#HEq.rfl","doc":"A version of `HEq.refl` with an implicit argument. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L444-L445","name":"HEq.refl","kind":"ctor","docLink":"./Init/Prelude.html#HEq.refl","doc":"Reflexivity of heterogeneous equality. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L443-L445","name":"HEq","kind":"inductive","docLink":"./Init/Prelude.html#HEq","doc":"Heterogeneous equality. `HEq a b` asserts that `a` and `b` have the same\ntype, and casting `a` across the equality yields `b`, and vice versa.\n\nYou should avoid using this type if you can. Heterogeneous equality does not\nhave all the same properties as `Eq`, because the assumption that the types of\n`a` and `b` are equal is often too weak to prove theorems of interest. One\nimportant non-theorem is the analogue of `congr`: If `HEq f g` and `HEq x y`\nand `f x` and `g y` are well typed it does not follow that `HEq (f x) (g y)`.\n(This does follow if you have `f = g` instead.) However if `a` and `b` have\nthe same type then `a = b` and `HEq a b` are equivalent.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L429-L429","name":"Quot.lcInv","kind":"axiom","docLink":"./Init/Prelude.html#Quot.lcInv","doc":"Unsafe auxiliary constant used by the compiler to erase `Quot.lift`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L363-L364","name":"congrFun","kind":"theorem","docLink":"./Init/Prelude.html#congrFun","doc":"Congruence in the function part of an application: If `f = g` then `f a = g a`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L359-L360","name":"congr","kind":"theorem","docLink":"./Init/Prelude.html#congr","doc":"Congruence in both function and argument. If `f₁ = f₂` and `a₁ = a₂` then\n`f₁ a₁ = f₂ a₂`. This only works for nondependent functions; the theorem\nstatement is more complex in the dependent case.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L349-L350","name":"congrArg","kind":"theorem","docLink":"./Init/Prelude.html#congrArg","doc":"Congruence in the function argument: if `a₁ = a₂` then `f a₁ = f a₂` for\nany (nondependent) function `f`. This is more powerful than it might look at first, because\nyou can also use a lambda expression for `f` to prove that\n`<something containing a₁> = <something containing a₂>`. This function is used\ninternally by tactics like `congr` and `simp` to apply equalities inside\nsubterms.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L336-L337","name":"cast","kind":"def","docLink":"./Init/Prelude.html#cast","doc":"Cast across a type equality. If `h : α = β` is an equality of types, and\n`a : α`, then `a : β` will usually not typecheck directly, but this function\nwill allow you to work around this and embed `a` in type `β` as `cast h a : β`.\n\nIt is best to avoid this function if you can, because it is more complicated\nto reason about terms containing casts, but if the types don't match up\ndefinitionally sometimes there isn't anything better you can do.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L322-L323","name":"Eq.trans","kind":"theorem","docLink":"./Init/Prelude.html#Eq.trans","doc":"Equality is transitive: if `a = b` and `b = c` then `a = c`.\n\nBecause this is in the `Eq` namespace, if you have variables or expressions\n`h₁ : a = b` and `h₂ : b = c`, you can use `h₁.trans h₂ : a = c` as shorthand\nfor `Eq.trans h₁ h₂`.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L310-L311","name":"Eq.symm","kind":"theorem","docLink":"./Init/Prelude.html#Eq.symm","doc":"Equality is symmetric: if `a = b` then `b = a`.\n\nBecause this is in the `Eq` namespace, if you have a variable `h : a = b`,\n`h.symm` can be used as shorthand for `Eq.symm h` as a proof of `b = a`.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L299-L300","name":"Eq.subst","kind":"theorem","docLink":"./Init/Prelude.html#Eq.subst","doc":"The substitution principle for equality. If `a = b ` and `P a` holds,\nthen `P b` also holds. We conventionally use the name `motive` for `P` here,\nso that you can specify it explicitly using e.g.\n`Eq.subst (motive := fun x => x < 5)` if it is not otherwise inferred correctly.\n\nThis theorem is the underlying mechanism behind the `rw` tactic, which is\nessentially a fancy algorithm for finding good `motive` arguments to usefully\napply this theorem to replace occurrences of `a` with `b` in the goal or\nhypotheses.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L284-L284","name":"id_eq","kind":"theorem","docLink":"./Init/Prelude.html#id_eq","doc":"`id x = x`, as a `@[simp]` lemma. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L281-L281","name":"rfl","kind":"def","docLink":"./Init/Prelude.html#rfl","doc":"`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nlean by `rfl`, because both sides are the same up to definitional equality.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L264-L266","name":"Eq.refl","kind":"ctor","docLink":"./Init/Prelude.html#Eq.refl","doc":"`Eq.refl a : a = a` is reflexivity, the unique constructor of the\nequality type. See also `rfl`, which is usually used instead. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L263-L266","name":"Eq","kind":"inductive","docLink":"./Init/Prelude.html#Eq","doc":"The equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L233-L234","name":"absurd","kind":"def","docLink":"./Init/Prelude.html#absurd","doc":"Anything follows from two contradictory hypotheses. Example:\n```\nexample (hp : p) (hnp : ¬p) : q := absurd hp hnp\n```\nFor more information: [Propositional Logic](https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L223-L224","name":"False.elim","kind":"def","docLink":"./Init/Prelude.html#False.elim","doc":"`False.elim : False → C` says that from `False`, any desired proposition\n`C` holds. Also known as ex falso quodlibet (EFQ) or the principle of explosion.\n\nThe target type is actually `C : Sort u` which means it works for both\npropositions and types. When executed, this acts like an \"unreachable\"\ninstruction: it is **undefined behavior** to run, but it will probably print\n\"unreachable code\". (You would need to construct a proof of false to run it\nanyway, which you can only do using `sorry` or unsound axioms.)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L211-L211","name":"Not","kind":"def","docLink":"./Init/Prelude.html#Not","doc":"`Not p`, or `¬p`, is the negation of `p`. It is defined to be `p → False`,\nso if your goal is `¬p` you can use `intro h` to turn the goal into\n`h : p ⊢ False`, and if you have `hn : ¬p` and `h : p` then `hn h : False`\nand `(hn h).elim` will prove anything.\nFor more information: [Propositional Logic](https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L202-L202","name":"PEmpty","kind":"inductive","docLink":"./Init/Prelude.html#PEmpty","doc":"The universe-polymorphic empty type. Prefer `Empty` or `False` where\npossible.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L195-L195","name":"Empty","kind":"inductive","docLink":"./Init/Prelude.html#Empty","doc":"The empty type. It has no constructors. The `Empty.rec`\neliminator expresses the fact that anything follows from the empty type.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L189-L189","name":"False","kind":"inductive","docLink":"./Init/Prelude.html#False","doc":"`False` is the empty proposition. Thus, it has no introduction rules.\nIt represents a contradiction. `False` elimination rule, `False.rec`,\nexpresses the fact that anything follows from a contradiction.\nThis rule is sometimes called ex falso (short for ex falso sequitur quodlibet),\nor the principle of explosion.\nFor more information: [Propositional Logic](https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L177-L179","name":"True.intro","kind":"ctor","docLink":"./Init/Prelude.html#True.intro","doc":"`True` is true, and `True.intro` (or more commonly, `trivial`)\nis the proof. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L176-L179","name":"True","kind":"inductive","docLink":"./Init/Prelude.html#True","doc":"`True` is a proposition and has only an introduction rule, `True.intro : True`.\nIn other words, `True` is simply true, and has a canonical proof, `True.intro`\nFor more information: [Propositional Logic](https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L169-L169","name":"lcUnreachable","kind":"axiom","docLink":"./Init/Prelude.html#lcUnreachable","doc":"Auxiliary unsafe constant used by the Compiler to mark unreachable code.\n\nLike `lcProof`, this is an `unsafe axiom`, which means that even though it is\nnot sound, the kernel will not let us use it for regular proofs.\n\nExecuting this expression to actually synthesize a value of type `α` causes\n**immediate undefined behavior**, and the compiler does take advantage of this\nto optimize the code assuming that it is not called. If it is not optimized out,\nit is likely to appear as a print message saying \"unreachable code\", but this\nbehavior is not guaranteed or stable in any way.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L154-L154","name":"lcCast","kind":"axiom","docLink":"./Init/Prelude.html#lcCast","doc":"Auxiliary unsafe constant used by the Compiler when erasing casts.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L149-L149","name":"lcProof","kind":"axiom","docLink":"./Init/Prelude.html#lcProof","doc":"Auxiliary unsafe constant used by the Compiler when erasing proofs from code.\n\nIt may look strange to have an axiom that says \"every proposition is true\",\nsince this is obviously unsound, but the `unsafe` marker ensures that the\nkernel will not let this through into regular proofs. The lower levels of the\ncode generator don't need proofs in terms, so this is used to stub the proofs\nout.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L138-L138","name":"lcErased","kind":"axiom","docLink":"./Init/Prelude.html#lcErased","doc":"Marker for information that has been erased by the code generator. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L135-L135","name":"Unit.unit","kind":"def","docLink":"./Init/Prelude.html#Unit.unit","doc":"`Unit.unit : Unit` is the canonical element of the unit type.\nIt can also be written as `()`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L129-L129","name":"Unit","kind":"def","docLink":"./Init/Prelude.html#Unit","doc":"The unit type, the canonical type with one element, named `unit` or `()`.\nIn other words, it describes only a single value, which consists of said constructor applied\nto no arguments whatsoever.\nThe `Unit` type is similar to `void` in languages derived from C.\n\n`Unit` is actually defined as `PUnit.{0}` where `PUnit` is the universe\npolymorphic version. The `Unit` should be preferred over `PUnit` where possible to avoid\nunnecessary universe parameters.\n\nIn functional programming, `Unit` is the return type of things that \"return\nnothing\", since a type with one element conveys no additional information.\nWhen programming with monads, the type `m Unit` represents an action that has\nsome side effects but does not return a value, while `m α` would be an action\nthat has side effects and returns a value of type `α`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L110-L111","name":"PUnit.unit","kind":"ctor","docLink":"./Init/Prelude.html#PUnit.unit","doc":"`PUnit.unit : PUnit` is the canonical element of the unit type. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L109-L111","name":"PUnit","kind":"inductive","docLink":"./Init/Prelude.html#PUnit","doc":"The unit type, the canonical type with one element, named `unit` or `()`.\nThis is the universe-polymorphic version of `Unit`; it is preferred to use\n`Unit` instead where applicable.\nFor more information about universe levels: [Types as objects](https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html#types-as-objects)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L100-L100","name":"inferInstanceAs","kind":"def","docLink":"./Init/Prelude.html#inferInstanceAs","doc":"`inferInstanceAs α` synthesizes a value of any target type by typeclass\ninference. This is just like `inferInstance` except that `α` is given\nexplicitly instead of being inferred from the target type. It is especially\nuseful when the target type is some `α'` which is definitionally equal to `α`,\nbut the instance we are looking for is only registered for `α` (because\ntypeclass search does not unfold most definitions, but definitional equality\ndoes.) Example:\n```\n#check inferInstanceAs (Inhabited Nat) -- Inhabited Nat\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L86-L86","name":"inferInstance","kind":"def","docLink":"./Init/Prelude.html#inferInstance","doc":"`inferInstance` synthesizes a value of any target type by typeclass\ninference. This function has the same type signature as the identity\nfunction, but the square brackets on the `[i : α]` argument means that it will\nattempt to construct this argument by typeclass inference. (This will fail if\n`α` is not a `class`.) Example:\n```\n#check (inferInstance : Inhabited Nat) -- Inhabited Nat\n\ndef foo : Inhabited (Nat × Nat) :=\n  inferInstance\n\nexample : foo.default = (default, default) :=\n  rfl\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L66-L67","name":"Function.const","kind":"def","docLink":"./Init/Prelude.html#Function.const","doc":"The constant function. If `a : α`, then `Function.const β a : β → α` is the\n\"constant function with value `a`\", that is, `Function.const β a b = a`.\n```\nexample (b : Bool) : Function.const Bool 10 b = 10 :=\n  rfl\n\n#check Function.const Bool 10\n-- Bool → Nat\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L52-L53","name":"Function.comp","kind":"def","docLink":"./Init/Prelude.html#Function.comp","doc":"Function composition is the act of pipelining the result of one function, to the input of another, creating an entirely new function.\nExample:\n```\n#eval Function.comp List.reverse (List.drop 2) [3, 2, 4, 1]\n-- [1, 4]\n```\nYou can use the notation `f ∘ g` as shorthand for `Function.comp f g`.\n```\n#eval (List.reverse ∘ List.drop 2) [3, 2, 4, 1]\n-- [1, 4]\n```\nA simpler way of thinking about it, is that `List.reverse ∘ List.drop 2`\nis equivalent to `fun xs => List.reverse (List.drop 2 xs)`,\nthe benefit is that the meaning of composition is obvious,\nand the representation is compact.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L33-L33","name":"id","kind":"def","docLink":"./Init/Prelude.html#id","doc":"The identity function. `id` takes an implicit argument `α : Sort u`\n(a type in any universe), and an argument `a : α`, and returns `a`.\n\nAlthough this may look like a useless function, one application of the identity\nfunction is to explicitly put a type on an expression. If `e` has type `T`,\nand `T'` is definitionally equal to `T`, then `@id T' e` typechecks, and lean\nknows that this expression has type `T'` rather than `T`. This can make a\ndifference for typeclass inference, since `T` and `T'` may have different\ntypeclass instances on them. `show T' from e` is sugar for an `@id T' e`\nexpression.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1-L1","name":"Lean.MacroScopesView.mk","kind":"ctor","docLink":"./Init/Prelude.html#Lean.MacroScopesView.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1-L1","name":"Lean.Macro.State.mk","kind":"ctor","docLink":"./Init/Prelude.html#Lean.Macro.State.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1-L1","name":"UInt64.mk","kind":"ctor","docLink":"./Init/Prelude.html#UInt64.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1-L1","name":"UInt8.mk","kind":"ctor","docLink":"./Init/Prelude.html#UInt8.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1-L1","name":"Lean.Macro.Methods.mk","kind":"ctor","docLink":"./Init/Prelude.html#Lean.Macro.Methods.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1-L1","name":"Char.mk","kind":"ctor","docLink":"./Init/Prelude.html#Char.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1-L1","name":"String.Pos.mk","kind":"ctor","docLink":"./Init/Prelude.html#String.Pos.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1-L1","name":"UInt16.mk","kind":"ctor","docLink":"./Init/Prelude.html#UInt16.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1-L1","name":"UInt32.mk","kind":"ctor","docLink":"./Init/Prelude.html#UInt32.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1-L1","name":"USize.mk","kind":"ctor","docLink":"./Init/Prelude.html#USize.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1-L1","name":"Lean.Macro.Context.mk","kind":"ctor","docLink":"./Init/Prelude.html#Lean.Macro.Context.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Prelude.lean#L1-L1","name":"Substring.mk","kind":"ctor","docLink":"./Init/Prelude.html#Substring.mk","doc":""}]}