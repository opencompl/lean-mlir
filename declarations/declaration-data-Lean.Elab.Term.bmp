{"name":"Lean.Elab.Term","instances":[{"typeNames":["Lean.Elab.Term.SyntheticMVarKind"],"name":"Lean.Elab.Term.instInhabitedSyntheticMVarKind","className":"Inhabited"},{"typeNames":["Lean.Elab.Term.SyntheticMVarKind"],"name":"Lean.Elab.Term.instToStringSyntheticMVarKind","className":"ToString"},{"typeNames":["Lean.Elab.Term.SyntheticMVarDecl"],"name":"Lean.Elab.Term.instInhabitedSyntheticMVarDecl","className":"Inhabited"},{"typeNames":["Lean.Elab.Term.MVarErrorKind"],"name":"Lean.Elab.Term.instInhabitedMVarErrorKind","className":"Inhabited"},{"typeNames":["Lean.Elab.Term.MVarErrorKind"],"name":"Lean.Elab.Term.instToStringMVarErrorKind","className":"ToString"},{"typeNames":["Lean.Elab.Term.MVarErrorInfo"],"name":"Lean.Elab.Term.instInhabitedMVarErrorInfo","className":"Inhabited"},{"typeNames":["Lean.Elab.Term.LetRecToLift"],"name":"Lean.Elab.Term.instInhabitedLetRecToLift","className":"Inhabited"},{"typeNames":["Lean.Elab.Term.State"],"name":"Lean.Elab.Term.instInhabitedState","className":"Inhabited"},{"typeNames":["Lean.Elab.Tactic.State"],"name":"Lean.Elab.Tactic.instInhabitedState","className":"Inhabited"},{"typeNames":["Lean.Elab.Tactic.CacheKey"],"name":"Lean.Elab.Tactic.instBEqCacheKey","className":"BEq"},{"typeNames":["Lean.Elab.Tactic.CacheKey"],"name":"Lean.Elab.Tactic.instHashableCacheKey","className":"Hashable"},{"typeNames":["Lean.Elab.Tactic.CacheKey"],"name":"Lean.Elab.Tactic.instInhabitedCacheKey","className":"Inhabited"},{"typeNames":["Lean.Elab.Tactic.Cache"],"name":"Lean.Elab.Tactic.instInhabitedCache","className":"Inhabited"},{"typeNames":["Lean.Elab.Term.TermElabM"],"name":"Lean.Elab.Term.instMonadTermElabM","className":"Monad"},{"typeNames":["Lean.Elab.Term.TermElabM"],"name":"Lean.Elab.Term.instInhabitedTermElabM","className":"Inhabited"},{"typeNames":["Lean.Elab.Term.SavedState"],"name":"Lean.Elab.Term.instNonemptySavedState","className":"Nonempty"},{"typeNames":["Lean.Elab.Term.SavedState","Lean.Elab.Term.TermElabM"],"name":"Lean.Elab.Term.instMonadBacktrackSavedStateTermElabM","className":"Lean.MonadBacktrack"},{"typeNames":["Lean.Elab.Term.TermElabM"],"name":"Lean.Elab.Term.instAddErrorMessageContextTermElabM","className":"Lean.AddErrorMessageContext"},{"typeNames":["Lean.Elab.Term.LVal"],"name":"Lean.Elab.Term.instToStringLVal","className":"ToString"},{"typeNames":["Lean.Elab.Term.TermElabM"],"name":"Lean.Elab.Term.instMonadMacroAdapterTermElabM","className":"Lean.Elab.MonadMacroAdapter"},{"typeNames":["Lean.Elab.Term.TermElabM"],"name":"Lean.Elab.Term.instMetaEvalTermElabM","className":"Lean.MetaEval"}],"imports":["Init","Lean.Meta.AppBuilder","Lean.Meta.CollectMVars","Lean.Meta.Coe","Lean.Linter.Deprecated","Lean.Elab.Config","Lean.Elab.Level","Lean.Elab.DeclModifiers"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1714-L1715","name":"Lean.Elab.withoutModifyingStateWithInfoAndMessages","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.withoutModifyingStateWithInfoAndMessages","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1704-L1709","name":"Lean.Elab.Term.exprToSyntax","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.exprToSyntax","doc":"Helper function for \"embedding\" an `Expr` in `Syntax`.\nIt creates a named hole `?m` and immediately assigns `e` to it.\nExamples:\n```lean\nlet e := mkConst ``Nat.zero\n`(Nat.succ $(← exprToSyntax e))\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1689-L1693","name":"Lean.Elab.Term.expandDeclId","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.expandDeclId","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1684-L1687","name":"Lean.Elab.Term.universeConstraintsCheckpoint","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.universeConstraintsCheckpoint","doc":"Execute `x` and then tries to solve pending universe constraints.\nNote that, stuck constraints will not be discarded.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1673-L1678","name":"Lean.Elab.Term.instMetaEvalTermElabM","kind":"instance","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instMetaEvalTermElabM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1666-L1671","name":"Lean.Elab.Term.TermElabM.toIO","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM.toIO","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1663-L1664","name":"Lean.Elab.Term.TermElabM.run'","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM.run'","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1660-L1661","name":"Lean.Elab.Term.TermElabM.run","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM.run","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1645-L1657","name":"Lean.Elab.Term.resolveId?","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.resolveId?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1636-L1643","name":"Lean.Elab.Term.resolveName'","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.resolveName'","doc":"Similar to `resolveName`, but creates identifiers for the main part and each projection with position information derived from `ident`.\nExample: Assume resolveName `v.head.bla.boo` produces `(v.head, [\"bla\", \"boo\"])`, then this method produces\n`(v.head, id, [f₁, f₂])` where `id` is an identifier for `v.head`, and `f₁` and `f₂` are identifiers for fields `\"bla\"` and `\"boo\"`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1622-L1630","name":"Lean.Elab.Term.resolveName.process","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.resolveName.process","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1604-L1630","name":"Lean.Elab.Term.resolveName","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.resolveName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1588-L1595","name":"Lean.Elab.Term.mkConst","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkConst","doc":"Create an `Expr.const` using the given name and explicit levels.\nRemark: fresh universe metavariables are created if the constant has more universe\nparameters than `explicitLevels`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1578-L1582","name":"Lean.Elab.Term.isLetRecAuxMVar","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.isLetRecAuxMVar","doc":"Return true if mvarId is an auxiliary metavariable created for compiling `let rec` or it\nis delayed assigned to one. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1569-L1572","name":"Lean.Elab.Term.mkAuxName","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkAuxName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1562-L1567","name":"Lean.Elab.Term.addAutoBoundImplicits'","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.addAutoBoundImplicits'","doc":"Similar to `autoBoundImplicits`, but immediately if the resulting array of expressions contains metavariables,\nit immediately uses `mkForallFVars` + `forallBoundedTelescope` to convert them into free variables.\nThe type `type` is modified during the process if type depends on `xs`.\nWe use this method to simplify the conversion of code using `autoBoundImplicitsOld` to `autoBoundImplicits`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1542-L1554","name":"Lean.Elab.Term.addAutoBoundImplicits.go","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.addAutoBoundImplicits.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1538-L1554","name":"Lean.Elab.Term.addAutoBoundImplicits","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.addAutoBoundImplicits","doc":"Return `autoBoundImplicits ++ xs`\nThis method throws an error if a variable in `autoBoundImplicits` depends on some `x` in `xs`.\nThe `autoBoundImplicits` may contain free variables created by the auto-implicit feature, and unassigned free variables.\nIt avoids the hack used at `autoBoundImplicitsOld`.\n\nRemark: we cannot simply replace every occurrence of `addAutoBoundImplicitsOld` with this one because a particular\nuse-case may not be able to handle the metavariables in the array being given to `k`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1511-L1527","name":"Lean.Elab.Term.collectUnassignedMVars.go","kind":"opaque","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.collectUnassignedMVars.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1503-L1527","name":"Lean.Elab.Term.collectUnassignedMVars","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.collectUnassignedMVars","doc":"Collect unassigned metavariables in `type` that are not already in `init` and not satisfying `except`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1497-L1498","name":"Lean.Elab.Term.withAutoBoundImplicitForbiddenPred","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withAutoBoundImplicitForbiddenPred","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1494-L1495","name":"Lean.Elab.Term.withoutAutoBoundImplicit","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withoutAutoBoundImplicit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1478-L1489","name":"Lean.Elab.Term.withAutoBoundImplicit.loop","kind":"opaque","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withAutoBoundImplicit.loop","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1474-L1492","name":"Lean.Elab.Term.withAutoBoundImplicit","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withAutoBoundImplicit","doc":"Enable auto-bound implicits, and execute `k` while catching auto bound implicit exceptions. When an exception is caught,\na new local declaration is created, registered, and `k` is tried to be executed again. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1466-L1469","name":"Lean.Elab.Term.elabType","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.elabType","doc":"Elaborate `stx` and ensure result is a type. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1450-L1463","name":"Lean.Elab.Term.ensureType","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.ensureType","doc":"Make sure `e` is a type by inferring its type and making sure it is an `Expr.sort`\nor is unifiable with `Expr.sort`, or can be coerced into one. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1440-L1445","name":"Lean.Elab.Term.mkInstMVar","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkInstMVar","doc":"Create a new metavariable with the given type, and try to synthesize it.\nIf type class resolution cannot be executed (e.g., it is stuck because of metavariables in `type`),\nregister metavariable as a pending one.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1431-L1433","name":"Lean.Elab.Term.adaptExpander","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.adaptExpander","doc":"Adapt a syntax transformation to a regular, term-producing elaborator. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1415-L1428","name":"Lean.Elab.Term.commitIfNoErrors?","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.commitIfNoErrors?","doc":"Execute `x` and return `some` if no new errors were recorded or exceptions were thrown. Otherwise, return `none`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1410-L1412","name":"Lean.Elab.Term.elabTermEnsuringType","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.elabTermEnsuringType","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1407-L1408","name":"Lean.Elab.Term.elabTerm","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.elabTerm","doc":"Main function for elaborating terms.\nIt extracts the elaboration methods from the environment using the node kind.\nRecall that the environment has a mapping from `SyntaxNodeKind` to `TermElab` methods.\nIt creates a fresh macro scope for executing the elaboration method.\nAll unlogged trace messages produced by the elaboration method are logged using\nthe position information at `stx`. If the elaboration method throws an `Exception.error` and `errToSorry == true`,\nthe error is logged and a synthetic sorry expression is returned.\nIf the elaboration throws `Exception.postpone` and `catchExPostpone == true`,\na new synthetic metavariable of kind `SyntheticMVarKind.postponed` is created, registered,\nand returned.\nThe option `catchExPostpone == false` is used to implement `resumeElabTerm`\nto prevent the creation of another synthetic metavariable when resuming the elaboration.\n\nIf `implicitLambda == true`, then disable implicit lambdas feature for the given syntax, but not for its subterms.\nWe use this flag to implement, for example, the `@` modifier. If `Context.implicitLambda == false`, then this parameter has no effect.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1387-L1388","name":"Lean.Elab.Term.addDotCompletionInfo","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.addDotCompletionInfo","doc":"Store in the `InfoTree` that `e` is a \"dot\"-completion target. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1265-L1265","name":"Lean.Elab.Term.UseImplicitLambdaResult.postpone","kind":"ctor","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.UseImplicitLambdaResult.postpone","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1264-L1264","name":"Lean.Elab.Term.UseImplicitLambdaResult.yes","kind":"ctor","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.UseImplicitLambdaResult.yes","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1263-L1263","name":"Lean.Elab.Term.UseImplicitLambdaResult.no","kind":"ctor","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.UseImplicitLambdaResult.no","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1262-L1265","name":"Lean.Elab.Term.UseImplicitLambdaResult","kind":"inductive","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.UseImplicitLambdaResult","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1253-L1260","name":"Lean.Elab.Term.isLocalIdent?","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.isLocalIdent?","doc":"Return true iff `stx` is a `Syntax.ident`, and it is a local variable. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1237-L1249","name":"Lean.Elab.Term.resolveLocalName.loop","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.resolveLocalName.loop","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1186-L1191","name":"Lean.Elab.Term.resolveLocalName.go","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.resolveLocalName.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1102-L1250","name":"Lean.Elab.Term.resolveLocalName","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.resolveLocalName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1096-L1100","name":"Lean.Elab.Term.blockImplicitLambda","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.blockImplicitLambda","doc":"Block usage of implicit lambdas if `stx` is `@f` or `@f arg1 ...` or `fun` with an implicit binder annotation. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1089-L1093","name":"Lean.Elab.Term.mkNoImplicitLambdaAnnotation","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkNoImplicitLambdaAnnotation","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1086-L1087","name":"Lean.Elab.Term.hasNoImplicitLambdaAnnotation","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.hasNoImplicitLambdaAnnotation","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1038-L1041","name":"Lean.Elab.Term.instMonadMacroAdapterTermElabM","kind":"instance","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instMonadMacroAdapterTermElabM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L976-L978","name":"Lean.Elab.Term.postponeElabTerm","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.postponeElabTerm","doc":"Postpone the elaboration of `stx`, return a metavariable that acts as a placeholder, and\nensures the info tree is updated and a hole id is introduced.\nWhen `stx` is elaborated, new info nodes are created and attached to the new hole id in the info tree.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L964-L969","name":"Lean.Elab.Term.withInfoContext'","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withInfoContext'","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L961-L962","name":"Lean.Elab.Term.addTermInfo'","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.addTermInfo'","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L952-L959","name":"Lean.Elab.Term.addTermInfo","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.addTermInfo","doc":"Pushes a new leaf node to the info tree associating the expression `e` to the syntax `stx`.\nAs a result, when the user hovers over `stx` they will see the type of `e`, and if `e`\nis a constant they will see the constant's doc string.\n\n* `expectedType?`: the expected type of `e` at the point of elaboration, if available\n* `lctx?`: the local context in which to interpret `e` (otherwise it will use `← getLCtx`)\n* `elaborator`: a declaration name used as an alternative target for go-to-definition\n* `isBinder`: if true, this will be treated as defining `e` (which should be a local constant)\n  for the purpose of go-to-definition on local variables\n* `force`: In patterns, the effect of `addTermInfo` is usually suppressed and replaced\n  by a `patternWithRef?` annotation which will be turned into a term info on the\n  post-match-elaboration expression. This flag overrides that behavior and adds the term\n  info immediately. (See https://github.com/leanprover/lean4/pull/1664.)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L930-L935","name":"Lean.Elab.Term.mkTermInfo","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkTermInfo","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L921-L928","name":"Lean.Elab.Term.isTacticOrPostponedHole?","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.isTacticOrPostponedHole?","doc":"Return `some mvarId` if `e` corresponds to a hole that is going to be filled \"later\" by executing a tactic or resuming elaboration.\n\nWe do not save `ofTermInfo` for this kind of node in the `InfoTree`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L911-L914","name":"Lean.Elab.Term.removeSaveInfoAnnotation","kind":"opaque","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.removeSaveInfoAnnotation","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L908-L909","name":"Lean.Elab.Term.isSaveInfoAnnotation?","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.isSaveInfoAnnotation?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L902-L906","name":"Lean.Elab.Term.mkSaveInfoAnnotation","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkSaveInfoAnnotation","doc":"Create an auxiliary annotation to make sure we create an `Info` even if `e` is a metavariable.\nSee `mkTermInfo`.\n\nWe use this function because some elaboration functions elaborate subterms that may not be immediately\npart of the resulting term. Example:\n```\nlet_mvar% ?m := b; wait_if_type_mvar% ?m; body\n```\nIf the type of `b` is not known, then `wait_if_type_mvar% ?m; body` is postponed and just returns a fresh\nmetavariable `?n`. The elaborator for\n```\nlet_mvar% ?m := b; wait_if_type_mvar% ?m; body\n```\nreturns `mkSaveInfoAnnotation ?n` to make sure the info nodes created when elaborating `b` are \"saved\".\nThis is a bit hackish, but elaborators like `let_mvar%` are rare.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L882-L883","name":"Lean.Elab.Term.getSyntheticMVarDecl?","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.getSyntheticMVarDecl?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L866-L869","name":"Lean.Elab.Term.withSavedContext","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withSavedContext","doc":"Execute `x` with the context saved using `saveContext`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L853-L861","name":"Lean.Elab.Term.saveContext","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.saveContext","doc":"Save relevant context for term elaboration postponement.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L845-L848","name":"Lean.Elab.Term.tryPostponeIfHasMVars","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.tryPostponeIfHasMVars","doc":"Throws `Exception.postpone`, if `expectedType?` contains unassigned metavariables.\nIf `mayPostpone == false`, it throws error `msg`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L832-L839","name":"Lean.Elab.Term.tryPostponeIfHasMVars?","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.tryPostponeIfHasMVars?","doc":"Throws `Exception.postpone`, if `expectedType?` contains unassigned metavariables.\nIt is a noop if `mayPostpone == false`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L823-L826","name":"Lean.Elab.Term.tryPostponeIfNoneOrMVar","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.tryPostponeIfNoneOrMVar","doc":"If `e? = some e`, then `tryPostponeIfMVar e`, otherwise it is just `tryPostpone`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L818-L820","name":"Lean.Elab.Term.tryPostponeIfMVar","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.tryPostponeIfMVar","doc":"If `mayPostpone == true` and `e`'s head is a metavariable, throw `Exception.postpone`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L814-L815","name":"Lean.Elab.Term.isMVarApp","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.isMVarApp","doc":"Return `true` if `e` reduces (by unfolding only `[reducible]` declarations) to `?m ...` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L809-L811","name":"Lean.Elab.Term.tryPostpone","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.tryPostpone","doc":"If `mayPostpone == true`, throw `Expection.postpone`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L803-L806","name":"Lean.Elab.Term.exceptionToSorry","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.exceptionToSorry","doc":"Log the given exception, and create a synthetic sorry for representing the failed\nelaboration step with exception `ex`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L781-L787","name":"Lean.Elab.Term.ensureHasType","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.ensureHasType","doc":"If `expectedType?` is `some t`, then ensure `t` and `eType` are definitionally equal.\nIf they are not, then try coercions.\n\nArgument `f?` is used only for generating error messages. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L761-L774","name":"Lean.Elab.Term.mkCoe","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkCoe","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L715-L759","name":"Lean.Elab.Term.synthesizeInstMVarCore","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.synthesizeInstMVarCore","doc":"Try to synthesize metavariable using type class resolution.\nThis method assumes the local context and local instances of `instMVar` coincide\nwith the current local context and local instances.\nReturn `true` if the instance was synthesized successfully, and `false` if\nthe instance contains unassigned metavariables that are blocking the type class\nresolution procedure. Throw an exception if resolution or assignment irrevocably fails.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L702-L705","name":"Lean.Elab.Term.containsPendingMVar","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.containsPendingMVar","doc":"Return `true` if `e` contains a pending metavariable. Remark: it also visits let-declarations. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L676-L697","name":"Lean.Elab.Term.ContainsPendingMVar.visit","kind":"opaque","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.ContainsPendingMVar.visit","doc":"See `containsPostponedTerm` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L673-L673","name":"Lean.Elab.Term.ContainsPendingMVar.M","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.ContainsPendingMVar.M","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L668-L669","name":"Lean.Elab.Term.withoutMacroStackAtErr","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withoutMacroStackAtErr","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L647-L666","name":"Lean.Elab.Term.throwTypeMismatchError","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.throwTypeMismatchError","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L641-L645","name":"Lean.Elab.Term.mkTypeMismatchError","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkTypeMismatchError","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L638-L639","name":"Lean.Elab.Term.applyAttributes","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.applyAttributes","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L635-L636","name":"Lean.Elab.Term.applyAttributesAt","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.applyAttributesAt","doc":"Apply given attributes **at** a given application time "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L603-L604","name":"Lean.Elab.Term.mkFreshIdent","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkFreshIdent","doc":"Auxiliary method for creating a `Syntax.ident` containing\na fresh name. This method is intended for creating fresh binder names.\nIt is just a thin layer on top of `mkFreshUserName`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L596-L597","name":"Lean.Elab.Term.mkFreshBinderName","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkFreshBinderName","doc":"Auxiliary method for creating fresh binder names.\nDo not confuse with the method for creating fresh free/meta variable ids. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L586-L591","name":"Lean.Elab.Term.levelMVarToParam","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.levelMVarToParam","doc":"Convert unassigned universe level metavariables into parameters.\nThe new parameter names are fresh names of the form `u_i` with regard to `ctx.levelNames`, which is updated with the new names. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L580-L581","name":"Lean.Elab.Term.mkExplicitBinder","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkExplicitBinder","doc":"Creates syntax for `(` <ident> `:` <type> `)` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L576-L577","name":"Lean.Elab.Term.withoutPostponing","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withoutPostponing","doc":"Execute `x` without allowing it to postpone elaboration tasks.\nThat is, `tryPostpone` is a noop. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L568-L571","name":"Lean.Elab.Term.ensureNoUnassignedMVars","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.ensureNoUnassignedMVars","doc":"Ensure metavariables registered using `registerMVarErrorInfos` (and used in the given declaration) have been assigned. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L541-L565","name":"Lean.Elab.Term.logUnassignedUsingErrorInfos","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.logUnassignedUsingErrorInfos","doc":"Try to log errors for the unassigned metavariables `pendingMVarIds`.\n\nReturn `true` if there were \"unfilled holes\", and we should \"abort\" declaration.\nTODO: try to fill \"all\" holes using synthetic \"sorry's\"\n\nRemark: We only log the \"unfilled holes\" as new errors if no error has been logged so far. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L529-L532","name":"Lean.Elab.Term.MVarErrorInfo.logError.appendExtra","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.MVarErrorInfo.logError.appendExtra","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L524-L527","name":"Lean.Elab.Term.MVarErrorInfo.logError.addArgName","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.MVarErrorInfo.logError.addArgName","doc":"Append `mvarErrorInfo` argument name (if available) to the message.\nRemark: if the argument name contains macro scopes we do not append it. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L508-L532","name":"Lean.Elab.Term.MVarErrorInfo.logError","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.MVarErrorInfo.logError","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L502-L506","name":"Lean.Elab.Term.throwMVarError","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.throwMVarError","doc":"Auxiliary method for reporting errors of the form \"... contains metavariables ...\".\nThis kind of error is thrown, for example, at `Match.lean` where elaboration\ncannot continue if there are metavariables in patterns.\nWe only want to log it if we haven't logged any errors so far. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L492-L495","name":"Lean.Elab.Term.registerCustomErrorIfMVar","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.registerCustomErrorIfMVar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L489-L490","name":"Lean.Elab.Term.getMVarErrorInfo?","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.getMVarErrorInfo?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L486-L487","name":"Lean.Elab.Term.registerMVarErrorCustomInfo","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.registerMVarErrorCustomInfo","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L483-L484","name":"Lean.Elab.Term.registerMVarErrorImplicitArgInfo","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.registerMVarErrorImplicitArgInfo","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L480-L481","name":"Lean.Elab.Term.registerMVarErrorHoleInfo","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.registerMVarErrorHoleInfo","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L477-L478","name":"Lean.Elab.Term.registerMVarErrorInfo","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.registerMVarErrorInfo","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L474-L475","name":"Lean.Elab.Term.registerSyntheticMVarWithCurrRef","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.registerSyntheticMVarWithCurrRef","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L471-L472","name":"Lean.Elab.Term.registerSyntheticMVar","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.registerSyntheticMVar","doc":"Add the given metavariable to the list of pending synthetic metavariables.\nThe method `synthesizeSyntheticMVars` is used to process the metavariables on this list. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L464-L466","name":"Lean.Elab.Term.withMacroExpansion","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withMacroExpansion","doc":"Elaborate `x` with `stx` on the macro stack and produce macro expansion info "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L460-L461","name":"Lean.Elab.Term.withPushMacroExpansionStack","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withPushMacroExpansionStack","doc":"Elaborate `x` with `stx` on the macro stack "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L456-L457","name":"Lean.Elab.Term.elabLevel","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.elabLevel","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L447-L454","name":"Lean.Elab.Term.liftLevelM","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.liftLevelM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L442-L443","name":"Lean.Elab.Term.ppGoal","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.ppGoal","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L439-L440","name":"Lean.Elab.Term.traceAtCmdPos","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.traceAtCmdPos","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L435-L437","name":"Lean.Elab.Term.throwErrorIfErrors","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.throwErrorIfErrors","doc":"For testing `TermElabM` methods. The #eval command will sign the error. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L431-L432","name":"Lean.Elab.Term.withoutErrToSorry","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withoutErrToSorry","doc":"Execute `x` without converting errors (i.e., exceptions) to `sorry` applications.\nRecall that when `errToSorry = true`, the method `elabTerm` catches exceptions and converts them into `sorry` applications.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L424-L425","name":"Lean.Elab.Term.withoutErrToSorryImp","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withoutErrToSorryImp","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L419-L422","name":"Lean.Elab.Term.withAuxDecl","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withAuxDecl","doc":"Declare an auxiliary local declaration `shortDeclName : type` for elaborating recursive declaration `declName`,\nupdate the mapping `auxDeclToFullName`, and then execute `k`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L410-L413","name":"Lean.Elab.Term.withLevelNames","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withLevelNames","doc":"Execute `x` using `levelNames` as the universe level parameter names. See `getLevelNames`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L406-L407","name":"Lean.Elab.Term.setLevelNames","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.setLevelNames","doc":"Update the universe level parameter names. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L402-L403","name":"Lean.Elab.Term.withDeclName","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withDeclName","doc":"Execute `x` with `declName? := name`. See `getDeclName?`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L399-L399","name":"Lean.Elab.Term.getMVarDecl","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.getMVarDecl","doc":"Return the declaration of the given metavariable "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L397-L397","name":"Lean.Elab.Term.getLetRecsToLift","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.getLetRecsToLift","doc":"Return the list of nested `let rec` declarations that need to be lifted. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L395-L395","name":"Lean.Elab.Term.getDeclName?","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.getDeclName?","doc":"Return the name of the declaration being elaborated if available. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L389-L392","name":"Lean.Elab.Term.instToStringLVal","kind":"instance","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instToStringLVal","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L385-L387","name":"Lean.Elab.Term.LVal.isFieldName","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.LVal.isFieldName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L381-L383","name":"Lean.Elab.Term.LVal.getRef","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.LVal.getRef","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L377-L379","name":"Lean.Elab.Term.LVal.fieldName","kind":"ctor","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.LVal.fieldName","doc":"Field `suffix?` is for producing better error messages because `x.y` may be a field access or a hierarchical/composite name.\n`ref` is the syntax object representing the field. `targetStx` is the target object being accessed. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L376-L376","name":"Lean.Elab.Term.LVal.fieldIdx","kind":"ctor","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.LVal.fieldIdx","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L375-L379","name":"Lean.Elab.Term.LVal","kind":"inductive","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.LVal","doc":"Auxiliary datatype for presenting a Lean lvalue modifier.\nWe represent an unelaborated lvalue as a `Syntax` (or `Expr`) and `List LVal`.\nExample: `a.foo.1` is represented as the `Syntax` `a` and the list\n`[LVal.fieldName \"foo\", LVal.fieldIdx 1]`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L367-L367","name":"Lean.Elab.Term.termElabAttribute","kind":"opaque","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.termElabAttribute","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L365-L365","name":"Lean.Elab.Term.mkTermElabAttribute","kind":"opaque","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkTermElabAttribute","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L361-L362","name":"Lean.Elab.Term.mkTermElabAttributeUnsafe","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkTermElabAttributeUnsafe","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L358-L359","name":"Lean.Elab.Term.withoutSavingRecAppSyntax","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withoutSavingRecAppSyntax","doc":"Execute `x` without storing `Syntax` for recursive applications. See `saveRecAppSyntax` field at `Context`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L335-L342","name":"Lean.Elab.Term.withoutModifyingElabMetaStateWithInfo","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withoutModifyingElabMetaStateWithInfo","doc":"Execute `x` but discard changes performed at `Term.State` and `Meta.State`.\nRecall that the `Environment` and `InfoState` are at `Core.State`. Thus, any updates to it will\nbe preserved. This method is useful for performing computations where all\nmetavariable must be resolved or discarded.\nThe `InfoTree`s are not discarded, however, and wrapped in `InfoTree.Context`\nto store their metavariable context. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L320-L326","name":"Lean.Elab.Term.instAddErrorMessageContextTermElabM","kind":"instance","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instAddErrorMessageContextTermElabM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L315-L318","name":"Lean.Elab.Term.getFVarLocalDecl!","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.getFVarLocalDecl!","doc":"Given a free variable `fvar`, return its declaration.\nThis function panics if `fvar` is not a free variable.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L308-L309","name":"Lean.Elab.Term.getLevelNames","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.getLevelNames","doc":"Return the universe level names explicitly provided by the user.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L300-L303","name":"Lean.Elab.Term.commitIfDidNotPostpone","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.commitIfDidNotPostpone","doc":"Execute `x`, but keep state modifications only if `x` did not postpone.\nThis method is useful to implement elaboration functions that cannot decide whether\nthey need to postpone or not without updating the state. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L291-L294","name":"Lean.Elab.Term.applyResult","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.applyResult","doc":"Apply the result/exception and state captured with `observing`.\nWe use this method to implement overloaded notation and symbols. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L271-L286","name":"Lean.Elab.Term.observing","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.observing","doc":"Execute `x`, save resulting expression and new state.\nWe remove any `Info` created by `x`.\nThe info nodes are committed when we execute `applyResult`.\nWe use `observing` to implement overloaded notation and decls.\nWe want to save `Info` nodes for the chosen alternative.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L262-L262","name":"Lean.Elab.Term.TermElabResult","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabResult","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L258-L260","name":"Lean.Elab.Term.instMonadBacktrackSavedStateTermElabM","kind":"instance","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instMonadBacktrackSavedStateTermElabM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L249-L256","name":"Lean.Elab.Term.SavedState.restore","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.SavedState.restore","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L246-L247","name":"Lean.Elab.Term.saveState","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.saveState","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L244-L244","name":"Lean.Elab.Term.instNonemptySavedState","kind":"instance","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instNonemptySavedState","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L243-L243","name":"Lean.Elab.Term.SavedState.elab","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.SavedState.elab","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L242-L242","name":"Lean.Elab.Term.SavedState.meta","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.SavedState.meta","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L241-L244","name":"Lean.Elab.Term.SavedState","kind":"structure","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.SavedState","doc":"Backtrackable state for the `TermElabM` monad.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L235-L236","name":"Lean.Elab.Term.instInhabitedTermElabM","kind":"instance","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instInhabitedTermElabM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L229-L231","name":"Lean.Elab.Term.instMonadTermElabM","kind":"instance","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instMonadTermElabM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L222-L222","name":"Lean.Elab.Term.TermElab","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.TermElab","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L221-L221","name":"Lean.Elab.Term.TermElabM","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L219-L219","name":"Lean.Elab.Term.Context.holesAsSyntheticOpaque","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.Context.holesAsSyntheticOpaque","doc":"If `holesAsSyntheticOpaque` is `true`, then we mark metavariables associated\nwith `_`s as `synthethicOpaque` if they do not occur in patterns.\nThis option is useful when elaborating terms in tactics such as `refine'` where\nwe want holes there to become new goals. See issue #1681, we have\n`refine' (fun x => _)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L211-L211","name":"Lean.Elab.Term.Context.saveRecAppSyntax","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.Context.saveRecAppSyntax","doc":"If `true`, we store in the `Expr` the `Syntax` for recursive applications (i.e., applications\nof free variables tagged with `isAuxDecl`). We store the `Syntax` using `mkRecAppWithSyntax`.\nWe use the `Syntax` object to produce better error messages at `Structural.lean` and `WF.lean`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L206-L206","name":"Lean.Elab.Term.Context.tacticCache?","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.Context.tacticCache?","doc":"Cache for the `save` tactic. It is only `some` in the LSP server. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L204-L204","name":"Lean.Elab.Term.Context.inPattern","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.Context.inPattern","doc":"`true` when elaborating patterns. It affects how we elaborate named holes. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L202-L202","name":"Lean.Elab.Term.Context.ignoreTCFailures","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.Context.ignoreTCFailures","doc":"When `true` we skip TC failures. We use this option when processing patterns. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L200-L200","name":"Lean.Elab.Term.Context.isNoncomputableSection","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.Context.isNoncomputableSection","doc":"Noncomputable sections automatically add the `noncomputable` modifier to any declaration we cannot generate code for. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L198-L198","name":"Lean.Elab.Term.Context.implicitLambda","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.Context.implicitLambda","doc":"Enable/disable implicit lambdas feature. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L196-L196","name":"Lean.Elab.Term.Context.sectionFVars","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.Context.sectionFVars","doc":"Map from internal name to fvar "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L194-L194","name":"Lean.Elab.Term.Context.sectionVars","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.Context.sectionVars","doc":"Map from user name to internal unique name "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L192-L192","name":"Lean.Elab.Term.Context.autoBoundImplicitForbidden","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.Context.autoBoundImplicitForbidden","doc":"A name `n` is only eligible to be an auto implicit name if `autoBoundImplicitForbidden n = false`.\nWe use this predicate to disallow `f` to be considered an auto implicit name in a definition such\nas\n```\ndef f : f → Bool := fun _ => true\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L183-L183","name":"Lean.Elab.Term.Context.autoBoundImplicits","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.Context.autoBoundImplicits","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L182-L182","name":"Lean.Elab.Term.Context.autoBoundImplicit","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.Context.autoBoundImplicit","doc":"When `autoBoundImplicit` is set to true, instead of producing\nan \"unknown identifier\" error for unbound variables, we generate an\ninternal exception. This exception is caught at `elabBinders` and\n`elabTypeWithUnboldImplicit`. Both methods add implicit declarations\nfor the unbound variable and try again. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L175-L175","name":"Lean.Elab.Term.Context.errToSorry","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.Context.errToSorry","doc":"When `errToSorry` is set to true, the method `elabTerm` catches\nexceptions and converts them into synthetic `sorry`s.\nThe implementation of choice nodes and overloaded symbols rely on the fact\nthat when `errToSorry` is set to false for an elaboration function `F`, then\n`errToSorry` remains `false` for all elaboration functions invoked by `F`.\nThat is, it is safe to transition `errToSorry` from `true` to `false`, but\nwe must not set `errToSorry` to `true` when it is currently set to `false`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L166-L166","name":"Lean.Elab.Term.Context.mayPostpone","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.Context.mayPostpone","doc":"When `mayPostpone == true`, an elaboration function may interrupt its execution by throwing `Exception.postpone`.\nThe function `elabTerm` catches this exception and creates fresh synthetic metavariable `?m`, stores `?m` in\nthe list of pending synthetic metavariables, and returns `?m`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L161-L161","name":"Lean.Elab.Term.Context.macroStack","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.Context.macroStack","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L160-L160","name":"Lean.Elab.Term.Context.auxDeclToFullName","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.Context.auxDeclToFullName","doc":"Map `.auxDecl` local declarations used to encode recursive declarations to their full-names.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L156-L156","name":"Lean.Elab.Term.Context.declName?","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.Context.declName?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L155-L219","name":"Lean.Elab.Term.Context","kind":"structure","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.Context","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L149-L149","name":"Lean.Elab.Tactic.instInhabitedCache","kind":"instance","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.instInhabitedCache","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L148-L148","name":"Lean.Elab.Tactic.Cache.post","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.Cache.post","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L147-L147","name":"Lean.Elab.Tactic.Cache.pre","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.Cache.pre","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L146-L149","name":"Lean.Elab.Tactic.Cache","kind":"structure","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.Cache","doc":"Cache for the `save` tactic.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L141-L141","name":"Lean.Elab.Tactic.instInhabitedCacheKey","kind":"instance","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.instInhabitedCacheKey","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L141-L141","name":"Lean.Elab.Tactic.instHashableCacheKey","kind":"instance","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.instHashableCacheKey","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L141-L141","name":"Lean.Elab.Tactic.instBEqCacheKey","kind":"instance","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.instBEqCacheKey","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L140-L140","name":"Lean.Elab.Tactic.CacheKey.pos","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.CacheKey.pos","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L139-L139","name":"Lean.Elab.Tactic.CacheKey.mvarId","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.CacheKey.mvarId","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L138-L141","name":"Lean.Elab.Tactic.CacheKey","kind":"structure","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.CacheKey","doc":"Key for the cache used to implement the `save` tactic.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L133-L133","name":"Lean.Elab.Tactic.Snapshot.stx","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.Snapshot.stx","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L132-L132","name":"Lean.Elab.Tactic.Snapshot.tactic","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.Snapshot.tactic","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L131-L131","name":"Lean.Elab.Tactic.Snapshot.term","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.Snapshot.term","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L130-L130","name":"Lean.Elab.Tactic.Snapshot.meta","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.Snapshot.meta","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L129-L129","name":"Lean.Elab.Tactic.Snapshot.core","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.Snapshot.core","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L128-L133","name":"Lean.Elab.Tactic.Snapshot","kind":"structure","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.Snapshot","doc":"Snapshots are used to implement the `save` tactic.\nThis tactic caches the state of the system, and allows us to \"replay\"\nexpensive proofs efficiently. This is only relevant implementing the\nLSP server.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L120-L120","name":"Lean.Elab.Tactic.instInhabitedState","kind":"instance","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.instInhabitedState","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L119-L119","name":"Lean.Elab.Tactic.State.goals","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.State.goals","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L118-L120","name":"Lean.Elab.Tactic.State","kind":"structure","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.State","doc":"State of the `TacticM` monad.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L109-L109","name":"Lean.Elab.Term.instInhabitedState","kind":"instance","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instInhabitedState","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L108-L108","name":"Lean.Elab.Term.State.letRecsToLift","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.State.letRecsToLift","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L107-L107","name":"Lean.Elab.Term.State.mvarErrorInfos","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.State.mvarErrorInfos","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L106-L106","name":"Lean.Elab.Term.State.pendingMVars","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.State.pendingMVars","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L105-L105","name":"Lean.Elab.Term.State.syntheticMVars","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.State.syntheticMVars","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L104-L104","name":"Lean.Elab.Term.State.levelNames","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.State.levelNames","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L103-L109","name":"Lean.Elab.Term.State","kind":"structure","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.State","doc":"State of the `TermElabM` monad.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L98-L98","name":"Lean.Elab.Term.instInhabitedLetRecToLift","kind":"instance","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instInhabitedLetRecToLift","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L97-L97","name":"Lean.Elab.Term.LetRecToLift.mvarId","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.LetRecToLift.mvarId","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L96-L96","name":"Lean.Elab.Term.LetRecToLift.val","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.LetRecToLift.val","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L95-L95","name":"Lean.Elab.Term.LetRecToLift.type","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.LetRecToLift.type","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L94-L94","name":"Lean.Elab.Term.LetRecToLift.localInstances","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.LetRecToLift.localInstances","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L93-L93","name":"Lean.Elab.Term.LetRecToLift.lctx","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.LetRecToLift.lctx","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L92-L92","name":"Lean.Elab.Term.LetRecToLift.declName","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.LetRecToLift.declName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L91-L91","name":"Lean.Elab.Term.LetRecToLift.shortDeclName","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.LetRecToLift.shortDeclName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L90-L90","name":"Lean.Elab.Term.LetRecToLift.attrs","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.LetRecToLift.attrs","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L89-L89","name":"Lean.Elab.Term.LetRecToLift.fvarId","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.LetRecToLift.fvarId","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L88-L88","name":"Lean.Elab.Term.LetRecToLift.ref","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.LetRecToLift.ref","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L87-L98","name":"Lean.Elab.Term.LetRecToLift","kind":"structure","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.LetRecToLift","doc":"Nested `let rec` expressions are eagerly lifted by the elaborator.\nWe store the information necessary for performing the lifting here.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L81-L81","name":"Lean.Elab.Term.instInhabitedMVarErrorInfo","kind":"instance","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instInhabitedMVarErrorInfo","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L80-L80","name":"Lean.Elab.Term.MVarErrorInfo.argName?","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.MVarErrorInfo.argName?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L79-L79","name":"Lean.Elab.Term.MVarErrorInfo.kind","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.MVarErrorInfo.kind","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L78-L78","name":"Lean.Elab.Term.MVarErrorInfo.ref","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.MVarErrorInfo.ref","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L77-L77","name":"Lean.Elab.Term.MVarErrorInfo.mvarId","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.MVarErrorInfo.mvarId","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L76-L81","name":"Lean.Elab.Term.MVarErrorInfo","kind":"structure","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.MVarErrorInfo","doc":"We can optionally associate an error context with metavariables.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L67-L71","name":"Lean.Elab.Term.instToStringMVarErrorKind","kind":"instance","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instToStringMVarErrorKind","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L65-L65","name":"Lean.Elab.Term.instInhabitedMVarErrorKind","kind":"instance","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instInhabitedMVarErrorKind","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L63-L64","name":"Lean.Elab.Term.MVarErrorKind.custom","kind":"ctor","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.MVarErrorKind.custom","doc":"\"Custom\", `msgData` stores the additional error messages. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L61-L62","name":"Lean.Elab.Term.MVarErrorKind.hole","kind":"ctor","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.MVarErrorKind.hole","doc":"Metavariable for explicit holes provided by the user (e.g., `_` and `?m`) "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L59-L60","name":"Lean.Elab.Term.MVarErrorKind.implicitArg","kind":"ctor","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.MVarErrorKind.implicitArg","doc":"Metavariable for implicit arguments. `ctx` is the parent application. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L58-L65","name":"Lean.Elab.Term.MVarErrorKind","kind":"inductive","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.MVarErrorKind","doc":"We can optionally associate an error context with a metavariable (see `MVarErrorInfo`).\nWe have three different kinds of error context.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L52-L52","name":"Lean.Elab.Term.instInhabitedSyntheticMVarDecl","kind":"instance","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instInhabitedSyntheticMVarDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L51-L51","name":"Lean.Elab.Term.SyntheticMVarDecl.kind","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.SyntheticMVarDecl.kind","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L50-L50","name":"Lean.Elab.Term.SyntheticMVarDecl.stx","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.SyntheticMVarDecl.stx","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L49-L52","name":"Lean.Elab.Term.SyntheticMVarDecl","kind":"structure","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.SyntheticMVarDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L42-L47","name":"Lean.Elab.Term.instToStringSyntheticMVarKind","kind":"instance","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instToStringSyntheticMVarKind","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L40-L40","name":"Lean.Elab.Term.instInhabitedSyntheticMVarKind","kind":"instance","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instInhabitedSyntheticMVarKind","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L38-L39","name":"Lean.Elab.Term.SyntheticMVarKind.postponed","kind":"ctor","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.SyntheticMVarKind.postponed","doc":"Metavariable represents a hole whose elaboration has been postponed. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L36-L37","name":"Lean.Elab.Term.SyntheticMVarKind.tactic","kind":"ctor","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.SyntheticMVarKind.tactic","doc":"Use tactic to synthesize value for metavariable. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L31-L35","name":"Lean.Elab.Term.SyntheticMVarKind.coe","kind":"ctor","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.SyntheticMVarKind.coe","doc":"Use coercion to synthesize value for the metavariable.\nif `f?` is `some f`, we produce an application type mismatch error message.\nOtherwise, if `header?` is `some header`, we generate the error `(header ++ \"has type\" ++ eType ++ \"but it is expected to have type\" ++ expectedType)`\nOtherwise, we generate the error `(\"type mismatch\" ++ e ++ \"has type\" ++ eType ++ \"but it is expected to have type\" ++ expectedType)` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L29-L30","name":"Lean.Elab.Term.SyntheticMVarKind.typeClass","kind":"ctor","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.SyntheticMVarKind.typeClass","doc":"Use typeclass resolution to synthesize value for metavariable. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L28-L40","name":"Lean.Elab.Term.SyntheticMVarKind","kind":"inductive","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.SyntheticMVarKind","doc":"We use synthetic metavariables as placeholders for pending elaboration steps. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L25-L25","name":"Lean.Elab.Term.SavedContext.levelNames","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.SavedContext.levelNames","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L24-L24","name":"Lean.Elab.Term.SavedContext.errToSorry","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.SavedContext.errToSorry","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L23-L23","name":"Lean.Elab.Term.SavedContext.macroStack","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.SavedContext.macroStack","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L22-L22","name":"Lean.Elab.Term.SavedContext.openDecls","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.SavedContext.openDecls","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L21-L21","name":"Lean.Elab.Term.SavedContext.options","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.SavedContext.options","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L20-L20","name":"Lean.Elab.Term.SavedContext.declName?","kind":"def","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.SavedContext.declName?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L19-L25","name":"Lean.Elab.Term.SavedContext","kind":"structure","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.SavedContext","doc":"Saved context for postponed terms and tactics to be executed. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1-L1","name":"Lean.Elab.Term.State.mk","kind":"ctor","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.State.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1-L1","name":"Lean.Elab.Tactic.Snapshot.mk","kind":"ctor","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.Snapshot.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1-L1","name":"Lean.Elab.Term.MVarErrorInfo.mk","kind":"ctor","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.MVarErrorInfo.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1-L1","name":"Lean.Elab.Tactic.CacheKey.mk","kind":"ctor","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.CacheKey.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1-L1","name":"Lean.Elab.Term.SyntheticMVarDecl.mk","kind":"ctor","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.SyntheticMVarDecl.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1-L1","name":"Lean.Elab.Term.SavedContext.mk","kind":"ctor","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.SavedContext.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1-L1","name":"Lean.Elab.Tactic.State.mk","kind":"ctor","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.State.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1-L1","name":"Lean.Elab.Term.Context.mk","kind":"ctor","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.Context.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1-L1","name":"Lean.Elab.Term.LetRecToLift.mk","kind":"ctor","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.LetRecToLift.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1-L1","name":"Lean.Elab.Term.SavedState.mk","kind":"ctor","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.SavedState.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Lean/Elab/Term.lean#L1-L1","name":"Lean.Elab.Tactic.Cache.mk","kind":"ctor","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.Cache.mk","doc":""}]}