{"name":"Lean.Parser.Term","instances":[{"typeNames":["Lean.TSyntax","List.cons","Lean.SyntaxNodeKind","Lean.Name.mkStr4","List.nil","Lean.TSyntax","List.cons","Lean.SyntaxNodeKind","Lean.Name.mkStr4","List.nil"],"name":"Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil","className":"Coe"},{"typeNames":["Lean.TSyntax","List.cons","Lean.SyntaxNodeKind","Lean.Name.mkStr4","List.nil","Lean.TSyntax","List.cons","Lean.SyntaxNodeKind","Lean.Name.mkStr4","List.nil"],"name":"Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_1","className":"Coe"}],"imports":["Init","Lean.Parser.Attr","Lean.Parser.Level"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L683-L684","name":"Lean.Parser.Tactic.quotSeq","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.quotSeq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L681-L682","name":"Lean.Parser.Tactic.quot","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.quot","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L676-L677","name":"Lean.Parser.Term.dotIdent","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.dotIdent","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L673-L674","name":"Lean.Parser.Term.dynamicQuot","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.dynamicQuot","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L670-L671","name":"Lean.Parser.Term.stateRefT","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.stateRefT","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L667-L667","name":"Lean.Parser.Term.macroLastArg","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.macroLastArg","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L666-L666","name":"Lean.Parser.Term.macroDollarArg","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.macroDollarArg","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L665-L665","name":"Lean.Parser.Term.macroArg","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.macroArg","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L661-L662","name":"Lean.Parser.Term.assert","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.assert","doc":"`assert! cond` panics if `cond` evaluates to `false`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L657-L659","name":"Lean.Parser.Term.dbgTrace","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.dbgTrace","doc":"`dbg_trace e; body` evaluates to `body` and prints `e` (which can be an\ninterpolated string literal) to stderr. It should only be used for debugging.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L651-L652","name":"Lean.Parser.Term.unreachable","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.unreachable","doc":"A shorthand for `panic! \"unreachable code has been reached\"`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L648-L649","name":"Lean.Parser.Term.panic","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.panic","doc":"`panic! msg` formally evaluates to `@Inhabited.default α` if the expected type\n`α` implements `Inhabited`.\nAt runtime, `msg` and the file position are printed to stderr unless the C\nfunction `lean_set_panic_messages(false)` has been executed before. If the C\nfunction `lean_set_exit_on_panic(true)` has been executed before, the process is\nthen aborted.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L638-L638","name":"Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_1","kind":"instance","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_1","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L637-L637","name":"Lean.Parser.Term.bracketedBinderF","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinderF","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L634-L635","name":"Lean.Parser.Term.subst","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.subst","doc":"`h ▸ e` is a macro built on top of `Eq.rec` and `Eq.symm` definitions.\nGiven `h : a = b` and `e : p a`, the term `h ▸ e` has type `p b`.\nYou can also view `h ▸ e` as a \"type casting\" operation\nwhere you change the type of `e` by using `h`.\nSee the Chapter \"Quantifiers and Equality\" in the manual\n\"Theorem Proving in Lean\" for additional information.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L623-L624","name":"Lean.Parser.Term.pipeCompletion","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.pipeCompletion","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L621-L622","name":"Lean.Parser.Term.pipeProj","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.pipeProj","doc":"`e |>.x` is a shorthand for `(e).x`.\nIt is especially useful for avoiding parentheses with repeated applications.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L612-L615","name":"Lean.Parser.Term.namedPattern","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.namedPattern","doc":"`x@e` matches the pattern `e` and binds its value to the identifier `x`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L607-L610","name":"Lean.Parser.Term.explicitUniv","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.explicitUniv","doc":"`x.{u, ...}` explicitly specifies the universes `u, ...` of the constant `x`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L602-L604","name":"Lean.Parser.Term.isIdent","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.isIdent","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L599-L600","name":"Lean.Parser.Term.arrow","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.arrow","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L597-L598","name":"Lean.Parser.Term.completion","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.completion","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L595-L596","name":"Lean.Parser.Term.proj","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.proj","doc":"The *extended field notation* `e.f` is roughly short for `T.f e` where `T` is the type of `e`.\nMore precisely,\n* if `e` is of a function type, `e.f` is translated to `Function.f (p := e)`\n  where `p` is the first explicit parameter of function type\n* if `e` is of a named type `T ...` and there is a declaration `T.f` (possibly from `export`),\n  `e.f` is translated to `T.f (p := e)` where `p` is the first explicit parameter of type `T ...`\n* otherwise, if `e` is of a structure type,\n  the above is repeated for every base type of the structure.\n\nThe field index notation `e.i`, where `i` is a positive number,\nis short for accessing the `i`-th field (1-indexed) of `e` if it is of a structure type. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L581-L581","name":"Lean.Parser.Term.app","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.app","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L574-L577","name":"Lean.Parser.Term.argument","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.argument","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L572-L573","name":"Lean.Parser.Term.ellipsis","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.ellipsis","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L570-L571","name":"Lean.Parser.Term.namedArgument","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.namedArgument","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L567-L568","name":"Lean.Parser.Term.noErrorIfUnused","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.noErrorIfUnused","doc":"Helper parser for marking `match`-alternatives that should not trigger errors if unused.\nWe use them to implement `macro_rules` and `elab_rules`\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L560-L561","name":"Lean.Parser.Term.defaultOrOfNonempty","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.defaultOrOfNonempty","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L557-L558","name":"Lean.Parser.Term.waitIfContainsMVar","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfContainsMVar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L555-L556","name":"Lean.Parser.Term.waitIfTypeContainsMVar","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfTypeContainsMVar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L553-L554","name":"Lean.Parser.Term.waitIfTypeMVar","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfTypeMVar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L551-L552","name":"Lean.Parser.Term.letMVar","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letMVar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L548-L549","name":"Lean.Parser.Term.clear","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.clear","doc":"`clear% x; e` elaborates `x` after clearing the free variable `x` from the local context.\nIf `x` cannot be cleared (due to dependencies), it will keep `x` without failing.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L541-L542","name":"Lean.Parser.Term.noImplicitLambda","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.noImplicitLambda","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L539-L540","name":"Lean.Parser.Term.ensureExpectedType","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.ensureExpectedType","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L537-L538","name":"Lean.Parser.Term.ensureTypeOf","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.ensureTypeOf","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L535-L536","name":"Lean.Parser.Term.typeOf","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.typeOf","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L533-L534","name":"Lean.Parser.Term.withDeclName","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.withDeclName","doc":"* `with_decl_name% id e` elaborates `e` in a context while changing the effective\n  declaration name to `id`.\n* `with_decl_name% ?id e` does the same, but resolves `id` as a new definition name\n  (appending the current namespaces).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L525-L525","name":"Lean.Parser.Term.declName","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.declName","doc":"A macro which evaluates to the name of the currently elaborating declaration. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L521-L522","name":"Lean.Parser.Term.forInMacro'","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.forInMacro'","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L519-L520","name":"Lean.Parser.Term.forInMacro","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.forInMacro","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L516-L517","name":"Lean.Parser.Term.unop","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.unop","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L514-L515","name":"Lean.Parser.Term.binop_lazy","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binop_lazy","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L512-L513","name":"Lean.Parser.Term.binop","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binop","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L510-L511","name":"Lean.Parser.Term.binrel_no_prop","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binrel_no_prop","doc":"Similar to `binrel`, but coerce `Prop` arguments into `Bool`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L507-L508","name":"Lean.Parser.Term.binrel","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binrel","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L504-L505","name":"Lean.Parser.Term.noindex","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.noindex","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L501-L502","name":"Lean.Parser.Term.matchAltsWhereDecls","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchAltsWhereDecls","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L497-L498","name":"Lean.Parser.Term.whereDecls","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.whereDecls","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L492-L494","name":"Lean.Parser.Term.letrec","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letrec","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L489-L490","name":"Lean.Parser.Term.letRecDecls","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letRecDecls","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L487-L488","name":"Lean.Parser.Term.letRecDecl","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letRecDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L485-L486","name":"Lean.Parser.Term.attributes","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.attributes","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L483-L483","name":"Lean.Parser.Term.attrInstance","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.attrInstance","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L482-L482","name":"Lean.Parser.Term.attrKind","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.attrKind","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L481-L481","name":"Lean.Parser.Term.local","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.local","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L480-L480","name":"Lean.Parser.Term.scoped","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.scoped","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L477-L478","name":"Lean.Parser.Term.have","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.have","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L475-L476","name":"Lean.Parser.Term.haveDecl","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.haveDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L473-L474","name":"Lean.Parser.Term.haveEqnsDecl","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.haveEqnsDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L471-L472","name":"Lean.Parser.Term.haveIdDecl","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.haveIdDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L470-L470","name":"Lean.Parser.Term.haveIdLhs","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.haveIdLhs","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L466-L467","name":"Lean.Parser.Term.let_tmp","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.let_tmp","doc":"`let`-declaration that is only included in the elaborated term if variable is still there.\nIt is often used when building macros.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L460-L461","name":"Lean.Parser.Term.let_delayed","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.let_delayed","doc":"`let_delayed x := v; b` is similar to `let x := v; b`, but `b` is elaborated before `v`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L455-L456","name":"Lean.Parser.Term.let_fun","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.let_fun","doc":"`let_fun x := v; b` is syntax sugar for `(fun x => b) v`.\nIt is very similar to `let x := v; b`, but they are not equivalent.\nIn `let_fun`, the value `v` has been abstracted away and cannot be accessed in `b`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L448-L449","name":"Lean.Parser.Term.let","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.let","doc":"`let` is used to declare a local definition. Example:\n```\nlet x := 1\nlet y := x + 1\nx + y\n```\nSince functions are first class citizens in Lean, you can use `let` to declare\nlocal functions too.\n```\nlet double := fun x => 2*x\ndouble (double 3)\n```\nFor recursive definitions, you should use `let rec`.\nYou can also perform pattern matching using `let`. For example,\nassume `p` has type `Nat × Nat`, then you can write\n```\nlet (x, y) := p\nx + y\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L424-L426","name":"Lean.Parser.Term.letDecl","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L420-L421","name":"Lean.Parser.Term.letEqnsDecl","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letEqnsDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L402-L403","name":"Lean.Parser.Term.letPatDecl","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letPatDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L400-L401","name":"Lean.Parser.Term.letIdDecl","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letIdDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L396-L399","name":"Lean.Parser.Term.letIdLhs","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letIdLhs","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L392-L394","name":"Lean.Parser.Term.letIdBinder","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letIdBinder","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L389-L390","name":"Lean.Parser.Term.doubleQuotedName","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.doubleQuotedName","doc":"A resolved name literal. Evaluates to the full name of the given constant if\nexistent in the current context, or else fails.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L382-L382","name":"Lean.Parser.Term.quotedName","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.quotedName","doc":"A literal of type `Name`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L379-L380","name":"Lean.Parser.Term.borrowed","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.borrowed","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L376-L377","name":"Lean.Parser.Term.trailing_parser","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.trailing_parser","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L374-L375","name":"Lean.Parser.Term.leading_parser","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.leading_parser","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L371-L373","name":"Lean.Parser.Term.withAnonymousAntiquot","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.withAnonymousAntiquot","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L370-L370","name":"Lean.Parser.Term.optExprPrecedence","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optExprPrecedence","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L367-L368","name":"Lean.Parser.Term.fun","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.fun","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L365-L366","name":"Lean.Parser.Term.basicFun","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.basicFun","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L360-L362","name":"Lean.Parser.Term.funBinder","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.funBinder","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L355-L359","name":"Lean.Parser.Term.funStrictImplicitBinder","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.funStrictImplicitBinder","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L353-L354","name":"Lean.Parser.Term.funImplicitBinder","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.funImplicitBinder","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L351-L351","name":"Lean.Parser.Term.nomatch","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.nomatch","doc":"Empty match/ex falso. `nomatch e` is of arbitrary type `α : Sort u` if\nLean can show that an empty set of patterns is exhaustive given `e`'s type,\ne.g. because it has no constructors.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L343-L345","name":"Lean.Parser.Term.match","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.match","doc":"Pattern matching. `match e, ... with | p, ... => f | ...` matches each given\nterm `e` against each pattern `p` of a match alternative. When all patterns\nof an alternative match, the `match` term evaluates to the value of the\ncorresponding right-hand side `f` with the pattern variables bound to the\nrespective matched values.\nWhen not constructing a proof, `match` does not automatically substitute variables\nmatched on in dependent variables' types. Use `match (generalizing := true) ...` to\nenforce this.\n\nSyntax quotations can also be used in a pattern match.\nThis matches a `Syntax` value against quotations, pattern variables, or `_`.\n\nQuoted identifiers only match identical identifiers - custom matching such as by the preresolved\nnames only should be done explicitly.\n\n`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.\nFor users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they\nshould participate in matching.\nFor example, in\n```lean\nsyntax \"c\" (\"foo\" <|> \"bar\") ...\n```\n`foo` and `bar` are indistinguishable during matching, but in\n```lean\nsyntax foo := \"foo\"\nsyntax \"c\" (foo <|> \"bar\") ...\n```\nthey are not.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L309-L311","name":"Lean.Parser.Term.motive","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.motive","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L305-L307","name":"Lean.Parser.Term.generalizingParam","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.generalizingParam","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L304-L304","name":"Lean.Parser.Term.falseVal","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.falseVal","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L303-L303","name":"Lean.Parser.Term.trueVal","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.trueVal","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L300-L301","name":"Lean.Parser.Term.matchDiscr","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchDiscr","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L297-L298","name":"Lean.Parser.Term.matchAlts","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchAlts","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L294-L295","name":"Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil","kind":"instance","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L292-L292","name":"Lean.Parser.Term.matchAltExpr","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchAltExpr","doc":"Useful for syntax quotations. Note that generic patterns such as `` `(matchAltExpr| | ... => $rhs) `` should also\nwork with other `rhsParser`s (of arity 1). "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L283-L288","name":"Lean.Parser.Term.matchAlt","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchAlt","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L278-L281","name":"Lean.Parser.Term.forall","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.forall","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L274-L275","name":"Lean.Parser.Term.depArrow","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.depArrow","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L254-L257","name":"Lean.Parser.Term.bracketedBinder","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinder","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L252-L253","name":"Lean.Parser.Term.instBinder","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.instBinder","doc":"Instance-implicit binder. In regular applications without `@`, it is automatically inserted\nand solved by typeclass inference of the specified class.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L245-L247","name":"Lean.Parser.Term.strictImplicitBinder","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitBinder","doc":"Strict-implicit binder. In contrast to `{ ... }` regular implicit binders,\na strict-implicit binder is inserted automatically only when at least one subsequent\nexplicit parameter is specified.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L239-L239","name":"Lean.Parser.Term.strictImplicitRightBracket","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitRightBracket","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L238-L238","name":"Lean.Parser.Term.strictImplicitLeftBracket","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitLeftBracket","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L236-L237","name":"Lean.Parser.Term.implicitBinder","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.implicitBinder","doc":"Implicit binder. In regular applications without `@`, it is automatically inserted\nand solved by unification whenever all explicit parameters before it are specified.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L230-L231","name":"Lean.Parser.Term.explicitBinder","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.explicitBinder","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L221-L228","name":"Lean.Parser.Term.binderDefault.parenthesizer","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binderDefault.parenthesizer","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L217-L218","name":"Lean.Parser.Term.binderDefault","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binderDefault","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L215-L216","name":"Lean.Parser.Term.binderTactic","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binderTactic","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L213-L214","name":"Lean.Parser.Term.binderType","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binderType","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L212-L212","name":"Lean.Parser.Term.binderIdent","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binderIdent","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L210-L211","name":"Lean.Parser.Term.inaccessible","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.inaccessible","doc":"`.(e)` marks an \"inaccessible pattern\", which does not influence evaluation of the pattern match, but may be necessary for type-checking.\nIn contrast to regular patterns, `e` may be an arbitrary term of the appropriate type.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L204-L205","name":"Lean.Parser.Term.explicit","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.explicit","doc":"`@x` disables automatic insertion of implicit parameters of the constant `x`.\n`@e` for any term `e` also disables the insertion of implicit lambdas at this position.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L199-L199","name":"Lean.Parser.Term.optType","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optType","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L198-L198","name":"Lean.Parser.Term.typeSpec","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.typeSpec","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L193-L197","name":"Lean.Parser.Term.structInst","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInst","doc":"Structure instance. `{ x := e, ... }` assigns `e` to field `x`, which may be\ninherited. If `e` is itself a variable called `x`, it can be elided:\n`fun y => { x := 1, y }`.\nA *structure update* of an existing value can be given via `with`:\n`{ point with x := 1 }`.\nThe structure type can be specified if not inferable:\n`{ x := 1, y := 2 : Point }`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L182-L183","name":"Lean.Parser.Term.optEllipsis","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optEllipsis","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L179-L181","name":"Lean.Parser.Term.structInstFieldAbbrev","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInstFieldAbbrev","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L177-L178","name":"Lean.Parser.Term.structInstField","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInstField","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L174-L176","name":"Lean.Parser.Term.structInstLVal","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInstLVal","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L172-L173","name":"Lean.Parser.Term.structInstArrayRef","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInstArrayRef","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L171-L171","name":"Lean.Parser.Term.show","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.show","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L169-L170","name":"Lean.Parser.Term.suffices","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.suffices","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L167-L168","name":"Lean.Parser.Term.sufficesDecl","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.sufficesDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L166-L166","name":"Lean.Parser.Term.showRhs","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.showRhs","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L164-L165","name":"Lean.Parser.Term.fromTerm","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.fromTerm","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L162-L163","name":"Lean.Parser.Term.optIdent","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optIdent","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L160-L161","name":"Lean.Parser.Term.anonymousCtor","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.anonymousCtor","doc":"The *anonymous constructor* `⟨e, ...⟩` is equivalent to `c e ...` if the\nexpected type is an inductive type with a single constructor `c`.\nIf more terms are given than `c` has parameters, the remaining arguments\nare turned into a new anonymous constructor application. For example,\n`⟨a, b, c⟩ : α × (β × γ)` is equivalent to `⟨a, ⟨b, c⟩⟩`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L151-L152","name":"Lean.Parser.Term.paren","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.paren","doc":"Parentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L140-L141","name":"Lean.Parser.Term.tuple","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.tuple","doc":"Tuple notation; `()` is short for `Unit.unit`, `(a, b, c)` for `Prod.mk a (Prod.mk b c)`, etc. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L137-L138","name":"Lean.Parser.Term.typeAscription","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.typeAscription","doc":"Type ascription notation: `(0 : Int)` instructs Lean to process `0` as a value of type `Int`.\nAn empty type ascription `(e :)` elaborates `e` without the expected type.\nThis is occasionally useful when Lean's heuristics for filling arguments from the expected type\ndo not yield the right result.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L129-L130","name":"Lean.Parser.Term.cdot","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.cdot","doc":"A placeholder for an implicit lambda abstraction's variable. The lambda abstraction is scoped to the surrounding parentheses.\nFor example, `(· + ·)` is equivalent to `fun x y => x + y`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L123-L124","name":"Lean.Parser.Term.sorry","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.sorry","doc":"A temporary placeholder for a missing proof or value. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L120-L121","name":"Lean.Parser.Term.syntheticHole","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.syntheticHole","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L118-L119","name":"Lean.Parser.Term.hole","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.hole","doc":"A placeholder term, to be synthesized by unification. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L115-L116","name":"Lean.Parser.Term.prop","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.prop","doc":"The universe of propositions. `Prop ≡ Sort 0`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L112-L113","name":"Lean.Parser.Term.sort","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.sort","doc":"A specific universe in Lean's infinite hierarchy of universes. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L109-L110","name":"Lean.Parser.Term.type","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.type","doc":"A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L106-L107","name":"Lean.Parser.Term.char","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.char","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L104-L105","name":"Lean.Parser.Term.str","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.str","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L102-L103","name":"Lean.Parser.Term.scientific","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.scientific","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L100-L101","name":"Lean.Parser.Term.num","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.num","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L98-L99","name":"Lean.Parser.Term.ident","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.ident","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L94-L95","name":"Lean.Parser.Term.optSemicolon","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optSemicolon","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L90-L91","name":"Lean.Parser.Term.byTactic'","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.byTactic'","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L81-L82","name":"Lean.Parser.Term.byTactic","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.byTactic","doc":"`by tac` constructs a term of the expected type by running the tactic(s) `tac`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L74-L74","name":"Lean.Parser.semicolonOrLinebreak","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.semicolonOrLinebreak","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L73-L73","name":"Lean.Parser.darrow","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.darrow","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L68-L69","name":"Lean.Parser.Tactic.seq1","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.seq1","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L64-L65","name":"Lean.Parser.Tactic.tacticSeqIndentGt","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeqIndentGt","doc":"Same as [`tacticSeq`] but requires delimiter-free tactic sequence to have strict indentation.\nThe strict indentation requirement only apply to *nested* `by`s, as top-level `by`s do not have a\nposition set. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L58-L59","name":"Lean.Parser.Tactic.tacticSeq","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeq","doc":"A sequence of tactics in brackets, or a delimiter-free indented sequence of tactics.\nDelimiter-free indentation is determined by the *first* tactic of the sequence. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L53-L54","name":"Lean.Parser.Tactic.tacticSeqBracketed","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeqBracketed","doc":"The syntax `{ tacs }` is an alternative syntax for `· tacs`.\nIt runs the tactics in sequence, and fails if the goal is not solved. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L49-L50","name":"Lean.Parser.Tactic.tacticSeq1Indented","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeq1Indented","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L42-L43","name":"Lean.Parser.Tactic.sepBy1IndentSemicolon","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.sepBy1IndentSemicolon","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L38-L39","name":"Lean.Parser.Tactic.sepByIndentSemicolon","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.sepByIndentSemicolon","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L32-L33","name":"Lean.Parser.convParser","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.convParser","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L29-L30","name":"Lean.Parser.tacticParser","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.tacticParser","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L21-L22","name":"Lean.Parser.Command.docComment","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.docComment","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L19-L19","name":"Lean.Parser.Command.commentBody.formatter","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody.formatter","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L17-L17","name":"Lean.Parser.Command.commentBody.parenthesizer","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody.parenthesizer","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Parser/Term.lean#L13-L14","name":"Lean.Parser.Command.commentBody","kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody","doc":""}]}