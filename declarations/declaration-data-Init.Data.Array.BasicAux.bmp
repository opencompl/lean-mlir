{"name":"Init.Data.Array.BasicAux","instances":[],"imports":["Init.Data.Array.Basic","Init.Data.Nat.Linear","Init.NotationExtra"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Data/Array/BasicAux.lean#L73-L74","name":"Array.mapMono","kind":"def","docLink":"./Init/Data/Array/BasicAux.html#Array.mapMono","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Data/Array/BasicAux.lean#L70-L71","name":"Array.mapMonoM","kind":"def","docLink":"./Init/Data/Array/BasicAux.html#Array.mapMonoM","doc":"Monomorphic `Array.mapM`. The internal implementation uses pointer equality, and does not allocate a new array\nif the result of each `f a` is a pointer equal value `a`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Data/Array/BasicAux.lean#L43-L49","name":"Array.mapM'.go","kind":"def","docLink":"./Init/Data/Array/BasicAux.html#Array.mapM'.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Data/Array/BasicAux.lean#L40-L50","name":"Array.mapM'","kind":"def","docLink":"./Init/Data/Array/BasicAux.html#Array.mapM'","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Data/Array/BasicAux.lean#L35-L38","name":"List.toArray_eq_toArray_eq","kind":"theorem","docLink":"./Init/Data/Array/BasicAux.html#List.toArray_eq_toArray_eq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/9ec9ea61a4ebbcd2672b8905e7c583958113e24e/src/Init/Data/Array/BasicAux.lean#L11-L15","name":"Array.of_push_eq_push","kind":"theorem","docLink":"./Init/Data/Array/BasicAux.html#Array.of_push_eq_push","doc":""}]}