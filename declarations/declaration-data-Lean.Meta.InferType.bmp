{"name":"Lean.Meta.InferType","instances":[],"imports":["Init","Lean.Data.LBool","Lean.Meta.Basic"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/InferType.lean#L408-L409","name":"Lean.Meta.isTypeFormer","kind":"def","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isTypeFormer","doc":"Return true iff `e : Sort _` or `e : (forall As, Sort _)`.\nRemark: it subsumes `isType`\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/InferType.lean#L393-L402","name":"Lean.Meta.isTypeFormerType.go","kind":"opaque","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isTypeFormerType.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/InferType.lean#L388-L402","name":"Lean.Meta.isTypeFormerType","kind":"def","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isTypeFormerType","doc":"Return true iff `type` is `Sort _` or `As → Sort _`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/InferType.lean#L380-L383","name":"Lean.Meta.isTypeFormerTypeQuick","kind":"def","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isTypeFormerTypeQuick","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/InferType.lean#L363-L372","name":"Lean.Meta.isType","kind":"def","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isType","doc":"Return `true` iff the type of `e` is a `Sort _`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/InferType.lean#L346-L358","name":"Lean.Meta.isTypeQuick","kind":"opaque","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isTypeQuick","doc":"`isTypeQuick e` is an \"approximate\" predicate which returns `LBool.true`\nif `e` is a type. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/InferType.lean#L311-L315","name":"Lean.Meta.isProof","kind":"def","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isProof","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/InferType.lean#L295-L307","name":"Lean.Meta.isProofQuick","kind":"opaque","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isProofQuick","doc":"`isProofQuick e` is an \"approximate\" predicate which returns `LBool.true`\nif `e` is a proof. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/InferType.lean#L255-L264","name":"Lean.Meta.isProp","kind":"def","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isProp","doc":"`isProp whnf e` return `true` if `e` is a proposition.\n\nIf `e` contains metavariables, it may not be possible\nto decide whether is a proposition or not. We return `false` in this\ncase. We considered using `LBool` and retuning `LBool.undef`, but\nwe have no applications for it. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/InferType.lean#L235-L247","name":"Lean.Meta.isPropQuick","kind":"opaque","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isPropQuick","doc":"`isPropQuick e` is an \"approximate\" predicate which returns `LBool.true`\nif `e` is a proposition. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/InferType.lean#L178-L192","name":"Lean.Meta.inferTypeImp.infer","kind":"def","docLink":"./Lean/Meta/InferType.html#Lean.Meta.inferTypeImp.infer","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/InferType.lean#L177-L193","name":"Lean.Meta.inferTypeImp","kind":"def","docLink":"./Lean/Meta/InferType.html#Lean.Meta.inferTypeImp","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/InferType.lean#L154-L155","name":"Lean.Meta.throwUnknownMVar","kind":"def","docLink":"./Lean/Meta/InferType.html#Lean.Meta.throwUnknownMVar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/InferType.lean#L125-L137","name":"Lean.Meta.getLevel","kind":"def","docLink":"./Lean/Meta/InferType.html#Lean.Meta.getLevel","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/InferType.lean#L122-L123","name":"Lean.Meta.throwTypeExcepted","kind":"def","docLink":"./Lean/Meta/InferType.html#Lean.Meta.throwTypeExcepted","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/InferType.lean#L86-L87","name":"Lean.Meta.throwIncorrectNumberOfLevels","kind":"def","docLink":"./Lean/Meta/InferType.html#Lean.Meta.throwIncorrectNumberOfLevels","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/InferType.lean#L69-L70","name":"Lean.Meta.throwFunctionExpected","kind":"def","docLink":"./Lean/Meta/InferType.html#Lean.Meta.throwFunctionExpected","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/InferType.lean#L32-L65","name":"Lean.Expr.instantiateBetaRevRange.visit","kind":"opaque","docLink":"./Lean/Meta/InferType.html#Lean.Expr.instantiateBetaRevRange.visit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/ebc32af2e606deef0d7b437e67f24c20ed866818/src/Lean/Meta/InferType.lean#L25-L65","name":"Lean.Expr.instantiateBetaRevRange","kind":"def","docLink":"./Lean/Meta/InferType.html#Lean.Expr.instantiateBetaRevRange","doc":"Auxiliary function for instantiating the loose bound variables in `e` with `args[start:stop]`.\nThis function is similar to `instantiateRevRange`, but it applies beta-reduction when\nwe instantiate a bound variable with a lambda expression.\nExample: Given the term `#0 a`, and `start := 0, stop := 1, args := #[fun x => x]` the result is\n`a` instead of `(fun x => x) a`.\nThis reduction is useful when we are inferring the type of eliminator-like applications.\nFor example, given `(n m : Nat) (f : Nat → Nat) (h : m = n)`,\nthe type of `Eq.subst (motive := fun x => f m = f x) h rfl`\nis `motive n` which is `(fun (x : Nat) => f m = f x) n`\nThis function reduces the new application to `f m = f n`\n\nWe use it to implement `inferAppType`\n"}]}